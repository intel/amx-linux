
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Pathname lookup &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Filesystems API summary" href="api-summary.html" />
    <link rel="prev" title="Overview of the Linux Virtual File System" href="vfs.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pathname-lookup">
<h1>Pathname lookup<a class="headerlink" href="#pathname-lookup" title="Permalink to this headline">¶</a></h1>
<p>This write-up is based on three articles published at lwn.net:</p>
<ul class="simple">
<li><p>&lt;<a class="reference external" href="https://lwn.net/Articles/649115/">https://lwn.net/Articles/649115/</a>&gt; Pathname lookup in Linux</p></li>
<li><p>&lt;<a class="reference external" href="https://lwn.net/Articles/649729/">https://lwn.net/Articles/649729/</a>&gt; RCU-walk: faster pathname lookup in Linux</p></li>
<li><p>&lt;<a class="reference external" href="https://lwn.net/Articles/650786/">https://lwn.net/Articles/650786/</a>&gt; A walk among the symlinks</p></li>
</ul>
<p>Written by Neil Brown with help from Al Viro and Jon Corbet.
It has subsequently been updated to reflect changes in the kernel
including:</p>
<ul class="simple">
<li><p>per-directory parallel name lookup.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">openat2()</span></code> resolution restriction flags.</p></li>
</ul>
<section id="introduction-to-pathname-lookup">
<h2>Introduction to pathname lookup<a class="headerlink" href="#introduction-to-pathname-lookup" title="Permalink to this headline">¶</a></h2>
<p>The most obvious aspect of pathname lookup, which very little
exploration is needed to discover, is that it is complex.  There are
many rules, special cases, and implementation alternatives that all
combine to confuse the unwary reader.  Computer science has long been
acquainted with such complexity and has tools to help manage it.  One
tool that we will make extensive use of is “divide and conquer”.  For
the early parts of the analysis we will divide off symlinks - leaving
them until the final part.  Well before we get to symlinks we have
another major division based on the VFS’s approach to locking which
will allow us to review “REF-walk” and “RCU-walk” separately.  But we
are getting ahead of ourselves.  There are some important low level
distinctions we need to clarify first.</p>
<section id="there-are-two-sorts-of">
<h3>There are two sorts of …<a class="headerlink" href="#there-are-two-sorts-of" title="Permalink to this headline">¶</a></h3>
<p>Pathnames (sometimes “file names”), used to identify objects in the
filesystem, will be familiar to most readers.  They contain two sorts
of elements: “slashes” that are sequences of one or more “<code class="docutils literal notranslate"><span class="pre">/</span></code>”
characters, and “components” that are sequences of one or more
non-”<code class="docutils literal notranslate"><span class="pre">/</span></code>” characters.  These form two kinds of paths.  Those that
start with slashes are “absolute” and start from the filesystem root.
The others are “relative” and start from the current directory, or
from some other location specified by a file descriptor given to
“<code class="docutils literal notranslate"><span class="pre">*at()</span></code>” system calls such as <a class="reference external" href="http://man7.org/linux/man-pages/man2/openat.2.html">openat()</a>.</p>
<p>It is tempting to describe the second kind as starting with a
component, but that isn’t always accurate: a pathname can lack both
slashes and components, it can be empty, in other words.  This is
generally forbidden in POSIX, but some of those “<code class="docutils literal notranslate"><span class="pre">*at()</span></code>” system calls
in Linux permit it when the <code class="docutils literal notranslate"><span class="pre">AT_EMPTY_PATH</span></code> flag is given.  For
example, if you have an open file descriptor on an executable file you
can execute it by calling <a class="reference external" href="http://man7.org/linux/man-pages/man2/execveat.2.html">execveat()</a> passing
the file descriptor, an empty path, and the <code class="docutils literal notranslate"><span class="pre">AT_EMPTY_PATH</span></code> flag.</p>
<p>These paths can be divided into two sections: the final component and
everything else.  The “everything else” is the easy bit.  In all cases
it must identify a directory that already exists, otherwise an error
such as <code class="docutils literal notranslate"><span class="pre">ENOENT</span></code> or <code class="docutils literal notranslate"><span class="pre">ENOTDIR</span></code> will be reported.</p>
<p>The final component is not so simple.  Not only do different system
calls interpret it quite differently (e.g. some create it, some do
not), but it might not even exist: neither the empty pathname nor the
pathname that is just slashes have a final component.  If it does
exist, it could be “<code class="docutils literal notranslate"><span class="pre">.</span></code>” or “<code class="docutils literal notranslate"><span class="pre">..</span></code>” which are handled quite differently
from other components.</p>
<p>If a pathname ends with a slash, such as “<code class="docutils literal notranslate"><span class="pre">/tmp/foo/</span></code>” it might be
tempting to consider that to have an empty final component.  In many
ways that would lead to correct results, but not always.  In
particular, <code class="docutils literal notranslate"><span class="pre">mkdir()</span></code> and <code class="docutils literal notranslate"><span class="pre">rmdir()</span></code> each create or remove a directory named
by the final component, and they are required to work with pathnames
ending in “<code class="docutils literal notranslate"><span class="pre">/</span></code>”.  According to <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12">POSIX</a>:</p>
<blockquote>
<div><p>A pathname that contains at least one non-&lt;slash&gt; character and
that ends with one or more trailing &lt;slash&gt; characters shall not
be resolved successfully unless the last pathname component before
the trailing &lt;slash&gt; characters names an existing directory or a
directory entry that is to be created for a directory immediately
after the pathname is resolved.</p>
</div></blockquote>
<p>The Linux pathname walking code (mostly in <code class="docutils literal notranslate"><span class="pre">fs/namei.c</span></code>) deals with
all of these issues: breaking the path into components, handling the
“everything else” quite separately from the final component, and
checking that the trailing slash is not used where it isn’t
permitted.  It also addresses the important issue of concurrent
access.</p>
<p>While one process is looking up a pathname, another might be making
changes that affect that lookup.  One fairly extreme case is that if
“a/b” were renamed to “a/c/b” while another process were looking up
“a/b/..”, that process might successfully resolve on “a/c”.
Most races are much more subtle, and a big part of the task of
pathname lookup is to prevent them from having damaging effects.  Many
of the possible races are seen most clearly in the context of the
“dcache” and an understanding of that is central to understanding
pathname lookup.</p>
</section>
<section id="more-than-just-a-cache">
<h3>More than just a cache<a class="headerlink" href="#more-than-just-a-cache" title="Permalink to this headline">¶</a></h3>
<p>The “dcache” caches information about names in each filesystem to
make them quickly available for lookup.  Each entry (known as a
“dentry”) contains three significant fields: a component name, a
pointer to a parent dentry, and a pointer to the “inode” which
contains further information about the object in that parent with
the given name.  The inode pointer can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> indicating that the
name doesn’t exist in the parent.  While there can be linkage in the
dentry of a directory to the dentries of the children, that linkage is
not used for pathname lookup, and so will not be considered here.</p>
<p>The dcache has a number of uses apart from accelerating lookup.  One
that will be particularly relevant is that it is closely integrated
with the mount table that records which filesystem is mounted where.
What the mount table actually stores is which dentry is mounted on top
of which other dentry.</p>
<p>When considering the dcache, we have another of our “two types”
distinctions: there are two types of filesystems.</p>
<p>Some filesystems ensure that the information in the dcache is always
completely accurate (though not necessarily complete).  This can allow
the VFS to determine if a particular file does or doesn’t exist
without checking with the filesystem, and means that the VFS can
protect the filesystem against certain races and other problems.
These are typically “local” filesystems such as ext3, XFS, and Btrfs.</p>
<p>Other filesystems don’t provide that guarantee because they cannot.
These are typically filesystems that are shared across a network,
whether remote filesystems like NFS and 9P, or cluster filesystems
like ocfs2 or cephfs.  These filesystems allow the VFS to revalidate
cached information, and must provide their own protection against
awkward races.  The VFS can detect these filesystems by the
<code class="docutils literal notranslate"><span class="pre">DCACHE_OP_REVALIDATE</span></code> flag being set in the dentry.</p>
</section>
<section id="ref-walk-simple-concurrency-management-with-refcounts-and-spinlocks">
<h3>REF-walk: simple concurrency management with refcounts and spinlocks<a class="headerlink" href="#ref-walk-simple-concurrency-management-with-refcounts-and-spinlocks" title="Permalink to this headline">¶</a></h3>
<p>With all of those divisions carefully classified, we can now start
looking at the actual process of walking along a path.  In particular
we will start with the handling of the “everything else” part of a
pathname, and focus on the “REF-walk” approach to concurrency
management.  This code is found in the <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> function, if
you ignore all the places that only run when “<code class="docutils literal notranslate"><span class="pre">LOOKUP_RCU</span></code>”
(indicating the use of RCU-walk) is set.</p>
<p>REF-walk is fairly heavy-handed with locks and reference counts.  Not
as heavy-handed as in the old “big kernel lock” days, but certainly not
afraid of taking a lock when one is needed.  It uses a variety of
different concurrency controls.  A background understanding of the
various primitives is assumed, or can be gleaned from elsewhere such
as in <a class="reference external" href="https://lwn.net/Articles/453685/">Meet the Lockers</a>.</p>
<p>The locking mechanisms used by REF-walk include:</p>
<section id="dentry-d-lockref">
<h4>dentry-&gt;d_lockref<a class="headerlink" href="#dentry-d-lockref" title="Permalink to this headline">¶</a></h4>
<p>This uses the lockref primitive to provide both a spinlock and a
reference count.  The special-sauce of this primitive is that the
conceptual sequence “lock; inc_ref; unlock;” can often be performed
with a single atomic memory operation.</p>
<p>Holding a reference on a dentry ensures that the dentry won’t suddenly
be freed and used for something else, so the values in various fields
will behave as expected.  It also protects the <code class="docutils literal notranslate"><span class="pre">-&gt;d_inode</span></code> reference
to the inode to some extent.</p>
<p>The association between a dentry and its inode is fairly permanent.
For example, when a file is renamed, the dentry and inode move
together to the new location.  When a file is created the dentry will
initially be negative (i.e. <code class="docutils literal notranslate"><span class="pre">d_inode</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>), and will be assigned
to the new inode as part of the act of creation.</p>
<p>When a file is deleted, this can be reflected in the cache either by
setting <code class="docutils literal notranslate"><span class="pre">d_inode</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, or by removing it from the hash table
(described shortly) used to look up the name in the parent directory.
If the dentry is still in use the second option is used as it is
perfectly legal to keep using an open file after it has been deleted
and having the dentry around helps.  If the dentry is not otherwise in
use (i.e. if the refcount in <code class="docutils literal notranslate"><span class="pre">d_lockref</span></code> is one), only then will
<code class="docutils literal notranslate"><span class="pre">d_inode</span></code> be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  Doing it this way is more efficient for a
very common case.</p>
<p>So as long as a counted reference is held to a dentry, a non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> <code class="docutils literal notranslate"><span class="pre">-&gt;d_inode</span></code>
value will never be changed.</p>
</section>
<section id="dentry-d-lock">
<h4>dentry-&gt;d_lock<a class="headerlink" href="#dentry-d-lock" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">d_lock</span></code> is a synonym for the spinlock that is part of <code class="docutils literal notranslate"><span class="pre">d_lockref</span></code> above.
For our purposes, holding this lock protects against the dentry being
renamed or unlinked.  In particular, its parent (<code class="docutils literal notranslate"><span class="pre">d_parent</span></code>), and its
name (<code class="docutils literal notranslate"><span class="pre">d_name</span></code>) cannot be changed, and it cannot be removed from the
dentry hash table.</p>
<p>When looking for a name in a directory, REF-walk takes <code class="docutils literal notranslate"><span class="pre">d_lock</span></code> on
each candidate dentry that it finds in the hash table and then checks
that the parent and name are correct.  So it doesn’t lock the parent
while searching in the cache; it only locks children.</p>
<p>When looking for the parent for a given name (to handle “<code class="docutils literal notranslate"><span class="pre">..</span></code>”),
REF-walk can take <code class="docutils literal notranslate"><span class="pre">d_lock</span></code> to get a stable reference to <code class="docutils literal notranslate"><span class="pre">d_parent</span></code>,
but it first tries a more lightweight approach.  As seen in
<code class="docutils literal notranslate"><span class="pre">dget_parent()</span></code>, if a reference can be claimed on the parent, and if
subsequently <code class="docutils literal notranslate"><span class="pre">d_parent</span></code> can be seen to have not changed, then there is
no need to actually take the lock on the child.</p>
</section>
<section id="rename-lock">
<h4>rename_lock<a class="headerlink" href="#rename-lock" title="Permalink to this headline">¶</a></h4>
<p>Looking up a given name in a given directory involves computing a hash
from the two values (the name and the dentry of the directory),
accessing that slot in a hash table, and searching the linked list
that is found there.</p>
<p>When a dentry is renamed, the name and the parent dentry can both
change so the hash will almost certainly change too.  This would move the
dentry to a different chain in the hash table.  If a filename search
happened to be looking at a dentry that was moved in this way,
it might end up continuing the search down the wrong chain,
and so miss out on part of the correct chain.</p>
<p>The name-lookup process (<code class="docutils literal notranslate"><span class="pre">d_lookup()</span></code>) does <em>not</em> try to prevent this
from happening, but only to detect when it happens.
<code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> is a seqlock that is updated whenever any dentry is
renamed.  If <code class="docutils literal notranslate"><span class="pre">d_lookup</span></code> finds that a rename happened while it
unsuccessfully scanned a chain in the hash table, it simply tries
again.</p>
<p><code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> is also used to detect and defend against potential attacks
against <code class="docutils literal notranslate"><span class="pre">LOOKUP_BENEATH</span></code> and <code class="docutils literal notranslate"><span class="pre">LOOKUP_IN_ROOT</span></code> when resolving “..” (where
the parent directory is moved outside the root, bypassing the <code class="docutils literal notranslate"><span class="pre">path_equal()</span></code>
check). If <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> is updated during the lookup and the path encounters
a “..”, a potential attack occurred and <code class="docutils literal notranslate"><span class="pre">handle_dots()</span></code> will bail out with
<code class="docutils literal notranslate"><span class="pre">-EAGAIN</span></code>.</p>
</section>
<section id="inode-i-rwsem">
<h4>inode-&gt;i_rwsem<a class="headerlink" href="#inode-i-rwsem" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> is a read/write semaphore that serializes all changes to a particular
directory.  This ensures that, for example, an <code class="docutils literal notranslate"><span class="pre">unlink()</span></code> and a <code class="docutils literal notranslate"><span class="pre">rename()</span></code>
cannot both happen at the same time.  It also keeps the directory
stable while the filesystem is asked to look up a name that is not
currently in the dcache or, optionally, when the list of entries in a
directory is being retrieved with <code class="docutils literal notranslate"><span class="pre">readdir()</span></code>.</p>
<p>This has a complementary role to that of <code class="docutils literal notranslate"><span class="pre">d_lock</span></code>: <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> on a
directory protects all of the names in that directory, while <code class="docutils literal notranslate"><span class="pre">d_lock</span></code>
on a name protects just one name in a directory.  Most changes to the
dcache hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> on the relevant directory inode and briefly take
<code class="docutils literal notranslate"><span class="pre">d_lock</span></code> on one or more the dentries while the change happens.  One
exception is when idle dentries are removed from the dcache due to
memory pressure.  This uses <code class="docutils literal notranslate"><span class="pre">d_lock</span></code>, but <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> plays no role.</p>
<p>The semaphore affects pathname lookup in two distinct ways.  Firstly it
prevents changes during lookup of a name in a directory.  <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> uses
<code class="docutils literal notranslate"><span class="pre">lookup_fast()</span></code> first which, in turn, checks to see if the name is in the cache,
using only <code class="docutils literal notranslate"><span class="pre">d_lock</span></code> locking.  If the name isn’t found, then <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code>
falls back to <code class="docutils literal notranslate"><span class="pre">lookup_slow()</span></code> which takes a shared lock on <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code>, checks again that
the name isn’t in the cache, and then calls in to the filesystem to get a
definitive answer.  A new dentry will be added to the cache regardless of
the result.</p>
<p>Secondly, when pathname lookup reaches the final component, it will
sometimes need to take an exclusive lock on <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> before performing the last lookup so
that the required exclusion can be achieved.  How path lookup chooses
to take, or not take, <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> is one of the
issues addressed in a subsequent section.</p>
<p>If two threads attempt to look up the same name at the same time - a
name that is not yet in the dcache - the shared lock on <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> will
not prevent them both adding new dentries with the same name.  As this
would result in confusion an extra level of interlocking is used,
based around a secondary hash table (<code class="docutils literal notranslate"><span class="pre">in_lookup_hashtable</span></code>) and a
per-dentry flag bit (<code class="docutils literal notranslate"><span class="pre">DCACHE_PAR_LOOKUP</span></code>).</p>
<p>To add a new dentry to the cache while only holding a shared lock on
<code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code>, a thread must call <code class="docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code>.  This allocates a
dentry, stores the required name and parent in it, checks if there
is already a matching dentry in the primary or secondary hash
tables, and if not, stores the newly allocated dentry in the secondary
hash table, with <code class="docutils literal notranslate"><span class="pre">DCACHE_PAR_LOOKUP</span></code> set.</p>
<p>If a matching dentry was found in the primary hash table then that is
returned and the caller can know that it lost a race with some other
thread adding the entry.  If no matching dentry is found in either
cache, the newly allocated dentry is returned and the caller can
detect this from the presence of <code class="docutils literal notranslate"><span class="pre">DCACHE_PAR_LOOKUP</span></code>.  In this case it
knows that it has won any race and now is responsible for asking the
filesystem to perform the lookup and find the matching inode.  When
the lookup is complete, it must call <code class="docutils literal notranslate"><span class="pre">d_lookup_done()</span></code> which clears
the flag and does some other house keeping, including removing the
dentry from the secondary hash table - it will normally have been
added to the primary hash table already.  Note that a <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">waitqueue_head</span></code> is passed to <code class="docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">d_lookup_done()</span></code> must be called while this <code class="docutils literal notranslate"><span class="pre">waitqueue_head</span></code> is still
in scope.</p>
<p>If a matching dentry is found in the secondary hash table,
<code class="docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code> has a little more work to do. It first waits for
<code class="docutils literal notranslate"><span class="pre">DCACHE_PAR_LOOKUP</span></code> to be cleared, using a wait_queue that was passed
to the instance of <code class="docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code> that won the race and that
will be woken by the call to <code class="docutils literal notranslate"><span class="pre">d_lookup_done()</span></code>.  It then checks to see
if the dentry has now been added to the primary hash table.  If it
has, the dentry is returned and the caller just sees that it lost any
race.  If it hasn’t been added to the primary hash table, the most
likely explanation is that some other dentry was added instead using
<code class="docutils literal notranslate"><span class="pre">d_splice_alias()</span></code>.  In any case, <code class="docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code> repeats all the
look ups from the start and will normally return something from the
primary hash table.</p>
</section>
<section id="mnt-mnt-count">
<h4>mnt-&gt;mnt_count<a class="headerlink" href="#mnt-mnt-count" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">mnt_count</span></code> is a per-CPU reference counter on “<code class="docutils literal notranslate"><span class="pre">mount</span></code>” structures.
Per-CPU here means that incrementing the count is cheap as it only
uses CPU-local memory, but checking if the count is zero is expensive as
it needs to check with every CPU.  Taking a <code class="docutils literal notranslate"><span class="pre">mnt_count</span></code> reference
prevents the mount structure from disappearing as the result of regular
unmount operations, but does not prevent a “lazy” unmount.  So holding
<code class="docutils literal notranslate"><span class="pre">mnt_count</span></code> doesn’t ensure that the mount remains in the namespace and,
in particular, doesn’t stabilize the link to the mounted-on dentry.  It
does, however, ensure that the <code class="docutils literal notranslate"><span class="pre">mount</span></code> data structure remains coherent,
and it provides a reference to the root dentry of the mounted
filesystem.  So a reference through <code class="docutils literal notranslate"><span class="pre">-&gt;mnt_count</span></code> provides a stable
reference to the mounted dentry, but not the mounted-on dentry.</p>
</section>
<section id="mount-lock">
<h4>mount_lock<a class="headerlink" href="#mount-lock" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> is a global seqlock, a bit like <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code>.  It can be used to
check if any change has been made to any mount points.</p>
<p>While walking down the tree (away from the root) this lock is used when
crossing a mount point to check that the crossing was safe.  That is,
the value in the seqlock is read, then the code finds the mount that
is mounted on the current directory, if there is one, and increments
the <code class="docutils literal notranslate"><span class="pre">mnt_count</span></code>.  Finally the value in <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> is checked against
the old value.  If there is no change, then the crossing was safe.  If there
was a change, the <code class="docutils literal notranslate"><span class="pre">mnt_count</span></code> is decremented and the whole process is
retried.</p>
<p>When walking up the tree (towards the root) by following a “..” link,
a little more care is needed.  In this case the seqlock (which
contains both a counter and a spinlock) is fully locked to prevent
any changes to any mount points while stepping up.  This locking is
needed to stabilize the link to the mounted-on dentry, which the
refcount on the mount itself doesn’t ensure.</p>
<p><code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> is also used to detect and defend against potential attacks
against <code class="docutils literal notranslate"><span class="pre">LOOKUP_BENEATH</span></code> and <code class="docutils literal notranslate"><span class="pre">LOOKUP_IN_ROOT</span></code> when resolving “..” (where
the parent directory is moved outside the root, bypassing the <code class="docutils literal notranslate"><span class="pre">path_equal()</span></code>
check). If <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> is updated during the lookup and the path encounters
a “..”, a potential attack occurred and <code class="docutils literal notranslate"><span class="pre">handle_dots()</span></code> will bail out with
<code class="docutils literal notranslate"><span class="pre">-EAGAIN</span></code>.</p>
</section>
<section id="rcu">
<h4>RCU<a class="headerlink" href="#rcu" title="Permalink to this headline">¶</a></h4>
<p>Finally the global (but extremely lightweight) RCU read lock is held
from time to time to ensure certain data structures don’t get freed
unexpectedly.</p>
<p>In particular it is held while scanning chains in the dcache hash
table, and the mount point hash table.</p>
</section>
</section>
<section id="bringing-it-together-with-struct-nameidata">
<h3>Bringing it together with <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code><a class="headerlink" href="#bringing-it-together-with-struct-nameidata" title="Permalink to this headline">¶</a></h3>
<p>Throughout the process of walking a path, the current status is stored
in a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code>, “namei” being the traditional name - dating
all the way back to <a class="reference external" href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/u2.s">First Edition Unix</a> - of the function that
converts a “name” to an “inode”.  <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code> contains (among
other fields):</p>
<section id="struct-path-path">
<h4><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">path</span></code><a class="headerlink" href="#struct-path-path" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">path</span></code> contains a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span></code> (which is
embedded in a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mount</span></code>) and a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span></code>.  Together these
record the current status of the walk.  They start out referring to the
starting point (the current working directory, the root directory, or some other
directory identified by a file descriptor), and are updated on each
step.  A reference through <code class="docutils literal notranslate"><span class="pre">d_lockref</span></code> and <code class="docutils literal notranslate"><span class="pre">mnt_count</span></code> is always
held.</p>
</section>
<section id="struct-qstr-last">
<h4><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">last</span></code><a class="headerlink" href="#struct-qstr-last" title="Permalink to this headline">¶</a></h4>
<p>This is a string together with a length (i.e. <em>not</em> <code class="docutils literal notranslate"><span class="pre">nul</span></code> terminated)
that is the “next” component in the pathname.</p>
</section>
<section id="int-last-type">
<h4><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">last_type</span></code><a class="headerlink" href="#int-last-type" title="Permalink to this headline">¶</a></h4>
<p>This is one of <code class="docutils literal notranslate"><span class="pre">LAST_NORM</span></code>, <code class="docutils literal notranslate"><span class="pre">LAST_ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">LAST_DOT</span></code> or <code class="docutils literal notranslate"><span class="pre">LAST_DOTDOT</span></code>.
The <code class="docutils literal notranslate"><span class="pre">last</span></code> field is only valid if the type is <code class="docutils literal notranslate"><span class="pre">LAST_NORM</span></code>.</p>
</section>
<section id="struct-path-root">
<h4><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">root</span></code><a class="headerlink" href="#struct-path-root" title="Permalink to this headline">¶</a></h4>
<p>This is used to hold a reference to the effective root of the
filesystem.  Often that reference won’t be needed, so this field is
only assigned the first time it is used, or when a non-standard root
is requested.  Keeping a reference in the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code> ensures that
only one root is in effect for the entire path walk, even if it races
with a <code class="docutils literal notranslate"><span class="pre">chroot()</span></code> system call.</p>
<p>It should be noted that in the case of <code class="docutils literal notranslate"><span class="pre">LOOKUP_IN_ROOT</span></code> or
<code class="docutils literal notranslate"><span class="pre">LOOKUP_BENEATH</span></code>, the effective root becomes the directory file descriptor
passed to <code class="docutils literal notranslate"><span class="pre">openat2()</span></code> (which exposes these <code class="docutils literal notranslate"><span class="pre">LOOKUP_</span></code> flags).</p>
<p>The root is needed when either of two conditions holds: (1) either the
pathname or a symbolic link starts with a “’/’”, or (2) a “<code class="docutils literal notranslate"><span class="pre">..</span></code>”
component is being handled, since “<code class="docutils literal notranslate"><span class="pre">..</span></code>” from the root must always stay
at the root.  The value used is usually the current root directory of
the calling process.  An alternate root can be provided as when
<code class="docutils literal notranslate"><span class="pre">sysctl()</span></code> calls <code class="docutils literal notranslate"><span class="pre">file_open_root()</span></code>, and when NFSv4 or Btrfs call
<code class="docutils literal notranslate"><span class="pre">mount_subtree()</span></code>.  In each case a pathname is being looked up in a very
specific part of the filesystem, and the lookup must not be allowed to
escape that subtree.  It works a bit like a local <code class="docutils literal notranslate"><span class="pre">chroot()</span></code>.</p>
<p>Ignoring the handling of symbolic links, we can now describe the
“<code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code>” function, which handles the lookup of everything
except the final component as:</p>
<blockquote>
<div><p>Given a path (<code class="docutils literal notranslate"><span class="pre">name</span></code>) and a nameidata structure (<code class="docutils literal notranslate"><span class="pre">nd</span></code>), check that the
current directory has execute permission and then advance <code class="docutils literal notranslate"><span class="pre">name</span></code>
over one component while updating <code class="docutils literal notranslate"><span class="pre">last_type</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code>.  If that
was the final component, then return, otherwise call
<code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> and repeat from the top.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> is even easier.  If the component is <code class="docutils literal notranslate"><span class="pre">LAST_DOTS</span></code>,
it calls <code class="docutils literal notranslate"><span class="pre">handle_dots()</span></code> which does the necessary locking as already
described.  If it finds a <code class="docutils literal notranslate"><span class="pre">LAST_NORM</span></code> component it first calls
“<code class="docutils literal notranslate"><span class="pre">lookup_fast()</span></code>” which only looks in the dcache, but will ask the
filesystem to revalidate the result if it is that sort of filesystem.
If that doesn’t get a good result, it calls “<code class="docutils literal notranslate"><span class="pre">lookup_slow()</span></code>” which
takes <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code>, rechecks the cache, and then asks the filesystem
to find a definitive answer.</p>
<p>As the last step of walk_component(), step_into() will be called either
directly from walk_component() or from handle_dots().  It calls
handle_mounts(), to check and handle mount points, in which a new
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> is created containing a counted reference to the new dentry and
a reference to the new <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> which is only counted if it is
different from the previous <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code>. Then if there is
a symbolic link, step_into() calls pick_link() to deal with it,
otherwise it installs the new <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code>, and
drops the unneeded references.</p>
<p>This “hand-over-hand” sequencing of getting a reference to the new
dentry before dropping the reference to the previous dentry may
seem obvious, but is worth pointing out so that we will recognize its
analogue in the “RCU-walk” version.</p>
</section>
</section>
<section id="handling-the-final-component">
<h3>Handling the final component<a class="headerlink" href="#handling-the-final-component" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> only walks as far as setting <code class="docutils literal notranslate"><span class="pre">nd-&gt;last</span></code> and
<code class="docutils literal notranslate"><span class="pre">nd-&gt;last_type</span></code> to refer to the final component of the path.  It does
not call <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> that last time.  Handling that final
component remains for the caller to sort out. Those callers are
path_lookupat(), path_parentat() and
path_openat() each of which handles the differing requirements of
different system calls.</p>
<p><code class="docutils literal notranslate"><span class="pre">path_parentat()</span></code> is clearly the simplest - it just wraps a little bit
of housekeeping around <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> and returns the parent
directory and final component to the caller.  The caller will be either
aiming to create a name (via <code class="docutils literal notranslate"><span class="pre">filename_create()</span></code>) or remove or rename
a name (in which case <code class="docutils literal notranslate"><span class="pre">user_path_parent()</span></code> is used).  They will use
<code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> to exclude other changes while they validate and then
perform their operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">path_lookupat()</span></code> is nearly as simple - it is used when an existing
object is wanted such as by <code class="docutils literal notranslate"><span class="pre">stat()</span></code> or <code class="docutils literal notranslate"><span class="pre">chmod()</span></code>.  It essentially just
calls <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> on the final component through a call to
<code class="docutils literal notranslate"><span class="pre">lookup_last()</span></code>.  <code class="docutils literal notranslate"><span class="pre">path_lookupat()</span></code> returns just the final dentry.
It is worth noting that when flag <code class="docutils literal notranslate"><span class="pre">LOOKUP_MOUNTPOINT</span></code> is set,
path_lookupat() will unset LOOKUP_JUMPED in nameidata so that in the
subsequent path traversal d_weak_revalidate() won’t be called.
This is important when unmounting a filesystem that is inaccessible, such as
one provided by a dead NFS server.</p>
<p>Finally <code class="docutils literal notranslate"><span class="pre">path_openat()</span></code> is used for the <code class="docutils literal notranslate"><span class="pre">open()</span></code> system call; it
contains, in support functions starting with “open_last_lookups()”, all the
complexity needed to handle the different subtleties of O_CREAT (with
or without O_EXCL), final “<code class="docutils literal notranslate"><span class="pre">/</span></code>” characters, and trailing symbolic
links.  We will revisit this in the final part of this series, which
focuses on those symbolic links.  “open_last_lookups()” will sometimes, but
not always, take <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code>, depending on what it finds.</p>
<p>Each of these, or the functions which call them, need to be alert to
the possibility that the final component is not <code class="docutils literal notranslate"><span class="pre">LAST_NORM</span></code>.  If the
goal of the lookup is to create something, then any value for
<code class="docutils literal notranslate"><span class="pre">last_type</span></code> other than <code class="docutils literal notranslate"><span class="pre">LAST_NORM</span></code> will result in an error.  For
example if <code class="docutils literal notranslate"><span class="pre">path_parentat()</span></code> reports <code class="docutils literal notranslate"><span class="pre">LAST_DOTDOT</span></code>, then the caller
won’t try to create that name.  They also check for trailing slashes
by testing <code class="docutils literal notranslate"><span class="pre">last.name[last.len]</span></code>.  If there is any character beyond
the final component, it must be a trailing slash.</p>
</section>
<section id="revalidation-and-automounts">
<h3>Revalidation and automounts<a class="headerlink" href="#revalidation-and-automounts" title="Permalink to this headline">¶</a></h3>
<p>Apart from symbolic links, there are only two parts of the “REF-walk”
process not yet covered.  One is the handling of stale cache entries
and the other is automounts.</p>
<p>On filesystems that require it, the lookup routines will call the
<code class="docutils literal notranslate"><span class="pre">-&gt;d_revalidate()</span></code> dentry method to ensure that the cached information
is current.  This will often confirm validity or update a few details
from a server.  In some cases it may find that there has been change
further up the path and that something that was thought to be valid
previously isn’t really.  When this happens the lookup of the whole
path is aborted and retried with the “<code class="docutils literal notranslate"><span class="pre">LOOKUP_REVAL</span></code>” flag set.  This
forces revalidation to be more thorough.  We will see more details of
this retry process in the next article.</p>
<p>Automount points are locations in the filesystem where an attempt to
lookup a name can trigger changes to how that lookup should be
handled, in particular by mounting a filesystem there.  These are
covered in greater detail in <a class="reference internal" href="autofs.html"><span class="doc">autofs - how it works</span></a> in the Linux documentation
tree, but a few notes specifically related to path lookup are in order
here.</p>
<p>The Linux VFS has a concept of “managed” dentries.  There are three
potentially interesting things about these dentries corresponding
to three different flags that might be set in <code class="docutils literal notranslate"><span class="pre">dentry-&gt;d_flags</span></code>:</p>
<section id="dcache-manage-transit">
<h4><code class="docutils literal notranslate"><span class="pre">DCACHE_MANAGE_TRANSIT</span></code><a class="headerlink" href="#dcache-manage-transit" title="Permalink to this headline">¶</a></h4>
<p>If this flag has been set, then the filesystem has requested that the
<code class="docutils literal notranslate"><span class="pre">d_manage()</span></code> dentry operation be called before handling any possible
mount point.  This can perform two particular services:</p>
<p>It can block to avoid races.  If an automount point is being
unmounted, the <code class="docutils literal notranslate"><span class="pre">d_manage()</span></code> function will usually wait for that
process to complete before letting the new lookup proceed and possibly
trigger a new automount.</p>
<p>It can selectively allow only some processes to transit through a
mount point.  When a server process is managing automounts, it may
need to access a directory without triggering normal automount
processing.  That server process can identify itself to the <code class="docutils literal notranslate"><span class="pre">autofs</span></code>
filesystem, which will then give it a special pass through
<code class="docutils literal notranslate"><span class="pre">d_manage()</span></code> by returning <code class="docutils literal notranslate"><span class="pre">-EISDIR</span></code>.</p>
</section>
<section id="dcache-mounted">
<h4><code class="docutils literal notranslate"><span class="pre">DCACHE_MOUNTED</span></code><a class="headerlink" href="#dcache-mounted" title="Permalink to this headline">¶</a></h4>
<p>This flag is set on every dentry that is mounted on.  As Linux
supports multiple filesystem namespaces, it is possible that the
dentry may not be mounted on in <em>this</em> namespace, just in some
other.  So this flag is seen as a hint, not a promise.</p>
<p>If this flag is set, and <code class="docutils literal notranslate"><span class="pre">d_manage()</span></code> didn’t return <code class="docutils literal notranslate"><span class="pre">-EISDIR</span></code>,
<code class="docutils literal notranslate"><span class="pre">lookup_mnt()</span></code> is called to examine the mount hash table (honoring the
<code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> described earlier) and possibly return a new <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code>
and a new <code class="docutils literal notranslate"><span class="pre">dentry</span></code> (both with counted references).</p>
</section>
<section id="dcache-need-automount">
<h4><code class="docutils literal notranslate"><span class="pre">DCACHE_NEED_AUTOMOUNT</span></code><a class="headerlink" href="#dcache-need-automount" title="Permalink to this headline">¶</a></h4>
<p>If <code class="docutils literal notranslate"><span class="pre">d_manage()</span></code> allowed us to get this far, and <code class="docutils literal notranslate"><span class="pre">lookup_mnt()</span></code> didn’t
find a mount point, then this flag causes the <code class="docutils literal notranslate"><span class="pre">d_automount()</span></code> dentry
operation to be called.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">d_automount()</span></code> operation can be arbitrarily complex and may
communicate with server processes etc. but it should ultimately either
report that there was an error, that there was nothing to mount, or
should provide an updated <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> with new <code class="docutils literal notranslate"><span class="pre">dentry</span></code> and <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code>.</p>
<p>In the latter case, <code class="docutils literal notranslate"><span class="pre">finish_automount()</span></code> will be called to safely
install the new mount point into the mount table.</p>
<p>There is no new locking of import here and it is important that no
locks (only counted references) are held over this processing due to
the very real possibility of extended delays.
This will become more important next time when we examine RCU-walk
which is particularly sensitive to delays.</p>
</section>
</section>
</section>
<section id="rcu-walk-faster-pathname-lookup-in-linux">
<h2>RCU-walk - faster pathname lookup in Linux<a class="headerlink" href="#rcu-walk-faster-pathname-lookup-in-linux" title="Permalink to this headline">¶</a></h2>
<p>RCU-walk is another algorithm for performing pathname lookup in Linux.
It is in many ways similar to REF-walk and the two share quite a bit
of code.  The significant difference in RCU-walk is how it allows for
the possibility of concurrent access.</p>
<p>We noted that REF-walk is complex because there are numerous details
and special cases.  RCU-walk reduces this complexity by simply
refusing to handle a number of cases – it instead falls back to
REF-walk.  The difficulty with RCU-walk comes from a different
direction: unfamiliarity.  The locking rules when depending on RCU are
quite different from traditional locking, so we will spend a little extra
time when we come to those.</p>
<section id="clear-demarcation-of-roles">
<h3>Clear demarcation of roles<a class="headerlink" href="#clear-demarcation-of-roles" title="Permalink to this headline">¶</a></h3>
<p>The easiest way to manage concurrency is to forcibly stop any other
thread from changing the data structures that a given thread is
looking at.  In cases where no other thread would even think of
changing the data and lots of different threads want to read at the
same time, this can be very costly.  Even when using locks that permit
multiple concurrent readers, the simple act of updating the count of
the number of current readers can impose an unwanted cost.  So the
goal when reading a shared data structure that no other process is
changing is to avoid writing anything to memory at all.  Take no
locks, increment no counts, leave no footprints.</p>
<p>The REF-walk mechanism already described certainly doesn’t follow this
principle, but then it is really designed to work when there may well
be other threads modifying the data.  RCU-walk, in contrast, is
designed for the common situation where there are lots of frequent
readers and only occasional writers.  This may not be common in all
parts of the filesystem tree, but in many parts it will be.  For the
other parts it is important that RCU-walk can quickly fall back to
using REF-walk.</p>
<p>Pathname lookup always starts in RCU-walk mode but only remains there
as long as what it is looking for is in the cache and is stable.  It
dances lightly down the cached filesystem image, leaving no footprints
and carefully watching where it is, to be sure it doesn’t trip.  If it
notices that something has changed or is changing, or if something
isn’t in the cache, then it tries to stop gracefully and switch to
REF-walk.</p>
<p>This stopping requires getting a counted reference on the current
<code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> and <code class="docutils literal notranslate"><span class="pre">dentry</span></code>, and ensuring that these are still valid -
that a path walk with REF-walk would have found the same entries.
This is an invariant that RCU-walk must guarantee.  It can only make
decisions, such as selecting the next step, that are decisions which
REF-walk could also have made if it were walking down the tree at the
same time.  If the graceful stop succeeds, the rest of the path is
processed with the reliable, if slightly sluggish, REF-walk.  If
RCU-walk finds it cannot stop gracefully, it simply gives up and
restarts from the top with REF-walk.</p>
<p>This pattern of “try RCU-walk, if that fails try REF-walk” can be
clearly seen in functions like filename_lookup(),
filename_parentat(),
do_filp_open(), and do_file_open_root().  These four
correspond roughly to the three <code class="docutils literal notranslate"><span class="pre">path_*()</span></code> functions we met earlier,
each of which calls <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code>.  The <code class="docutils literal notranslate"><span class="pre">path_*()</span></code> functions are
called using different mode flags until a mode is found which works.
They are first called with <code class="docutils literal notranslate"><span class="pre">LOOKUP_RCU</span></code> set to request “RCU-walk”.  If
that fails with the error <code class="docutils literal notranslate"><span class="pre">ECHILD</span></code> they are called again with no
special flag to request “REF-walk”.  If either of those report the
error <code class="docutils literal notranslate"><span class="pre">ESTALE</span></code> a final attempt is made with <code class="docutils literal notranslate"><span class="pre">LOOKUP_REVAL</span></code> set (and no
<code class="docutils literal notranslate"><span class="pre">LOOKUP_RCU</span></code>) to ensure that entries found in the cache are forcibly
revalidated - normally entries are only revalidated if the filesystem
determines that they are too old to trust.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LOOKUP_RCU</span></code> attempt may drop that flag internally and switch to
REF-walk, but will never then try to switch back to RCU-walk.  Places
that trip up RCU-walk are much more likely to be near the leaves and
so it is very unlikely that there will be much, if any, benefit from
switching back.</p>
</section>
<section id="rcu-and-seqlocks-fast-and-light">
<h3>RCU and seqlocks: fast and light<a class="headerlink" href="#rcu-and-seqlocks-fast-and-light" title="Permalink to this headline">¶</a></h3>
<p>RCU is, unsurprisingly, critical to RCU-walk mode.  The
<code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> is held for the entire time that RCU-walk is walking
down a path.  The particular guarantee it provides is that the key
data structures - dentries, inodes, super_blocks, and mounts - will
not be freed while the lock is held.  They might be unlinked or
invalidated in one way or another, but the memory will not be
repurposed so values in various fields will still be meaningful.  This
is the only guarantee that RCU provides; everything else is done using
seqlocks.</p>
<p>As we saw above, REF-walk holds a counted reference to the current
dentry and the current vfsmount, and does not release those references
before taking references to the “next” dentry or vfsmount.  It also
sometimes takes the <code class="docutils literal notranslate"><span class="pre">d_lock</span></code> spinlock.  These references and locks are
taken to prevent certain changes from happening.  RCU-walk must not
take those references or locks and so cannot prevent such changes.
Instead, it checks to see if a change has been made, and aborts or
retries if it has.</p>
<p>To preserve the invariant mentioned above (that RCU-walk may only make
decisions that REF-walk could have made), it must make the checks at
or near the same places that REF-walk holds the references.  So, when
REF-walk increments a reference count or takes a spinlock, RCU-walk
samples the status of a seqlock using <code class="docutils literal notranslate"><span class="pre">read_seqcount_begin()</span></code> or a
similar function.  When REF-walk decrements the count or drops the
lock, RCU-walk checks if the sampled status is still valid using
<code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code> or similar.</p>
<p>However, there is a little bit more to seqlocks than that.  If
RCU-walk accesses two different fields in a seqlock-protected
structure, or accesses the same field twice, there is no a priori
guarantee of any consistency between those accesses.  When consistency
is needed - which it usually is - RCU-walk must take a copy and then
use <code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code> to validate that copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code> not only checks the sequence number, but also
imposes a memory barrier so that no memory-read instruction from
<em>before</em> the call can be delayed until <em>after</em> the call, either by the
CPU or by the compiler.  A simple example of this can be seen in
<code class="docutils literal notranslate"><span class="pre">slow_dentry_cmp()</span></code> which, for filesystems which do not use simple
byte-wise name equality, calls into the filesystem to compare a name
against a dentry.  The length and name pointer are copied into local
variables, then <code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code> is called to confirm the two
are consistent, and only then is <code class="docutils literal notranslate"><span class="pre">-&gt;d_compare()</span></code> called.  When
standard filename comparison is used, <code class="docutils literal notranslate"><span class="pre">dentry_cmp()</span></code> is called
instead.  Notably it does <em>not</em> use <code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code>, but
instead has a large comment explaining why the consistency guarantee
isn’t necessary.  A subsequent <code class="docutils literal notranslate"><span class="pre">read_seqcount_retry()</span></code> will be
sufficient to catch any problem that could occur at this point.</p>
<p>With that little refresher on seqlocks out of the way we can look at
the bigger picture of how RCU-walk uses seqlocks.</p>
<section id="mount-lock-and-nd-m-seq">
<h4><code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> and <code class="docutils literal notranslate"><span class="pre">nd-&gt;m_seq</span></code><a class="headerlink" href="#mount-lock-and-nd-m-seq" title="Permalink to this headline">¶</a></h4>
<p>We already met the <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> seqlock when REF-walk used it to
ensure that crossing a mount point is performed safely.  RCU-walk uses
it for that too, but for quite a bit more.</p>
<p>Instead of taking a counted reference to each <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> as it
descends the tree, RCU-walk samples the state of <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> at the
start of the walk and stores this initial sequence number in the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code> in the <code class="docutils literal notranslate"><span class="pre">m_seq</span></code> field.  This one lock and one
sequence number are used to validate all accesses to all <code class="docutils literal notranslate"><span class="pre">vfsmounts</span></code>,
and all mount point crossings.  As changes to the mount table are
relatively rare, it is reasonable to fall back on REF-walk any time
that any “mount” or “unmount” happens.</p>
<p><code class="docutils literal notranslate"><span class="pre">m_seq</span></code> is checked (using <code class="docutils literal notranslate"><span class="pre">read_seqretry()</span></code>) at the end of an RCU-walk
sequence, whether switching to REF-walk for the rest of the path or
when the end of the path is reached.  It is also checked when stepping
down over a mount point (in <code class="docutils literal notranslate"><span class="pre">__follow_mount_rcu()</span></code>) or up (in
<code class="docutils literal notranslate"><span class="pre">follow_dotdot_rcu()</span></code>).  If it is ever found to have changed, the
whole RCU-walk sequence is aborted and the path is processed again by
REF-walk.</p>
<p>If RCU-walk finds that <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> hasn’t changed then it can be sure
that, had REF-walk taken counted references on each vfsmount, the
results would have been the same.  This ensures the invariant holds,
at least for vfsmount structures.</p>
</section>
<section id="dentry-d-seq-and-nd-seq">
<h4><code class="docutils literal notranslate"><span class="pre">dentry-&gt;d_seq</span></code> and <code class="docutils literal notranslate"><span class="pre">nd-&gt;seq</span></code><a class="headerlink" href="#dentry-d-seq-and-nd-seq" title="Permalink to this headline">¶</a></h4>
<p>In place of taking a count or lock on <code class="docutils literal notranslate"><span class="pre">d_reflock</span></code>, RCU-walk samples
the per-dentry <code class="docutils literal notranslate"><span class="pre">d_seq</span></code> seqlock, and stores the sequence number in the
<code class="docutils literal notranslate"><span class="pre">seq</span></code> field of the nameidata structure, so <code class="docutils literal notranslate"><span class="pre">nd-&gt;seq</span></code> should always be
the current sequence number of <code class="docutils literal notranslate"><span class="pre">nd-&gt;dentry</span></code>.  This number needs to be
revalidated after copying, and before using, the name, parent, or
inode of the dentry.</p>
<p>The handling of the name we have already looked at, and the parent is
only accessed in <code class="docutils literal notranslate"><span class="pre">follow_dotdot_rcu()</span></code> which fairly trivially follows
the required pattern, though it does so for three different cases.</p>
<p>When not at a mount point, <code class="docutils literal notranslate"><span class="pre">d_parent</span></code> is followed and its <code class="docutils literal notranslate"><span class="pre">d_seq</span></code> is
collected.  When we are at a mount point, we instead follow the
<code class="docutils literal notranslate"><span class="pre">mnt-&gt;mnt_mountpoint</span></code> link to get a new dentry and collect its
<code class="docutils literal notranslate"><span class="pre">d_seq</span></code>.  Then, after finally finding a <code class="docutils literal notranslate"><span class="pre">d_parent</span></code> to follow, we must
check if we have landed on a mount point and, if so, must find that
mount point and follow the <code class="docutils literal notranslate"><span class="pre">mnt-&gt;mnt_root</span></code> link.  This would imply a
somewhat unusual, but certainly possible, circumstance where the
starting point of the path lookup was in part of the filesystem that
was mounted on, and so not visible from the root.</p>
<p>The inode pointer, stored in <code class="docutils literal notranslate"><span class="pre">-&gt;d_inode</span></code>, is a little more
interesting.  The inode will always need to be accessed at least
twice, once to determine if it is NULL and once to verify access
permissions.  Symlink handling requires a validated inode pointer too.
Rather than revalidating on each access, a copy is made on the first
access and it is stored in the <code class="docutils literal notranslate"><span class="pre">inode</span></code> field of <code class="docutils literal notranslate"><span class="pre">nameidata</span></code> from where
it can be safely accessed without further validation.</p>
<p><code class="docutils literal notranslate"><span class="pre">lookup_fast()</span></code> is the only lookup routine that is used in RCU-mode,
<code class="docutils literal notranslate"><span class="pre">lookup_slow()</span></code> being too slow and requiring locks.  It is in
<code class="docutils literal notranslate"><span class="pre">lookup_fast()</span></code> that we find the important “hand over hand” tracking
of the current dentry.</p>
<p>The current <code class="docutils literal notranslate"><span class="pre">dentry</span></code> and current <code class="docutils literal notranslate"><span class="pre">seq</span></code> number are passed to
<code class="docutils literal notranslate"><span class="pre">__d_lookup_rcu()</span></code> which, on success, returns a new <code class="docutils literal notranslate"><span class="pre">dentry</span></code> and a
new <code class="docutils literal notranslate"><span class="pre">seq</span></code> number.  <code class="docutils literal notranslate"><span class="pre">lookup_fast()</span></code> then copies the inode pointer and
revalidates the new <code class="docutils literal notranslate"><span class="pre">seq</span></code> number.  It then validates the old <code class="docutils literal notranslate"><span class="pre">dentry</span></code>
with the old <code class="docutils literal notranslate"><span class="pre">seq</span></code> number one last time and only then continues.  This
process of getting the <code class="docutils literal notranslate"><span class="pre">seq</span></code> number of the new dentry and then
checking the <code class="docutils literal notranslate"><span class="pre">seq</span></code> number of the old exactly mirrors the process of
getting a counted reference to the new dentry before dropping that for
the old dentry which we saw in REF-walk.</p>
</section>
<section id="no-inode-i-rwsem-or-even-rename-lock">
<h4>No <code class="docutils literal notranslate"><span class="pre">inode-&gt;i_rwsem</span></code> or even <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code><a class="headerlink" href="#no-inode-i-rwsem-or-even-rename-lock" title="Permalink to this headline">¶</a></h4>
<p>A semaphore is a fairly heavyweight lock that can only be taken when it is
permissible to sleep.  As <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> forbids sleeping,
<code class="docutils literal notranslate"><span class="pre">inode-&gt;i_rwsem</span></code> plays no role in RCU-walk.  If some other thread does
take <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> and modifies the directory in a way that RCU-walk needs
to notice, the result will be either that RCU-walk fails to find the
dentry that it is looking for, or it will find a dentry which
<code class="docutils literal notranslate"><span class="pre">read_seqretry()</span></code> won’t validate.  In either case it will drop down to
REF-walk mode which can take whatever locks are needed.</p>
<p>Though <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> could be used by RCU-walk as it doesn’t require
any sleeping, RCU-walk doesn’t bother.  REF-walk uses <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> to
protect against the possibility of hash chains in the dcache changing
while they are being searched.  This can result in failing to find
something that actually is there.  When RCU-walk fails to find
something in the dentry cache, whether it is really there or not, it
already drops down to REF-walk and tries again with appropriate
locking.  This neatly handles all cases, so adding extra checks on
rename_lock would bring no significant value.</p>
</section>
</section>
<section id="unlazy-walk-and-complete-walk">
<h3><code class="docutils literal notranslate"><span class="pre">unlazy</span> <span class="pre">walk()</span></code> and <code class="docutils literal notranslate"><span class="pre">complete_walk()</span></code><a class="headerlink" href="#unlazy-walk-and-complete-walk" title="Permalink to this headline">¶</a></h3>
<p>That “dropping down to REF-walk” typically involves a call to
<code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code>, so named because “RCU-walk” is also sometimes
referred to as “lazy walk”.  <code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code> is called when
following the path down to the current vfsmount/dentry pair seems to
have proceeded successfully, but the next step is problematic.  This
can happen if the next name cannot be found in the dcache, if
permission checking or name revalidation couldn’t be achieved while
the <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> is held (which forbids sleeping), if an
automount point is found, or in a couple of cases involving symlinks.
It is also called from <code class="docutils literal notranslate"><span class="pre">complete_walk()</span></code> when the lookup has reached
the final component, or the very end of the path, depending on which
particular flavor of lookup is used.</p>
<p>Other reasons for dropping out of RCU-walk that do not trigger a call
to <code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code> are when some inconsistency is found that cannot be
handled immediately, such as <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> or one of the <code class="docutils literal notranslate"><span class="pre">d_seq</span></code>
seqlocks reporting a change.  In these cases the relevant function
will return <code class="docutils literal notranslate"><span class="pre">-ECHILD</span></code> which will percolate up until it triggers a new
attempt from the top using REF-walk.</p>
<p>For those cases where <code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code> is an option, it essentially
takes a reference on each of the pointers that it holds (vfsmount,
dentry, and possibly some symbolic links) and then verifies that the
relevant seqlocks have not been changed.  If there have been changes,
it, too, aborts with <code class="docutils literal notranslate"><span class="pre">-ECHILD</span></code>, otherwise the transition to REF-walk
has been a success and the lookup process continues.</p>
<p>Taking a reference on those pointers is not quite as simple as just
incrementing a counter.  That works to take a second reference if you
already have one (often indirectly through another object), but it
isn’t sufficient if you don’t actually have a counted reference at
all.  For <code class="docutils literal notranslate"><span class="pre">dentry-&gt;d_lockref</span></code>, it is safe to increment the reference
counter to get a reference unless it has been explicitly marked as
“dead” which involves setting the counter to <code class="docutils literal notranslate"><span class="pre">-128</span></code>.
<code class="docutils literal notranslate"><span class="pre">lockref_get_not_dead()</span></code> achieves this.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">mnt-&gt;mnt_count</span></code> it is safe to take a reference as long as
<code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> is then used to validate the reference.  If that
validation fails, it may <em>not</em> be safe to just drop that reference in
the standard way of calling <code class="docutils literal notranslate"><span class="pre">mnt_put()</span></code> - an unmount may have
progressed too far.  So the code in <code class="docutils literal notranslate"><span class="pre">legitimize_mnt()</span></code>, when it
finds that the reference it got might not be safe, checks the
<code class="docutils literal notranslate"><span class="pre">MNT_SYNC_UMOUNT</span></code> flag to determine if a simple <code class="docutils literal notranslate"><span class="pre">mnt_put()</span></code> is
correct, or if it should just decrement the count and pretend none of
this ever happened.</p>
</section>
<section id="taking-care-in-filesystems">
<h3>Taking care in filesystems<a class="headerlink" href="#taking-care-in-filesystems" title="Permalink to this headline">¶</a></h3>
<p>RCU-walk depends almost entirely on cached information and often will
not call into the filesystem at all.  However there are two places,
besides the already-mentioned component-name comparison, where the
file system might be included in RCU-walk, and it must know to be
careful.</p>
<p>If the filesystem has non-standard permission-checking requirements -
such as a networked filesystem which may need to check with the server
- the <code class="docutils literal notranslate"><span class="pre">i_op-&gt;permission</span></code> interface might be called during RCU-walk.
In this case an extra “<code class="docutils literal notranslate"><span class="pre">MAY_NOT_BLOCK</span></code>” flag is passed so that it
knows not to sleep, but to return <code class="docutils literal notranslate"><span class="pre">-ECHILD</span></code> if it cannot complete
promptly.  <code class="docutils literal notranslate"><span class="pre">i_op-&gt;permission</span></code> is given the inode pointer, not the
dentry, so it doesn’t need to worry about further consistency checks.
However if it accesses any other filesystem data structures, it must
ensure they are safe to be accessed with only the <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code>
held.  This typically means they must be freed using <code class="docutils literal notranslate"><span class="pre">kfree_rcu()</span></code> or
similar.</p>
<p>If the filesystem may need to revalidate dcache entries, then
<code class="docutils literal notranslate"><span class="pre">d_op-&gt;d_revalidate</span></code> may be called in RCU-walk too.  This interface
<em>is</em> passed the dentry but does not have access to the <code class="docutils literal notranslate"><span class="pre">inode</span></code> or the
<code class="docutils literal notranslate"><span class="pre">seq</span></code> number from the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code>, so it needs to be extra careful
when accessing fields in the dentry.  This “extra care” typically
involves using  <a class="reference external" href="https://lwn.net/Articles/624126/">READ_ONCE()</a> to access fields, and verifying the
result is not NULL before using it.  This pattern can be seen in
<code class="docutils literal notranslate"><span class="pre">nfs_lookup_revalidate()</span></code>.</p>
</section>
<section id="a-pair-of-patterns">
<h3>A pair of patterns<a class="headerlink" href="#a-pair-of-patterns" title="Permalink to this headline">¶</a></h3>
<p>In various places in the details of REF-walk and RCU-walk, and also in
the big picture, there are a couple of related patterns that are worth
being aware of.</p>
<p>The first is “try quickly and check, if that fails try slowly”.  We
can see that in the high-level approach of first trying RCU-walk and
then trying REF-walk, and in places where <code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code> is used to
switch to REF-walk for the rest of the path.  We also saw it earlier
in <code class="docutils literal notranslate"><span class="pre">dget_parent()</span></code> when following a “<code class="docutils literal notranslate"><span class="pre">..</span></code>” link.  It tries a quick way
to get a reference, then falls back to taking locks if needed.</p>
<p>The second pattern is “try quickly and check, if that fails try
again - repeatedly”.  This is seen with the use of <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> and
<code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> in REF-walk.  RCU-walk doesn’t make use of this pattern -
if anything goes wrong it is much safer to just abort and try a more
sedate approach.</p>
<p>The emphasis here is “try quickly and check”.  It should probably be
“try quickly <em>and carefully</em>, then check”.  The fact that checking is
needed is a reminder that the system is dynamic and only a limited
number of things are safe at all.  The most likely cause of errors in
this whole process is assuming something is safe when in reality it
isn’t.  Careful consideration of what exactly guarantees the safety of
each access is sometimes necessary.</p>
</section>
</section>
<section id="a-walk-among-the-symlinks">
<h2>A walk among the symlinks<a class="headerlink" href="#a-walk-among-the-symlinks" title="Permalink to this headline">¶</a></h2>
<p>There are several basic issues that we will examine to understand the
handling of symbolic links:  the symlink stack, together with cache
lifetimes, will help us understand the overall recursive handling of
symlinks and lead to the special care needed for the final component.
Then a consideration of access-time updates and summary of the various
flags controlling lookup will finish the story.</p>
<section id="the-symlink-stack">
<h3>The symlink stack<a class="headerlink" href="#the-symlink-stack" title="Permalink to this headline">¶</a></h3>
<p>There are only two sorts of filesystem objects that can usefully
appear in a path prior to the final component: directories and symlinks.
Handling directories is quite straightforward: the new directory
simply becomes the starting point at which to interpret the next
component on the path.  Handling symbolic links requires a bit more
work.</p>
<p>Conceptually, symbolic links could be handled by editing the path.  If
a component name refers to a symbolic link, then that component is
replaced by the body of the link and, if that body starts with a ‘/’,
then all preceding parts of the path are discarded.  This is what the
“<code class="docutils literal notranslate"><span class="pre">readlink</span> <span class="pre">-f</span></code>” command does, though it also edits out “<code class="docutils literal notranslate"><span class="pre">.</span></code>” and
“<code class="docutils literal notranslate"><span class="pre">..</span></code>” components.</p>
<p>Directly editing the path string is not really necessary when looking
up a path, and discarding early components is pointless as they aren’t
looked at anyway.  Keeping track of all remaining components is
important, but they can of course be kept separately; there is no need
to concatenate them.  As one symlink may easily refer to another,
which in turn can refer to a third, we may need to keep the remaining
components of several paths, each to be processed when the preceding
ones are completed.  These path remnants are kept on a stack of
limited size.</p>
<p>There are two reasons for placing limits on how many symlinks can
occur in a single path lookup.  The most obvious is to avoid loops.
If a symlink referred to itself either directly or through
intermediaries, then following the symlink can never complete
successfully - the error <code class="docutils literal notranslate"><span class="pre">ELOOP</span></code> must be returned.  Loops can be
detected without imposing limits, but limits are the simplest solution
and, given the second reason for restriction, quite sufficient.</p>
<p>The second reason was <a class="reference external" href="http://thread.gmane.org/gmane.linux.kernel/1934390/focus=1934550">outlined recently</a> by Linus:</p>
<blockquote>
<div><p>Because it’s a latency and DoS issue too. We need to react well to
true loops, but also to “very deep” non-loops. It’s not about memory
use, it’s about users triggering unreasonable CPU resources.</p>
</div></blockquote>
<p>Linux imposes a limit on the length of any pathname: <code class="docutils literal notranslate"><span class="pre">PATH_MAX</span></code>, which
is 4096.  There are a number of reasons for this limit; not letting the
kernel spend too much time on just one path is one of them.  With
symbolic links you can effectively generate much longer paths so some
sort of limit is needed for the same reason.  Linux imposes a limit of
at most 40 (MAXSYMLINKS) symlinks in any one path lookup.  It previously imposed
a further limit of eight on the maximum depth of recursion, but that was
raised to 40 when a separate stack was implemented, so there is now
just the one limit.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nameidata</span></code> structure that we met in an earlier article contains a
small stack that can be used to store the remaining part of up to two
symlinks.  In many cases this will be sufficient.  If it isn’t, a
separate stack is allocated with room for 40 symlinks.  Pathname
lookup will never exceed that stack as, once the 40th symlink is
detected, an error is returned.</p>
<p>It might seem that the name remnants are all that needs to be stored on
this stack, but we need a bit more.  To see that, we need to move on to
cache lifetimes.</p>
</section>
<section id="storage-and-lifetime-of-cached-symlinks">
<h3>Storage and lifetime of cached symlinks<a class="headerlink" href="#storage-and-lifetime-of-cached-symlinks" title="Permalink to this headline">¶</a></h3>
<p>Like other filesystem resources, such as inodes and directory
entries, symlinks are cached by Linux to avoid repeated costly access
to external storage.  It is particularly important for RCU-walk to be
able to find and temporarily hold onto these cached entries, so that
it doesn’t need to drop down into REF-walk.</p>
<p>While each filesystem is free to make its own choice, symlinks are
typically stored in one of two places.  Short symlinks are often
stored directly in the inode.  When a filesystem allocates a <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">inode</span></code> it typically allocates extra space to store private data (a
common <a class="reference external" href="https://lwn.net/Articles/446317/">object-oriented design pattern</a> in the kernel).  This will
sometimes include space for a symlink.  The other common location is
in the page cache, which normally stores the content of files.  The
pathname in a symlink can be seen as the content of that symlink and
can easily be stored in the page cache just like file content.</p>
<p>When neither of these is suitable, the next most likely scenario is
that the filesystem will allocate some temporary memory and copy or
construct the symlink content into that memory whenever it is needed.</p>
<p>When the symlink is stored in the inode, it has the same lifetime as
the inode which, itself, is protected by RCU or by a counted reference
on the dentry.  This means that the mechanisms that pathname lookup
uses to access the dcache and icache (inode cache) safely are quite
sufficient for accessing some cached symlinks safely.  In these cases,
the <code class="docutils literal notranslate"><span class="pre">i_link</span></code> pointer in the inode is set to point to wherever the
symlink is stored and it can be accessed directly whenever needed.</p>
<p>When the symlink is stored in the page cache or elsewhere, the
situation is not so straightforward.  A reference on a dentry or even
on an inode does not imply any reference on cached pages of that
inode, and even an <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> is not sufficient to ensure that
a page will not disappear.  So for these symlinks the pathname lookup
code needs to ask the filesystem to provide a stable reference and,
significantly, needs to release that reference when it is finished
with it.</p>
<p>Taking a reference to a cache page is often possible even in RCU-walk
mode.  It does require making changes to memory, which is best avoided,
but that isn’t necessarily a big cost and it is better than dropping
out of RCU-walk mode completely.  Even filesystems that allocate
space to copy the symlink into can use <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> to often successfully
allocate memory without the need to drop out of RCU-walk.  If a
filesystem cannot successfully get a reference in RCU-walk mode, it
must return <code class="docutils literal notranslate"><span class="pre">-ECHILD</span></code> and <code class="docutils literal notranslate"><span class="pre">unlazy_walk()</span></code> will be called to return to
REF-walk mode in which the filesystem is allowed to sleep.</p>
<p>The place for all this to happen is the <code class="docutils literal notranslate"><span class="pre">i_op-&gt;get_link()</span></code> inode
method. This is called both in RCU-walk and REF-walk. In RCU-walk the
<code class="docutils literal notranslate"><span class="pre">dentry*</span></code> argument is NULL, <code class="docutils literal notranslate"><span class="pre">-&gt;get_link()</span></code> can return -ECHILD to drop out of
RCU-walk.  Much like the <code class="docutils literal notranslate"><span class="pre">i_op-&gt;permission()</span></code> method we
looked at previously, <code class="docutils literal notranslate"><span class="pre">-&gt;get_link()</span></code> would need to be careful that
all the data structures it references are safe to be accessed while
holding no counted reference, only the RCU lock. A callback
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_called</span></code> will be passed to <code class="docutils literal notranslate"><span class="pre">-&gt;get_link()</span></code>:
file systems can set their own put_link function and argument through
set_delayed_call(). Later on, when VFS wants to put link, it will call
do_delayed_call() to invoke that callback function with the argument.</p>
<p>In order for the reference to each symlink to be dropped when the walk completes,
whether in RCU-walk or REF-walk, the symlink stack needs to contain,
along with the path remnants:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> to provide a reference to the previous path</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> to provide a reference to the to previous name</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">seq</span></code> to allow the path to be safely switched from RCU-walk to REF-walk</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span></code> for later invocation.</p></li>
</ul>
<p>This means that each entry in the symlink stack needs to hold five
pointers and an integer instead of just one pointer (the path
remnant).  On a 64-bit system, this is about 40 bytes per entry;
with 40 entries it adds up to 1600 bytes total, which is less than
half a page.  So it might seem like a lot, but is by no means
excessive.</p>
<p>Note that, in a given stack frame, the path remnant (<code class="docutils literal notranslate"><span class="pre">name</span></code>) is not
part of the symlink that the other fields refer to.  It is the remnant
to be followed once that symlink has been fully parsed.</p>
</section>
<section id="following-the-symlink">
<h3>Following the symlink<a class="headerlink" href="#following-the-symlink" title="Permalink to this headline">¶</a></h3>
<p>The main loop in <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> iterates seamlessly over all
components in the path and all of the non-final symlinks.  As symlinks
are processed, the <code class="docutils literal notranslate"><span class="pre">name</span></code> pointer is adjusted to point to a new
symlink, or is restored from the stack, so that much of the loop
doesn’t need to notice.  Getting this <code class="docutils literal notranslate"><span class="pre">name</span></code> variable on and off the
stack is very straightforward; pushing and popping the references is
a little more complex.</p>
<p>When a symlink is found, walk_component() calls pick_link() via step_into()
which returns the link from the filesystem.
Providing that operation is successful, the old path <code class="docutils literal notranslate"><span class="pre">name</span></code> is placed on the
stack, and the new value is used as the <code class="docutils literal notranslate"><span class="pre">name</span></code> for a while.  When the end of
the path is found (i.e. <code class="docutils literal notranslate"><span class="pre">*name</span></code> is <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>) the old <code class="docutils literal notranslate"><span class="pre">name</span></code> is restored
off the stack and path walking continues.</p>
<p>Pushing and popping the reference pointers (inode, cookie, etc.) is more
complex in part because of the desire to handle tail recursion.  When
the last component of a symlink itself points to a symlink, we
want to pop the symlink-just-completed off the stack before pushing
the symlink-just-found to avoid leaving empty path remnants that would
just get in the way.</p>
<p>It is most convenient to push the new symlink references onto the
stack in <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> immediately when the symlink is found;
<code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> is also the last piece of code that needs to look at the
old symlink as it walks that last component.  So it is quite
convenient for <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> to release the old symlink and pop
the references just before pushing the reference information for the
new symlink.  It is guided in this by three flags: <code class="docutils literal notranslate"><span class="pre">WALK_NOFOLLOW</span></code> which
forbids it from following a symlink if it finds one, <code class="docutils literal notranslate"><span class="pre">WALK_MORE</span></code>
which indicates that it is yet too early to release the
current symlink, and <code class="docutils literal notranslate"><span class="pre">WALK_TRAILING</span></code> which indicates that it is on the final
component of the lookup, so we will check userspace flag <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOLLOW</span></code> to
decide whether follow it when it is a symlink and call <code class="docutils literal notranslate"><span class="pre">may_follow_link()</span></code> to
check if we have privilege to follow it.</p>
<section id="symlinks-with-no-final-component">
<h4>Symlinks with no final component<a class="headerlink" href="#symlinks-with-no-final-component" title="Permalink to this headline">¶</a></h4>
<p>A pair of special-case symlinks deserve a little further explanation.
Both result in a new <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> (with mount and dentry) being set
up in the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code>, and result in pick_link() returning <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The more obvious case is a symlink to “<code class="docutils literal notranslate"><span class="pre">/</span></code>”.  All symlinks starting
with “<code class="docutils literal notranslate"><span class="pre">/</span></code>” are detected in pick_link() which resets the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code>
to point to the effective filesystem root.  If the symlink only
contains “<code class="docutils literal notranslate"><span class="pre">/</span></code>” then there is nothing more to do, no components at all,
so <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned to indicate that the symlink can be released and
the stack frame discarded.</p>
<p>The other case involves things in <code class="docutils literal notranslate"><span class="pre">/proc</span></code> that look like symlinks but
aren’t really (and are therefore commonly referred to as “magic-links”):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -l /proc/self/fd/1
lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -&gt; /dev/pts/4
</pre></div>
</div>
<p>Every open file descriptor in any process is represented in <code class="docutils literal notranslate"><span class="pre">/proc</span></code> by
something that looks like a symlink.  It is really a reference to the
target file, not just the name of it.  When you <code class="docutils literal notranslate"><span class="pre">readlink</span></code> these
objects you get a name that might refer to the same file - unless it
has been unlinked or mounted over.  When <code class="docutils literal notranslate"><span class="pre">walk_component()</span></code> follows
one of these, the <code class="docutils literal notranslate"><span class="pre">-&gt;get_link()</span></code> method in “procfs” doesn’t return
a string name, but instead calls nd_jump_link() which updates the
<code class="docutils literal notranslate"><span class="pre">nameidata</span></code> in place to point to that target.  <code class="docutils literal notranslate"><span class="pre">-&gt;get_link()</span></code> then
returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  Again there is no final component and pick_link()
returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</section>
</section>
<section id="following-the-symlink-in-the-final-component">
<h3>Following the symlink in the final component<a class="headerlink" href="#following-the-symlink-in-the-final-component" title="Permalink to this headline">¶</a></h3>
<p>All this leads to <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> walking down every component, and
following all symbolic links it finds, until it reaches the final
component.  This is just returned in the <code class="docutils literal notranslate"><span class="pre">last</span></code> field of <code class="docutils literal notranslate"><span class="pre">nameidata</span></code>.
For some callers, this is all they need; they want to create that
<code class="docutils literal notranslate"><span class="pre">last</span></code> name if it doesn’t exist or give an error if it does.  Other
callers will want to follow a symlink if one is found, and possibly
apply special handling to the last component of that symlink, rather
than just the last component of the original file name.  These callers
potentially need to call <code class="docutils literal notranslate"><span class="pre">link_path_walk()</span></code> again and again on
successive symlinks until one is found that doesn’t point to another
symlink.</p>
<p>This case is handled by relevant callers of link_path_walk(), such as
path_lookupat(), path_openat() using a loop that calls link_path_walk(),
and then handles the final component by calling open_last_lookups() or
lookup_last(). If it is a symlink that needs to be followed,
open_last_lookups() or lookup_last() will set things up properly and
return the path so that the loop repeats, calling
link_path_walk() again.  This could loop as many as 40 times if the last
component of each symlink is another symlink.</p>
<p>Of the various functions that examine the final component,
open_last_lookups() is the most interesting as it works in tandem
with do_open() for opening a file.  Part of open_last_lookups() runs
with <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> held and this part is in a separate function: lookup_open().</p>
<p>Explaining open_last_lookups() and do_open() completely is beyond the scope
of this article, but a few highlights should help those interested in exploring
the code.</p>
<ol class="arabic">
<li><p>Rather than just finding the target file, do_open() is used after
open_last_lookup() to open
it.  If the file was found in the dcache, then <code class="docutils literal notranslate"><span class="pre">vfs_open()</span></code> is used for
this.  If not, then <code class="docutils literal notranslate"><span class="pre">lookup_open()</span></code> will either call <code class="docutils literal notranslate"><span class="pre">atomic_open()</span></code> (if
the filesystem provides it) to combine the final lookup with the open, or
will perform the separate <code class="docutils literal notranslate"><span class="pre">i_op-&gt;lookup()</span></code> and <code class="docutils literal notranslate"><span class="pre">i_op-&gt;create()</span></code> steps
directly.  In the later case the actual “open” of this newly found or
created file will be performed by vfs_open(), just as if the name
were found in the dcache.</p></li>
<li><p>vfs_open() can fail with <code class="docutils literal notranslate"><span class="pre">-EOPENSTALE</span></code> if the cached information
wasn’t quite current enough.  If it’s in RCU-walk <code class="docutils literal notranslate"><span class="pre">-ECHILD</span></code> will be returned
otherwise <code class="docutils literal notranslate"><span class="pre">-ESTALE</span></code> is returned.  When <code class="docutils literal notranslate"><span class="pre">-ESTALE</span></code> is returned, the caller may
retry with <code class="docutils literal notranslate"><span class="pre">LOOKUP_REVAL</span></code> flag set.</p></li>
<li><p>An open with O_CREAT <strong>does</strong> follow a symlink in the final component,
unlike other creation system calls (like <code class="docutils literal notranslate"><span class="pre">mkdir</span></code>).  So the sequence:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ln -s bar /tmp/foo
echo hello &gt; /tmp/foo
</pre></div>
</div>
<p>will create a file called <code class="docutils literal notranslate"><span class="pre">/tmp/bar</span></code>.  This is not permitted if
<code class="docutils literal notranslate"><span class="pre">O_EXCL</span></code> is set but otherwise is handled for an O_CREAT open much
like for a non-creating open: lookup_last() or open_last_lookup()
returns a non <code class="docutils literal notranslate"><span class="pre">NULL</span></code> value, and link_path_walk() gets called and the
open process continues on the symlink that was found.</p>
</li>
</ol>
</section>
<section id="updating-the-access-time">
<h3>Updating the access time<a class="headerlink" href="#updating-the-access-time" title="Permalink to this headline">¶</a></h3>
<p>We previously said of RCU-walk that it would “take no locks, increment
no counts, leave no footprints.”  We have since seen that some
“footprints” can be needed when handling symlinks as a counted
reference (or even a memory allocation) may be needed.  But these
footprints are best kept to a minimum.</p>
<p>One other place where walking down a symlink can involve leaving
footprints in a way that doesn’t affect directories is in updating access times.
In Unix (and Linux) every filesystem object has a “last accessed
time”, or “<code class="docutils literal notranslate"><span class="pre">atime</span></code>”.  Passing through a directory to access a file
within is not considered to be an access for the purposes of
<code class="docutils literal notranslate"><span class="pre">atime</span></code>; only listing the contents of a directory can update its <code class="docutils literal notranslate"><span class="pre">atime</span></code>.
Symlinks are different it seems.  Both reading a symlink (with <code class="docutils literal notranslate"><span class="pre">readlink()</span></code>)
and looking up a symlink on the way to some other destination can
update the atime on that symlink.</p>
<p>It is not clear why this is the case; POSIX has little to say on the
subject.  The <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_08">clearest statement</a> is that, if a particular implementation
updates a timestamp in a place not specified by POSIX, this must be
documented “except that any changes caused by pathname resolution need
not be documented”.  This seems to imply that POSIX doesn’t really
care about access-time updates during pathname lookup.</p>
<p>An examination of history shows that prior to <a class="reference external" href="https://git.kernel.org/cgit/linux/kernel/git/history/history.git/diff/fs/ext2/symlink.c?id=f806c6db77b8eaa6e00dcfb6b567706feae8dbb8">Linux 1.3.87</a>, the ext2
filesystem, at least, didn’t update atime when following a link.
Unfortunately we have no record of why that behavior was changed.</p>
<p>In any case, access time must now be updated and that operation can be
quite complex.  Trying to stay in RCU-walk while doing it is best
avoided.  Fortunately it is often permitted to skip the <code class="docutils literal notranslate"><span class="pre">atime</span></code>
update.  Because <code class="docutils literal notranslate"><span class="pre">atime</span></code> updates cause performance problems in various
areas, Linux supports the <code class="docutils literal notranslate"><span class="pre">relatime</span></code> mount option, which generally
limits the updates of <code class="docutils literal notranslate"><span class="pre">atime</span></code> to once per day on files that aren’t
being changed (and symlinks never change once created).  Even without
<code class="docutils literal notranslate"><span class="pre">relatime</span></code>, many filesystems record <code class="docutils literal notranslate"><span class="pre">atime</span></code> with a one-second
granularity, so only one update per second is required.</p>
<p>It is easy to test if an <code class="docutils literal notranslate"><span class="pre">atime</span></code> update is needed while in RCU-walk
mode and, if it isn’t, the update can be skipped and RCU-walk mode
continues.  Only when an <code class="docutils literal notranslate"><span class="pre">atime</span></code> update is actually required does the
path walk drop down to REF-walk.  All of this is handled in the
<code class="docutils literal notranslate"><span class="pre">get_link()</span></code> function.</p>
</section>
<section id="a-few-flags">
<h3>A few flags<a class="headerlink" href="#a-few-flags" title="Permalink to this headline">¶</a></h3>
<p>A suitable way to wrap up this tour of pathname walking is to list
the various flags that can be stored in the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code> to guide the
lookup process.  Many of these are only meaningful on the final
component, others reflect the current state of the pathname lookup, and some
apply restrictions to all path components encountered in the path lookup.</p>
<p>And then there is <code class="docutils literal notranslate"><span class="pre">LOOKUP_EMPTY</span></code>, which doesn’t fit conceptually with
the others.  If this is not set, an empty pathname causes an error
very early on.  If it is set, empty pathnames are not considered to be
an error.</p>
<section id="global-state-flags">
<h4>Global state flags<a class="headerlink" href="#global-state-flags" title="Permalink to this headline">¶</a></h4>
<p>We have already met two global state flags: <code class="docutils literal notranslate"><span class="pre">LOOKUP_RCU</span></code> and
<code class="docutils literal notranslate"><span class="pre">LOOKUP_REVAL</span></code>.  These select between one of three overall approaches
to lookup: RCU-walk, REF-walk, and REF-walk with forced revalidation.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_PARENT</span></code> indicates that the final component hasn’t been reached
yet.  This is primarily used to tell the audit subsystem the full
context of a particular access being audited.</p>
<p><code class="docutils literal notranslate"><span class="pre">ND_ROOT_PRESET</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">root</span></code> field in the <code class="docutils literal notranslate"><span class="pre">nameidata</span></code> was
provided by the caller, so it shouldn’t be released when it is no
longer needed.</p>
<p><code class="docutils literal notranslate"><span class="pre">ND_JUMPED</span></code> means that the current dentry was chosen not because
it had the right name but for some other reason.  This happens when
following “<code class="docutils literal notranslate"><span class="pre">..</span></code>”, following a symlink to <code class="docutils literal notranslate"><span class="pre">/</span></code>, crossing a mount point
or accessing a “<code class="docutils literal notranslate"><span class="pre">/proc/$PID/fd/$FD</span></code>” symlink (also known as a “magic
link”). In this case the filesystem has not been asked to revalidate the
name (with <code class="docutils literal notranslate"><span class="pre">d_revalidate()</span></code>).  In such cases the inode may still need
to be revalidated, so <code class="docutils literal notranslate"><span class="pre">d_op-&gt;d_weak_revalidate()</span></code> is called if
<code class="docutils literal notranslate"><span class="pre">ND_JUMPED</span></code> is set when the look completes - which may be at the
final component or, when creating, unlinking, or renaming, at the penultimate component.</p>
</section>
<section id="resolution-restriction-flags">
<h4>Resolution-restriction flags<a class="headerlink" href="#resolution-restriction-flags" title="Permalink to this headline">¶</a></h4>
<p>In order to allow userspace to protect itself against certain race conditions
and attack scenarios involving changing path components, a series of flags are
available which apply restrictions to all path components encountered during
path lookup. These flags are exposed through <code class="docutils literal notranslate"><span class="pre">openat2()</span></code>’s <code class="docutils literal notranslate"><span class="pre">resolve</span></code> field.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_NO_SYMLINKS</span></code> blocks all symlink traversals (including magic-links).
This is distinctly different from <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOLLOW</span></code>, because the latter only
relates to restricting the following of trailing symlinks.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_NO_MAGICLINKS</span></code> blocks all magic-link traversals. Filesystems must
ensure that they return errors from <code class="docutils literal notranslate"><span class="pre">nd_jump_link()</span></code>, because that is how
<code class="docutils literal notranslate"><span class="pre">LOOKUP_NO_MAGICLINKS</span></code> and other magic-link restrictions are implemented.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_NO_XDEV</span></code> blocks all <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> traversals (this includes both
bind-mounts and ordinary mounts). Note that the <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> which contains the
lookup is determined by the first mountpoint the path lookup reaches –
absolute paths start with the <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> of <code class="docutils literal notranslate"><span class="pre">/</span></code>, and relative paths start
with the <code class="docutils literal notranslate"><span class="pre">dfd</span></code>’s <code class="docutils literal notranslate"><span class="pre">vfsmount</span></code>. Magic-links are only permitted if the
<code class="docutils literal notranslate"><span class="pre">vfsmount</span></code> of the path is unchanged.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_BENEATH</span></code> blocks any path components which resolve outside the
starting point of the resolution. This is done by blocking <code class="docutils literal notranslate"><span class="pre">nd_jump_root()</span></code>
as well as blocking “..” if it would jump outside the starting point.
<code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> and <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> are used to detect attacks against the
resolution of “..”. Magic-links are also blocked.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_IN_ROOT</span></code> resolves all path components as though the starting point
were the filesystem root. <code class="docutils literal notranslate"><span class="pre">nd_jump_root()</span></code> brings the resolution back to
the starting point, and “..” at the starting point will act as a no-op. As with
<code class="docutils literal notranslate"><span class="pre">LOOKUP_BENEATH</span></code>, <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code> and <code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> are used to detect
attacks against “..” resolution. Magic-links are also blocked.</p>
</section>
<section id="final-component-flags">
<h4>Final-component flags<a class="headerlink" href="#final-component-flags" title="Permalink to this headline">¶</a></h4>
<p>Some of these flags are only set when the final component is being
considered.  Others are only checked for when considering that final
component.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_AUTOMOUNT</span></code> ensures that, if the final component is an automount
point, then the mount is triggered.  Some operations would trigger it
anyway, but operations like <code class="docutils literal notranslate"><span class="pre">stat()</span></code> deliberately don’t.  <code class="docutils literal notranslate"><span class="pre">statfs()</span></code>
needs to trigger the mount but otherwise behaves a lot like <code class="docutils literal notranslate"><span class="pre">stat()</span></code>, so
it sets <code class="docutils literal notranslate"><span class="pre">LOOKUP_AUTOMOUNT</span></code>, as does “<code class="docutils literal notranslate"><span class="pre">quotactl()</span></code>” and the handling of
“<code class="docutils literal notranslate"><span class="pre">mount</span> <span class="pre">--bind</span></code>”.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_FOLLOW</span></code> has a similar function to <code class="docutils literal notranslate"><span class="pre">LOOKUP_AUTOMOUNT</span></code> but for
symlinks.  Some system calls set or clear it implicitly, while
others have API flags such as <code class="docutils literal notranslate"><span class="pre">AT_SYMLINK_FOLLOW</span></code> and
<code class="docutils literal notranslate"><span class="pre">UMOUNT_NOFOLLOW</span></code> to control it.  Its effect is similar to
<code class="docutils literal notranslate"><span class="pre">WALK_GET</span></code> that we already met, but it is used in a different way.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOOKUP_DIRECTORY</span></code> insists that the final component is a directory.
Various callers set this and it is also set when the final component
is found to be followed by a slash.</p>
<p>Finally <code class="docutils literal notranslate"><span class="pre">LOOKUP_OPEN</span></code>, <code class="docutils literal notranslate"><span class="pre">LOOKUP_CREATE</span></code>, <code class="docutils literal notranslate"><span class="pre">LOOKUP_EXCL</span></code>, and
<code class="docutils literal notranslate"><span class="pre">LOOKUP_RENAME_TARGET</span></code> are not used directly by the VFS but are made
available to the filesystem and particularly the <code class="docutils literal notranslate"><span class="pre">-&gt;d_revalidate()</span></code>
method.  A filesystem can choose not to bother revalidating too hard
if it knows that it will be asked to open or create the file soon.
These flags were previously useful for <code class="docutils literal notranslate"><span class="pre">-&gt;lookup()</span></code> too but with the
introduction of <code class="docutils literal notranslate"><span class="pre">-&gt;atomic_open()</span></code> they are less relevant there.</p>
</section>
</section>
<section id="end-of-the-road">
<h3>End of the road<a class="headerlink" href="#end-of-the-road" title="Permalink to this headline">¶</a></h3>
<p>Despite its complexity, all this pathname lookup code appears to be
in good shape - various parts are certainly easier to understand now
than even a couple of releases ago.  But that doesn’t mean it is
“finished”.   As already mentioned, RCU-walk currently only follows
symlinks that are stored in the inode so, while it handles many ext4
symlinks, it doesn’t help with NFS, XFS, or Btrfs.  That support
is not likely to be long delayed.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Pathname lookup</a><ul>
<li><a class="reference internal" href="#introduction-to-pathname-lookup">Introduction to pathname lookup</a><ul>
<li><a class="reference internal" href="#there-are-two-sorts-of">There are two sorts of …</a></li>
<li><a class="reference internal" href="#more-than-just-a-cache">More than just a cache</a></li>
<li><a class="reference internal" href="#ref-walk-simple-concurrency-management-with-refcounts-and-spinlocks">REF-walk: simple concurrency management with refcounts and spinlocks</a><ul>
<li><a class="reference internal" href="#dentry-d-lockref">dentry-&gt;d_lockref</a></li>
<li><a class="reference internal" href="#dentry-d-lock">dentry-&gt;d_lock</a></li>
<li><a class="reference internal" href="#rename-lock">rename_lock</a></li>
<li><a class="reference internal" href="#inode-i-rwsem">inode-&gt;i_rwsem</a></li>
<li><a class="reference internal" href="#mnt-mnt-count">mnt-&gt;mnt_count</a></li>
<li><a class="reference internal" href="#mount-lock">mount_lock</a></li>
<li><a class="reference internal" href="#rcu">RCU</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bringing-it-together-with-struct-nameidata">Bringing it together with <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code></a><ul>
<li><a class="reference internal" href="#struct-path-path"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">path</span></code></a></li>
<li><a class="reference internal" href="#struct-qstr-last"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">last</span></code></a></li>
<li><a class="reference internal" href="#int-last-type"><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">last_type</span></code></a></li>
<li><a class="reference internal" href="#struct-path-root"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">root</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-the-final-component">Handling the final component</a></li>
<li><a class="reference internal" href="#revalidation-and-automounts">Revalidation and automounts</a><ul>
<li><a class="reference internal" href="#dcache-manage-transit"><code class="docutils literal notranslate"><span class="pre">DCACHE_MANAGE_TRANSIT</span></code></a></li>
<li><a class="reference internal" href="#dcache-mounted"><code class="docutils literal notranslate"><span class="pre">DCACHE_MOUNTED</span></code></a></li>
<li><a class="reference internal" href="#dcache-need-automount"><code class="docutils literal notranslate"><span class="pre">DCACHE_NEED_AUTOMOUNT</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rcu-walk-faster-pathname-lookup-in-linux">RCU-walk - faster pathname lookup in Linux</a><ul>
<li><a class="reference internal" href="#clear-demarcation-of-roles">Clear demarcation of roles</a></li>
<li><a class="reference internal" href="#rcu-and-seqlocks-fast-and-light">RCU and seqlocks: fast and light</a><ul>
<li><a class="reference internal" href="#mount-lock-and-nd-m-seq"><code class="docutils literal notranslate"><span class="pre">mount_lock</span></code> and <code class="docutils literal notranslate"><span class="pre">nd-&gt;m_seq</span></code></a></li>
<li><a class="reference internal" href="#dentry-d-seq-and-nd-seq"><code class="docutils literal notranslate"><span class="pre">dentry-&gt;d_seq</span></code> and <code class="docutils literal notranslate"><span class="pre">nd-&gt;seq</span></code></a></li>
<li><a class="reference internal" href="#no-inode-i-rwsem-or-even-rename-lock">No <code class="docutils literal notranslate"><span class="pre">inode-&gt;i_rwsem</span></code> or even <code class="docutils literal notranslate"><span class="pre">rename_lock</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#unlazy-walk-and-complete-walk"><code class="docutils literal notranslate"><span class="pre">unlazy</span> <span class="pre">walk()</span></code> and <code class="docutils literal notranslate"><span class="pre">complete_walk()</span></code></a></li>
<li><a class="reference internal" href="#taking-care-in-filesystems">Taking care in filesystems</a></li>
<li><a class="reference internal" href="#a-pair-of-patterns">A pair of patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-walk-among-the-symlinks">A walk among the symlinks</a><ul>
<li><a class="reference internal" href="#the-symlink-stack">The symlink stack</a></li>
<li><a class="reference internal" href="#storage-and-lifetime-of-cached-symlinks">Storage and lifetime of cached symlinks</a></li>
<li><a class="reference internal" href="#following-the-symlink">Following the symlink</a><ul>
<li><a class="reference internal" href="#symlinks-with-no-final-component">Symlinks with no final component</a></li>
</ul>
</li>
<li><a class="reference internal" href="#following-the-symlink-in-the-final-component">Following the symlink in the final component</a></li>
<li><a class="reference internal" href="#updating-the-access-time">Updating the access time</a></li>
<li><a class="reference internal" href="#a-few-flags">A few flags</a><ul>
<li><a class="reference internal" href="#global-state-flags">Global state flags</a></li>
<li><a class="reference internal" href="#resolution-restriction-flags">Resolution-restriction flags</a></li>
<li><a class="reference internal" href="#final-component-flags">Final-component flags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#end-of-the-road">End of the road</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/path-lookup.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/path-lookup.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>