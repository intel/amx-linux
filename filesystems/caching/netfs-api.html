
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Network Filesystem Caching API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Cache Backend API" href="backend-api.html" />
    <link rel="prev" title="General Filesystem Caching" href="fscache.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="network-filesystem-caching-api">
<h1>Network Filesystem Caching API<a class="headerlink" href="#network-filesystem-caching-api" title="Permalink to this headline">¶</a></h1>
<p>Fscache provides an API by which a network filesystem can make use of local
caching facilities.  The API is arranged around a number of principles:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A cache is logically organised into volumes and data storage objects
within those volumes.</p></li>
<li><p>Volumes and data storage objects are represented by various types of
cookie.</p></li>
<li><p>Cookies have keys that distinguish them from their peers.</p></li>
<li><p>Cookies have coherency data that allows a cache to determine if the
cached data is still valid.</p></li>
<li><p>I/O is done asynchronously where possible.</p></li>
</ol>
</div></blockquote>
<p>This API is used by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/fscache.h&gt;.
</pre></div>
</div>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The fscache hierarchy is organised on two levels from a network filesystem’s
point of view.  The upper level represents “volumes” and the lower level
represents “data storage objects”.  These are represented by two types of
cookie, hereafter referred to as “volume cookies” and “cookies”.</p>
<p>A network filesystem acquires a volume cookie for a volume using a volume key,
which represents all the information that defines that volume (e.g. cell name
or server address, volume ID or share name).  This must be rendered as a
printable string that can be used as a directory name (ie. no ‘/’ characters
and shouldn’t begin with a ‘.’).  The maximum name length is one less than the
maximum size of a filename component (allowing the cache backend one char for
its own purposes).</p>
<p>A filesystem would typically have a volume cookie for each superblock.</p>
<p>The filesystem then acquires a cookie for each file within that volume using an
object key.  Object keys are binary blobs and only need to be unique within
their parent volume.  The cache backend is reponsible for rendering the binary
blob into something it can use and may employ hash tables, trees or whatever to
improve its ability to find an object.  This is transparent to the network
filesystem.</p>
<p>A filesystem would typically have a cookie for each inode, and would acquire it
in iget and relinquish it when evicting the cookie.</p>
<p>Once it has a cookie, the filesystem needs to mark the cookie as being in use.
This causes fscache to send the cache backend off to look up/create resources
for the cookie in the background, to check its coherency and, if necessary, to
mark the object as being under modification.</p>
<p>A filesystem would typically “use” the cookie in its file open routine and
unuse it in file release and it needs to use the cookie around calls to
truncate the cookie locally.  It <em>also</em> needs to use the cookie when the
pagecache becomes dirty and unuse it when writeback is complete.  This is
slightly tricky, and provision is made for it.</p>
<p>When performing a read, write or resize on a cookie, the filesystem must first
begin an operation.  This copies the resources into a holding struct and puts
extra pins into the cache to stop cache withdrawal from tearing down the
structures being used.  The actual operation can then be issued and conflicting
invalidations can be detected upon completion.</p>
<p>The filesystem is expected to use netfslib to access the cache, but that’s not
actually required and it can use the fscache I/O API directly.</p>
</section>
<section id="volume-registration">
<h2>Volume Registration<a class="headerlink" href="#volume-registration" title="Permalink to this headline">¶</a></h2>
<p>The first step for a network filsystem is to acquire a volume cookie for the
volume it wants to access:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_volume *
fscache_acquire_volume(const char *volume_key,
                       const char *cache_name,
                       const void *coherency_data,
                       size_t coherency_len);
</pre></div>
</div>
<p>This function creates a volume cookie with the specified volume key as its name
and notes the coherency data.</p>
<p>The volume key must be a printable string with no ‘/’ characters in it.  It
should begin with the name of the filesystem and should be no longer than 254
characters.  It should uniquely represent the volume and will be matched with
what’s stored in the cache.</p>
<p>The caller may also specify the name of the cache to use.  If specified,
fscache will look up or create a cache cookie of that name and will use a cache
of that name if it is online or comes online.  If no cache name is specified,
it will use the first cache that comes to hand and set the name to that.</p>
<p>The specified coherency data is stored in the cookie and will be matched
against coherency data stored on disk.  The data pointer may be NULL if no data
is provided.  If the coherency data doesn’t match, the entire cache volume will
be invalidated.</p>
<p>This function can return errors such as EBUSY if the volume key is already in
use by an acquired volume or ENOMEM if an allocation failure occured.  It may
also return a NULL volume cookie if fscache is not enabled.  It is safe to
pass a NULL cookie to any function that takes a volume cookie.  This will
cause that function to do nothing.</p>
<p>When the network filesystem has finished with a volume, it should relinquish it
by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_relinquish_volume(struct fscache_volume *volume,
                               const void *coherency_data,
                               bool invalidate);
</pre></div>
</div>
<p>This will cause the volume to be committed or removed, and if sealed the
coherency data will be set to the value supplied.  The amount of coherency data
must match the length specified when the volume was acquired.  Note that all
data cookies obtained in this volume must be relinquished before the volume is
relinquished.</p>
</section>
<section id="data-file-registration">
<h2>Data File Registration<a class="headerlink" href="#data-file-registration" title="Permalink to this headline">¶</a></h2>
<p>Once it has a volume cookie, a network filesystem can use it to acquire a
cookie for data storage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie *
fscache_acquire_cookie(struct fscache_volume *volume,
                       u8 advice,
                       const void *index_key,
                       size_t index_key_len,
                       const void *aux_data,
                       size_t aux_data_len,
                       loff_t object_size)
</pre></div>
</div>
<p>This creates the cookie in the volume using the specified index key.  The index
key is a binary blob of the given length and must be unique for the volume.
This is saved into the cookie.  There are no restrictions on the content, but
its length shouldn’t exceed about three quarters of the maximum filename length
to allow for encoding.</p>
<p>The caller should also pass in a piece of coherency data in aux_data.  A buffer
of size aux_data_len will be allocated and the coherency data copied in.  It is
assumed that the size is invariant over time.  The coherency data is used to
check the validity of data in the cache.  Functions are provided by which the
coherency data can be updated.</p>
<p>The file size of the object being cached should also be provided.  This may be
used to trim the data and will be stored with the coherency data.</p>
<p>This function never returns an error, though it may return a NULL cookie on
allocation failure or if fscache is not enabled.  It is safe to pass in a NULL
volume cookie and pass the NULL cookie returned to any function that takes it.
This will cause that function to do nothing.</p>
<p>When the network filesystem has finished with a cookie, it should relinquish it
by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_relinquish_cookie(struct fscache_cookie *cookie,
                               bool retire);
</pre></div>
</div>
<p>This will cause fscache to either commit the storage backing the cookie or
delete it.</p>
</section>
<section id="marking-a-cookie-in-use">
<h2>Marking A Cookie In-Use<a class="headerlink" href="#marking-a-cookie-in-use" title="Permalink to this headline">¶</a></h2>
<p>Once a cookie has been acquired by a network filesystem, the filesystem should
tell fscache when it intends to use the cookie (typically done on file open)
and should say when it has finished with it (typically on file close):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_use_cookie(struct fscache_cookie *cookie,
                        bool will_modify);
void fscache_unuse_cookie(struct fscache_cookie *cookie,
                          const void *aux_data,
                          const loff_t *object_size);
</pre></div>
</div>
<p>The <em>use</em> function tells fscache that it will use the cookie and, additionally,
indicate if the user is intending to modify the contents locally.  If not yet
done, this will trigger the cache backend to go and gather the resources it
needs to access/store data in the cache.  This is done in the background, and
so may not be complete by the time the function returns.</p>
<p>The <em>unuse</em> function indicates that a filesystem has finished using a cookie.
It optionally updates the stored coherency data and object size and then
decreases the in-use counter.  When the last user unuses the cookie, it is
scheduled for garbage collection.  If not reused within a short time, the
resources will be released to reduce system resource consumption.</p>
<p>A cookie must be marked in-use before it can be accessed for read, write or
resize - and an in-use mark must be kept whilst there is dirty data in the
pagecache in order to avoid an oops due to trying to open a file during process
exit.</p>
<p>Note that in-use marks are cumulative.  For each time a cookie is marked
in-use, it must be unused.</p>
</section>
<section id="resizing-a-data-file-truncation">
<h2>Resizing A Data File (Truncation)<a class="headerlink" href="#resizing-a-data-file-truncation" title="Permalink to this headline">¶</a></h2>
<p>If a network filesystem file is resized locally by truncation, the following
should be called to notify the cache:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_resize_cookie(struct fscache_cookie *cookie,
                           loff_t new_size);
</pre></div>
</div>
<p>The caller must have first marked the cookie in-use.  The cookie and the new
size are passed in and the cache is synchronously resized.  This is expected to
be called from <code class="docutils literal notranslate"><span class="pre">-&gt;setattr()</span></code> inode operation under the inode lock.</p>
</section>
<section id="data-i-o-api">
<h2>Data I/O API<a class="headerlink" href="#data-i-o-api" title="Permalink to this headline">¶</a></h2>
<p>To do data I/O operations directly through a cookie, the following functions
are available:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_begin_read_operation(struct netfs_cache_resources *cres,
                                 struct fscache_cookie *cookie);
int fscache_read(struct netfs_cache_resources *cres,
                 loff_t start_pos,
                 struct iov_iter *iter,
                 enum netfs_read_from_hole read_hole,
                 netfs_io_terminated_t term_func,
                 void *term_func_priv);
int fscache_write(struct netfs_cache_resources *cres,
                  loff_t start_pos,
                  struct iov_iter *iter,
                  netfs_io_terminated_t term_func,
                  void *term_func_priv);
</pre></div>
</div>
<p>The <em>begin</em> function sets up an operation, attaching the resources required to
the cache resources block from the cookie.  Assuming it doesn’t return an error
(for instance, it will return -ENOBUFS if given a NULL cookie, but otherwise do
nothing), then one of the other two functions can be issued.</p>
<p>The <em>read</em> and <em>write</em> functions initiate a direct-IO operation.  Both take the
previously set up cache resources block, an indication of the start file
position, and an I/O iterator that describes buffer and indicates the amount of
data.</p>
<p>The read function also takes a parameter to indicate how it should handle a
partially populated region (a hole) in the disk content.  This may be to ignore
it, skip over an initial hole and place zeros in the buffer or give an error.</p>
<p>The read and write functions can be given an optional termination function that
will be run on completion:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef
void (*netfs_io_terminated_t)(void *priv, ssize_t transferred_or_error,
                              bool was_async);
</pre></div>
</div>
<p>If a termination function is given, the operation will be run asynchronously
and the termination function will be called upon completion.  If not given, the
operation will be run synchronously.  Note that in the asynchronous case, it is
possible for the operation to complete before the function returns.</p>
<p>Both the read and write functions end the operation when they complete,
detaching any pinned resources.</p>
<p>The read operation will fail with ESTALE if invalidation occurred whilst the
operation was ongoing.</p>
</section>
<section id="data-file-coherency">
<h2>Data File Coherency<a class="headerlink" href="#data-file-coherency" title="Permalink to this headline">¶</a></h2>
<p>To request an update of the coherency data and file size on a cookie, the
following should be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_update_cookie(struct fscache_cookie *cookie,
                           const void *aux_data,
                           const loff_t *object_size);
</pre></div>
</div>
<p>This will update the cookie’s coherency data and/or file size.</p>
</section>
<section id="data-file-invalidation">
<h2>Data File Invalidation<a class="headerlink" href="#data-file-invalidation" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it will be necessary to invalidate an object that contains data.
Typically this will be necessary when the server informs the network filesystem
of a remote third-party change - at which point the filesystem has to throw
away the state and cached data that it had for an file and reload from the
server.</p>
<p>To indicate that a cache object should be invalidated, the following should be
called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_invalidate(struct fscache_cookie *cookie,
                        const void *aux_data,
                        loff_t size,
                        unsigned int flags);
</pre></div>
</div>
<p>This increases the invalidation counter in the cookie to cause outstanding
reads to fail with -ESTALE, sets the coherency data and file size from the
information supplied, blocks new I/O on the cookie and dispatches the cache to
go and get rid of the old data.</p>
<p>Invalidation runs asynchronously in a worker thread so that it doesn’t block
too much.</p>
</section>
<section id="write-back-resource-management">
<h2>Write-Back Resource Management<a class="headerlink" href="#write-back-resource-management" title="Permalink to this headline">¶</a></h2>
<p>To write data to the cache from network filesystem writeback, the cache
resources required need to be pinned at the point the modification is made (for
instance when the page is marked dirty) as it’s not possible to open a file in
a thread that’s exiting.</p>
<p>The following facilities are provided to manage this:</p>
<blockquote>
<div><ul class="simple">
<li><p>An inode flag, <code class="docutils literal notranslate"><span class="pre">I_PINNING_FSCACHE_WB</span></code>, is provided to indicate that an
in-use is held on the cookie for this inode.  It can only be changed if the
the inode lock is held.</p></li>
<li><p>A flag, <code class="docutils literal notranslate"><span class="pre">unpinned_fscache_wb</span></code> is placed in the <code class="docutils literal notranslate"><span class="pre">writeback_control</span></code>
struct that gets set if <code class="docutils literal notranslate"><span class="pre">__writeback_single_inode()</span></code> clears
<code class="docutils literal notranslate"><span class="pre">I_PINNING_FSCACHE_WB</span></code> because all the dirty pages were cleared.</p></li>
</ul>
</div></blockquote>
<p>To support this, the following functions are provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool fscache_dirty_folio(struct address_space *mapping,
                         struct folio *folio,
                         struct fscache_cookie *cookie);
void fscache_unpin_writeback(struct writeback_control *wbc,
                             struct fscache_cookie *cookie);
void fscache_clear_inode_writeback(struct fscache_cookie *cookie,
                                   struct inode *inode,
                                   const void *aux);
</pre></div>
</div>
<p>The <em>set</em> function is intended to be called from the filesystem’s
<code class="docutils literal notranslate"><span class="pre">dirty_folio</span></code> address space operation.  If <code class="docutils literal notranslate"><span class="pre">I_PINNING_FSCACHE_WB</span></code> is not
set, it sets that flag and increments the use count on the cookie (the caller
must already have called <code class="docutils literal notranslate"><span class="pre">fscache_use_cookie()</span></code>).</p>
<p>The <em>unpin</em> function is intended to be called from the filesystem’s
<code class="docutils literal notranslate"><span class="pre">write_inode</span></code> superblock operation.  It cleans up after writing by unusing
the cookie if unpinned_fscache_wb is set in the writeback_control struct.</p>
<p>The <em>clear</em> function is intended to be called from the netfs’s <code class="docutils literal notranslate"><span class="pre">evict_inode</span></code>
superblock operation.  It must be called <em>after</em>
<code class="docutils literal notranslate"><span class="pre">truncate_inode_pages_final()</span></code>, but <em>before</em> <code class="docutils literal notranslate"><span class="pre">clear_inode()</span></code>.  This cleans
up any hanging <code class="docutils literal notranslate"><span class="pre">I_PINNING_FSCACHE_WB</span></code>.  It also allows the coherency data to
be updated.</p>
</section>
<section id="caching-of-local-modifications">
<h2>Caching of Local Modifications<a class="headerlink" href="#caching-of-local-modifications" title="Permalink to this headline">¶</a></h2>
<p>If a network filesystem has locally modified data that it wants to write to the
cache, it needs to mark the pages to indicate that a write is in progress, and
if the mark is already present, it needs to wait for it to be removed first
(presumably due to an already in-progress operation).  This prevents multiple
competing DIO writes to the same storage in the cache.</p>
<p>Firstly, the netfs should determine if caching is available by doing something
like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool caching = fscache_cookie_enabled(cookie);
</pre></div>
</div>
<p>If caching is to be attempted, pages should be waited for and then marked using
the following functions provided by the netfs helper library:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void set_page_fscache(struct page *page);
void wait_on_page_fscache(struct page *page);
int wait_on_page_fscache_killable(struct page *page);
</pre></div>
</div>
<p>Once all the pages in the span are marked, the netfs can ask fscache to
schedule a write of that region:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_write_to_cache(struct fscache_cookie *cookie,
                            struct address_space *mapping,
                            loff_t start, size_t len, loff_t i_size,
                            netfs_io_terminated_t term_func,
                            void *term_func_priv,
                            bool caching)
</pre></div>
</div>
<p>And if an error occurs before that point is reached, the marks can be removed
by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_clear_page_bits(struct address_space *mapping,
                             loff_t start, size_t len,
                             bool caching)
</pre></div>
</div>
<p>In these functions, a pointer to the mapping to which the source pages are
attached is passed in and start and len indicate the size of the region that’s
going to be written (it doesn’t have to align to page boundaries necessarily,
but it does have to align to DIO boundaries on the backing filesystem).  The
caching parameter indicates if caching should be skipped, and if false, the
functions do nothing.</p>
<p>The write function takes some additional parameters: the cookie representing
the cache object to be written to, i_size indicates the size of the netfs file
and term_func indicates an optional completion function, to which
term_func_priv will be passed, along with the error or amount written.</p>
<p>Note that the write function will always run asynchronously and will unmark all
the pages upon completion before calling term_func.</p>
</section>
<section id="page-release-and-invalidation">
<h2>Page Release and Invalidation<a class="headerlink" href="#page-release-and-invalidation" title="Permalink to this headline">¶</a></h2>
<p>Fscache keeps track of whether we have any data in the cache yet for a cache
object we’ve just created.  It knows it doesn’t have to do any reading until it
has done a write and then the page it wrote from has been released by the VM,
after which it <em>has</em> to look in the cache.</p>
<p>To inform fscache that a page might now be in the cache, the following function
should be called from the <code class="docutils literal notranslate"><span class="pre">release_folio</span></code> address space op:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_note_page_release(struct fscache_cookie *cookie);
</pre></div>
</div>
<p>if the page has been released (ie. release_folio returned true).</p>
<p>Page release and page invalidation should also wait for any mark left on the
page to say that a DIO write is underway from that page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void wait_on_page_fscache(struct page *page);
int wait_on_page_fscache_killable(struct page *page);
</pre></div>
</div>
</section>
<section id="api-function-reference">
<h2>API Function Reference<a class="headerlink" href="#api-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.fscache_acquire_volume">
struct fscache_volume * <code class="sig-name descname">fscache_acquire_volume</code><span class="sig-paren">(</span>const char<em> *volume_key</em>, const char<em> *cache_name</em>, const void<em> *coherency_data</em>, size_t<em> coherency_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_acquire_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a volume as desiring caching services</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*volume_key</span></code></dt><dd><p>An identification string for the volume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cache_name</span></code></dt><dd><p>The name of the cache to use (or NULL for the default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*coherency_data</span></code></dt><dd><p>Piece of arbitrary coherency data to check (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">coherency_len</span></code></dt><dd><p>The size of the coherency data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a volume as desiring caching services if they’re available.  The
caller must provide an identifier for the volume and may also indicate which
cache it should be in.  If a preexisting volume entry is found in the cache,
the coherency data must match otherwise the entry will be invalidated.</p>
<p>Returns a cookie pointer on success, -ENOMEM if out of memory or -EBUSY if a
cache volume of that name is already acquired.  Note that “NULL” is a valid
cookie pointer and can be returned if caching is refused.</p>
</div>
<dl class="function">
<dt id="c.fscache_relinquish_volume">
void <code class="sig-name descname">fscache_relinquish_volume</code><span class="sig-paren">(</span>struct fscache_volume<em> *volume</em>, const void<em> *coherency_data</em>, bool<em> invalidate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_relinquish_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Cease caching a volume</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_volume</span> <span class="pre">*volume</span></code></dt><dd><p>The volume cookie</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*coherency_data</span></code></dt><dd><p>Piece of arbitrary coherency data to set (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">invalidate</span></code></dt><dd><p>True if the volume should be invalidated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Indicate that a filesystem no longer desires caching services for a volume.
The caller must have relinquished all file cookies prior to calling this.
The stored coherency data is updated.</p>
</div>
<dl class="function">
<dt id="c.fscache_acquire_cookie">
struct fscache_cookie * <code class="sig-name descname">fscache_acquire_cookie</code><span class="sig-paren">(</span>struct fscache_volume<em> *volume</em>, u8<em> advice</em>, const void<em> *index_key</em>, size_t<em> index_key_len</em>, const void<em> *aux_data</em>, size_t<em> aux_data_len</em>, loff_t<em> object_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_acquire_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a cookie to represent a cache object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_volume</span> <span class="pre">*volume</span></code></dt><dd><p>The volume in which to locate/create this cookie</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">advice</span></code></dt><dd><p>Advice flags (FSCACHE_COOKIE_ADV_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*index_key</span></code></dt><dd><p>The index key for this cookie</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">index_key_len</span></code></dt><dd><p>Size of the index key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*aux_data</span></code></dt><dd><p>The auxiliary data for the cookie (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">aux_data_len</span></code></dt><dd><p>Size of the auxiliary data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">object_size</span></code></dt><dd><p>The initial size of object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquire a cookie to represent a data file within the given cache volume.</p>
<p>See <a class="reference internal" href="#"><span class="doc">Network Filesystem Caching API</span></a> for a complete
description.</p>
</div>
<dl class="function">
<dt id="c.fscache_use_cookie">
void <code class="sig-name descname">fscache_use_cookie</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, bool<em> will_modify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_use_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Request usage of cookie attached to an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">will_modify</span></code></dt><dd><p>If cache is expected to be modified locally</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request usage of the cookie attached to an object.  The caller should tell
the cache if the object’s contents are about to be modified locally and then
the cache can apply the policy that has been set to handle this case.</p>
</div>
<dl class="function">
<dt id="c.fscache_unuse_cookie">
void <code class="sig-name descname">fscache_unuse_cookie</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, const void<em> *aux_data</em>, const loff_t<em> *object_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_unuse_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Cease usage of cookie attached to an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*aux_data</span></code></dt><dd><p>Updated auxiliary data (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">loff_t</span> <span class="pre">*object_size</span></code></dt><dd><p>Revised size of the object (or NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cease usage of the cookie attached to an object.  When the users count
reaches zero then the cookie relinquishment will be permitted to proceed.</p>
</div>
<dl class="function">
<dt id="c.fscache_relinquish_cookie">
void <code class="sig-name descname">fscache_relinquish_cookie</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, bool<em> retire</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_relinquish_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cookie to the cache, maybe discarding it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie being returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">retire</span></code></dt><dd><p>True if the cache object the cookie represents is to be discarded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a cookie to the cache, forcibly discarding the
associated cache object if retire is set to true.</p>
<p>See <a class="reference internal" href="#"><span class="doc">Network Filesystem Caching API</span></a> for a complete
description.</p>
</div>
<dl class="function">
<dt id="c.fscache_update_cookie">
void <code class="sig-name descname">fscache_update_cookie</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, const void<em> *aux_data</em>, const loff_t<em> *object_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_update_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Request that a cache object be updated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*aux_data</span></code></dt><dd><p>The updated auxiliary data for the cookie (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">loff_t</span> <span class="pre">*object_size</span></code></dt><dd><p>The current size of the object (may be NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request an update of the index data for the cache object associated with the
cookie.  The auxiliary data on the cookie will be updated first if <strong>aux_data</strong>
is set and the object size will be updated and the object possibly trimmed
if <strong>object_size</strong> is set.</p>
<p>See <a class="reference internal" href="#"><span class="doc">Network Filesystem Caching API</span></a> for a complete
description.</p>
</div>
<dl class="function">
<dt id="c.fscache_resize_cookie">
void <code class="sig-name descname">fscache_resize_cookie</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, loff_t<em> new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_resize_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Request that a cache object be resized</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_size</span></code></dt><dd><p>The new size of the object (may be NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request that the size of an object be changed.</p>
<p>See <a class="reference internal" href="#"><span class="doc">Network Filesystem Caching API</span></a> for a complete
description.</p>
</div>
<dl class="function">
<dt id="c.fscache_invalidate">
void <code class="sig-name descname">fscache_invalidate</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, const void<em> *aux_data</em>, loff_t<em> size</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify cache that an object needs invalidation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*aux_data</span></code></dt><dd><p>The updated auxiliary data for the cookie (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">size</span></code></dt><dd><p>The revised size of the object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Invalidation flags (FSCACHE_INVAL_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify the cache that an object is needs to be invalidated and that it
should abort any retrievals or stores it is doing on the cache.  This
increments inval_counter on the cookie which can be used by the caller to
reconsider I/O requests as they complete.</p>
<p>If <strong>flags</strong> has FSCACHE_INVAL_DIO_WRITE set, this indicates that this is due
to a direct I/O write and will cause caching to be disabled on this cookie
until it is completely unused.</p>
<p>See <a class="reference internal" href="#"><span class="doc">Network Filesystem Caching API</span></a> for a complete
description.</p>
</div>
<dl class="function">
<dt id="c.fscache_operation_valid">
const struct netfs_cache_ops * <code class="sig-name descname">fscache_operation_valid</code><span class="sig-paren">(</span>const struct netfs_cache_resources<em> *cres</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_operation_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if operations resources are usable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The resources to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the operations table if usable or NULL if not.</p>
</div>
<dl class="function">
<dt id="c.fscache_begin_read_operation">
int <code class="sig-name descname">fscache_begin_read_operation</code><span class="sig-paren">(</span>struct netfs_cache_resources<em> *cres</em>, struct fscache_cookie<em> *cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_begin_read_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin a read operation for the netfs lib</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The cache resources for the read being performed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Begin a read operation on behalf of the netfs helper library.  <strong>cres</strong>
indicates the cache resources to which the operation state should be
attached; <strong>cookie</strong> indicates the cache object that will be accessed.</p>
<p>This is intended to be called from the -&gt;begin_cache_operation() netfs lib
operation as implemented by the network filesystem.</p>
<p><strong>cres-&gt;inval_counter</strong> is set from <strong>cookie-&gt;inval_counter</strong> for comparison at
the end of the operation.  This allows invalidation during the operation to
be detected by the caller.</p>
<p><strong>Return</strong></p>
<ul>
<li><p>0          - Success</p></li>
<li><dl class="option-list">
<dt><kbd><span class="option">-E<var>NOBUFS</var></span></kbd></dt>
<dd><ul class="simple">
<li><p>No caching available</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Other error code from the cache, such as -ENOMEM.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.fscache_end_operation">
void <code class="sig-name descname">fscache_end_operation</code><span class="sig-paren">(</span>struct netfs_cache_resources<em> *cres</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_end_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>End the read operation for the netfs lib</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The cache resources for the read operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clean up the resources at the end of the read request.</p>
</div>
<dl class="function">
<dt id="c.fscache_read">
int <code class="sig-name descname">fscache_read</code><span class="sig-paren">(</span>struct netfs_cache_resources<em> *cres</em>, loff_t<em> start_pos</em>, struct iov_iter<em> *iter</em>, enum netfs_read_from_hole<em> read_hole</em>, netfs_io_terminated_t<em> term_func</em>, void<em> *term_func_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a read from the cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The cache resources to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_pos</span></code></dt><dd><p>The beginning file offset in the cache file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>The buffer to fill - and also the length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">netfs_read_from_hole</span> <span class="pre">read_hole</span></code></dt><dd><p>How to handle a hole in the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netfs_io_terminated_t</span> <span class="pre">term_func</span></code></dt><dd><p>The function to call upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*term_func_priv</span></code></dt><dd><p>The private data for <strong>term_func</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a read from the cache.  <strong>cres</strong> indicates the cache object to read from
and must be obtained by a call to fscache_begin_operation() beforehand.</p>
<p>The data is read into the iterator, <strong>iter</strong>, and that also indicates the size
of the operation.  <strong>start_pos</strong> is the start position in the file, though if
<strong>seek_data</strong> is set appropriately, the cache can use SEEK_DATA to find the
next piece of data, writing zeros for the hole into the iterator.</p>
<p>Upon termination of the operation, <strong>term_func</strong> will be called and supplied
with <strong>term_func_priv</strong> plus the amount of data written, if successful, or the
error code otherwise.</p>
<p><strong>read_hole</strong> indicates how a partially populated region in the cache should be
handled.  It can be one of a number of settings:</p>
<blockquote>
<div><p>NETFS_READ_HOLE_IGNORE - Just try to read (may return a short read).</p>
<dl class="simple">
<dt>NETFS_READ_HOLE_CLEAR - Seek for data, clearing the part of the buffer</dt><dd><p>skipped over, then do as for IGNORE.</p>
</dd>
</dl>
<p>NETFS_READ_HOLE_FAIL - Give ENODATA if we encounter a hole.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fscache_begin_write_operation">
int <code class="sig-name descname">fscache_begin_write_operation</code><span class="sig-paren">(</span>struct netfs_cache_resources<em> *cres</em>, struct fscache_cookie<em> *cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_begin_write_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin a write operation for the netfs lib</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The cache resources for the write being performed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Begin a write operation on behalf of the netfs helper library.  <strong>cres</strong>
indicates the cache resources to which the operation state should be
attached; <strong>cookie</strong> indicates the cache object that will be accessed.</p>
<p><strong>cres-&gt;inval_counter</strong> is set from <strong>cookie-&gt;inval_counter</strong> for comparison at
the end of the operation.  This allows invalidation during the operation to
be detected by the caller.</p>
<p><strong>Return</strong></p>
<ul>
<li><p>0          - Success</p></li>
<li><dl class="option-list">
<dt><kbd><span class="option">-E<var>NOBUFS</var></span></kbd></dt>
<dd><ul class="simple">
<li><p>No caching available</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Other error code from the cache, such as -ENOMEM.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.fscache_write">
int <code class="sig-name descname">fscache_write</code><span class="sig-paren">(</span>struct netfs_cache_resources<em> *cres</em>, loff_t<em> start_pos</em>, struct iov_iter<em> *iter</em>, netfs_io_terminated_t<em> term_func</em>, void<em> *term_func_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a write to the cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_cache_resources</span> <span class="pre">*cres</span></code></dt><dd><p>The cache resources to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_pos</span></code></dt><dd><p>The beginning file offset in the cache file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>The data to write - and also the length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netfs_io_terminated_t</span> <span class="pre">term_func</span></code></dt><dd><p>The function to call upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*term_func_priv</span></code></dt><dd><p>The private data for <strong>term_func</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a write to the cache.  <strong>cres</strong> indicates the cache object to write to and
must be obtained by a call to fscache_begin_operation() beforehand.</p>
<p>The data to be written is obtained from the iterator, <strong>iter</strong>, and that also
indicates the size of the operation.  <strong>start_pos</strong> is the start position in
the file.</p>
<p>Upon termination of the operation, <strong>term_func</strong> will be called and supplied
with <strong>term_func_priv</strong> plus the amount of data written, if successful, or the
error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.fscache_clear_page_bits">
void <code class="sig-name descname">fscache_clear_page_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../api-summary.html#c.address_space" title="address_space">address_space</a><em> *mapping</em>, loff_t<em> start</em>, size_t<em> len</em>, bool<em> caching</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_clear_page_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the PG_fscache bits from a set of pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The netfs inode to use as the source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>The start position in <strong>mapping</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The amount of data to unlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">caching</span></code></dt><dd><p>If PG_fscache has been set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the PG_fscache flag from a sequence of pages and wake up anyone who’s
waiting.</p>
</div>
<dl class="function">
<dt id="c.fscache_write_to_cache">
void <code class="sig-name descname">fscache_write_to_cache</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, struct <a class="reference internal" href="../api-summary.html#c.address_space" title="address_space">address_space</a><em> *mapping</em>, loff_t<em> start</em>, size_t<em> len</em>, loff_t<em> i_size</em>, netfs_io_terminated_t<em> term_func</em>, void<em> *term_func_priv</em>, bool<em> caching</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_write_to_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a write to the cache and clear PG_fscache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie representing the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The netfs inode to use as the source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>The start position in <strong>mapping</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The amount of data to write back</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">i_size</span></code></dt><dd><p>The new size of the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netfs_io_terminated_t</span> <span class="pre">term_func</span></code></dt><dd><p>The function to call upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*term_func_priv</span></code></dt><dd><p>The private data for <strong>term_func</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">caching</span></code></dt><dd><p>If PG_fscache has been set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for a netfs to write dirty data from an inode into the cache
object that’s backing it.</p>
<p><strong>start</strong> and <strong>len</strong> describe the range of the data.  This does not need to be
page-aligned, but to satisfy DIO requirements, the cache may expand it up to
the page boundaries on either end.  All the pages covering the range must be
marked with PG_fscache.</p>
<p>If given, <strong>term_func</strong> will be called upon completion and supplied with
<strong>term_func_priv</strong>.  Note that the PG_fscache flags will have been cleared by
this point, so the netfs must retain its own pin on the mapping.</p>
</div>
<dl class="function">
<dt id="c.fscache_unpin_writeback">
void <code class="sig-name descname">fscache_unpin_writeback</code><span class="sig-paren">(</span>struct writeback_control<em> *wbc</em>, struct fscache_cookie<em> *cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_unpin_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin writeback resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>The writeback control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie referring to the cache object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpin the writeback resources pinned by fscache_dirty_folio().  This is
intended to be called by the netfs’s -&gt;write_inode() method.</p>
</div>
<dl class="function">
<dt id="c.fscache_clear_inode_writeback">
void <code class="sig-name descname">fscache_clear_inode_writeback</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em>, struct inode<em> *inode</em>, const void<em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_clear_inode_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear writeback resources pinned by an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie referring to the cache object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to clean up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*aux</span></code></dt><dd><p>Auxiliary data to apply to the inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear any writeback resources held by an inode when the inode is evicted.
This must be called before clear_inode() is called.</p>
</div>
<dl class="function">
<dt id="c.fscache_note_page_release">
void <code class="sig-name descname">fscache_note_page_release</code><span class="sig-paren">(</span>struct fscache_cookie<em> *cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fscache_note_page_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that a netfs page got released</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscache_cookie</span> <span class="pre">*cookie</span></code></dt><dd><p>The cookie corresponding to the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that a page that has been copied to the cache has been released.  This
means that future reads will need to look in the cache to see if it’s there.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Network Filesystem Caching API</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#volume-registration">Volume Registration</a></li>
<li><a class="reference internal" href="#data-file-registration">Data File Registration</a></li>
<li><a class="reference internal" href="#marking-a-cookie-in-use">Marking A Cookie In-Use</a></li>
<li><a class="reference internal" href="#resizing-a-data-file-truncation">Resizing A Data File (Truncation)</a></li>
<li><a class="reference internal" href="#data-i-o-api">Data I/O API</a></li>
<li><a class="reference internal" href="#data-file-coherency">Data File Coherency</a></li>
<li><a class="reference internal" href="#data-file-invalidation">Data File Invalidation</a></li>
<li><a class="reference internal" href="#write-back-resource-management">Write-Back Resource Management</a></li>
<li><a class="reference internal" href="#caching-of-local-modifications">Caching of Local Modifications</a></li>
<li><a class="reference internal" href="#page-release-and-invalidation">Page Release and Invalidation</a></li>
<li><a class="reference internal" href="#api-function-reference">API Function Reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/caching/netfs-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/caching/netfs-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>