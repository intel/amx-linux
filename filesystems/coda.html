
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Coda Kernel-Venus Interface &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Configfs - Userspace-driven Kernel Object Configuration" href="configfs.html" />
    <link rel="prev" title="Ceph Distributed File System" href="ceph.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="coda-kernel-venus-interface">
<h1>Coda Kernel-Venus Interface<a class="headerlink" href="#coda-kernel-venus-interface" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is one of the technical documents describing a component of
Coda – this document describes the client kernel-Venus interface.</p>
</div>
<p>For more information:</p>
<blockquote>
<div><p><a class="reference external" href="http://www.coda.cs.cmu.edu">http://www.coda.cs.cmu.edu</a></p>
</div></blockquote>
<p>For user level software needed to run Coda:</p>
<blockquote>
<div><p><a class="reference external" href="ftp://ftp.coda.cs.cmu.edu">ftp://ftp.coda.cs.cmu.edu</a></p>
</div></blockquote>
<p>To run Coda you need to get a user level cache manager for the client,
named Venus, as well as tools to manipulate ACLs, to log in, etc.  The
client needs to have the Coda filesystem selected in the kernel
configuration.</p>
<p>The server needs a user level server and at present does not depend on
kernel support.</p>
<blockquote>
<div><p>The Venus kernel interface</p>
<p>Peter J. Braam</p>
<p>v1.0, Nov 9, 1997</p>
<p>This document describes the communication between Venus and kernel
level filesystem code needed for the operation of the Coda file sys-
tem.  This document version is meant to describe the current interface
(version 1.0) as well as improvements we envisage.</p>
</div></blockquote>
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A key component in the Coda Distributed File System is the cache
manager, Venus.</p>
<p>When processes on a Coda enabled system access files in the Coda
filesystem, requests are directed at the filesystem layer in the
operating system. The operating system will communicate with Venus to
service the request for the process.  Venus manages a persistent
client cache and makes remote procedure calls to Coda file servers and
related servers (such as authentication servers) to service these
requests it receives from the operating system.  When Venus has
serviced a request it replies to the operating system with appropriate
return codes, and other data related to the request.  Optionally the
kernel support for Coda may maintain a minicache of recently processed
requests to limit the number of interactions with Venus.  Venus
possesses the facility to inform the kernel when elements from its
minicache are no longer valid.</p>
<p>This document describes precisely this communication between the
kernel and Venus.  The definitions of so called upcalls and downcalls
will be given with the format of the data they handle. We shall also
describe the semantic invariants resulting from the calls.</p>
<p>Historically Coda was implemented in a BSD file system in Mach 2.6.
The interface between the kernel and Venus is very similar to the BSD
VFS interface.  Similar functionality is provided, and the format of
the parameters and returned data is very similar to the BSD VFS.  This
leads to an almost natural environment for implementing a kernel-level
filesystem driver for Coda in a BSD system.  However, other operating
systems such as Linux and Windows 95 and NT have virtual filesystem
with different interfaces.</p>
<p>To implement Coda on these systems some reverse engineering of the
Venus/Kernel protocol is necessary.  Also it came to light that other
systems could profit significantly from certain small optimizations
and modifications to the protocol. To facilitate this work as well as
to make future ports easier, communication between Venus and the
kernel should be documented in great detail.  This is the aim of this
document.</p>
</div></blockquote>
</section>
<section id="servicing-coda-filesystem-calls">
<h2>2.  Servicing Coda filesystem calls<a class="headerlink" href="#servicing-coda-filesystem-calls" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The service of a request for a Coda file system service originates in
a process P which accessing a Coda file. It makes a system call which
traps to the OS kernel. Examples of such calls trapping to the kernel
are <code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, <code class="docutils literal notranslate"><span class="pre">open</span></code>, <code class="docutils literal notranslate"><span class="pre">close</span></code>, <code class="docutils literal notranslate"><span class="pre">create</span></code>, <code class="docutils literal notranslate"><span class="pre">mkdir</span></code>,
<code class="docutils literal notranslate"><span class="pre">rmdir</span></code>, <code class="docutils literal notranslate"><span class="pre">chmod</span></code> in a Unix ontext.  Similar calls exist in the Win32
environment, and are named <code class="docutils literal notranslate"><span class="pre">CreateFile</span></code>.</p>
<p>Generally the operating system handles the request in a virtual
filesystem (VFS) layer, which is named I/O Manager in NT and IFS
manager in Windows 95.  The VFS is responsible for partial processing
of the request and for locating the specific filesystem(s) which will
service parts of the request.  Usually the information in the path
assists in locating the correct FS drivers.  Sometimes after extensive
pre-processing, the VFS starts invoking exported routines in the FS
driver.  This is the point where the FS specific processing of the
request starts, and here the Coda specific kernel code comes into
play.</p>
<p>The FS layer for Coda must expose and implement several interfaces.
First and foremost the VFS must be able to make all necessary calls to
the Coda FS layer, so the Coda FS driver must expose the VFS interface
as applicable in the operating system. These differ very significantly
among operating systems, but share features such as facilities to
read/write and create and remove objects.  The Coda FS layer services
such VFS requests by invoking one or more well defined services
offered by the cache manager Venus.  When the replies from Venus have
come back to the FS driver, servicing of the VFS call continues and
finishes with a reply to the kernel’s VFS. Finally the VFS layer
returns to the process.</p>
<p>As a result of this design a basic interface exposed by the FS driver
must allow Venus to manage message traffic.  In particular Venus must
be able to retrieve and place messages and to be notified of the
arrival of a new message. The notification must be through a mechanism
which does not block Venus since Venus must attend to other tasks even
when no messages are waiting or being processed.</p>
<p><strong>Interfaces of the Coda FS Driver</strong></p>
<p>Furthermore the FS layer provides for a special path of communication
between a user process and Venus, called the pioctl interface. The
pioctl interface is used for Coda specific services, such as
requesting detailed information about the persistent cache managed by
Venus. Here the involvement of the kernel is minimal.  It identifies
the calling process and passes the information on to Venus.  When
Venus replies the response is passed back to the caller in unmodified
form.</p>
<p>Finally Venus allows the kernel FS driver to cache the results from
certain services.  This is done to avoid excessive context switches
and results in an efficient system.  However, Venus may acquire
information, for example from the network which implies that cached
information must be flushed or replaced. Venus then makes a downcall
to the Coda FS layer to request flushes or updates in the cache.  The
kernel FS driver handles such requests synchronously.</p>
<p>Among these interfaces the VFS interface and the facility to place,
receive and be notified of messages are platform specific.  We will
not go into the calls exported to the VFS layer but we will state the
requirements of the message exchange mechanism.</p>
</div></blockquote>
</section>
<section id="the-message-layer">
<h2>3.  The message layer<a class="headerlink" href="#the-message-layer" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>At the lowest level the communication between Venus and the FS driver
proceeds through messages.  The synchronization between processes
requesting Coda file service and Venus relies on blocking and waking
up processes.  The Coda FS driver processes VFS- and pioctl-requests
on behalf of a process P, creates messages for Venus, awaits replies
and finally returns to the caller.  The implementation of the exchange
of messages is platform specific, but the semantics have (so far)
appeared to be generally applicable.  Data buffers are created by the
FS Driver in kernel memory on behalf of P and copied to user memory in
Venus.</p>
<p>The FS Driver while servicing P makes upcalls to Venus.  Such an
upcall is dispatched to Venus by creating a message structure.  The
structure contains the identification of P, the message sequence
number, the size of the request and a pointer to the data in kernel
memory for the request.  Since the data buffer is re-used to hold the
reply from Venus, there is a field for the size of the reply.  A flags
field is used in the message to precisely record the status of the
message.  Additional platform dependent structures involve pointers to
determine the position of the message on queues and pointers to
synchronization objects.  In the upcall routine the message structure
is filled in, flags are set to 0, and it is placed on the <em>pending</em>
queue.  The routine calling upcall is responsible for allocating the
data buffer; its structure will be described in the next section.</p>
<p>A facility must exist to notify Venus that the message has been
created, and implemented using available synchronization objects in
the OS. This notification is done in the upcall context of the process
P. When the message is on the pending queue, process P cannot proceed
in upcall.  The (kernel mode) processing of P in the filesystem
request routine must be suspended until Venus has replied.  Therefore
the calling thread in P is blocked in upcall.  A pointer in the
message structure will locate the synchronization object on which P is
sleeping.</p>
<p>Venus detects the notification that a message has arrived, and the FS
driver allow Venus to retrieve the message with a getmsg_from_kernel
call. This action finishes in the kernel by putting the message on the
queue of processing messages and setting flags to READ.  Venus is
passed the contents of the data buffer. The getmsg_from_kernel call
now returns and Venus processes the request.</p>
<p>At some later point the FS driver receives a message from Venus,
namely when Venus calls sendmsg_to_kernel.  At this moment the Coda FS
driver looks at the contents of the message and decides if:</p>
<ul class="simple">
<li><p>the message is a reply for a suspended thread P.  If so it removes
the message from the processing queue and marks the message as
WRITTEN.  Finally, the FS driver unblocks P (still in the kernel
mode context of Venus) and the sendmsg_to_kernel call returns to
Venus.  The process P will be scheduled at some point and continues
processing its upcall with the data buffer replaced with the reply
from Venus.</p></li>
<li><p>The message is a <code class="docutils literal notranslate"><span class="pre">downcall</span></code>.  A downcall is a request from Venus to
the FS Driver. The FS driver processes the request immediately
(usually a cache eviction or replacement) and when it finishes
sendmsg_to_kernel returns.</p></li>
</ul>
<p>Now P awakes and continues processing upcall.  There are some
subtleties to take account of. First P will determine if it was woken
up in upcall by a signal from some other source (for example an
attempt to terminate P) or as is normally the case by Venus in its
sendmsg_to_kernel call.  In the normal case, the upcall routine will
deallocate the message structure and return.  The FS routine can proceed
with its processing.</p>
<p><strong>Sleeping and IPC arrangements</strong></p>
<p>In case P is woken up by a signal and not by Venus, it will first look
at the flags field.  If the message is not yet READ, the process P can
handle its signal without notifying Venus.  If Venus has READ, and
the request should not be processed, P can send Venus a signal message
to indicate that it should disregard the previous message.  Such
signals are put in the queue at the head, and read first by Venus.  If
the message is already marked as WRITTEN it is too late to stop the
processing.  The VFS routine will now continue.  (– If a VFS request
involves more than one upcall, this can lead to complicated state, an
extra field “handle_signals” could be added in the message structure
to indicate points of no return have been passed.–)</p>
</div></blockquote>
<section id="implementation-details">
<h3>3.1.  Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The Unix implementation of this mechanism has been through the
implementation of a character device associated with Coda.  Venus
retrieves messages by doing a read on the device, replies are sent
with a write and notification is through the select system call on the
file descriptor for the device.  The process P is kept waiting on an
interruptible wait queue object.</p>
<p>In Windows NT and the DPMI Windows 95 implementation a DeviceIoControl
call is used.  The DeviceIoControl call is designed to copy buffers
from user memory to kernel memory with OPCODES. The sendmsg_to_kernel
is issued as a synchronous call, while the getmsg_from_kernel call is
asynchronous.  Windows EventObjects are used for notification of
message arrival.  The process P is kept waiting on a KernelEvent
object in NT and a semaphore in Windows 95.</p>
</div></blockquote>
</section>
</section>
<section id="the-interface-at-the-call-level">
<h2>4.  The interface at the call level<a class="headerlink" href="#the-interface-at-the-call-level" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This section describes the upcalls a Coda FS driver can make to Venus.
Each of these upcalls make use of two structures: inputArgs and
outputArgs.   In pseudo BNF form the structures take the following
form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct inputArgs {
    u_long opcode;
    u_long unique;     /* Keep multiple outstanding msgs distinct */
    u_short pid;                 /* Common to all */
    u_short pgid;                /* Common to all */
    struct CodaCred cred;        /* Common to all */

    &lt;union &quot;in&quot; of call dependent parts of inputArgs&gt;
};

struct outputArgs {
    u_long opcode;
    u_long unique;       /* Keep multiple outstanding msgs distinct */
    u_long result;

    &lt;union &quot;out&quot; of call dependent parts of inputArgs&gt;
};
</pre></div>
</div>
<p>Before going on let us elucidate the role of the various fields. The
inputArgs start with the opcode which defines the type of service
requested from Venus. There are approximately 30 upcalls at present
which we will discuss.   The unique field labels the inputArg with a
unique number which will identify the message uniquely.  A process and
process group id are passed.  Finally the credentials of the caller
are included.</p>
<p>Before delving into the specific calls we need to discuss a variety of
data structures shared by the kernel and Venus.</p>
</div></blockquote>
<section id="data-structures-shared-by-the-kernel-and-venus">
<h3>4.1.  Data structures shared by the kernel and Venus<a class="headerlink" href="#data-structures-shared-by-the-kernel-and-venus" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The CodaCred structure defines a variety of user and group ids as
they are set for the calling process. The vuid_t and vgid_t are 32 bit
unsigned integers.  It also defines group membership in an array.  On
Unix the CodaCred has proven sufficient to implement good security
semantics for Coda but the structure may have to undergo modification
for the Windows environment when these mature:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct CodaCred {
    vuid_t cr_uid, cr_euid, cr_suid, cr_fsuid; /* Real, effective, set, fs uid */
    vgid_t cr_gid, cr_egid, cr_sgid, cr_fsgid; /* same for groups */
    vgid_t cr_groups[NGROUPS];        /* Group membership for caller */
};
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is questionable if we need CodaCreds in Venus. Finally Venus
doesn’t know about groups, although it does create files with the
default uid/gid.  Perhaps the list of group membership is superfluous.</p>
</div>
<p>The next item is the fundamental identifier used to identify Coda
files, the ViceFid.  A fid of a file uniquely defines a file or
directory in the Coda filesystem within a cell <a class="footnote-reference brackets" href="#id2" id="id1">1</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct ViceFid {
    VolumeId Volume;
    VnodeId Vnode;
    Unique_t Unique;
} ViceFid;
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>A cell is agroup of Coda servers acting under the aegis of a single
system control machine or SCM. See the Coda Administration manual
for a detailed description of the role of the SCM.</p>
</dd>
</dl>
<p>Each of the constituent fields: VolumeId, VnodeId and Unique_t are
unsigned 32 bit integers.  We envisage that a further field will need
to be prefixed to identify the Coda cell; this will probably take the
form of a Ipv6 size IP address naming the Coda cell through DNS.</p>
<p>The next important structure shared between Venus and the kernel is
the attributes of the file.  The following structure is used to
exchange information.  It has room for future extensions such as
support for device files (currently not present in Coda):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct coda_timespec {
        int64_t         tv_sec;         /* seconds */
        long            tv_nsec;        /* nanoseconds */
};

struct coda_vattr {
        enum coda_vtype va_type;        /* vnode type (for create) */
        u_short         va_mode;        /* files access mode and type */
        short           va_nlink;       /* number of references to file */
        vuid_t          va_uid;         /* owner user id */
        vgid_t          va_gid;         /* owner group id */
        long            va_fsid;        /* file system id (dev for now) */
        long            va_fileid;      /* file id */
        u_quad_t        va_size;        /* file size in bytes */
        long            va_blocksize;   /* blocksize preferred for i/o */
        struct coda_timespec va_atime;  /* time of last access */
        struct coda_timespec va_mtime;  /* time of last modification */
        struct coda_timespec va_ctime;  /* time file changed */
        u_long          va_gen;         /* generation number of file */
        u_long          va_flags;       /* flags defined for file */
        dev_t           va_rdev;        /* device special file represents */
        u_quad_t        va_bytes;       /* bytes of disk space held by file */
        u_quad_t        va_filerev;     /* file modification number */
        u_int           va_vaflags;     /* operations flags, see below */
        long            va_spare;       /* remain quad aligned */
};
</pre></div>
</div>
</div></blockquote>
</section>
<section id="the-pioctl-interface">
<h3>4.2.  The pioctl interface<a class="headerlink" href="#the-pioctl-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Coda specific requests can be made by application through the pioctl
interface. The pioctl is implemented as an ordinary ioctl on a
fictitious file /coda/.CONTROL.  The pioctl call opens this file, gets
a file handle and makes the ioctl call. Finally it closes the file.</p>
<p>The kernel involvement in this is limited to providing the facility to
open and close and pass the ioctl message and to verify that a path in
the pioctl data buffers is a file in a Coda filesystem.</p>
<p>The kernel is handed a data packet of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {
    const char *path;
    struct ViceIoctl vidata;
    int follow;
} data;
</pre></div>
</div>
<p>where:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ViceIoctl {
        caddr_t in, out;        /* Data to be transferred in, or out */
        short in_size;          /* Size of input buffer &lt;= 2K */
        short out_size;         /* Maximum size of output buffer, &lt;= 2K */
};
</pre></div>
</div>
<p>The path must be a Coda file, otherwise the ioctl upcall will not be
made.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The data structures and code are a mess.  We need to clean this up.</p>
</div>
</div></blockquote>
<p><strong>We now proceed to document the individual calls</strong>:</p>
</section>
<section id="root">
<h3>4.3.  root<a class="headerlink" href="#root" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><p>in</p>
<blockquote>
<div><p>empty</p>
</div></blockquote>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_root_out {
    ViceFid VFid;
} cfs_root;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This call is made to Venus during the initialization of
the Coda filesystem. If the result is zero, the cfs_root structure
contains the ViceFid of the root of the Coda filesystem. If a non-zero
result is generated, its value is a platform dependent error code
indicating the difficulty Venus encountered in locating the root of
the Coda filesystem.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="lookup">
<h3>4.4.  lookup<a class="headerlink" href="#lookup" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Find the ViceFid and type of an object in a directory if it exists.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct  cfs_lookup_in {
    ViceFid     VFid;
    char        *name;          /* Place holder for data. */
} cfs_lookup;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_lookup_out {
    ViceFid VFid;
    int vtype;
} cfs_lookup;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This call is made to determine the ViceFid and filetype of
a directory entry.  The directory entry requested carries name ‘name’
and Venus will search the directory identified by cfs_lookup_in.VFid.
The result may indicate that the name does not exist, or that
difficulty was encountered in finding it (e.g. due to disconnection).
If the result is zero, the field cfs_lookup_out.VFid contains the
targets ViceFid and cfs_lookup_out.vtype the coda_vtype giving the
type of object the name designates.</p>
</dd>
</dl>
<p>The name of the object is an 8 bit character string of maximum length
CFS_MAXNAMLEN, currently set to 256 (including a 0 terminator.)</p>
<p>It is extremely important to realize that Venus bitwise ors the field
cfs_lookup.vtype with CFS_NOCACHE to indicate that the object should
not be put in the kernel name cache.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The type of the vtype is currently wrong.  It should be
coda_vtype. Linux does not take note of CFS_NOCACHE.  It should.</p>
</div>
</div></blockquote>
</section>
<section id="getattr">
<h3>4.5.  getattr<a class="headerlink" href="#getattr" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Summary Get the attributes of a file.</p>
<dl>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_getattr_in {
    ViceFid VFid;
    struct coda_vattr attr; /* XXXXX */
} cfs_getattr;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_getattr_out {
    struct coda_vattr attr;
} cfs_getattr;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This call returns the attributes of the file identified by fid.</p>
</dd>
<dt>Errors</dt><dd><p>Errors can occur if the object with fid does not exist, is
unaccessible or if the caller does not have permission to fetch
attributes.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Many kernel FS drivers (Linux, NT and Windows 95) need to acquire
the attributes as well as the Fid for the instantiation of an internal
“inode” or “FileHandle”.  A significant improvement in performance on
such systems could be made by combining the lookup and getattr calls
both at the Venus/kernel interaction level and at the RPC level.</p>
</div>
<p>The vattr structure included in the input arguments is superfluous and
should be removed.</p>
</div></blockquote>
</section>
<section id="setattr">
<h3>4.6.  setattr<a class="headerlink" href="#setattr" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Set the attributes of a file.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_setattr_in {
    ViceFid VFid;
    struct coda_vattr attr;
} cfs_setattr;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>empty</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>The structure attr is filled with attributes to be changed
in BSD style.  Attributes not to be changed are set to -1, apart from
vtype which is set to VNON. Other are set to the value to be assigned.
The only attributes which the FS driver may request to change are the
mode, owner, groupid, atime, mtime and ctime.  The return value
indicates success or failure.</p>
</dd>
<dt>Errors</dt><dd><p>A variety of errors can occur.  The object may not exist, may
be inaccessible, or permission may not be granted by Venus.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="access">
<h3>4.7.  access<a class="headerlink" href="#access" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_access_in {
    ViceFid     VFid;
    int flags;
} cfs_access;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>empty</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Verify if access to the object identified by VFid for
operations described by flags is permitted.  The result indicates if
access will be granted.  It is important to remember that Coda uses
ACLs to enforce protection and that ultimately the servers, not the
clients enforce the security of the system.  The result of this call
will depend on whether a token is held by the user.</p>
</dd>
<dt>Errors</dt><dd><p>The object may not exist, or the ACL describing the protection
may not be accessible.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="create">
<h3>4.8.  create<a class="headerlink" href="#create" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Invoked to create a file</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_create_in {
    ViceFid VFid;
    struct coda_vattr attr;
    int excl;
    int mode;
    char        *name;          /* Place holder for data. */
} cfs_create;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_create_out {
    ViceFid VFid;
    struct coda_vattr attr;
} cfs_create;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This upcall is invoked to request creation of a file.
The file will be created in the directory identified by VFid, its name
will be name, and the mode will be mode.  If excl is set an error will
be returned if the file already exists.  If the size field in attr is
set to zero the file will be truncated.  The uid and gid of the file
are set by converting the CodaCred to a uid using a macro CRTOUID
(this macro is platform dependent).  Upon success the VFid and
attributes of the file are returned.  The Coda FS Driver will normally
instantiate a vnode, inode or file handle at kernel level for the new
object.</p>
</dd>
<dt>Errors</dt><dd><p>A variety of errors can occur. Permissions may be insufficient.
If the object exists and is not a file the error EISDIR is returned
under Unix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The packing of parameters is very inefficient and appears to
indicate confusion between the system call creat and the VFS operation
create. The VFS operation create is only called to create new objects.
This create call differs from the Unix one in that it is not invoked
to return a file descriptor. The truncate and exclusive options,
together with the mode, could simply be part of the mode as it is
under Unix.  There should be no flags argument; this is used in open
(2) to return a file descriptor for READ or WRITE mode.</p>
</div>
<p>The attributes of the directory should be returned too, since the size
and mtime changed.</p>
</div></blockquote>
</section>
<section id="mkdir">
<h3>4.9.  mkdir<a class="headerlink" href="#mkdir" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Create a new directory.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_mkdir_in {
    ViceFid     VFid;
    struct coda_vattr attr;
    char        *name;          /* Place holder for data. */
} cfs_mkdir;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_mkdir_out {
    ViceFid VFid;
    struct coda_vattr attr;
} cfs_mkdir;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This call is similar to create but creates a directory.
Only the mode field in the input parameters is used for creation.
Upon successful creation, the attr returned contains the attributes of
the new directory.</p>
</dd>
<dt>Errors</dt><dd><p>As for create.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input parameter should be changed to mode instead of
attributes.</p>
</div>
<p>The attributes of the parent should be returned since the size and
mtime changes.</p>
</div></blockquote>
</section>
<section id="link">
<h3>4.10.  link<a class="headerlink" href="#link" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Create a link to an existing file.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_link_in {
    ViceFid sourceFid;          /* cnode to link *to* */
    ViceFid destFid;            /* Directory in which to place link */
    char        *tname;         /* Place holder for data. */
} cfs_link;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>empty</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>This call creates a link to the sourceFid in the directory
identified by destFid with name tname.  The source must reside in the
target’s parent, i.e. the source must be have parent destFid, i.e. Coda
does not support cross directory hard links.  Only the return value is
relevant.  It indicates success or the type of failure.</p>
</dd>
<dt>Errors</dt><dd><p>The usual errors can occur.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="symlink">
<h3>4.11.  symlink<a class="headerlink" href="#symlink" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>create a symbolic link</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_symlink_in {
    ViceFid     VFid;          /* Directory to put symlink in */
    char        *srcname;
    struct coda_vattr attr;
    char        *tname;
} cfs_symlink;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Create a symbolic link. The link is to be placed in the
directory identified by VFid and named tname.  It should point to the
pathname srcname.  The attributes of the newly created object are to
be set to attr.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The attributes of the target directory should be returned since
its size changed.</p>
</div>
</div></blockquote>
</section>
<section id="remove">
<h3>4.12.  remove<a class="headerlink" href="#remove" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Remove a file</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_remove_in {
    ViceFid     VFid;
    char        *name;          /* Place holder for data. */
} cfs_remove;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Remove file named cfs_remove_in.name in directory
identified by   VFid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The attributes of the directory should be returned since its
mtime and size may change.</p>
</div>
</div></blockquote>
</section>
<section id="rmdir">
<h3>4.13.  rmdir<a class="headerlink" href="#rmdir" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Remove a directory</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_rmdir_in {
    ViceFid     VFid;
    char        *name;          /* Place holder for data. */
} cfs_rmdir;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Remove the directory with name ‘name’ from the directory
identified by VFid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The attributes of the parent directory should be returned since
its mtime and size may change.</p>
</div>
</div></blockquote>
</section>
<section id="readlink">
<h3>4.14.  readlink<a class="headerlink" href="#readlink" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Read the value of a symbolic link.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_readlink_in {
    ViceFid VFid;
} cfs_readlink;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_readlink_out {
    int count;
    caddr_t     data;           /* Place holder for data. */
} cfs_readlink;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This routine reads the contents of symbolic link
identified by VFid into the buffer data.  The buffer data must be able
to hold any name up to CFS_MAXNAMLEN (PATH or NAM??).</p>
</dd>
<dt>Errors</dt><dd><p>No unusual errors.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="open">
<h3>4.15.  open<a class="headerlink" href="#open" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Open a file.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_open_in {
    ViceFid     VFid;
    int flags;
} cfs_open;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_open_out {
    dev_t       dev;
    ino_t       inode;
} cfs_open;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This request asks Venus to place the file identified by
VFid in its cache and to note that the calling process wishes to open
it with flags as in open(2).  The return value to the kernel differs
for Unix and Windows systems.  For Unix systems the Coda FS Driver is
informed of the device and inode number of the container file in the
fields dev and inode.  For Windows the path of the container file is
returned to the kernel.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently the cfs_open_out structure is not properly adapted to
deal with the Windows case.  It might be best to implement two
upcalls, one to open aiming at a container file name, the other at a
container file inode.</p>
</div>
</div></blockquote>
</section>
<section id="close">
<h3>4.16.  close<a class="headerlink" href="#close" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Close a file, update it on the servers.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_close_in {
    ViceFid     VFid;
    int flags;
} cfs_close;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Close the file identified by VFid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The flags argument is bogus and not used.  However, Venus’ code
has room to deal with an execp input field, probably this field should
be used to inform Venus that the file was closed but is still memory
mapped for execution.  There are comments about fetching versus not
fetching the data in Venus vproc_vfscalls.  This seems silly.  If a
file is being closed, the data in the container file is to be the new
data.  Here again the execp flag might be in play to create confusion:
currently Venus might think a file can be flushed from the cache when
it is still memory mapped.  This needs to be understood.</p>
</div>
</div></blockquote>
</section>
<section id="ioctl">
<h3>4.17.  ioctl<a class="headerlink" href="#ioctl" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Do an ioctl on a file. This includes the pioctl interface.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_ioctl_in {
    ViceFid VFid;
    int cmd;
    int len;
    int rwflag;
    char *data;                 /* Place holder for data. */
} cfs_ioctl;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_ioctl_out {
    int len;
    caddr_t     data;           /* Place holder for data. */
} cfs_ioctl;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Do an ioctl operation on a file.  The command, len and
data arguments are filled as usual.  flags is not used by Venus.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Another bogus parameter.  flags is not used.  What is the
business about PREFETCHING in the Venus code?</p>
</div>
</div></blockquote>
</section>
<section id="rename">
<h3>4.18.  rename<a class="headerlink" href="#rename" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Rename a fid.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_rename_in {
    ViceFid     sourceFid;
    char        *srcname;
    ViceFid destFid;
    char        *destname;
} cfs_rename;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Rename the object with name srcname in directory
sourceFid to destname in destFid.   It is important that the names
srcname and destname are 0 terminated strings.  Strings in Unix
kernels are not always null terminated.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="readdir">
<h3>4.19.  readdir<a class="headerlink" href="#readdir" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Read directory entries.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_readdir_in {
    ViceFid     VFid;
    int count;
    int offset;
} cfs_readdir;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_readdir_out {
    int size;
    caddr_t     data;           /* Place holder for data. */
} cfs_readdir;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Read directory entries from VFid starting at offset and
read at most count bytes.  Returns the data in data and returns
the size in size.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call is not used.  Readdir operations exploit container
files.  We will re-evaluate this during the directory revamp which is
about to take place.</p>
</div>
</div></blockquote>
</section>
<section id="vget">
<h3>4.20.  vget<a class="headerlink" href="#vget" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>instructs Venus to do an FSDB-&gt;Get.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_vget_in {
    ViceFid VFid;
} cfs_vget;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_vget_out {
    ViceFid VFid;
    int vtype;
} cfs_vget;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This upcall asks Venus to do a get operation on an fsobj
labelled by VFid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operation is not used.  However, it is extremely useful
since it can be used to deal with read/write memory mapped files.
These can be “pinned” in the Venus cache using vget and released with
inactive.</p>
</div>
</div></blockquote>
</section>
<section id="fsync">
<h3>4.21.  fsync<a class="headerlink" href="#fsync" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Tell Venus to update the RVM attributes of a file.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_fsync_in {
    ViceFid VFid;
} cfs_fsync;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>Ask Venus to update RVM attributes of object VFid. This
should be called as part of kernel level fsync type calls.  The
result indicates if the syncing was successful.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Linux does not implement this call. It should.</p>
</div>
</div></blockquote>
</section>
<section id="inactive">
<h3>4.22.  inactive<a class="headerlink" href="#inactive" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Tell Venus a vnode is no longer in use.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_inactive_in {
    ViceFid VFid;
} cfs_inactive;
</pre></div>
</div>
<p>out</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>This operation returns EOPNOTSUPP.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should perhaps be removed.</p>
</div>
</div></blockquote>
</section>
<section id="rdwr">
<h3>4.23.  rdwr<a class="headerlink" href="#rdwr" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Read or write from a file</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_rdwr_in {
    ViceFid     VFid;
    int rwflag;
    int count;
    int offset;
    int ioflag;
    caddr_t     data;           /* Place holder for data. */
} cfs_rdwr;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_rdwr_out {
    int rwflag;
    int count;
    caddr_t     data;   /* Place holder for data. */
} cfs_rdwr;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This upcall asks Venus to read or write from a file.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It should be removed since it is against the Coda philosophy that
read/write operations never reach Venus.  I have been told the
operation does not work.  It is not currently used.</p>
</div>
</div></blockquote>
</section>
<section id="odymount">
<h3>4.24.  odymount<a class="headerlink" href="#odymount" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Allows mounting multiple Coda “filesystems” on one Unix mount point.</p>
</dd>
<dt>Arguments</dt><dd><p>in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ody_mount_in {
    char        *name;          /* Place holder for data. */
} ody_mount;
</pre></div>
</div>
<p>out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ody_mount_out {
    ViceFid VFid;
} ody_mount;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Asks Venus to return the rootfid of a Coda system named
name.  The fid is returned in VFid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call was used by David for dynamic sets.  It should be
removed since it causes a jungle of pointers in the VFS mounting area.
It is not used by Coda proper.  Call is not implemented by Venus.</p>
</div>
</div></blockquote>
</section>
<section id="ody-lookup">
<h3>4.25.  ody_lookup<a class="headerlink" href="#ody-lookup" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Looks up something.</p>
</dd>
<dt>Arguments</dt><dd><p>in</p>
<blockquote>
<div><p>irrelevant</p>
</div></blockquote>
<p>out</p>
<blockquote>
<div><p>irrelevant</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Gut it. Call is not implemented by Venus.</p>
</div>
</div></blockquote>
</section>
<section id="ody-expand">
<h3>4.26.  ody_expand<a class="headerlink" href="#ody-expand" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>expands something in a dynamic set.</p>
</dd>
<dt>Arguments</dt><dd><p>in</p>
<blockquote>
<div><p>irrelevant</p>
</div></blockquote>
<p>out</p>
<blockquote>
<div><p>irrelevant</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Gut it. Call is not implemented by Venus.</p>
</div>
</div></blockquote>
</section>
<section id="prefetch">
<h3>4.27.  prefetch<a class="headerlink" href="#prefetch" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl class="simple">
<dt>Summary</dt><dd><p>Prefetch a dynamic set.</p>
</dd>
</dl>
<p>Arguments</p>
<blockquote>
<div><p>in</p>
<blockquote>
<div><p>Not documented.</p>
</div></blockquote>
<p>out</p>
<blockquote>
<div><p>Not documented.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Description</dt><dd><p>Venus worker.cc has support for this call, although it is
noted that it doesn’t work.  Not surprising, since the kernel does not
have support for it. (ODY_PREFETCH is not a defined operation).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Gut it. It isn’t working and isn’t used by Coda.</p>
</div>
</div></blockquote>
</section>
<section id="signal">
<h3>4.28.  signal<a class="headerlink" href="#signal" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Send Venus a signal about an upcall.</p>
</dd>
<dt>Arguments</dt><dd><p>in</p>
<blockquote>
<div><p>none</p>
</div></blockquote>
<p>out</p>
<blockquote>
<div><p>not applicable.</p>
</div></blockquote>
</dd>
<dt>Description</dt><dd><p>This is an out-of-band upcall to Venus to inform Venus
that the calling process received a signal after Venus read the
message from the input queue.  Venus is supposed to clean up the
operation.</p>
</dd>
<dt>Errors</dt><dd><p>No reply is given.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We need to better understand what Venus needs to clean up and if
it is doing this correctly.  Also we need to handle multiple upcall
per system call situations correctly.  It would be important to know
what state changes in Venus take place after an upcall for which the
kernel is responsible for notifying Venus to clean up (e.g. open
definitely is such a state change, but many others are maybe not).</p>
</div>
</div></blockquote>
</section>
</section>
<section id="the-minicache-and-downcalls">
<h2>5.  The minicache and downcalls<a class="headerlink" href="#the-minicache-and-downcalls" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Coda FS Driver can cache results of lookup and access upcalls, to
limit the frequency of upcalls.  Upcalls carry a price since a process
context switch needs to take place.  The counterpart of caching the
information is that Venus will notify the FS Driver that cached
entries must be flushed or renamed.</p>
<p>The kernel code generally has to maintain a structure which links the
internal file handles (called vnodes in BSD, inodes in Linux and
FileHandles in Windows) with the ViceFid’s which Venus maintains.  The
reason is that frequent translations back and forth are needed in
order to make upcalls and use the results of upcalls.  Such linking
objects are called cnodes.</p>
<p>The current minicache implementations have cache entries which record
the following:</p>
<ol class="arabic simple">
<li><p>the name of the file</p></li>
<li><p>the cnode of the directory containing the object</p></li>
<li><p>a list of CodaCred’s for which the lookup is permitted.</p></li>
<li><p>the cnode of the object</p></li>
</ol>
<p>The lookup call in the Coda FS Driver may request the cnode of the
desired object from the cache, by passing its name, directory and the
CodaCred’s of the caller.  The cache will return the cnode or indicate
that it cannot be found.  The Coda FS Driver must be careful to
invalidate cache entries when it modifies or removes objects.</p>
<p>When Venus obtains information that indicates that cache entries are
no longer valid, it will make a downcall to the kernel.  Downcalls are
intercepted by the Coda FS Driver and lead to cache invalidations of
the kind described below.  The Coda FS Driver does not return an error
unless the downcall data could not be read into kernel memory.</p>
</div></blockquote>
<section id="invalidate">
<h3>5.1.  INVALIDATE<a class="headerlink" href="#invalidate" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>No information is available on this call.</p>
</div></blockquote>
</section>
<section id="flush">
<h3>5.2.  FLUSH<a class="headerlink" href="#flush" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl class="simple">
<dt>Arguments</dt><dd><p>None</p>
</dd>
<dt>Summary</dt><dd><p>Flush the name cache entirely.</p>
</dd>
<dt>Description</dt><dd><p>Venus issues this call upon startup and when it dies. This
is to prevent stale cache information being held.  Some operating
systems allow the kernel name cache to be switched off dynamically.
When this is done, this downcall is made.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="purgeuser">
<h3>5.3.  PURGEUSER<a class="headerlink" href="#purgeuser" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_purgeuser_out {/* CFS_PURGEUSER is a venus-&gt;kernel call */
    struct CodaCred cred;
} cfs_purgeuser;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Remove all entries in the cache carrying the Cred.  This
call is issued when tokens for a user expire or are flushed.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="zapfile">
<h3>5.4.  ZAPFILE<a class="headerlink" href="#zapfile" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_zapfile_out {  /* CFS_ZAPFILE is a venus-&gt;kernel call */
    ViceFid CodaFid;
} cfs_zapfile;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Remove all entries which have the (dir vnode, name) pair.
This is issued as a result of an invalidation of cached attributes of
a vnode.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Call is not named correctly in NetBSD and Mach.  The minicache
zapfile routine takes different arguments. Linux does not implement
the invalidation of attributes correctly.</p>
</div>
</div></blockquote>
</section>
<section id="zapdir">
<h3>5.5.  ZAPDIR<a class="headerlink" href="#zapdir" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_zapdir_out {   /* CFS_ZAPDIR is a venus-&gt;kernel call */
    ViceFid CodaFid;
} cfs_zapdir;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Remove all entries in the cache lying in a directory
CodaFid, and all children of this directory. This call is issued when
Venus receives a callback on the directory.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="zapvnode">
<h3>5.6.  ZAPVNODE<a class="headerlink" href="#zapvnode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_zapvnode_out { /* CFS_ZAPVNODE is a venus-&gt;kernel call */
    struct CodaCred cred;
    ViceFid VFid;
} cfs_zapvnode;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Remove all entries in the cache carrying the cred and VFid
as in the arguments. This downcall is probably never issued.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="purgefid">
<h3>5.7.  PURGEFID<a class="headerlink" href="#purgefid" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_purgefid_out { /* CFS_PURGEFID is a venus-&gt;kernel call */
    ViceFid CodaFid;
} cfs_purgefid;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>Flush the attribute for the file. If it is a dir (odd
vnode), purge its children from the namecache and remove the file from the
namecache.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="replace">
<h3>5.8.  REPLACE<a class="headerlink" href="#replace" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl>
<dt>Summary</dt><dd><p>Replace the Fid’s for a collection of names.</p>
</dd>
<dt>Arguments</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfs_replace_out { /* cfs_replace is a venus-&gt;kernel call */
    ViceFid NewFid;
    ViceFid OldFid;
} cfs_replace;
</pre></div>
</div>
</dd>
<dt>Description</dt><dd><p>This routine replaces a ViceFid in the name cache with
another.  It is added to allow Venus during reintegration to replace
locally allocated temp fids while disconnected with global fids even
when the reference counts on those fids are not zero.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="initialization-and-cleanup">
<h2>6.  Initialization and cleanup<a class="headerlink" href="#initialization-and-cleanup" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This section gives brief hints as to desirable features for the Coda
FS Driver at startup and upon shutdown or Venus failures.  Before
entering the discussion it is useful to repeat that the Coda FS Driver
maintains the following data:</p>
<ol class="arabic">
<li><p>message queues</p></li>
<li><p>cnodes</p></li>
<li><p>name cache entries</p>
<p>The name cache entries are entirely private to the driver, so they
can easily be manipulated.   The message queues will generally have
clear points of initialization and destruction.  The cnodes are
much more delicate.  User processes hold reference counts in Coda
filesystems and it can be difficult to clean up the cnodes.</p>
</li>
</ol>
<p>It can expect requests through:</p>
<ol class="arabic">
<li><p>the message subsystem</p></li>
<li><p>the VFS layer</p></li>
<li><p>pioctl interface</p>
<p>Currently the pioctl passes through the VFS for Coda so we can
treat these similarly.</p>
</li>
</ol>
</div></blockquote>
<section id="requirements">
<h3>6.1.  Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The following requirements should be accommodated:</p>
<ol class="arabic simple">
<li><p>The message queues should have open and close routines.  On Unix
the opening of the character devices are such routines.</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Before opening, no messages can be placed.</p></li>
<li><p>Opening will remove any old messages still pending.</p></li>
<li><p>Close will notify any sleeping processes that their upcall cannot
be completed.</p></li>
<li><p>Close will free all memory allocated by the message queues.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>At open the namecache shall be initialized to empty state.</p></li>
<li><p>Before the message queues are open, all VFS operations will fail.
Fortunately this can be achieved by making sure than mounting the
Coda filesystem cannot succeed before opening.</p></li>
<li><p>After closing of the queues, no VFS operations can succeed.  Here
one needs to be careful, since a few operations (lookup,
read/write, readdir) can proceed without upcalls.  These must be
explicitly blocked.</p></li>
<li><p>Upon closing the namecache shall be flushed and disabled.</p></li>
<li><p>All memory held by cnodes can be freed without relying on upcalls.</p></li>
<li><p>Unmounting the file system can be done without relying on upcalls.</p></li>
<li><p>Mounting the Coda filesystem should fail gracefully if Venus cannot
get the rootfid or the attributes of the rootfid.  The latter is
best implemented by Venus fetching these objects before attempting
to mount.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NetBSD in particular but also Linux have not implemented the
above requirements fully.  For smooth operation this needs to be
corrected.</p>
</div>
</div></blockquote>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Coda Kernel-Venus Interface</a><ul>
<li><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li><a class="reference internal" href="#servicing-coda-filesystem-calls">2.  Servicing Coda filesystem calls</a></li>
<li><a class="reference internal" href="#the-message-layer">3.  The message layer</a><ul>
<li><a class="reference internal" href="#implementation-details">3.1.  Implementation details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-interface-at-the-call-level">4.  The interface at the call level</a><ul>
<li><a class="reference internal" href="#data-structures-shared-by-the-kernel-and-venus">4.1.  Data structures shared by the kernel and Venus</a></li>
<li><a class="reference internal" href="#the-pioctl-interface">4.2.  The pioctl interface</a></li>
<li><a class="reference internal" href="#root">4.3.  root</a></li>
<li><a class="reference internal" href="#lookup">4.4.  lookup</a></li>
<li><a class="reference internal" href="#getattr">4.5.  getattr</a></li>
<li><a class="reference internal" href="#setattr">4.6.  setattr</a></li>
<li><a class="reference internal" href="#access">4.7.  access</a></li>
<li><a class="reference internal" href="#create">4.8.  create</a></li>
<li><a class="reference internal" href="#mkdir">4.9.  mkdir</a></li>
<li><a class="reference internal" href="#link">4.10.  link</a></li>
<li><a class="reference internal" href="#symlink">4.11.  symlink</a></li>
<li><a class="reference internal" href="#remove">4.12.  remove</a></li>
<li><a class="reference internal" href="#rmdir">4.13.  rmdir</a></li>
<li><a class="reference internal" href="#readlink">4.14.  readlink</a></li>
<li><a class="reference internal" href="#open">4.15.  open</a></li>
<li><a class="reference internal" href="#close">4.16.  close</a></li>
<li><a class="reference internal" href="#ioctl">4.17.  ioctl</a></li>
<li><a class="reference internal" href="#rename">4.18.  rename</a></li>
<li><a class="reference internal" href="#readdir">4.19.  readdir</a></li>
<li><a class="reference internal" href="#vget">4.20.  vget</a></li>
<li><a class="reference internal" href="#fsync">4.21.  fsync</a></li>
<li><a class="reference internal" href="#inactive">4.22.  inactive</a></li>
<li><a class="reference internal" href="#rdwr">4.23.  rdwr</a></li>
<li><a class="reference internal" href="#odymount">4.24.  odymount</a></li>
<li><a class="reference internal" href="#ody-lookup">4.25.  ody_lookup</a></li>
<li><a class="reference internal" href="#ody-expand">4.26.  ody_expand</a></li>
<li><a class="reference internal" href="#prefetch">4.27.  prefetch</a></li>
<li><a class="reference internal" href="#signal">4.28.  signal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-minicache-and-downcalls">5.  The minicache and downcalls</a><ul>
<li><a class="reference internal" href="#invalidate">5.1.  INVALIDATE</a></li>
<li><a class="reference internal" href="#flush">5.2.  FLUSH</a></li>
<li><a class="reference internal" href="#purgeuser">5.3.  PURGEUSER</a></li>
<li><a class="reference internal" href="#zapfile">5.4.  ZAPFILE</a></li>
<li><a class="reference internal" href="#zapdir">5.5.  ZAPDIR</a></li>
<li><a class="reference internal" href="#zapvnode">5.6.  ZAPVNODE</a></li>
<li><a class="reference internal" href="#purgefid">5.7.  PURGEFID</a></li>
<li><a class="reference internal" href="#replace">5.8.  REPLACE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initialization-and-cleanup">6.  Initialization and cleanup</a><ul>
<li><a class="reference internal" href="#requirements">6.1.  Requirements</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/coda.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/coda.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>