
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ORANGEFS &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Overlay Filesystem" href="overlayfs.html" />
    <link rel="prev" title="Optimized MPEG Filesystem (OMFS)" href="omfs.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="orangefs">
<h1>ORANGEFS<a class="headerlink" href="#orangefs" title="Permalink to this headline">¶</a></h1>
<p>OrangeFS is an LGPL userspace scale-out parallel storage system. It is ideal
for large storage problems faced by HPC, BigData, Streaming Video,
Genomics, Bioinformatics.</p>
<p>Orangefs, originally called PVFS, was first developed in 1993 by
Walt Ligon and Eric Blumer as a parallel file system for Parallel
Virtual Machine (PVM) as part of a NASA grant to study the I/O patterns
of parallel programs.</p>
<p>Orangefs features include:</p>
<blockquote>
<div><ul class="simple">
<li><p>Distributes file data among multiple file servers</p></li>
<li><p>Supports simultaneous access by multiple clients</p></li>
<li><p>Stores file data and metadata on servers using local file system
and access methods</p></li>
<li><p>Userspace implementation is easy to install and maintain</p></li>
<li><p>Direct MPI support</p></li>
<li><p>Stateless</p></li>
</ul>
</div></blockquote>
<section id="mailing-list-archives">
<h2>Mailing List Archives<a class="headerlink" href="#mailing-list-archives" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://lists.orangefs.org/pipermail/devel_lists.orangefs.org/">http://lists.orangefs.org/pipermail/devel_lists.orangefs.org/</a></p>
</section>
<section id="mailing-list-submissions">
<h2>Mailing List Submissions<a class="headerlink" href="#mailing-list-submissions" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="mailto:devel&#37;&#52;&#48;lists&#46;orangefs&#46;org">devel<span>&#64;</span>lists<span>&#46;</span>orangefs<span>&#46;</span>org</a></p>
</section>
<section id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://www.orangefs.org/documentation/">http://www.orangefs.org/documentation/</a></p>
</section>
<section id="running-orangefs-on-a-single-server">
<h2>Running ORANGEFS On a Single Server<a class="headerlink" href="#running-orangefs-on-a-single-server" title="Permalink to this headline">¶</a></h2>
<p>OrangeFS is usually run in large installations with multiple servers and
clients, but a complete filesystem can be run on a single machine for
development and testing.</p>
<p>On Fedora, install orangefs and orangefs-server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dnf -y install orangefs orangefs-server
</pre></div>
</div>
<p>There is an example server configuration file in
/etc/orangefs/orangefs.conf.  Change localhost to your hostname if
necessary.</p>
<p>To generate a filesystem to run xfstests against, see below.</p>
<p>There is an example client configuration file in /etc/pvfs2tab.  It is a
single line.  Uncomment it and change the hostname if necessary.  This
controls clients which use libpvfs2.  This does not control the
pvfs2-client-core.</p>
<p>Create the filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-server -f /etc/orangefs/orangefs.conf
</pre></div>
</div>
<p>Start the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>systemctl start orangefs-server
</pre></div>
</div>
<p>Test the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-ping -m /pvfsmnt
</pre></div>
</div>
<p>Start the client.  The module must be compiled in or loaded before this
point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>systemctl start orangefs-client
</pre></div>
</div>
<p>Mount the filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t pvfs2 tcp://localhost:3334/orangefs /pvfsmnt
</pre></div>
</div>
</section>
<section id="userspace-filesystem-source">
<h2>Userspace Filesystem Source<a class="headerlink" href="#userspace-filesystem-source" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://www.orangefs.org/download">http://www.orangefs.org/download</a></p>
<p>Orangefs versions prior to 2.9.3 would not be compatible with the
upstream version of the kernel client.</p>
</section>
<section id="building-orangefs-on-a-single-server">
<h2>Building ORANGEFS on a Single Server<a class="headerlink" href="#building-orangefs-on-a-single-server" title="Permalink to this headline">¶</a></h2>
<p>Where OrangeFS cannot be installed from distribution packages, it may be
built from source.</p>
<p>You can omit –prefix if you don’t care that things are sprinkled around
in /usr/local.  As of version 2.9.6, OrangeFS uses Berkeley DB by
default, we will probably be changing the default to LMDB soon.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./configure --prefix=/opt/ofs --with-db-backend=lmdb --disable-usrint

make

make install
</pre></div>
</div>
<p>Create an orangefs config file by running pvfs2-genconfig and
specifying a target config file. Pvfs2-genconfig will prompt you
through. Generally it works fine to take the defaults, but you
should use your server’s hostname, rather than “localhost” when
it comes to that question:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/bin/pvfs2-genconfig /etc/pvfs2.conf
</pre></div>
</div>
<p>Create an /etc/pvfs2tab file (localhost is fine):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo tcp://localhost:3334/orangefs /pvfsmnt pvfs2 defaults,noauto 0 0 &gt; \
    /etc/pvfs2tab
</pre></div>
</div>
<p>Create the mount point you specified in the tab file if needed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir /pvfsmnt
</pre></div>
</div>
<p>Bootstrap the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-server -f /etc/pvfs2.conf
</pre></div>
</div>
<p>Start the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-server /etc/pvfs2.conf
</pre></div>
</div>
<p>Now the server should be running. Pvfs2-ls is a simple
test to verify that the server is running:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/bin/pvfs2-ls /pvfsmnt
</pre></div>
</div>
<p>If stuff seems to be working, load the kernel module and
turn on the client core:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-client -p /opt/ofs/sbin/pvfs2-client-core
</pre></div>
</div>
<p>Mount your filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t pvfs2 tcp://`hostname`:3334/orangefs /pvfsmnt
</pre></div>
</div>
</section>
<section id="running-xfstests">
<h2>Running xfstests<a class="headerlink" href="#running-xfstests" title="Permalink to this headline">¶</a></h2>
<p>It is useful to use a scratch filesystem with xfstests.  This can be
done with only one server.</p>
<p>Make a second copy of the FileSystem section in the server configuration
file, which is /etc/orangefs/orangefs.conf.  Change the Name to scratch.
Change the ID to something other than the ID of the first FileSystem
section (2 is usually a good choice).</p>
<p>Then there are two FileSystem sections: orangefs and scratch.</p>
<p>This change should be made before creating the filesystem.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-server -f /etc/orangefs/orangefs.conf
</pre></div>
</div>
<p>To run xfstests, create /etc/xfsqa.config:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TEST_DIR=/orangefs
TEST_DEV=tcp://localhost:3334/orangefs
SCRATCH_MNT=/scratch
SCRATCH_DEV=tcp://localhost:3334/scratch
</pre></div>
</div>
<p>Then xfstests can be run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./check -pvfs2
</pre></div>
</div>
</section>
<section id="options">
<h2>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<p>The following mount options are accepted:</p>
<blockquote>
<div><dl class="simple">
<dt>acl</dt><dd><p>Allow the use of Access Control Lists on files and directories.</p>
</dd>
<dt>intr</dt><dd><p>Some operations between the kernel client and the user space
filesystem can be interruptible, such as changes in debug levels
and the setting of tunable parameters.</p>
</dd>
<dt>local_lock</dt><dd><p>Enable posix locking from the perspective of “this” kernel. The
default file_operations lock action is to return ENOSYS. Posix
locking kicks in if the filesystem is mounted with -o local_lock.
Distributed locking is being worked on for the future.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>If you want the debug (GOSSIP) statements in a particular
source file (inode.c for example) go to syslog:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo inode &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>No debugging (the default):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo none &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>Debugging from several source files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo inode,dir &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>All debugging:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo all &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>Get a list of all debugging keywords:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/kernel/debug/orangefs/debug-help
</pre></div>
</div>
</section>
<section id="protocol-between-kernel-module-and-userspace">
<h2>Protocol between Kernel Module and Userspace<a class="headerlink" href="#protocol-between-kernel-module-and-userspace" title="Permalink to this headline">¶</a></h2>
<p>Orangefs is a user space filesystem and an associated kernel module.
We’ll just refer to the user space part of Orangefs as “userspace”
from here on out. Orangefs descends from PVFS, and userspace code
still uses PVFS for function and variable names. Userspace typedefs
many of the important structures. Function and variable names in
the kernel module have been transitioned to “orangefs”, and The Linux
Coding Style avoids typedefs, so kernel module structures that
correspond to userspace structures are not typedefed.</p>
<p>The kernel module implements a pseudo device that userspace
can read from and write to. Userspace can also manipulate the
kernel module through the pseudo device with ioctl.</p>
<section id="the-bufmap">
<h3>The Bufmap<a class="headerlink" href="#the-bufmap" title="Permalink to this headline">¶</a></h3>
<p>At startup userspace allocates two page-size-aligned (posix_memalign)
mlocked memory buffers, one is used for IO and one is used for readdir
operations. The IO buffer is 41943040 bytes and the readdir buffer is
4194304 bytes. Each buffer contains logical chunks, or partitions, and
a pointer to each buffer is added to its own PVFS_dev_map_desc structure
which also describes its total size, as well as the size and number of
the partitions.</p>
<p>A pointer to the IO buffer’s PVFS_dev_map_desc structure is sent to a
mapping routine in the kernel module with an ioctl. The structure is
copied from user space to kernel space with copy_from_user and is used
to initialize the kernel module’s “bufmap” (struct orangefs_bufmap), which
then contains:</p>
<blockquote>
<div><ul>
<li><p>refcnt
- a reference counter</p></li>
<li><p>desc_size - PVFS2_BUFMAP_DEFAULT_DESC_SIZE (4194304) - the IO buffer’s
partition size, which represents the filesystem’s block size and
is used for s_blocksize in super blocks.</p></li>
<li><p>desc_count - PVFS2_BUFMAP_DEFAULT_DESC_COUNT (10) - the number of
partitions in the IO buffer.</p></li>
<li><p>desc_shift - log2(desc_size), used for s_blocksize_bits in super blocks.</p></li>
<li><p>total_size - the total size of the IO buffer.</p></li>
<li><p>page_count - the number of 4096 byte pages in the IO buffer.</p></li>
<li><p>page_array - a pointer to <code class="docutils literal notranslate"><span class="pre">page_count</span> <span class="pre">*</span> <span class="pre">(sizeof(struct</span> <span class="pre">page*))</span></code> bytes
of kcalloced memory. This memory is used as an array of pointers
to each of the pages in the IO buffer through a call to get_user_pages.</p></li>
<li><p>desc_array - a pointer to <code class="docutils literal notranslate"><span class="pre">desc_count</span> <span class="pre">*</span> <span class="pre">(sizeof(struct</span> <span class="pre">orangefs_bufmap_desc))</span></code>
bytes of kcalloced memory. This memory is further intialized:</p>
<blockquote>
<div><p>user_desc is the kernel’s copy of the IO buffer’s ORANGEFS_dev_map_desc
structure. user_desc-&gt;ptr points to the IO buffer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pages_per_desc = bufmap-&gt;desc_size / PAGE_SIZE
offset = 0

bufmap-&gt;desc_array[0].page_array = &amp;bufmap-&gt;page_array[offset]
bufmap-&gt;desc_array[0].array_count = pages_per_desc = 1024
bufmap-&gt;desc_array[0].uaddr = (user_desc-&gt;ptr) + (0 * 1024 * 4096)
offset += 1024
                   .
                   .
                   .
bufmap-&gt;desc_array[9].page_array = &amp;bufmap-&gt;page_array[offset]
bufmap-&gt;desc_array[9].array_count = pages_per_desc = 1024
bufmap-&gt;desc_array[9].uaddr = (user_desc-&gt;ptr) +
                                       (9 * 1024 * 4096)
offset += 1024
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>buffer_index_array - a desc_count sized array of ints, used to
indicate which of the IO buffer’s partitions are available to use.</p></li>
<li><p>buffer_index_lock - a spinlock to protect buffer_index_array during update.</p></li>
<li><p>readdir_index_array - a five (ORANGEFS_READDIR_DEFAULT_DESC_COUNT) element
int array used to indicate which of the readdir buffer’s partitions are
available to use.</p></li>
<li><p>readdir_index_lock - a spinlock to protect readdir_index_array during
update.</p></li>
</ul>
</div></blockquote>
</section>
<section id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h3>
<p>The kernel module builds an “op” (struct orangefs_kernel_op_s) when it
needs to communicate with userspace. Part of the op contains the “upcall”
which expresses the request to userspace. Part of the op eventually
contains the “downcall” which expresses the results of the request.</p>
<p>The slab allocator is used to keep a cache of op structures handy.</p>
<p>At init time the kernel module defines and initializes a request list
and an in_progress hash table to keep track of all the ops that are
in flight at any given time.</p>
<p>Ops are stateful:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>unknown</dt><dd><ul>
<li><p>op was just initialized</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>waiting</dt><dd><ul>
<li><p>op is on request_list (upward bound)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>inprogr</dt><dd><ul>
<li><p>op is in progress (waiting for downcall)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>serviced</dt><dd><ul>
<li><p>op has matching downcall; ok</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>purged</dt><dd><ul>
<li><p>op has to start a timer since client-core
exited uncleanly before servicing op</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>given up</dt><dd><ul>
<li><p>submitter has given up waiting for it</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>When some arbitrary userspace program needs to perform a
filesystem operation on Orangefs (readdir, I/O, create, whatever)
an op structure is initialized and tagged with a distinguishing ID
number. The upcall part of the op is filled out, and the op is
passed to the “service_operation” function.</p>
<p>Service_operation changes the op’s state to “waiting”, puts
it on the request list, and signals the Orangefs file_operations.poll
function through a wait queue. Userspace is polling the pseudo-device
and thus becomes aware of the upcall request that needs to be read.</p>
<p>When the Orangefs file_operations.read function is triggered, the
request list is searched for an op that seems ready-to-process.
The op is removed from the request list. The tag from the op and
the filled-out upcall struct are copy_to_user’ed back to userspace.</p>
<p>If any of these (and some additional protocol) copy_to_users fail,
the op’s state is set to “waiting” and the op is added back to
the request list. Otherwise, the op’s state is changed to “in progress”,
and the op is hashed on its tag and put onto the end of a list in the
in_progress hash table at the index the tag hashed to.</p>
<p>When userspace has assembled the response to the upcall, it
writes the response, which includes the distinguishing tag, back to
the pseudo device in a series of io_vecs. This triggers the Orangefs
file_operations.write_iter function to find the op with the associated
tag and remove it from the in_progress hash table. As long as the op’s
state is not “canceled” or “given up”, its state is set to “serviced”.
The file_operations.write_iter function returns to the waiting vfs,
and back to service_operation through wait_for_matching_downcall.</p>
<p>Service operation returns to its caller with the op’s downcall
part (the response to the upcall) filled out.</p>
<p>The “client-core” is the bridge between the kernel module and
userspace. The client-core is a daemon. The client-core has an
associated watchdog daemon. If the client-core is ever signaled
to die, the watchdog daemon restarts the client-core. Even though
the client-core is restarted “right away”, there is a period of
time during such an event that the client-core is dead. A dead client-core
can’t be triggered by the Orangefs file_operations.poll function.
Ops that pass through service_operation during a “dead spell” can timeout
on the wait queue and one attempt is made to recycle them. Obviously,
if the client-core stays dead too long, the arbitrary userspace processes
trying to use Orangefs will be negatively affected. Waiting ops
that can’t be serviced will be removed from the request list and
have their states set to “given up”. In-progress ops that can’t
be serviced will be removed from the in_progress hash table and
have their states set to “given up”.</p>
<p>Readdir and I/O ops are atypical with respect to their payloads.</p>
<blockquote>
<div><ul class="simple">
<li><p>readdir ops use the smaller of the two pre-allocated pre-partitioned
memory buffers. The readdir buffer is only available to userspace.
The kernel module obtains an index to a free partition before launching
a readdir op. Userspace deposits the results into the indexed partition
and then writes them to back to the pvfs device.</p></li>
<li><p>io (read and write) ops use the larger of the two pre-allocated
pre-partitioned memory buffers. The IO buffer is accessible from
both userspace and the kernel module. The kernel module obtains an
index to a free partition before launching an io op. The kernel module
deposits write data into the indexed partition, to be consumed
directly by userspace. Userspace deposits the results of read
requests into the indexed partition, to be consumed directly
by the kernel module.</p></li>
</ul>
</div></blockquote>
<p>Responses to kernel requests are all packaged in pvfs2_downcall_t
structs. Besides a few other members, pvfs2_downcall_t contains a
union of structs, each of which is associated with a particular
response type.</p>
<p>The several members outside of the union are:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">type</span></code></dt><dd><ul class="simple">
<li><p>type of operation.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">status</span></code></dt><dd><ul class="simple">
<li><p>return code for the operation.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">trailer_size</span></code></dt><dd><ul class="simple">
<li><p>0 unless readdir operation.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*trailer_buf</span></code></dt><dd><ul class="simple">
<li><p>initialized to NULL, used during readdir operations.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>The appropriate member inside the union is filled out for any
particular response.</p>
<blockquote>
<div><dl class="simple">
<dt>PVFS2_VFS_OP_FILE_IO</dt><dd><p>fill a pvfs2_io_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_LOOKUP</dt><dd><p>fill a PVFS_object_kref</p>
</dd>
<dt>PVFS2_VFS_OP_CREATE</dt><dd><p>fill a PVFS_object_kref</p>
</dd>
<dt>PVFS2_VFS_OP_SYMLINK</dt><dd><p>fill a PVFS_object_kref</p>
</dd>
<dt>PVFS2_VFS_OP_GETATTR</dt><dd><p>fill in a PVFS_sys_attr_s (tons of stuff the kernel doesn’t need)
fill in a string with the link target when the object is a symlink.</p>
</dd>
<dt>PVFS2_VFS_OP_MKDIR</dt><dd><p>fill a PVFS_object_kref</p>
</dd>
<dt>PVFS2_VFS_OP_STATFS</dt><dd><p>fill a pvfs2_statfs_response_t with useless info &lt;g&gt;. It is hard for
us to know, in a timely fashion, these statistics about our
distributed network filesystem.</p>
</dd>
<dt>PVFS2_VFS_OP_FS_MOUNT</dt><dd><p>fill a pvfs2_fs_mount_response_t which is just like a PVFS_object_kref
except its members are in a different order and “__pad1” is replaced
with “id”.</p>
</dd>
<dt>PVFS2_VFS_OP_GETXATTR</dt><dd><p>fill a pvfs2_getxattr_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_LISTXATTR</dt><dd><p>fill a pvfs2_listxattr_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_PARAM</dt><dd><p>fill a pvfs2_param_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_PERF_COUNT</dt><dd><p>fill a pvfs2_perf_count_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_FSKEY</dt><dd><p>file a pvfs2_fs_key_response_t</p>
</dd>
<dt>PVFS2_VFS_OP_READDIR</dt><dd><p>jamb everything needed to represent a pvfs2_readdir_response_t into
the readdir buffer descriptor specified in the upcall.</p>
</dd>
</dl>
</div></blockquote>
<p>Userspace uses writev() on /dev/pvfs2-req to pass responses to the requests
made by the kernel side.</p>
<p>A buffer_list containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>a pointer to the prepared response to the request from the
kernel (struct pvfs2_downcall_t).</p></li>
<li><p>and also, in the case of a readdir request, a pointer to a
buffer containing descriptors for the objects in the target
directory.</p></li>
</ul>
</div></blockquote>
<p>… is sent to the function (PINT_dev_write_list) which performs
the writev.</p>
<p>PINT_dev_write_list has a local iovec array: struct iovec io_array[10];</p>
<p>The first four elements of io_array are initialized like this for all
responses:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>io_array[0].iov_base = address of local variable &quot;proto_ver&quot; (int32_t)
io_array[0].iov_len = sizeof(int32_t)

io_array[1].iov_base = address of global variable &quot;pdev_magic&quot; (int32_t)
io_array[1].iov_len = sizeof(int32_t)

io_array[2].iov_base = address of parameter &quot;tag&quot; (PVFS_id_gen_t)
io_array[2].iov_len = sizeof(int64_t)

io_array[3].iov_base = address of out_downcall member (pvfs2_downcall_t)
                       of global variable vfs_request (vfs_request_t)
io_array[3].iov_len = sizeof(pvfs2_downcall_t)
</pre></div>
</div>
<p>Readdir responses initialize the fifth element io_array like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>io_array[4].iov_base = contents of member trailer_buf (char *)
                       from out_downcall member of global variable
                       vfs_request
io_array[4].iov_len = contents of member trailer_size (PVFS_size)
                      from out_downcall member of global variable
                      vfs_request
</pre></div>
</div>
<p>Orangefs exploits the dcache in order to avoid sending redundant
requests to userspace. We keep object inode attributes up-to-date with
orangefs_inode_getattr. Orangefs_inode_getattr uses two arguments to
help it decide whether or not to update an inode: “new” and “bypass”.
Orangefs keeps private data in an object’s inode that includes a short
timeout value, getattr_time, which allows any iteration of
orangefs_inode_getattr to know how long it has been since the inode was
updated. When the object is not new (new == 0) and the bypass flag is not
set (bypass == 0) orangefs_inode_getattr returns without updating the inode
if getattr_time has not timed out. Getattr_time is updated each time the
inode is updated.</p>
<p>Creation of a new object (file, dir, sym-link) includes the evaluation of
its pathname, resulting in a negative directory entry for the object.
A new inode is allocated and associated with the dentry, turning it from
a negative dentry into a “productive full member of society”. Orangefs
obtains the new inode from Linux with <a class="reference internal" href="api-summary.html#c.new_inode" title="new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">new_inode()</span></code></a> and associates
the inode with the dentry by sending the pair back to Linux with
<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a>.</p>
<p>The evaluation of a pathname for an object resolves to its corresponding
dentry. If there is no corresponding dentry, one is created for it in
the dcache. Whenever a dentry is modified or verified Orangefs stores a
short timeout value in the dentry’s d_time, and the dentry will be trusted
for that amount of time. Orangefs is a network filesystem, and objects
can potentially change out-of-band with any particular Orangefs kernel module
instance, so trusting a dentry is risky. The alternative to trusting
dentries is to always obtain the needed information from userspace - at
least a trip to the client-core, maybe to the servers. Obtaining information
from a dentry is cheap, obtaining it from userspace is relatively expensive,
hence the motivation to use the dentry when possible.</p>
<p>The timeout values d_time and getattr_time are jiffy based, and the
code is designed to avoid the jiffy-wrap problem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;In general, if the clock may have wrapped around more than once, there
is no way to tell how much time has elapsed. However, if the times t1
and t2 are known to be fairly close, we can reliably compute the
difference in a way that takes into account the possibility that the
clock may have wrapped between times.&quot;
</pre></div>
</div>
<p>from course notes by instructor Andy Wang</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ORANGEFS</a><ul>
<li><a class="reference internal" href="#mailing-list-archives">Mailing List Archives</a></li>
<li><a class="reference internal" href="#mailing-list-submissions">Mailing List Submissions</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
<li><a class="reference internal" href="#running-orangefs-on-a-single-server">Running ORANGEFS On a Single Server</a></li>
<li><a class="reference internal" href="#userspace-filesystem-source">Userspace Filesystem Source</a></li>
<li><a class="reference internal" href="#building-orangefs-on-a-single-server">Building ORANGEFS on a Single Server</a></li>
<li><a class="reference internal" href="#running-xfstests">Running xfstests</a></li>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#protocol-between-kernel-module-and-userspace">Protocol between Kernel Module and Userspace</a><ul>
<li><a class="reference internal" href="#the-bufmap">The Bufmap</a></li>
<li><a class="reference internal" href="#operations">Operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/orangefs.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/orangefs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>