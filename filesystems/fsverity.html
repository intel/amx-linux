
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>fs-verity: read-only file-based authenticity protection &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Network Filesystem Helper Library" href="netfs_library.html" />
    <link rel="prev" title="Filesystem-level encryption (fscrypt)" href="fscrypt.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fs-verity-read-only-file-based-authenticity-protection">
<span id="fsverity"></span><h1>fs-verity: read-only file-based authenticity protection<a class="headerlink" href="#fs-verity-read-only-file-based-authenticity-protection" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>fs-verity (<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code>) is a support layer that filesystems can
hook into to support transparent integrity and authenticity protection
of read-only files.  Currently, it is supported by the ext4, f2fs, and
btrfs filesystems.  Like fscrypt, not too much filesystem-specific
code is needed to support fs-verity.</p>
<p>fs-verity is similar to <a class="reference external" href="https://www.kernel.org/doc/Documentation/device-mapper/verity.txt">dm-verity</a>
but works on files rather than block devices.  On regular files on
filesystems supporting fs-verity, userspace can execute an ioctl that
causes the filesystem to build a Merkle tree for the file and persist
it to a filesystem-specific location associated with the file.</p>
<p>After this, the file is made readonly, and all reads from the file are
automatically verified against the file’s Merkle tree.  Reads of any
corrupted data, including mmap reads, will fail.</p>
<p>Userspace can use another ioctl to retrieve the root hash (actually
the “fs-verity file digest”, which is a hash that includes the Merkle
tree root hash) that fs-verity is enforcing for the file.  This ioctl
executes in constant time, regardless of the file size.</p>
<p>fs-verity is essentially a way to hash a file in constant time,
subject to the caveat that reads which would violate the hash will
fail at runtime.</p>
</section>
<section id="use-cases">
<h2>Use cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>By itself, the base fs-verity feature only provides integrity
protection, i.e. detection of accidental (non-malicious) corruption.</p>
<p>However, because fs-verity makes retrieving the file hash extremely
efficient, it’s primarily meant to be used as a tool to support
authentication (detection of malicious modifications) or auditing
(logging file hashes before use).</p>
<p>Trusted userspace code (e.g. operating system code running on a
read-only partition that is itself authenticated by dm-verity) can
authenticate the contents of an fs-verity file by using the
<a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a> ioctl to retrieve its hash, then verifying a
digital signature of it.</p>
<p>A standard file hash could be used instead of fs-verity.  However,
this is inefficient if the file is large and only a small portion may
be accessed.  This is often the case for Android application package
(APK) files, for example.  These typically contain many translations,
classes, and other resources that are infrequently or even never
accessed on a particular device.  It would be slow and wasteful to
read and hash the entire file before starting the application.</p>
<p>Unlike an ahead-of-time hash, fs-verity also re-verifies data each
time it’s paged in.  This ensures that malicious disk firmware can’t
undetectably change the contents of the file at runtime.</p>
<p>fs-verity does not replace or obsolete dm-verity.  dm-verity should
still be used on read-only filesystems.  fs-verity is for files that
must live on a read-write filesystem because they are independently
updated and potentially user-installed, so dm-verity cannot be used.</p>
<p>The base fs-verity feature is a hashing mechanism only; actually
authenticating the files may be done by:</p>
<ul>
<li><p>Userspace-only</p></li>
<li><p>Builtin signature verification + userspace policy</p>
<p>fs-verity optionally supports a simple signature verification
mechanism where users can configure the kernel to require that
all fs-verity files be signed by a key loaded into a keyring;
see <a class="reference internal" href="#built-in-signature-verification">Built-in signature verification</a>.</p>
</li>
<li><p>Integrity Measurement Architecture (IMA)</p>
<p>IMA supports including fs-verity file digests and signatures in the
IMA measurement list and verifying fs-verity based file signatures
stored as security.ima xattrs, based on policy.</p>
</li>
</ul>
</section>
<section id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<section id="fs-ioc-enable-verity">
<h3>FS_IOC_ENABLE_VERITY<a class="headerlink" href="#fs-ioc-enable-verity" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_ENABLE_VERITY ioctl enables fs-verity on a file.  It takes
in a pointer to a struct fsverity_enable_arg, defined as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_enable_arg {
        __u32 version;
        __u32 hash_algorithm;
        __u32 block_size;
        __u32 salt_size;
        __u64 salt_ptr;
        __u32 sig_size;
        __u32 __reserved1;
        __u64 sig_ptr;
        __u64 __reserved2[11];
};
</pre></div>
</div>
<p>This structure contains the parameters of the Merkle tree to build for
the file, and optionally contains a signature.  It must be initialized
as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> must be 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hash_algorithm</span></code> must be the identifier for the hash algorithm to
use for the Merkle tree, such as FS_VERITY_HASH_ALG_SHA256.  See
<code class="docutils literal notranslate"><span class="pre">include/uapi/linux/fsverity.h</span></code> for the list of possible values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_size</span></code> must be the Merkle tree block size.  Currently, this
must be equal to the system page size, which is usually 4096 bytes.
Other sizes may be supported in the future.  This value is not
necessarily the same as the filesystem block size.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">salt_size</span></code> is the size of the salt in bytes, or 0 if no salt is
provided.  The salt is a value that is prepended to every hashed
block; it can be used to personalize the hashing for a particular
file or device.  Currently the maximum salt size is 32 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">salt_ptr</span></code> is the pointer to the salt, or NULL if no salt is
provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sig_size</span></code> is the size of the signature in bytes, or 0 if no
signature is provided.  Currently the signature is (somewhat
arbitrarily) limited to 16128 bytes.  See <a class="reference internal" href="#built-in-signature-verification">Built-in signature
verification</a> for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sig_ptr</span></code>  is the pointer to the signature, or NULL if no
signature is provided.</p></li>
<li><p>All reserved fields must be zeroed.</p></li>
</ul>
<p>FS_IOC_ENABLE_VERITY causes the filesystem to build a Merkle tree for
the file and persist it to a filesystem-specific location associated
with the file, then mark the file as a verity file.  This ioctl may
take a long time to execute on large files, and it is interruptible by
fatal signals.</p>
<p>FS_IOC_ENABLE_VERITY checks for write access to the inode.  However,
it must be executed on an O_RDONLY file descriptor and no processes
can have the file open for writing.  Attempts to open the file for
writing while this ioctl is executing will fail with ETXTBSY.  (This
is necessary to guarantee that no writable file descriptors will exist
after verity is enabled, and to guarantee that the file’s contents are
stable while the Merkle tree is being built over it.)</p>
<p>On success, FS_IOC_ENABLE_VERITY returns 0, and the file becomes a
verity file.  On failure (including the case of interruption by a
fatal signal), no changes are made to the file.</p>
<p>FS_IOC_ENABLE_VERITY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: the process does not have write access to the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBADMSG</span></code>: the signature is malformed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>: this ioctl is already running on the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EEXIST</span></code>: the file already has verity enabled</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: the caller provided inaccessible memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINTR</span></code>: the operation was interrupted by a fatal signal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: unsupported version, hash algorithm, or block size; or
reserved bits are set; or the file descriptor refers to neither a
regular file nor a directory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EISDIR</span></code>: the file descriptor refers to a directory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EKEYREJECTED</span></code>: the signature doesn’t match the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EMSGSIZE</span></code>: the salt or signature is too long</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOKEY</span></code>: the fs-verity keyring doesn’t contain the certificate
needed to verify the signature</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOPKG</span></code>: fs-verity recognizes the hash algorithm, but it’s not
available in the kernel’s crypto API as currently configured (e.g.
for SHA-512, missing CONFIG_CRYPTO_SHA512).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement fs-verity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with fs-verity
support; or the filesystem superblock has not had the ‘verity’
feature enabled on it; or the filesystem does not support fs-verity
on this file.  (See <a class="reference internal" href="#filesystem-support">Filesystem support</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EPERM</span></code>: the file is append-only; or, a signature is required and
one was not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EROFS</span></code>: the filesystem is read-only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ETXTBSY</span></code>: someone has the file open for writing.  This can be the
caller’s file descriptor, another open file descriptor, or the file
reference held by a writable memory map.</p></li>
</ul>
</section>
<section id="fs-ioc-measure-verity">
<h3>FS_IOC_MEASURE_VERITY<a class="headerlink" href="#fs-ioc-measure-verity" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_MEASURE_VERITY ioctl retrieves the digest of a verity file.
The fs-verity file digest is a cryptographic digest that identifies
the file contents that are being enforced on reads; it is computed via
a Merkle tree and is different from a traditional full-file digest.</p>
<p>This ioctl takes in a pointer to a variable-length structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_digest {
        __u16 digest_algorithm;
        __u16 digest_size; /* input/output */
        __u8 digest[];
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">digest_size</span></code> is an input/output field.  On input, it must be
initialized to the number of bytes allocated for the variable-length
<code class="docutils literal notranslate"><span class="pre">digest</span></code> field.</p>
<p>On success, 0 is returned and the kernel fills in the structure as
follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">digest_algorithm</span></code> will be the hash algorithm used for the file
digest.  It will match <code class="docutils literal notranslate"><span class="pre">fsverity_enable_arg::hash_algorithm</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">digest_size</span></code> will be the size of the digest in bytes, e.g. 32
for SHA-256.  (This can be redundant with <code class="docutils literal notranslate"><span class="pre">digest_algorithm</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">digest</span></code> will be the actual bytes of the digest.</p></li>
</ul>
<p>FS_IOC_MEASURE_VERITY is guaranteed to execute in constant time,
regardless of the size of the file.</p>
<p>FS_IOC_MEASURE_VERITY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: the caller provided inaccessible memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENODATA</span></code>: the file is not a verity file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement fs-verity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with fs-verity
support, or the filesystem superblock has not had the ‘verity’
feature enabled on it.  (See <a class="reference internal" href="#filesystem-support">Filesystem support</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOVERFLOW</span></code>: the digest is longer than the specified
<code class="docutils literal notranslate"><span class="pre">digest_size</span></code> bytes.  Try providing a larger buffer.</p></li>
</ul>
</section>
<section id="fs-ioc-read-verity-metadata">
<h3>FS_IOC_READ_VERITY_METADATA<a class="headerlink" href="#fs-ioc-read-verity-metadata" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_READ_VERITY_METADATA ioctl reads verity metadata from a
verity file.  This ioctl is available since Linux v5.12.</p>
<p>This ioctl allows writing a server program that takes a verity file
and serves it to a client program, such that the client can do its own
fs-verity compatible verification of the file.  This only makes sense
if the client doesn’t trust the server and if the server needs to
provide the storage for the client.</p>
<p>This is a fairly specialized use case, and most fs-verity users won’t
need this ioctl.</p>
<p>This ioctl takes in a pointer to the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FS_VERITY_METADATA_TYPE_MERKLE_TREE     1
#define FS_VERITY_METADATA_TYPE_DESCRIPTOR      2
#define FS_VERITY_METADATA_TYPE_SIGNATURE       3

struct fsverity_read_metadata_arg {
        __u64 metadata_type;
        __u64 offset;
        __u64 length;
        __u64 buf_ptr;
        __u64 __reserved;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code> specifies the type of metadata to read:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FS_VERITY_METADATA_TYPE_MERKLE_TREE</span></code> reads the blocks of the
Merkle tree.  The blocks are returned in order from the root level
to the leaf level.  Within each level, the blocks are returned in
the same order that their hashes are themselves hashed.
See <a class="reference internal" href="#merkle-tree">Merkle tree</a> for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FS_VERITY_METADATA_TYPE_DESCRIPTOR</span></code> reads the fs-verity
descriptor.  See <a class="reference internal" href="#fs-verity-descriptor">fs-verity descriptor</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FS_VERITY_METADATA_TYPE_SIGNATURE</span></code> reads the signature which was
passed to FS_IOC_ENABLE_VERITY, if any.  See <a class="reference internal" href="#built-in-signature-verification">Built-in signature
verification</a>.</p></li>
</ul>
<p>The semantics are similar to those of <code class="docutils literal notranslate"><span class="pre">pread()</span></code>.  <code class="docutils literal notranslate"><span class="pre">offset</span></code>
specifies the offset in bytes into the metadata item to read from, and
<code class="docutils literal notranslate"><span class="pre">length</span></code> specifies the maximum number of bytes to read from the
metadata item.  <code class="docutils literal notranslate"><span class="pre">buf_ptr</span></code> is the pointer to the buffer to read into,
cast to a 64-bit integer.  <code class="docutils literal notranslate"><span class="pre">__reserved</span></code> must be 0.  On success, the
number of bytes read is returned.  0 is returned at the end of the
metadata item.  The returned length may be less than <code class="docutils literal notranslate"><span class="pre">length</span></code>, for
example if the ioctl is interrupted.</p>
<p>The metadata returned by FS_IOC_READ_VERITY_METADATA isn’t guaranteed
to be authenticated against the file digest that would be returned by
<a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a>, as the metadata is expected to be used to
implement fs-verity compatible verification anyway (though absent a
malicious disk, the metadata will indeed match).  E.g. to implement
this ioctl, the filesystem is allowed to just read the Merkle tree
blocks from disk without actually verifying the path to the root node.</p>
<p>FS_IOC_READ_VERITY_METADATA can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: the caller provided inaccessible memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINTR</span></code>: the ioctl was interrupted before any data was read</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: reserved fields were set, or <code class="docutils literal notranslate"><span class="pre">offset</span> <span class="pre">+</span> <span class="pre">length</span></code>
overflowed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENODATA</span></code>: the file is not a verity file, or
FS_VERITY_METADATA_TYPE_SIGNATURE was requested but the file doesn’t
have a built-in signature</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement fs-verity, or
this ioctl is not yet implemented on it</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with fs-verity
support, or the filesystem superblock has not had the ‘verity’
feature enabled on it.  (See <a class="reference internal" href="#filesystem-support">Filesystem support</a>.)</p></li>
</ul>
</section>
<section id="fs-ioc-getflags">
<h3>FS_IOC_GETFLAGS<a class="headerlink" href="#fs-ioc-getflags" title="Permalink to this headline">¶</a></h3>
<p>The existing ioctl FS_IOC_GETFLAGS (which isn’t specific to fs-verity)
can also be used to check whether a file has fs-verity enabled or not.
To do so, check for FS_VERITY_FL (0x00100000) in the returned flags.</p>
<p>The verity flag is not settable via FS_IOC_SETFLAGS.  You must use
FS_IOC_ENABLE_VERITY instead, since parameters must be provided.</p>
</section>
<section id="statx">
<h3>statx<a class="headerlink" href="#statx" title="Permalink to this headline">¶</a></h3>
<p>Since Linux v5.5, the statx() system call sets STATX_ATTR_VERITY if
the file has fs-verity enabled.  This can perform better than
FS_IOC_GETFLAGS and FS_IOC_MEASURE_VERITY because it doesn’t require
opening the file, and opening verity files can be expensive.</p>
</section>
</section>
<section id="accessing-verity-files">
<h2>Accessing verity files<a class="headerlink" href="#accessing-verity-files" title="Permalink to this headline">¶</a></h2>
<p>Applications can transparently access a verity file just like a
non-verity one, with the following exceptions:</p>
<ul class="simple">
<li><p>Verity files are readonly.  They cannot be opened for writing or
truncate()d, even if the file mode bits allow it.  Attempts to do
one of these things will fail with EPERM.  However, changes to
metadata such as owner, mode, timestamps, and xattrs are still
allowed, since these are not measured by fs-verity.  Verity files
can also still be renamed, deleted, and linked to.</p></li>
<li><p>Direct I/O is not supported on verity files.  Attempts to use direct
I/O on such files will fall back to buffered I/O.</p></li>
<li><p>DAX (Direct Access) is not supported on verity files, because this
would circumvent the data verification.</p></li>
<li><p>Reads of data that doesn’t match the verity Merkle tree will fail
with EIO (for read()) or SIGBUS (for mmap() reads).</p></li>
<li><p>If the sysctl “fs.verity.require_signatures” is set to 1 and the
file is not signed by a key in the fs-verity keyring, then opening
the file will fail.  See <a class="reference internal" href="#built-in-signature-verification">Built-in signature verification</a>.</p></li>
</ul>
<p>Direct access to the Merkle tree is not supported.  Therefore, if a
verity file is copied, or is backed up and restored, then it will lose
its “verity”-ness.  fs-verity is primarily meant for files like
executables that are managed by a package manager.</p>
</section>
<section id="file-digest-computation">
<h2>File digest computation<a class="headerlink" href="#file-digest-computation" title="Permalink to this headline">¶</a></h2>
<p>This section describes how fs-verity hashes the file contents using a
Merkle tree to produce the digest which cryptographically identifies
the file contents.  This algorithm is the same for all filesystems
that support fs-verity.</p>
<p>Userspace only needs to be aware of this algorithm if it needs to
compute fs-verity file digests itself, e.g. in order to sign files.</p>
<section id="merkle-tree">
<span id="fsverity-merkle-tree"></span><h3>Merkle tree<a class="headerlink" href="#merkle-tree" title="Permalink to this headline">¶</a></h3>
<p>The file contents is divided into blocks, where the block size is
configurable but is usually 4096 bytes.  The end of the last block is
zero-padded if needed.  Each block is then hashed, producing the first
level of hashes.  Then, the hashes in this first level are grouped
into ‘blocksize’-byte blocks (zero-padding the ends as needed) and
these blocks are hashed, producing the second level of hashes.  This
proceeds up the tree until only a single block remains.  The hash of
this block is the “Merkle tree root hash”.</p>
<p>If the file fits in one block and is nonempty, then the “Merkle tree
root hash” is simply the hash of the single data block.  If the file
is empty, then the “Merkle tree root hash” is all zeroes.</p>
<p>The “blocks” here are not necessarily the same as “filesystem blocks”.</p>
<p>If a salt was specified, then it’s zero-padded to the closest multiple
of the input size of the hash algorithm’s compression function, e.g.
64 bytes for SHA-256 or 128 bytes for SHA-512.  The padded salt is
prepended to every data or Merkle tree block that is hashed.</p>
<p>The purpose of the block padding is to cause every hash to be taken
over the same amount of data, which simplifies the implementation and
keeps open more possibilities for hardware acceleration.  The purpose
of the salt padding is to make the salting “free” when the salted hash
state is precomputed, then imported for each hash.</p>
<p>Example: in the recommended configuration of SHA-256 and 4K blocks,
128 hash values fit in each block.  Thus, each level of the Merkle
tree is approximately 128 times smaller than the previous, and for
large files the Merkle tree’s size converges to approximately 1/127 of
the original file size.  However, for small files, the padding is
significant, making the space overhead proportionally more.</p>
</section>
<section id="fs-verity-descriptor">
<span id="fsverity-descriptor"></span><h3>fs-verity descriptor<a class="headerlink" href="#fs-verity-descriptor" title="Permalink to this headline">¶</a></h3>
<p>By itself, the Merkle tree root hash is ambiguous.  For example, it
can’t a distinguish a large file from a small second file whose data
is exactly the top-level hash block of the first file.  Ambiguities
also arise from the convention of padding to the next block boundary.</p>
<p>To solve this problem, the fs-verity file digest is actually computed
as a hash of the following structure, which contains the Merkle tree
root hash as well as other fields such as the file size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_descriptor {
        __u8 version;           /* must be 1 */
        __u8 hash_algorithm;    /* Merkle tree hash algorithm */
        __u8 log_blocksize;     /* log2 of size of data and tree blocks */
        __u8 salt_size;         /* size of salt in bytes; 0 if none */
        __le32 __reserved_0x04; /* must be 0 */
        __le64 data_size;       /* size of file the Merkle tree is built over */
        __u8 root_hash[64];     /* Merkle tree root hash */
        __u8 salt[32];          /* salt prepended to each hashed block */
        __u8 __reserved[144];   /* must be 0&#39;s */
};
</pre></div>
</div>
</section>
</section>
<section id="built-in-signature-verification">
<h2>Built-in signature verification<a class="headerlink" href="#built-in-signature-verification" title="Permalink to this headline">¶</a></h2>
<p>With CONFIG_FS_VERITY_BUILTIN_SIGNATURES=y, fs-verity supports putting
a portion of an authentication policy (see <a class="reference internal" href="#use-cases">Use cases</a>) in the
kernel.  Specifically, it adds support for:</p>
<ol class="arabic simple">
<li><p>At fs-verity module initialization time, a keyring “.fs-verity” is
created.  The root user can add trusted X.509 certificates to this
keyring using the add_key() system call, then (when done)
optionally use keyctl_restrict_keyring() to prevent additional
certificates from being added.</p></li>
<li><p><a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a> accepts a pointer to a PKCS#7 formatted
detached signature in DER format of the file’s fs-verity digest.
On success, this signature is persisted alongside the Merkle tree.
Then, any time the file is opened, the kernel will verify the
file’s actual digest against this signature, using the certificates
in the “.fs-verity” keyring.</p></li>
<li><p>A new sysctl “fs.verity.require_signatures” is made available.
When set to 1, the kernel requires that all verity files have a
correctly signed digest as described in (2).</p></li>
</ol>
<p>fs-verity file digests must be signed in the following format, which
is similar to the structure used by <a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_formatted_digest {
        char magic[8];                  /* must be &quot;FSVerity&quot; */
        __le16 digest_algorithm;
        __le16 digest_size;
        __u8 digest[];
};
</pre></div>
</div>
<p>fs-verity’s built-in signature verification support is meant as a
relatively simple mechanism that can be used to provide some level of
authenticity protection for verity files, as an alternative to doing
the signature verification in userspace or using IMA-appraisal.
However, with this mechanism, userspace programs still need to check
that the verity bit is set, and there is no protection against verity
files being swapped around.</p>
</section>
<section id="filesystem-support">
<h2>Filesystem support<a class="headerlink" href="#filesystem-support" title="Permalink to this headline">¶</a></h2>
<p>fs-verity is supported by several filesystems, described below.  The
CONFIG_FS_VERITY kconfig option must be enabled to use fs-verity on
any of these filesystems.</p>
<p><code class="docutils literal notranslate"><span class="pre">include/linux/fsverity.h</span></code> declares the interface between the
<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> support layer and filesystems.  Briefly, filesystems
must provide an <code class="docutils literal notranslate"><span class="pre">fsverity_operations</span></code> structure that provides
methods to read and write the verity metadata to a filesystem-specific
location, including the Merkle tree blocks and
<code class="docutils literal notranslate"><span class="pre">fsverity_descriptor</span></code>.  Filesystems must also call functions in
<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> at certain times, such as when a file is opened or when
pages have been read into the pagecache.  (See <a class="reference internal" href="#verifying-data">Verifying data</a>.)</p>
<section id="ext4">
<h3>ext4<a class="headerlink" href="#ext4" title="Permalink to this headline">¶</a></h3>
<p>ext4 supports fs-verity since Linux v5.4 and e2fsprogs v1.45.2.</p>
<p>To create verity files on an ext4 filesystem, the filesystem must have
been formatted with <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">verity</span></code> or had <code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">verity</span></code> run on
it.  “verity” is an RO_COMPAT filesystem feature, so once set, old
kernels will only be able to mount the filesystem readonly, and old
versions of e2fsck will be unable to check the filesystem.  Moreover,
currently ext4 only supports mounting a filesystem with the “verity”
feature when its block size is equal to PAGE_SIZE (often 4096 bytes).</p>
<p>ext4 sets the EXT4_VERITY_FL on-disk inode flag on verity files.  It
can only be set by <a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a>, and it cannot be cleared.</p>
<p>ext4 also supports encryption, which can be used simultaneously with
fs-verity.  In this case, the plaintext data is verified rather than
the ciphertext.  This is necessary in order to make the fs-verity file
digest meaningful, since every file is encrypted differently.</p>
<p>ext4 stores the verity metadata (Merkle tree and fsverity_descriptor)
past the end of the file, starting at the first 64K boundary beyond
i_size.  This approach works because (a) verity files are readonly,
and (b) pages fully beyond i_size aren’t visible to userspace but can
be read/written internally by ext4 with only some relatively small
changes to ext4.  This approach avoids having to depend on the
EA_INODE feature and on rearchitecturing ext4’s xattr support to
support paging multi-gigabyte xattrs into memory, and to support
encrypting xattrs.  Note that the verity metadata <em>must</em> be encrypted
when the file is, since it contains hashes of the plaintext data.</p>
<p>Currently, ext4 verity only supports the case where the Merkle tree
block size, filesystem block size, and page size are all the same.  It
also only supports extent-based files.</p>
</section>
<section id="f2fs">
<h3>f2fs<a class="headerlink" href="#f2fs" title="Permalink to this headline">¶</a></h3>
<p>f2fs supports fs-verity since Linux v5.4 and f2fs-tools v1.11.0.</p>
<p>To create verity files on an f2fs filesystem, the filesystem must have
been formatted with <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">verity</span></code>.</p>
<p>f2fs sets the FADVISE_VERITY_BIT on-disk inode flag on verity files.
It can only be set by <a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a>, and it cannot be
cleared.</p>
<p>Like ext4, f2fs stores the verity metadata (Merkle tree and
fsverity_descriptor) past the end of the file, starting at the first
64K boundary beyond i_size.  See explanation for ext4 above.
Moreover, f2fs supports at most 4096 bytes of xattr entries per inode
which wouldn’t be enough for even a single Merkle tree block.</p>
<p>Currently, f2fs verity only supports a Merkle tree block size of 4096.
Also, f2fs doesn’t support enabling verity on files that currently
have atomic or volatile writes pending.</p>
</section>
<section id="btrfs">
<h3>btrfs<a class="headerlink" href="#btrfs" title="Permalink to this headline">¶</a></h3>
<p>btrfs supports fs-verity since Linux v5.15.  Verity-enabled inodes are
marked with a RO_COMPAT inode flag, and the verity metadata is stored
in separate btree items.</p>
</section>
</section>
<section id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<section id="verifying-data">
<h3>Verifying data<a class="headerlink" href="#verifying-data" title="Permalink to this headline">¶</a></h3>
<p>fs-verity ensures that all reads of a verity file’s data are verified,
regardless of which syscall is used to do the read (e.g. mmap(),
read(), pread()) and regardless of whether it’s the first read or a
later read (unless the later read can return cached data that was
already verified).  Below, we describe how filesystems implement this.</p>
<section id="pagecache">
<h4>Pagecache<a class="headerlink" href="#pagecache" title="Permalink to this headline">¶</a></h4>
<p>For filesystems using Linux’s pagecache, the <code class="docutils literal notranslate"><span class="pre">-&gt;read_folio()</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;readahead()</span></code> methods must be modified to verify pages before they
are marked Uptodate.  Merely hooking <code class="docutils literal notranslate"><span class="pre">-&gt;read_iter()</span></code> would be
insufficient, since <code class="docutils literal notranslate"><span class="pre">-&gt;read_iter()</span></code> is not used for memory maps.</p>
<p>Therefore, fs/verity/ provides a function fsverity_verify_page() which
verifies a page that has been read into the pagecache of a verity
inode, but is still locked and not Uptodate, so it’s not yet readable
by userspace.  As needed to do the verification,
fsverity_verify_page() will call back into the filesystem to read
Merkle tree pages via fsverity_operations::read_merkle_tree_page().</p>
<p>fsverity_verify_page() returns false if verification failed; in this
case, the filesystem must not set the page Uptodate.  Following this,
as per the usual Linux pagecache behavior, attempts by userspace to
read() from the part of the file containing the page will fail with
EIO, and accesses to the page within a memory map will raise SIGBUS.</p>
<p>fsverity_verify_page() currently only supports the case where the
Merkle tree block size is equal to PAGE_SIZE (often 4096 bytes).</p>
<p>In principle, fsverity_verify_page() verifies the entire path in the
Merkle tree from the data page to the root hash.  However, for
efficiency the filesystem may cache the hash pages.  Therefore,
fsverity_verify_page() only ascends the tree reading hash pages until
an already-verified hash page is seen, as indicated by the PageChecked
bit being set.  It then verifies the path to that page.</p>
<p>This optimization, which is also used by dm-verity, results in
excellent sequential read performance.  This is because usually (e.g.
127 in 128 times for 4K blocks and SHA-256) the hash page from the
bottom level of the tree will already be cached and checked from
reading a previous data page.  However, random reads perform worse.</p>
</section>
<section id="block-device-based-filesystems">
<h4>Block device based filesystems<a class="headerlink" href="#block-device-based-filesystems" title="Permalink to this headline">¶</a></h4>
<p>Block device based filesystems (e.g. ext4 and f2fs) in Linux also use
the pagecache, so the above subsection applies too.  However, they
also usually read many pages from a file at once, grouped into a
structure called a “bio”.  To make it easier for these types of
filesystems to support fs-verity, fs/verity/ also provides a function
fsverity_verify_bio() which verifies all pages in a bio.</p>
<p>ext4 and f2fs also support encryption.  If a verity file is also
encrypted, the pages must be decrypted before being verified.  To
support this, these filesystems allocate a “post-read context” for
each bio and store it in <code class="docutils literal notranslate"><span class="pre">-&gt;bi_private</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bio_post_read_ctx {
       struct bio *bio;
       struct work_struct work;
       unsigned int cur_step;
       unsigned int enabled_steps;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">enabled_steps</span></code> is a bitmask that specifies whether decryption,
verity, or both is enabled.  After the bio completes, for each needed
postprocessing step the filesystem enqueues the bio_post_read_ctx on a
workqueue, and then the workqueue work does the decryption or
verification.  Finally, pages where no decryption or verity error
occurred are marked Uptodate, and the pages are unlocked.</p>
<p>On many filesystems, files can contain holes.  Normally,
<code class="docutils literal notranslate"><span class="pre">-&gt;readahead()</span></code> simply zeroes holes and sets the corresponding pages
Uptodate; no bios are issued.  To prevent this case from bypassing
fs-verity, these filesystems use fsverity_verify_page() to verify hole
pages.</p>
<p>Filesystems also disable direct I/O on verity files, since otherwise
direct I/O would bypass fs-verity.</p>
</section>
</section>
</section>
<section id="userspace-utility">
<h2>Userspace utility<a class="headerlink" href="#userspace-utility" title="Permalink to this headline">¶</a></h2>
<p>This document focuses on the kernel, but a userspace utility for
fs-verity can be found at:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/ebiggers/fsverity-utils.git">https://git.kernel.org/pub/scm/linux/kernel/git/ebiggers/fsverity-utils.git</a></p>
</div></blockquote>
<p>See the README.md file in the fsverity-utils source tree for details,
including examples of setting up fs-verity protected files.</p>
</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>To test fs-verity, use xfstests.  For example, using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/kvm-quickstart.md">kvm-xfstests</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4,f2fs,btrfs -g verity
</pre></div>
</div>
</section>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h2>
<p>This section answers frequently asked questions about fs-verity that
weren’t already directly answered in other parts of this document.</p>
<dl class="field-list">
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why isn’t fs-verity part of IMA?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>fs-verity and IMA (Integrity Measurement Architecture) have
different focuses.  fs-verity is a filesystem-level mechanism for
hashing individual files using a Merkle tree.  In contrast, IMA
specifies a system-wide policy that specifies which files are
hashed and what to do with those hashes, such as log them,
authenticate them, or add them to a measurement list.</p>
<p>IMA supports the fs-verity hashing mechanism as an alternative
to full file hashes, for those who want the performance and
security benefits of the Merkle tree based hash.  However, it
doesn’t make sense to force all uses of fs-verity to be through
IMA.  fs-verity already meets many users’ needs even as a
standalone filesystem feature, and it’s testable like other
filesystem features e.g. with xfstests.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Isn’t fs-verity useless because the attacker can just modify the
hashes in the Merkle tree, which is stored on-disk?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>To verify the authenticity of an fs-verity file you must verify
the authenticity of the “fs-verity file digest”, which
incorporates the root hash of the Merkle tree.  See <a class="reference internal" href="#use-cases">Use cases</a>.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Isn’t fs-verity useless because the attacker can just replace a
verity file with a non-verity one?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>See <a class="reference internal" href="#use-cases">Use cases</a>.  In the initial use case, it’s really trusted
userspace code that authenticates the files; fs-verity is just a
tool to do this job efficiently and securely.  The trusted
userspace code will consider non-verity files to be inauthentic.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why does the Merkle tree need to be stored on-disk?  Couldn’t you
store just the root hash?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>If the Merkle tree wasn’t stored on-disk, then you’d have to
compute the entire tree when the file is first accessed, even if
just one byte is being read.  This is a fundamental consequence of
how Merkle tree hashing works.  To verify a leaf node, you need to
verify the whole path to the root hash, including the root node
(the thing which the root hash is a hash of).  But if the root
node isn’t stored on-disk, you have to compute it by hashing its
children, and so on until you’ve actually hashed the entire file.</p>
<p>That defeats most of the point of doing a Merkle tree-based hash,
since if you have to hash the whole file ahead of time anyway,
then you could simply do sha256(file) instead.  That would be much
simpler, and a bit faster too.</p>
<p>It’s true that an in-memory Merkle tree could still provide the
advantage of verification on every read rather than just on the
first read.  However, it would be inefficient because every time a
hash page gets evicted (you can’t pin the entire Merkle tree into
memory, since it may be very large), in order to restore it you
again need to hash everything below it in the tree.  This again
defeats most of the point of doing a Merkle tree-based hash, since
a single block read could trigger re-hashing gigabytes of data.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>But couldn’t you store just the leaf nodes and compute the rest?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>See previous answer; this really just moves up one level, since
one could alternatively interpret the data blocks as being the
leaf nodes of the Merkle tree.  It’s true that the tree can be
computed much faster if the leaf level is stored rather than just
the data, but that’s only because each level is less than 1% the
size of the level below (assuming the recommended settings of
SHA-256 and 4K blocks).  For the exact same reason, by storing
“just the leaf nodes” you’d already be storing over 99% of the
tree, so you might as well simply store the whole tree.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Can the Merkle tree be built ahead of time, e.g. distributed as
part of a package that is installed to many computers?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>This isn’t currently supported.  It was part of the original
design, but was removed to simplify the kernel UAPI and because it
wasn’t a critical use case.  Files are usually installed once and
used many times, and cryptographic hashing is somewhat fast on
most modern processors.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why doesn’t fs-verity support writes?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>Write support would be very difficult and would require a
completely different design, so it’s well outside the scope of
fs-verity.  Write support would require:</p>
<ul class="simple">
<li><p>A way to maintain consistency between the data and hashes,
including all levels of hashes, since corruption after a crash
(especially of potentially the entire file!) is unacceptable.
The main options for solving this are data journalling,
copy-on-write, and log-structured volume.  But it’s very hard to
retrofit existing filesystems with new consistency mechanisms.
Data journalling is available on ext4, but is very slow.</p></li>
<li><p>Rebuilding the Merkle tree after every write, which would be
extremely inefficient.  Alternatively, a different authenticated
dictionary structure such as an “authenticated skiplist” could
be used.  However, this would be far more complex.</p></li>
</ul>
<p>Compare it to dm-verity vs. dm-integrity.  dm-verity is very
simple: the kernel just verifies read-only data against a
read-only Merkle tree.  In contrast, dm-integrity supports writes
but is slow, is much more complex, and doesn’t actually support
full-device authentication since it authenticates each sector
independently, i.e. there is no “root hash”.  It doesn’t really
make sense for the same device-mapper target to support these two
very different cases; the same applies to fs-verity.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Since verity files are immutable, why isn’t the immutable bit set?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>The existing “immutable” bit (FS_IMMUTABLE_FL) already has a
specific set of semantics which not only make the file contents
read-only, but also prevent the file from being deleted, renamed,
linked to, or having its owner or mode changed.  These extra
properties are unwanted for fs-verity, so reusing the immutable
bit isn’t appropriate.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why does the API use ioctls instead of setxattr() and getxattr()?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>Abusing the xattr interface for basically arbitrary syscalls is
heavily frowned upon by most of the Linux filesystem developers.
An xattr should really just be an xattr on-disk, not an API to
e.g. magically trigger construction of a Merkle tree.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Does fs-verity support remote filesystems?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>So far all filesystems that have implemented fs-verity support are
local filesystems, but in principle any filesystem that can store
per-file verity metadata can support fs-verity, regardless of
whether it’s local or remote.  Some filesystems may have fewer
options of where to store the verity metadata; one possibility is
to store it past the end of the file and “hide” it from userspace
by manipulating i_size.  The data verification functions provided
by <code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> also assume that the filesystem uses the Linux
pagecache, but both local and remote filesystems normally do so.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why is anything filesystem-specific at all?  Shouldn’t fs-verity
be implemented entirely at the VFS level?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>There are many reasons why this is not possible or would be very
difficult, including the following:</p>
<ul>
<li><p>To prevent bypassing verification, pages must not be marked
Uptodate until they’ve been verified.  Currently, each
filesystem is responsible for marking pages Uptodate via
<code class="docutils literal notranslate"><span class="pre">-&gt;readahead()</span></code>.  Therefore, currently it’s not possible for
the VFS to do the verification on its own.  Changing this would
require significant changes to the VFS and all filesystems.</p></li>
<li><p>It would require defining a filesystem-independent way to store
the verity metadata.  Extended attributes don’t work for this
because (a) the Merkle tree may be gigabytes, but many
filesystems assume that all xattrs fit into a single 4K
filesystem block, and (b) ext4 and f2fs encryption doesn’t
encrypt xattrs, yet the Merkle tree <em>must</em> be encrypted when the
file contents are, because it stores hashes of the plaintext
file contents.</p>
<p>So the verity metadata would have to be stored in an actual
file.  Using a separate file would be very ugly, since the
metadata is fundamentally part of the file to be protected, and
it could cause problems where users could delete the real file
but not the metadata file or vice versa.  On the other hand,
having it be in the same file would break applications unless
filesystems’ notion of i_size were divorced from the VFS’s,
which would be complex and require changes to all filesystems.</p>
</li>
<li><p>It’s desirable that FS_IOC_ENABLE_VERITY uses the filesystem’s
transaction mechanism so that either the file ends up with
verity enabled, or no changes were made.  Allowing intermediate
states to occur after a crash may cause problems.</p></li>
</ul>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">fs-verity: read-only file-based authenticity protection</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#use-cases">Use cases</a></li>
<li><a class="reference internal" href="#user-api">User API</a><ul>
<li><a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a></li>
<li><a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a></li>
<li><a class="reference internal" href="#fs-ioc-read-verity-metadata">FS_IOC_READ_VERITY_METADATA</a></li>
<li><a class="reference internal" href="#fs-ioc-getflags">FS_IOC_GETFLAGS</a></li>
<li><a class="reference internal" href="#statx">statx</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accessing-verity-files">Accessing verity files</a></li>
<li><a class="reference internal" href="#file-digest-computation">File digest computation</a><ul>
<li><a class="reference internal" href="#merkle-tree">Merkle tree</a></li>
<li><a class="reference internal" href="#fs-verity-descriptor">fs-verity descriptor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-signature-verification">Built-in signature verification</a></li>
<li><a class="reference internal" href="#filesystem-support">Filesystem support</a><ul>
<li><a class="reference internal" href="#ext4">ext4</a></li>
<li><a class="reference internal" href="#f2fs">f2fs</a></li>
<li><a class="reference internal" href="#btrfs">btrfs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation details</a><ul>
<li><a class="reference internal" href="#verifying-data">Verifying data</a><ul>
<li><a class="reference internal" href="#pagecache">Pagecache</a></li>
<li><a class="reference internal" href="#block-device-based-filesystems">Block device based filesystems</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#userspace-utility">Userspace utility</a></li>
<li><a class="reference internal" href="#tests">Tests</a></li>
<li><a class="reference internal" href="#faq">FAQ</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/fsverity.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/fsverity.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>