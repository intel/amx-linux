
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Locking &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Directory Locking" href="directory-locking.html" />
    <link rel="prev" title="splice and pipes" href="splice.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="locking">
<h1>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h1>
<p>The text below describes the locking rules for VFS-related methods.
It is (believed to be) up-to-date. <em>Please</em>, if you change anything in
prototypes or locking protocols - update this file. And update the relevant
instances in the tree, don’t leave that to maintainers of filesystems/devices/
etc. At the very least, put the list of dubious cases in the end of this file.
Don’t turn it into log - maintainers of out-of-the-tree code are supposed to
be able to use diff(1).</p>
<p>Thing currently missing here: socket operations. Alexey?</p>
<section id="dentry-operations">
<h2>dentry_operations<a class="headerlink" href="#dentry-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*d_revalidate)(struct dentry *, unsigned int);
int (*d_weak_revalidate)(struct dentry *, unsigned int);
int (*d_hash)(const struct dentry *, struct qstr *);
int (*d_compare)(const struct dentry *,
                unsigned int, const char *, const struct qstr *);
int (*d_delete)(struct dentry *);
int (*d_init)(struct dentry *);
void (*d_release)(struct dentry *);
void (*d_iput)(struct dentry *, struct inode *);
char *(*d_dname)((struct dentry *dentry, char *buffer, int buflen);
struct vfsmount *(*d_automount)(struct path *path);
int (*d_manage)(const struct path *, bool);
struct dentry *(*d_real)(struct dentry *, const struct inode *);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 24%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>rename_lock</p></th>
<th class="head"><p>-&gt;d_lock</p></th>
<th class="head"><p>may block</p></th>
<th class="head"><p>rcu-walk</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>d_revalidate:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes (ref-walk)</p></td>
<td><p>maybe</p></td>
</tr>
<tr class="row-odd"><td><p>d_weak_revalidate:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>d_hash</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>maybe</p></td>
</tr>
<tr class="row-odd"><td><p>d_compare:</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>maybe</p></td>
</tr>
<tr class="row-even"><td><p>d_delete:</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>d_init:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>d_release:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>d_prune:</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>d_iput:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>d_dname:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>d_automount:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>d_manage:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes (ref-walk)</p></td>
<td><p>maybe</p></td>
</tr>
<tr class="row-even"><td><p>d_real</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
</section>
<section id="inode-operations">
<h2>inode_operations<a class="headerlink" href="#inode-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*create) (struct inode *,struct dentry *,umode_t, bool);
struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
int (*link) (struct dentry *,struct inode *,struct dentry *);
int (*unlink) (struct inode *,struct dentry *);
int (*symlink) (struct inode *,struct dentry *,const char *);
int (*mkdir) (struct inode *,struct dentry *,umode_t);
int (*rmdir) (struct inode *,struct dentry *);
int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
int (*rename) (struct inode *, struct dentry *,
                struct inode *, struct dentry *, unsigned int);
int (*readlink) (struct dentry *, char __user *,int);
const char *(*get_link) (struct dentry *, struct inode *, struct delayed_call *);
void (*truncate) (struct inode *);
int (*permission) (struct inode *, int, unsigned int);
struct posix_acl * (*get_inode_acl)(struct inode *, int, bool);
int (*setattr) (struct dentry *, struct iattr *);
int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);
ssize_t (*listxattr) (struct dentry *, char *, size_t);
int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start, u64 len);
void (*update_time)(struct inode *, struct timespec *, int);
int (*atomic_open)(struct inode *, struct dentry *,
                        struct file *, unsigned open_flag,
                        umode_t create_mode);
int (*tmpfile) (struct user_namespace *, struct inode *,
                struct file *, umode_t);
int (*fileattr_set)(struct user_namespace *mnt_userns,
                    struct dentry *dentry, struct fileattr *fa);
int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);
struct posix_acl * (*get_acl)(struct user_namespace *, struct dentry *, int);
</pre></div>
</div>
<dl class="simple">
<dt>locking rules:</dt><dd><p>all may block</p>
</dd>
</dl>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>i_rwsem(inode)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>lookup:</p></td>
<td><p>shared</p></td>
</tr>
<tr class="row-odd"><td><p>create:</p></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-even"><td><p>link:</p></td>
<td><p>exclusive (both)</p></td>
</tr>
<tr class="row-odd"><td><p>mknod:</p></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-even"><td><p>symlink:</p></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-odd"><td><p>mkdir:</p></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-even"><td><p>unlink:</p></td>
<td><p>exclusive (both)</p></td>
</tr>
<tr class="row-odd"><td><p>rmdir:</p></td>
<td><p>exclusive (both)(see below)</p></td>
</tr>
<tr class="row-even"><td><p>rename:</p></td>
<td><p>exclusive (all) (see below)</p></td>
</tr>
<tr class="row-odd"><td><p>readlink:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>get_link:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>setattr:</p></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-even"><td><p>permission:</p></td>
<td><p>no (may not block if called in rcu-walk mode)</p></td>
</tr>
<tr class="row-odd"><td><p>get_inode_acl:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>get_acl:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>getattr:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>listxattr:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>fiemap:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>update_time:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>atomic_open:</p></td>
<td><p>shared (exclusive if O_CREAT is set in open flags)</p></td>
</tr>
<tr class="row-even"><td><p>tmpfile:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>fileattr_get:</p></td>
<td><p>no or exclusive</p></td>
</tr>
<tr class="row-even"><td><p>fileattr_set:</p></td>
<td><p>exclusive</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Additionally, -&gt;rmdir(), -&gt;unlink() and -&gt;rename() have -&gt;i_rwsem
exclusive on victim.
cross-directory -&gt;rename() has (per-superblock) -&gt;s_vfs_rename_sem.</p>
</div></blockquote>
<p>See <a class="reference internal" href="directory-locking.html"><span class="doc">Directory Locking</span></a> for more detailed discussion
of the locking scheme for directory operations.</p>
</section>
<section id="xattr-handler-operations">
<h2>xattr_handler operations<a class="headerlink" href="#xattr-handler-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool (*list)(struct dentry *dentry);
int (*get)(const struct xattr_handler *handler, struct dentry *dentry,
           struct inode *inode, const char *name, void *buffer,
           size_t size);
int (*set)(const struct xattr_handler *handler,
           struct user_namespace *mnt_userns,
           struct dentry *dentry, struct inode *inode, const char *name,
           const void *buffer, size_t size, int flags);
</pre></div>
</div>
<dl class="simple">
<dt>locking rules:</dt><dd><p>all may block</p>
</dd>
</dl>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>i_rwsem(inode)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>list:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>get:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>set:</p></td>
<td><p>exclusive</p></td>
</tr>
</tbody>
</table>
</section>
<section id="super-operations">
<h2>super_operations<a class="headerlink" href="#super-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct inode *(*alloc_inode)(struct super_block *sb);
void (*free_inode)(struct inode *);
void (*destroy_inode)(struct inode *);
void (*dirty_inode) (struct inode *, int flags);
int (*write_inode) (struct inode *, struct writeback_control *wbc);
int (*drop_inode) (struct inode *);
void (*evict_inode) (struct inode *);
void (*put_super) (struct super_block *);
int (*sync_fs)(struct super_block *sb, int wait);
int (*freeze_fs) (struct super_block *);
int (*unfreeze_fs) (struct super_block *);
int (*statfs) (struct dentry *, struct kstatfs *);
int (*remount_fs) (struct super_block *, int *, char *);
void (*umount_begin) (struct super_block *);
int (*show_options)(struct seq_file *, struct dentry *);
ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
</pre></div>
</div>
<dl class="simple">
<dt>locking rules:</dt><dd><p>All may block [not true, see below]</p>
</dd>
</dl>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 21%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>s_umount</p></th>
<th class="head"><p>note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>alloc_inode:</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>free_inode:</p></td>
<td></td>
<td><p>called from RCU callback</p></td>
</tr>
<tr class="row-even"><td><p>destroy_inode:</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>dirty_inode:</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>write_inode:</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>drop_inode:</p></td>
<td></td>
<td><p>!!!inode-&gt;i_lock!!!</p></td>
</tr>
<tr class="row-even"><td><p>evict_inode:</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>put_super:</p></td>
<td><p>write</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>sync_fs:</p></td>
<td><p>read</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>freeze_fs:</p></td>
<td><p>write</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>unfreeze_fs:</p></td>
<td><p>write</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>statfs:</p></td>
<td><p>maybe(read)</p></td>
<td><p>(see below)</p></td>
</tr>
<tr class="row-even"><td><p>remount_fs:</p></td>
<td><p>write</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>umount_begin:</p></td>
<td><p>no</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>show_options:</p></td>
<td><p>no</p></td>
<td><p>(namespace_sem)</p></td>
</tr>
<tr class="row-odd"><td><p>quota_read:</p></td>
<td><p>no</p></td>
<td><p>(see below)</p></td>
</tr>
<tr class="row-even"><td><p>quota_write:</p></td>
<td><p>no</p></td>
<td><p>(see below)</p></td>
</tr>
</tbody>
</table>
<p>-&gt;statfs() has s_umount (shared) when called by ustat(2) (native or
compat), but that’s an accident of bad API; s_umount is used to pin
the superblock down when we only have dev_t given us by userland to
identify the superblock.  Everything else (statfs(), fstatfs(), etc.)
doesn’t hold it when calling -&gt;statfs() - superblock is pinned down
by resolving the pathname passed to syscall.</p>
<p>-&gt;quota_read() and -&gt;quota_write() functions are both guaranteed to
be the only ones operating on the quota file by the quota code (via
dqio_sem) (unless an admin really wants to screw up something and
writes to quota files with quotas on). For other details about locking
see also dquot_operations section.</p>
</section>
<section id="file-system-type">
<h2>file_system_type<a class="headerlink" href="#file-system-type" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dentry *(*mount) (struct file_system_type *, int,
               const char *, void *);
void (*kill_sb) (struct super_block *);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>may block</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>mount</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>kill_sb</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
<p>-&gt;mount() returns ERR_PTR or the root dentry; its superblock should be locked
on return.</p>
<p>-&gt;kill_sb() takes a write-locked superblock, does all shutdown work on it,
unlocks and drops the reference.</p>
</section>
<section id="address-space-operations">
<h2>address_space_operations<a class="headerlink" href="#address-space-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*writepage)(struct page *page, struct writeback_control *wbc);
int (*read_folio)(struct file *, struct folio *);
int (*writepages)(struct address_space *, struct writeback_control *);
bool (*dirty_folio)(struct address_space *, struct folio *folio);
void (*readahead)(struct readahead_control *);
int (*write_begin)(struct file *, struct address_space *mapping,
                        loff_t pos, unsigned len,
                        struct page **pagep, void **fsdata);
int (*write_end)(struct file *, struct address_space *mapping,
                        loff_t pos, unsigned len, unsigned copied,
                        struct page *page, void *fsdata);
sector_t (*bmap)(struct address_space *, sector_t);
void (*invalidate_folio) (struct folio *, size_t start, size_t len);
bool (*release_folio)(struct folio *, gfp_t);
void (*free_folio)(struct folio *);
int (*direct_IO)(struct kiocb *, struct iov_iter *iter);
int (*migrate_folio)(struct address_space *, struct folio *dst,
                struct folio *src, enum migrate_mode);
int (*launder_folio)(struct folio *);
bool (*is_partially_uptodate)(struct folio *, size_t from, size_t count);
int (*error_remove_page)(struct address_space *, struct page *);
int (*swap_activate)(struct swap_info_struct *sis, struct file *f, sector_t *span)
int (*swap_deactivate)(struct file *);
int (*swap_rw)(struct kiocb *iocb, struct iov_iter *iter);
</pre></div>
</div>
<dl class="simple">
<dt>locking rules:</dt><dd><p>All except dirty_folio and free_folio may block</p>
</dd>
</dl>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 34%" />
<col style="width: 13%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>folio locked</p></th>
<th class="head"><p>i_rwsem</p></th>
<th class="head"><p>invalidate_lock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>writepage:</p></td>
<td><p>yes, unlocks (see below)</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>read_folio:</p></td>
<td><p>yes, unlocks</p></td>
<td></td>
<td><p>shared</p></td>
</tr>
<tr class="row-even"><td><p>writepages:</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>dirty_folio:</p></td>
<td><p>maybe</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>readahead:</p></td>
<td><p>yes, unlocks</p></td>
<td></td>
<td><p>shared</p></td>
</tr>
<tr class="row-odd"><td><p>write_begin:</p></td>
<td><p>locks the page</p></td>
<td><p>exclusive</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>write_end:</p></td>
<td><p>yes, unlocks</p></td>
<td><p>exclusive</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>bmap:</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>invalidate_folio:</p></td>
<td><p>yes</p></td>
<td></td>
<td><p>exclusive</p></td>
</tr>
<tr class="row-odd"><td><p>release_folio:</p></td>
<td><p>yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>free_folio:</p></td>
<td><p>yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>direct_IO:</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>migrate_folio:</p></td>
<td><p>yes (both)</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>launder_folio:</p></td>
<td><p>yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>is_partially_uptodate:</p></td>
<td><p>yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>error_remove_page:</p></td>
<td><p>yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>swap_activate:</p></td>
<td><p>no</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>swap_deactivate:</p></td>
<td><p>no</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>swap_rw:</p></td>
<td><p>yes, unlocks</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>-&gt;write_begin(), -&gt;write_end() and -&gt;read_folio() may be called from
the request handler (/dev/loop).</p>
<p>-&gt;read_folio() unlocks the folio, either synchronously or via I/O
completion.</p>
<p>-&gt;readahead() unlocks the folios that I/O is attempted on like -&gt;read_folio().</p>
<p>-&gt;writepage() is used for two purposes: for “memory cleansing” and for
“sync”.  These are quite different operations and the behaviour may differ
depending upon the mode.</p>
<p>If writepage is called for sync (wbc-&gt;sync_mode != WBC_SYNC_NONE) then
it <em>must</em> start I/O against the page, even if that would involve
blocking on in-progress I/O.</p>
<p>If writepage is called for memory cleansing (sync_mode ==
WBC_SYNC_NONE) then its role is to get as much writeout underway as
possible.  So writepage should try to avoid blocking against
currently-in-progress I/O.</p>
<p>If the filesystem is not called for “sync” and it determines that it
would need to block against in-progress I/O to be able to start new I/O
against the page the filesystem should redirty the page with
redirty_page_for_writepage(), then unlock the page and return zero.
This may also be done to avoid internal deadlocks, but rarely.</p>
<p>If the filesystem is called for sync then it must wait on any
in-progress I/O and then start new I/O.</p>
<p>The filesystem should unlock the page synchronously, before returning to the
caller, unless -&gt;writepage() returns special WRITEPAGE_ACTIVATE
value. WRITEPAGE_ACTIVATE means that page cannot really be written out
currently, and VM should stop calling -&gt;writepage() on this page for some
time. VM does this by moving page to the head of the active list, hence the
name.</p>
<p>Unless the filesystem is going to redirty_page_for_writepage(), unlock the page
and return zero, writepage <em>must</em> run set_page_writeback() against the page,
followed by unlocking it.  Once set_page_writeback() has been run against the
page, write I/O can be submitted and the write I/O completion handler must run
end_page_writeback() once the I/O is complete.  If no I/O is submitted, the
filesystem must run end_page_writeback() against the page before returning from
writepage.</p>
<p>That is: after 2.5.12, pages which are under writeout are <em>not</em> locked.  Note,
if the filesystem needs the page to be locked during writeout, that is ok, too,
the page is allowed to be unlocked at any point in time between the calls to
set_page_writeback() and end_page_writeback().</p>
<p>Note, failure to run either redirty_page_for_writepage() or the combination of
set_page_writeback()/end_page_writeback() on a page submitted to writepage
will leave the page itself marked clean but it will be tagged as dirty in the
radix tree.  This incoherency can lead to all sorts of hard-to-debug problems
in the filesystem like having dirty inodes at umount and losing written data.</p>
<p>-&gt;writepages() is used for periodic writeback and for syscall-initiated
sync operations.  The address_space should start I/O against at least
<code class="docutils literal notranslate"><span class="pre">*nr_to_write</span></code> pages.  <code class="docutils literal notranslate"><span class="pre">*nr_to_write</span></code> must be decremented for each page
which is written.  The address_space implementation may write more (or less)
pages than <code class="docutils literal notranslate"><span class="pre">*nr_to_write</span></code> asks for, but it should try to be reasonably close.
If nr_to_write is NULL, all dirty pages must be written.</p>
<p>writepages should _only_ write pages which are present on
mapping-&gt;io_pages.</p>
<p>-&gt;dirty_folio() is called from various places in the kernel when
the target folio is marked as needing writeback.  The folio cannot be
truncated because either the caller holds the folio lock, or the caller
has found the folio while holding the page table lock which will block
truncation.</p>
<p>-&gt;<a class="reference internal" href="api-summary.html#c.bmap" title="bmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">bmap()</span></code></a> is currently used by legacy ioctl() (FIBMAP) provided by some
filesystems and by the swapper. The latter will eventually go away.  Please,
keep it that way and don’t breed new callers.</p>
<p>-&gt;invalidate_folio() is called when the filesystem must attempt to drop
some or all of the buffers from the page when it is being truncated. It
returns zero on success.  The filesystem must exclusively acquire
invalidate_lock before invalidating page cache in truncate / hole punch
path (and thus calling into -&gt;invalidate_folio) to block races between page
cache invalidation and page cache filling functions (fault, read, …).</p>
<p>-&gt;release_folio() is called when the kernel is about to try to drop the
buffers from the folio in preparation for freeing it.  It returns false to
indicate that the buffers are (or may be) freeable.  If -&gt;release_folio is
NULL, the kernel assumes that the fs has no private interest in the buffers.</p>
<p>-&gt;free_folio() is called when the kernel has dropped the folio
from the page cache.</p>
<p>-&gt;launder_folio() may be called prior to releasing a folio if
it is still found to be dirty. It returns zero if the folio was successfully
cleaned, or an error value if not. Note that in order to prevent the folio
getting mapped back in and redirtied, it needs to be kept locked
across the entire operation.</p>
<p>-&gt;swap_activate() will be called to prepare the given file for swap.  It
should perform any validation and preparation necessary to ensure that
writes can be performed with minimal memory allocation.  It should call
add_swap_extent(), or the helper iomap_swapfile_activate(), and return
the number of extents added.  If IO should be submitted through
-&gt;swap_rw(), it should set SWP_FS_OPS, otherwise IO will be submitted
directly to the block device <code class="docutils literal notranslate"><span class="pre">sis-&gt;bdev</span></code>.</p>
<p>-&gt;swap_deactivate() will be called in the sys_swapoff()
path after -&gt;swap_activate() returned success.</p>
<p>-&gt;swap_rw will be called for swap IO if SWP_FS_OPS was set by -&gt;swap_activate().</p>
</section>
<section id="file-lock-operations">
<h2>file_lock_operations<a class="headerlink" href="#file-lock-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
void (*fl_release_private)(struct file_lock *);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 32%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>inode-&gt;i_lock</p></th>
<th class="head"><p>may block</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>fl_copy_lock:</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>fl_release_private:</p></td>
<td><p>maybe</p></td>
<td><p>maybe[1]_</p></td>
</tr>
</tbody>
</table>
</section>
<section id="lock-manager-operations">
<h2>lock_manager_operations<a class="headerlink" href="#lock-manager-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*lm_notify)(struct file_lock *);  /* unblock callback */
int (*lm_grant)(struct file_lock *, struct file_lock *, int);
void (*lm_break)(struct file_lock *); /* break_lease callback */
int (*lm_change)(struct file_lock **, int);
bool (*lm_breaker_owns_lease)(struct file_lock *);
bool (*lm_lock_expirable)(struct file_lock *);
void (*lm_expire_lock)(void);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 21%" />
<col style="width: 28%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>flc_lock</p></th>
<th class="head"><p>blocked_lock_lock</p></th>
<th class="head"><p>may block</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>lm_notify:</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>lm_grant:</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>lm_break:</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>lm_change</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>lm_breaker_owns_lease:</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>lm_lock_expirable</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>lm_expire_lock</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
</section>
<section id="buffer-head">
<h2>buffer_head<a class="headerlink" href="#buffer-head" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*b_end_io)(struct buffer_head *bh, int uptodate);
</pre></div>
</div>
<p>locking rules:</p>
<p>called from interrupts. In other words, extreme care is needed here.
bh is locked, but that’s all warranties we have here. Currently only RAID1,
highmem, fs/buffer.c, and fs/ntfs/aops.c are providing these. Block devices
call this method upon the IO completion.</p>
</section>
<section id="block-device-operations">
<h2>block_device_operations<a class="headerlink" href="#block-device-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*open) (struct block_device *, fmode_t);
int (*release) (struct gendisk *, fmode_t);
int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
int (*direct_access) (struct block_device *, sector_t, void **,
                        unsigned long *);
void (*unlock_native_capacity) (struct gendisk *);
int (*getgeo)(struct block_device *, struct hd_geometry *);
void (*swap_slot_free_notify) (struct block_device *, unsigned long);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>open_mutex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>open:</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>release:</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>ioctl:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>compat_ioctl:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>direct_access:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>unlock_native_capacity:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>getgeo:</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>swap_slot_free_notify:</p></td>
<td><p>no      (see below)</p></td>
</tr>
</tbody>
</table>
<p>swap_slot_free_notify is called with swap_lock and sometimes the page lock
held.</p>
</section>
<section id="file-operations">
<h2>file_operations<a class="headerlink" href="#file-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>loff_t (*llseek) (struct file *, loff_t, int);
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
int (*iopoll) (struct kiocb *kiocb, bool spin);
int (*iterate) (struct file *, struct dir_context *);
int (*iterate_shared) (struct file *, struct dir_context *);
__poll_t (*poll) (struct file *, struct poll_table_struct *);
long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
int (*mmap) (struct file *, struct vm_area_struct *);
int (*open) (struct inode *, struct file *);
int (*flush) (struct file *);
int (*release) (struct inode *, struct file *);
int (*fsync) (struct file *, loff_t start, loff_t end, int datasync);
int (*fasync) (int, struct file *, int);
int (*lock) (struct file *, int, struct file_lock *);
ssize_t (*sendpage) (struct file *, struct page *, int, size_t,
                loff_t *, int);
unsigned long (*get_unmapped_area)(struct file *, unsigned long,
                unsigned long, unsigned long, unsigned long);
int (*check_flags)(int);
int (*flock) (struct file *, int, struct file_lock *);
ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *,
                size_t, unsigned int);
ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *,
                size_t, unsigned int);
int (*setlease)(struct file *, long, struct file_lock **, void **);
long (*fallocate)(struct file *, int, loff_t, loff_t);
void (*show_fdinfo)(struct seq_file *m, struct file *f);
unsigned (*mmap_capabilities)(struct file *);
ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
                loff_t, size_t, unsigned int);
loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                struct file *file_out, loff_t pos_out,
                loff_t len, unsigned int remap_flags);
int (*fadvise)(struct file *, loff_t, loff_t, int);
</pre></div>
</div>
<dl class="simple">
<dt>locking rules:</dt><dd><p>All may block.</p>
</dd>
</dl>
<p>-&gt;llseek() locking has moved from llseek to the individual llseek
implementations.  If your fs is not using generic_file_llseek, you
need to acquire and release the appropriate locks in your -&gt;llseek().
For many filesystems, it is probably safe to acquire the inode
mutex or just to use i_size_read() instead.
Note: this does not protect the file-&gt;f_pos against concurrent modifications
since this is something the userspace has to take care about.</p>
<p>-&gt;iterate() is called with i_rwsem exclusive.</p>
<p>-&gt;iterate_shared() is called with i_rwsem at least shared.</p>
<p>-&gt;fasync() is responsible for maintaining the FASYNC bit in filp-&gt;f_flags.
Most instances call fasync_helper(), which does that maintenance, so it’s
not normally something one needs to worry about.  Return values &gt; 0 will be
mapped to zero in the VFS layer.</p>
<p>-&gt;readdir() and -&gt;ioctl() on directories must be changed. Ideally we would
move -&gt;readdir() to inode_operations and use a separate method for directory
-&gt;ioctl() or kill the latter completely. One of the problems is that for
anything that resembles union-mount we won’t have a struct file for all
components. And there are other reasons why the current interface is a mess…</p>
<p>-&gt;read on directories probably must go away - we should just enforce -EISDIR
in sys_read() and friends.</p>
<p>-&gt;setlease operations should call <a class="reference internal" href="api-summary.html#c.generic_setlease" title="generic_setlease"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_setlease()</span></code></a> before or after setting
the lease within the individual filesystem to record the result of the
operation</p>
<p>-&gt;fallocate implementation must be really careful to maintain page cache
consistency when punching holes or performing other operations that invalidate
page cache contents. Usually the filesystem needs to call
<a class="reference internal" href="../core-api/mm-api.html#c.truncate_inode_pages_range" title="truncate_inode_pages_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_inode_pages_range()</span></code></a> to invalidate relevant range of the page cache.
However the filesystem usually also needs to update its internal (and on disk)
view of file offset -&gt; disk block mapping. Until this update is finished, the
filesystem needs to block page faults and reads from reloading now-stale page
cache contents from the disk. Since VFS acquires mapping-&gt;invalidate_lock in
shared mode when loading pages from disk (<a class="reference internal" href="../core-api/mm-api.html#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_fault()</span></code></a>, <a class="reference internal" href="../core-api/mm-api.html#c.filemap_read" title="filemap_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_read()</span></code></a>,
readahead paths), the fallocate implementation must take the invalidate_lock to
prevent reloading.</p>
<p>-&gt;copy_file_range and -&gt;remap_file_range implementations need to serialize
against modifications of file data while the operation is running. For
blocking changes through write(2) and similar operations inode-&gt;i_rwsem can be
used. To block changes to file contents via a memory mapping during the
operation, the filesystem must take mapping-&gt;invalidate_lock to coordinate
with -&gt;page_mkwrite.</p>
</section>
<section id="dquot-operations">
<h2>dquot_operations<a class="headerlink" href="#dquot-operations" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*write_dquot) (struct dquot *);
int (*acquire_dquot) (struct dquot *);
int (*release_dquot) (struct dquot *);
int (*mark_dirty) (struct dquot *);
int (*write_info) (struct super_block *, int);
</pre></div>
</div>
<p>These operations are intended to be more or less wrapping functions that ensure
a proper locking wrt the filesystem and call the generic quota operations.</p>
<p>What filesystem should expect from the generic quota functions:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 24%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>FS recursion</p></th>
<th class="head"><p>Held locks when called</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>write_dquot:</p></td>
<td><p>yes</p></td>
<td><p>dqonoff_sem or dqptr_sem</p></td>
</tr>
<tr class="row-odd"><td><p>acquire_dquot:</p></td>
<td><p>yes</p></td>
<td><p>dqonoff_sem or dqptr_sem</p></td>
</tr>
<tr class="row-even"><td><p>release_dquot:</p></td>
<td><p>yes</p></td>
<td><p>dqonoff_sem or dqptr_sem</p></td>
</tr>
<tr class="row-odd"><td><p>mark_dirty:</p></td>
<td><p>no</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>write_info:</p></td>
<td><p>yes</p></td>
<td><p>dqonoff_sem</p></td>
</tr>
</tbody>
</table>
<p>FS recursion means calling -&gt;quota_read() and -&gt;quota_write() from superblock
operations.</p>
<p>More details about quota locking can be found in fs/dquot.c.</p>
</section>
<section id="vm-operations-struct">
<h2>vm_operations_struct<a class="headerlink" href="#vm-operations-struct" title="Permalink to this headline">¶</a></h2>
<p>prototypes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*open)(struct vm_area_struct*);
void (*close)(struct vm_area_struct*);
vm_fault_t (*fault)(struct vm_area_struct*, struct vm_fault *);
vm_fault_t (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *);
vm_fault_t (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *);
int (*access)(struct vm_area_struct *, unsigned long, void*, int, int);
</pre></div>
</div>
<p>locking rules:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 18%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ops</p></th>
<th class="head"><p>mmap_lock</p></th>
<th class="head"><p>PageLocked(page)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>open:</p></td>
<td><p>yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>close:</p></td>
<td><p>yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>fault:</p></td>
<td><p>yes</p></td>
<td><p>can return with page locked</p></td>
</tr>
<tr class="row-odd"><td><p>map_pages:</p></td>
<td><p>yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>page_mkwrite:</p></td>
<td><p>yes</p></td>
<td><p>can return with page locked</p></td>
</tr>
<tr class="row-odd"><td><p>pfn_mkwrite:</p></td>
<td><p>yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>access:</p></td>
<td><p>yes</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>-&gt;fault() is called when a previously not present pte is about to be faulted
in. The filesystem must find and return the page associated with the passed in
“pgoff” in the vm_fault structure. If it is possible that the page may be
truncated and/or invalidated, then the filesystem must lock invalidate_lock,
then ensure the page is not already truncated (invalidate_lock will block
subsequent truncate), and then return with VM_FAULT_LOCKED, and the page
locked. The VM will unlock the page.</p>
<p>-&gt;map_pages() is called when VM asks to map easy accessible pages.
Filesystem should find and map pages associated with offsets from “start_pgoff”
till “end_pgoff”. -&gt;map_pages() is called with page table locked and must
not block.  If it’s not possible to reach a page without blocking,
filesystem should skip it. Filesystem should use do_set_pte() to setup
page table entry. Pointer to entry associated with the page is passed in
“pte” field in vm_fault structure. Pointers to entries for other offsets
should be calculated relative to “pte”.</p>
<p>-&gt;page_mkwrite() is called when a previously read-only pte is about to become
writeable. The filesystem again must ensure that there are no
truncate/invalidate races or races with operations such as -&gt;remap_file_range
or -&gt;copy_file_range, and then return with the page locked. Usually
mapping-&gt;invalidate_lock is suitable for proper serialization. If the page has
been truncated, the filesystem should not look up a new page like the -&gt;fault()
handler, but simply return with VM_FAULT_NOPAGE, which will cause the VM to
retry the fault.</p>
<p>-&gt;pfn_mkwrite() is the same as page_mkwrite but when the pte is
VM_PFNMAP or VM_MIXEDMAP with a page-less entry. Expected return is
VM_FAULT_NOPAGE. Or one of the VM_FAULT_ERROR types. The default behavior
after this call is to make the pte read-write, unless pfn_mkwrite returns
an error.</p>
<p>-&gt;access() is called when get_user_pages() fails in
access_process_vm(), typically used to debug a process through
/proc/pid/mem or ptrace.  This function is needed only for
VM_IO | VM_PFNMAP VMAs.</p>
<hr class="docutils" />
<blockquote>
<div><p>Dubious stuff</p>
</div></blockquote>
<p>(if you break something or notice that it is broken and do not fix it yourself
- at least put it here)</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Locking</a><ul>
<li><a class="reference internal" href="#dentry-operations">dentry_operations</a></li>
<li><a class="reference internal" href="#inode-operations">inode_operations</a></li>
<li><a class="reference internal" href="#xattr-handler-operations">xattr_handler operations</a></li>
<li><a class="reference internal" href="#super-operations">super_operations</a></li>
<li><a class="reference internal" href="#file-system-type">file_system_type</a></li>
<li><a class="reference internal" href="#address-space-operations">address_space_operations</a></li>
<li><a class="reference internal" href="#file-lock-operations">file_lock_operations</a></li>
<li><a class="reference internal" href="#lock-manager-operations">lock_manager_operations</a></li>
<li><a class="reference internal" href="#buffer-head">buffer_head</a></li>
<li><a class="reference internal" href="#block-device-operations">block_device_operations</a></li>
<li><a class="reference internal" href="#file-operations">file_operations</a></li>
<li><a class="reference internal" href="#dquot-operations">dquot_operations</a></li>
<li><a class="reference internal" href="#vm-operations-struct">vm_operations_struct</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/locking.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/locking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>