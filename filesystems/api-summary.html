
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Linux Filesystems API summary &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="splice and pipes" href="splice.html" />
    <link rel="prev" title="Pathname lookup" href="path-lookup.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linux-filesystems-api-summary">
<h1>Linux Filesystems API summary<a class="headerlink" href="#linux-filesystems-api-summary" title="Permalink to this headline">¶</a></h1>
<p>This section contains API-level documentation, mostly taken from the source
code itself.</p>
<section id="the-linux-vfs">
<h2>The Linux VFS<a class="headerlink" href="#the-linux-vfs" title="Permalink to this headline">¶</a></h2>
<section id="the-filesystem-types">
<h3>The Filesystem types<a class="headerlink" href="#the-filesystem-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.positive_aop_returns">
enum <code class="sig-name descname">positive_aop_returns</code><a class="headerlink" href="#c.positive_aop_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>aop return codes with specific semantics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AOP_WRITEPAGE_ACTIVATE</span></code></dt><dd><p>Informs the caller that page writeback has
completed, that the page is still locked, and
should be considered active.  The VM uses this hint
to return the page to the active list – it won’t
be a candidate for writeback again in the near
future.  Other callers must be careful to unlock
the page if they get this return.  Returned by
writepage();</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AOP_TRUNCATED_PAGE</span></code></dt><dd><p>The AOP method that was handed a locked page has
unlocked it and the page might have been truncated.
The caller should back up to acquiring a new page and
trying again.  The aop will be taking reasonable
precautions not to livelock.  If the caller held a page
reference, it should drop it before retrying.  Returned
by read_folio().</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>address_space_operation functions return these large constants to indicate
special semantics to the caller.  These are much larger than the bytes in a
page to allow for functions that return the number of bytes operated on in a
given page.</p>
<dl class="type">
<dt id="c.address_space">
struct <code class="sig-name descname">address_space</code><a class="headerlink" href="#c.address_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Contents of a cacheable, mappable object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct address_space {
    struct inode            *host;
    struct xarray           i_pages;
    struct rw_semaphore     invalidate_lock;
    gfp_t gfp_mask;
    atomic_t i_mmap_writable;
#ifdef CONFIG_READ_ONLY_THP_FOR_FS;
    atomic_t nr_thps;
#endif;
    struct rb_root_cached   i_mmap;
    struct rw_semaphore     i_mmap_rwsem;
    unsigned long           nrpages;
    pgoff_t writeback_index;
    const struct address_space_operations *a_ops;
    unsigned long           flags;
    errseq_t wb_err;
    spinlock_t private_lock;
    struct list_head        private_list;
    void *private_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">host</span></code></dt><dd><p>Owner, either the inode or the block_device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_pages</span></code></dt><dd><p>Cached pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code></dt><dd><p>Guards coherency between page cache contents and
file offset-&gt;disk block mappings in the filesystem during invalidates.
It is also used to block modification of page cache contents through
memory mappings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_mask</span></code></dt><dd><p>Memory allocation flags to use for allocating pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap_writable</span></code></dt><dd><p>Number of VM_SHARED mappings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_thps</span></code></dt><dd><p>Number of THPs in the pagecache (non-shmem only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap</span></code></dt><dd><p>Tree of private and shared mappings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap_rwsem</span></code></dt><dd><p>Protects <strong>i_mmap</strong> and <strong>i_mmap_writable</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nrpages</span></code></dt><dd><p>Number of page entries, protected by the i_pages lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_index</span></code></dt><dd><p>Writeback starts here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">a_ops</span></code></dt><dd><p>Methods.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Error bits and flags (AS_*).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_err</span></code></dt><dd><p>The most recent error which has occurred.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_lock</span></code></dt><dd><p>For use by the owner of the address_space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_list</span></code></dt><dd><p>For use by the owner of the address_space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>For use by the owner of the address_space.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.file_ra_state">
struct <code class="sig-name descname">file_ra_state</code><a class="headerlink" href="#c.file_ra_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Track a file’s readahead state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct file_ra_state {
    pgoff_t start;
    unsigned int size;
    unsigned int async_size;
    unsigned int ra_pages;
    unsigned int mmap_miss;
    loff_t prev_pos;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Where the most recent readahead started.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of pages read in the most recent readahead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">async_size</span></code></dt><dd><p>Numer of pages that were/are not needed immediately
and so were/are genuinely “ahead”.  Start next readahead when
the first of these pages is accessed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ra_pages</span></code></dt><dd><p>Maximum size of a readahead request, copied from the bdi.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap_miss</span></code></dt><dd><p>How many mmap accesses missed in the page cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev_pos</span></code></dt><dd><p>The last byte in the most recent read request.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When this structure is passed to -&gt;readahead(), the “most recent”
readahead means the current readahead.</p>
<dl class="function">
<dt id="c.i_uid_into_vfsuid">
vfsuid_t <code class="sig-name descname">i_uid_into_vfsuid</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_uid_into_vfsuid" title="Permalink to this definition">¶</a></dt>
<dd><p>map an inode’s i_uid down into a mnt_userns</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to map</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>whe inode’s i_uid mapped down according to <strong>mnt_userns</strong>.
If the inode’s i_uid has no mapping INVALID_VFSUID is returned.</p>
</div>
<dl class="function">
<dt id="c.i_uid_needs_update">
bool <code class="sig-name descname">i_uid_needs_update</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct iattr<em> *attr</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_uid_needs_update" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether inode’s i_uid needs to be updated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>the new attributes of <strong>inode</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the $inode’s i_uid field needs to be updated taking idmapped
mounts into account if the filesystem supports it.</p>
<p><strong>Return</strong></p>
<p>true if <strong>inode</strong>’s i_uid field needs to be updated, false if not.</p>
</div>
<dl class="function">
<dt id="c.i_uid_update">
void <code class="sig-name descname">i_uid_update</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct iattr<em> *attr</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_uid_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update <strong>inode</strong>’s i_uid field</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>the new attributes of <strong>inode</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely update <strong>inode</strong>’s i_uid field translating the vfsuid of any idmapped
mount into the filesystem kuid.</p>
</div>
<dl class="function">
<dt id="c.i_gid_into_vfsgid">
vfsgid_t <code class="sig-name descname">i_gid_into_vfsgid</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_gid_into_vfsgid" title="Permalink to this definition">¶</a></dt>
<dd><p>map an inode’s i_gid down into a mnt_userns</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to map</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the inode’s i_gid mapped down according to <strong>mnt_userns</strong>.
If the inode’s i_gid has no mapping INVALID_VFSGID is returned.</p>
</div>
<dl class="function">
<dt id="c.i_gid_needs_update">
bool <code class="sig-name descname">i_gid_needs_update</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct iattr<em> *attr</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_gid_needs_update" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether inode’s i_gid needs to be updated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>the new attributes of <strong>inode</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the $inode’s i_gid field needs to be updated taking idmapped
mounts into account if the filesystem supports it.</p>
<p><strong>Return</strong></p>
<p>true if <strong>inode</strong>’s i_gid field needs to be updated, false if not.</p>
</div>
<dl class="function">
<dt id="c.i_gid_update">
void <code class="sig-name descname">i_gid_update</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct iattr<em> *attr</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i_gid_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update <strong>inode</strong>’s i_gid field</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>the new attributes of <strong>inode</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely update <strong>inode</strong>’s i_gid field translating the vfsgid of any idmapped
mount into the filesystem kgid.</p>
</div>
<dl class="function">
<dt id="c.inode_fsuid_set">
void <code class="sig-name descname">inode_fsuid_set</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct user_namespace<em> *mnt_userns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_fsuid_set" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize inode’s i_uid field with callers fsuid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the i_uid field of <strong>inode</strong>. If the inode was found/created via
an idmapped mount map the caller’s fsuid according to <strong>mnt_users</strong>.</p>
</div>
<dl class="function">
<dt id="c.inode_fsgid_set">
void <code class="sig-name descname">inode_fsgid_set</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct user_namespace<em> *mnt_userns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_fsgid_set" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize inode’s i_gid field with callers fsgid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the i_gid field of <strong>inode</strong>. If the inode was found/created via
an idmapped mount map the caller’s fsgid according to <strong>mnt_users</strong>.</p>
</div>
<dl class="function">
<dt id="c.fsuidgid_has_mapping">
bool <code class="sig-name descname">fsuidgid_has_mapping</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, struct user_namespace<em> *mnt_userns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fsuidgid_has_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether caller’s fsuid/fsgid is mapped</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock we want a mapping in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the relevant mount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the caller’s fsuid and fsgid have a valid mapping in the
s_user_ns of the superblock <strong>sb</strong>. If the caller is on an idmapped mount map
the caller’s fsuid and fsgid according to the <strong>mnt_userns</strong> first.</p>
<p><strong>Return</strong></p>
<p>true if fsuid and fsgid is mapped, false if not.</p>
</div>
<dl class="function">
<dt id="c.sb_end_write">
void <code class="sig-name descname">sb_end_write</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_write" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we wrote to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of writers to the filesystem. Wake up possible waiters
wanting to freeze the filesystem.</p>
</div>
<dl class="function">
<dt id="c.sb_end_pagefault">
void <code class="sig-name descname">sb_end_pagefault</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock from a page fault</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we wrote to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of processes handling write page fault to the filesystem.
Wake up possible waiters wanting to freeze the filesystem.</p>
</div>
<dl class="function">
<dt id="c.sb_end_intwrite">
void <code class="sig-name descname">sb_end_intwrite</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_intwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock for internal fs purposes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we wrote to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement fs-internal number of writers to the filesystem.  Wake up possible
waiters wanting to freeze the filesystem.</p>
</div>
<dl class="function">
<dt id="c.sb_start_write">
void <code class="sig-name descname">sb_start_write</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_write" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we write to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process wants to write data or metadata to a file system (i.e. dirty
a page or an inode), it should embed the operation in a <a class="reference internal" href="#c.sb_start_write" title="sb_start_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_write()</span></code></a> -
<a class="reference internal" href="#c.sb_end_write" title="sb_end_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_end_write()</span></code></a> pair to get exclusion against file system freezing. This
function increments number of writers preventing freezing. If the file
system is already frozen, the function waits until the file system is
thawed.</p>
<p>Since freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. Generally,
freeze protection should be the outermost lock. In particular, we have:</p>
<dl class="simple">
<dt>sb_start_write</dt><dd><p>-&gt; i_mutex                 (write path, truncate, directory ops, …)
-&gt; s_umount                (freeze_super, thaw_super)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sb_start_pagefault">
void <code class="sig-name descname">sb_start_pagefault</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock from a page fault</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we write to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process starts handling write page fault, it should embed the
operation into <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_pagefault()</span></code></a> - <a class="reference internal" href="#c.sb_end_pagefault" title="sb_end_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_end_pagefault()</span></code></a> pair to get
exclusion against file system freezing. This is needed since the page fault
is going to dirty a page. This function increments number of running page
faults preventing freezing. If the file system is already frozen, the
function waits until the file system is thawed.</p>
<p>Since page fault freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. It is advised to
put <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_pagefault()</span></code></a> close to mmap_lock in lock ordering. Page fault
handling code implies lock dependency:</p>
<dl class="simple">
<dt>mmap_lock</dt><dd><p>-&gt; sb_start_pagefault</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sb_start_intwrite">
void <code class="sig-name descname">sb_start_intwrite</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_intwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock for internal fs purposes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super we write to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the third level of protection against filesystem freezing. It is
free for use by a filesystem. The only requirement is that it must rank
below sb_start_pagefault.</p>
<p>For example filesystem can call <a class="reference internal" href="#c.sb_start_intwrite" title="sb_start_intwrite"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_intwrite()</span></code></a> when starting a
transaction which somewhat eases handling of freezing for internal sources
of filesystem changes (internal fs threads, discarding preallocation on file
close, etc.).</p>
</div>
<dl class="type">
<dt id="c.renamedata">
struct <code class="sig-name descname">renamedata</code><a class="headerlink" href="#c.renamedata" title="Permalink to this definition">¶</a></dt>
<dd><p>contains all information required for renaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct renamedata {
    struct user_namespace *old_mnt_userns;
    struct inode *old_dir;
    struct dentry *old_dentry;
    struct user_namespace *new_mnt_userns;
    struct inode *new_dir;
    struct dentry *new_dentry;
    struct inode **delegated_inode;
    unsigned int flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_mnt_userns</span></code></dt><dd><p>old user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_dir</span></code></dt><dd><p>parent of source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_dentry</span></code></dt><dd><p>source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_mnt_userns</span></code></dt><dd><p>new user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_dir</span></code></dt><dd><p>parent of destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_dentry</span></code></dt><dd><p>destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delegated_inode</span></code></dt><dd><p>returns an inode needing a delegation break</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>rename flags</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.is_idmapped_mnt">
bool <code class="sig-name descname">is_idmapped_mnt</code><span class="sig-paren">(</span>const struct vfsmount<em> *mnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_idmapped_mnt" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a mount is mapped</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>the mount to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>mnt</strong> has an non <strong>nop_mnt_idmap</strong> attached to it then <strong>mnt</strong> is mapped.</p>
<p><strong>Return</strong></p>
<p>true if mount is mapped, false if not.</p>
</div>
<dl class="function">
<dt id="c.inode_dio_begin">
void <code class="sig-name descname">inode_dio_begin</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_dio_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>signal start of a direct I/O requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode the direct I/O happens on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called once we’ve finished processing a direct I/O request,
and is used to wake up callers waiting for direct I/O to be quiesced.</p>
</div>
<dl class="function">
<dt id="c.inode_dio_end">
void <code class="sig-name descname">inode_dio_end</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_dio_end" title="Permalink to this definition">¶</a></dt>
<dd><p>signal finish of a direct I/O requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode the direct I/O happens on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called once we’ve finished processing a direct I/O request,
and is used to wake up callers waiting for direct I/O to be quiesced.</p>
</div>
</section>
<section id="the-directory-cache">
<h3>The Directory Cache<a class="headerlink" href="#the-directory-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.d_drop">
void <code class="sig-name descname">d_drop</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_drop" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry to drop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.d_drop" title="d_drop"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_drop()</span></code></a> unhashes the entry from the parent dentry hashes, so that it won’t
be found through a VFS lookup any more. Note that this is different from
deleting the dentry - d_delete will try to mark the dentry negative if
possible, giving a successful _negative_ lookup, while d_drop will
just make the cache lookup fail.</p>
<p><a class="reference internal" href="#c.d_drop" title="d_drop"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_drop()</span></code></a> is used mainly for stuff that wants to invalidate a dentry for some
reason (NFS timeouts or autofs deletes).</p>
<p>__d_drop requires dentry-&gt;d_lock</p>
<p>___d_drop doesn’t mark dentry as “unhashed”
(dentry-&gt;d_hash.pprev will be LIST_POISON2, not NULL).</p>
</div>
<dl class="function">
<dt id="c.d_find_any_alias">
struct dentry * <code class="sig-name descname">d_find_any_alias</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_find_any_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find any alias for a given inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to find an alias for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If any aliases exist for the given inode, take and return a
reference for one of them.  If no aliases exist, return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.d_find_alias">
struct dentry * <code class="sig-name descname">d_find_alias</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_find_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>grab a hashed alias of inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If inode has a hashed alias, or is a directory and has any alias,
acquire the reference to alias and return it. Otherwise return NULL.
Notice that if inode is a directory there can be only one alias and
it can be unhashed only if it has no children, or if it is the root
of a filesystem, or if the directory was renamed and d_revalidate
was the first vfs operation to notice.</p>
<p>If the inode has an IS_ROOT, DCACHE_DISCONNECTED alias, then prefer
any other hashed alias over that one.</p>
</div>
<dl class="function">
<dt id="c.shrink_dcache_sb">
void <code class="sig-name descname">shrink_dcache_sb</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>shrink dcache for a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shrink the dcache for the specified super block. This is used to free
the dcache before unmounting a file system.</p>
</div>
<dl class="function">
<dt id="c.path_has_submounts">
int <code class="sig-name descname">path_has_submounts</code><span class="sig-paren">(</span>const struct path<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_has_submounts" title="Permalink to this definition">¶</a></dt>
<dd><p>check for mounts over a dentry in the current namespace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*parent</span></code></dt><dd><p>path to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the parent or its subdirectories contain
a mount point in the current namespace.</p>
</div>
<dl class="function">
<dt id="c.shrink_dcache_parent">
void <code class="sig-name descname">shrink_dcache_parent</code><span class="sig-paren">(</span>struct dentry<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>prune dcache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>parent of entries to prune</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prune the dcache to remove unused children of the parent dentry.</p>
</div>
<dl class="function">
<dt id="c.d_invalidate">
void <code class="sig-name descname">d_invalidate</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>detach submounts, prune dcache, and drop</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry to invalidate (aka detach, prune and drop)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.d_alloc">
struct dentry * <code class="sig-name descname">d_alloc</code><span class="sig-paren">(</span>struct dentry *<em> parent</em>, const struct qstr<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dcache entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent of entry to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>qstr of the name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a dentry. It returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is insufficient memory
available. On a success the dentry is returned. The name passed in is
copied and the copy passed in may be reused after this call.</p>
</div>
<dl class="function">
<dt id="c.d_instantiate">
void <code class="sig-name descname">d_instantiate</code><span class="sig-paren">(</span>struct dentry<em> *entry</em>, struct inode *<em> inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_instantiate" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in inode information for a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*entry</span></code></dt><dd><p>dentry to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt><dd><p>inode to attach to this dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in inode information in the entry.</p>
<p>This turns negative dentries into productive full members
of society.</p>
<p>NOTE! This assumes that the inode count has been incremented
(or otherwise set) by the caller to indicate that it is now
in use by the dcache.</p>
</div>
<dl class="function">
<dt id="c.d_obtain_alias">
struct dentry * <code class="sig-name descname">d_obtain_alias</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a DISCONNECTED dentry for a given inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to allocate the dentry for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain a dentry for an inode resulting from NFS filehandle conversion or
similar open by handle operations.  The returned dentry may be anonymous,
or may have a full name (if the inode was already in the cache).</p>
<p>When called on a directory inode, we must ensure that the inode only ever
has one dentry.  If a dentry is found, that is returned instead of
allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is released.
To make it easier to use in export operations a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or IS_ERR inode may
be passed in and the error will be propagated to the return value,
with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <strong>inode</strong> replaced by ERR_PTR(-ESTALE).</p>
</div>
<dl class="function">
<dt id="c.d_obtain_root">
struct dentry * <code class="sig-name descname">d_obtain_root</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_root" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a dentry for a given inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to allocate the dentry for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain an IS_ROOT dentry for the root of a filesystem.</p>
<p>We must ensure that directory inodes only ever have one dentry.  If a
dentry is found, that is returned instead of allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is
released.  A <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or IS_ERR inode may be passed in and will be the
error will be propagate to the return value, with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <strong>inode</strong>
replaced by ERR_PTR(-ESTALE).</p>
</div>
<dl class="function">
<dt id="c.d_add_ci">
struct dentry * <code class="sig-name descname">d_add_ci</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, struct inode<em> *inode</em>, struct qstr<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup or allocate new dentry with case-exact name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the negative dentry that was passed to the parent’s lookup func</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode case-insensitive lookup has found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>the case-exact name to be associated with the returned dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to avoid filling the dcache with case-insensitive names to the
same inode, only the actual correct case is stored in the dcache for
case-insensitive filesystems.</p>
<p>For a case-insensitive lookup match and if the case-exact dentry
already exists in the dcache, use it and return it.</p>
<p>If no entry exists with the exact case name, allocate new dentry with
the exact case, and return the spliced entry.</p>
</div>
<dl class="function">
<dt id="c.d_same_name">
bool <code class="sig-name descname">d_same_name</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em>, const struct dentry<em> *parent</em>, const struct qstr<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_same_name" title="Permalink to this definition">¶</a></dt>
<dd><p>compare dentry name with case-exact name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the negative dentry that was passed to the parent’s lookup func</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>parent dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>the case-exact name to be associated with the returned dentry</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if names are same, or false</p>
</div>
<dl class="function">
<dt id="c.d_lookup">
struct dentry * <code class="sig-name descname">d_lookup</code><span class="sig-paren">(</span>const struct dentry<em> *parent</em>, const struct qstr<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>parent dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>qstr of name we wish to find</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dentry, or NULL</p>
<p><strong>Description</strong></p>
<p>d_lookup searches the children of the parent dentry for the name in
question. If the dentry is found its reference count is incremented and the
dentry is returned. The caller must use dput to free the entry when it has
finished using it. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the dentry does not exist.</p>
</div>
<dl class="function">
<dt id="c.d_hash_and_lookup">
struct dentry * <code class="sig-name descname">d_hash_and_lookup</code><span class="sig-paren">(</span>struct dentry<em> *dir</em>, struct qstr<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_hash_and_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>hash the qstr then search for a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dir</span></code></dt><dd><p>Directory to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>qstr of name we wish to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On lookup failure NULL is returned; on bad name - ERR_PTR(-error)</p>
</div>
<dl class="function">
<dt id="c.d_delete">
void <code class="sig-name descname">d_delete</code><span class="sig-paren">(</span>struct dentry *<em> dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt><dd><p>The dentry to delete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the dentry into a negative dentry if possible, otherwise
remove it from the hash queues so it can be deleted later</p>
</div>
<dl class="function">
<dt id="c.d_rehash">
void <code class="sig-name descname">d_rehash</code><span class="sig-paren">(</span>struct dentry *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_rehash" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry back to the hash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>dentry to add to the hash</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a dentry to the hash according to its name.</p>
</div>
<dl class="function">
<dt id="c.d_add">
void <code class="sig-name descname">d_add</code><span class="sig-paren">(</span>struct dentry<em> *entry</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add dentry to hash queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*entry</span></code></dt><dd><p>dentry to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to attach to this dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the entry to the hash queues and initializes <strong>inode</strong>.
The entry was actually filled in earlier during <a class="reference internal" href="#c.d_alloc" title="d_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_alloc()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.d_exact_alias">
struct dentry * <code class="sig-name descname">d_exact_alias</code><span class="sig-paren">(</span>struct dentry<em> *entry</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_exact_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find and hash an exact unhashed alias</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*entry</span></code></dt><dd><p>dentry to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to go with this dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an unhashed dentry with the same name/parent and desired
inode already exists, hash and return it.  Otherwise, return
NULL.</p>
<p>Parent directory should be locked.</p>
</div>
<dl class="function">
<dt id="c.d_splice_alias">
struct dentry * <code class="sig-name descname">d_splice_alias</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_splice_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>splice a disconnected dentry into the tree if one exists</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode which may have a disconnected dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>a negative dentry which we want to point to the inode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If inode is a directory and has an IS_ROOT alias, then d_move that in
place of the given dentry and return it, else simply d_add the inode
to the dentry and return NULL.</p>
<p>If a non-IS_ROOT directory is found, the filesystem is corrupt, and
we should error out: directories can’t have multiple aliases.</p>
<p>This is needed in the lookup routine of any filesystem that is exportable
(via knfsd) so that we can build dcache paths to directories effectively.</p>
<p>If a dentry was found and moved, then it is returned.  Otherwise NULL
is returned.  This matches the expected return value of -&gt;lookup.</p>
<p>Cluster filesystems may call this function with a negative, hashed dentry.
In that case, we know that the inode will be a regular file, and also this
will only occur during atomic_open. So we need to check for the dentry
being already hashed only in the final case.</p>
</div>
<dl class="function">
<dt id="c.is_subdir">
bool <code class="sig-name descname">is_subdir</code><span class="sig-paren">(</span>struct dentry<em> *new_dentry</em>, struct dentry<em> *old_dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_subdir" title="Permalink to this definition">¶</a></dt>
<dd><p>is new dentry a subdirectory of old_dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dentry</span></code></dt><dd><p>new dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>old dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if new_dentry is a subdirectory of the parent (at any depth).
Returns false otherwise.
Caller must ensure that “new_dentry” is pinned before calling <a class="reference internal" href="#c.is_subdir" title="is_subdir"><code class="xref c c-func docutils literal notranslate"><span class="pre">is_subdir()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.d_unhashed">
int <code class="sig-name descname">d_unhashed</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_unhashed" title="Permalink to this definition">¶</a></dt>
<dd><p>is dentry hashed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>entry to check</p>
<p>Returns true if the dentry passed is not currently hashed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.d_really_is_negative">
bool <code class="sig-name descname">d_really_is_negative</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really negative (ignoring fallthroughs)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>The dentry in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents either an absent name or a name that
doesn’t map to an inode (ie. -&gt;d_inode is NULL).  The dentry could represent
a true miss, a whiteout that isn’t represented by a 0,0 chardev or a
fallthrough marker in an opaque directory.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a> to get
the inode.  (3) The dentry may have something attached to -&gt;d_lower and the
type field of the flags may be set to something other than miss or whiteout.</p>
</div>
<dl class="function">
<dt id="c.d_really_is_positive">
bool <code class="sig-name descname">d_really_is_positive</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really positive (ignoring fallthroughs)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>The dentry in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents a name that maps to an inode
(ie. -&gt;d_inode is not NULL).  The dentry might still represent a whiteout if
that is represented on medium as a 0,0 chardev.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a> to get
the inode.</p>
</div>
<dl class="function">
<dt id="c.d_inode">
struct inode * <code class="sig-name descname">d_inode</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>The dentry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
</div>
<dl class="function">
<dt id="c.d_inode_rcu">
struct inode * <code class="sig-name descname">d_inode_rcu</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry with READ_ONCE()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>The dentry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
</div>
<dl class="function">
<dt id="c.d_backing_inode">
struct inode * <code class="sig-name descname">d_backing_inode</code><span class="sig-paren">(</span>const struct dentry<em> *upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower inode we should be using</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*upper</span></code></dt><dd><p>The upper layer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get at the inode that will be used
if this dentry were to be opened as a file.  The inode may be on the upper
dentry or it may be on a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own inodes.</p>
</div>
<dl class="function">
<dt id="c.d_backing_dentry">
struct dentry * <code class="sig-name descname">d_backing_dentry</code><span class="sig-paren">(</span>struct dentry<em> *upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower dentry we should be using</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*upper</span></code></dt><dd><p>The upper layer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get the dentry of the inode that
will be used if this dentry were opened as a file.  It may be the upper
dentry or it may be a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own dentries.</p>
</div>
<dl class="function">
<dt id="c.d_real">
struct dentry * <code class="sig-name descname">d_real</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to select the dentry from multiple layers (can be NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real dentry.
Otherwise return the dentry itself.</p>
<p>See also: <a class="reference internal" href="vfs.html"><span class="doc">Overview of the Linux Virtual File System</span></a></p>
</div>
<dl class="function">
<dt id="c.d_real_inode">
struct inode * <code class="sig-name descname">d_real_inode</code><span class="sig-paren">(</span>const struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>The dentry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real inode.
Otherwise return <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a>.</p>
</div>
</section>
<section id="inode-handling">
<h3>Inode Handling<a class="headerlink" href="#inode-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.inode_init_always">
int <code class="sig-name descname">inode_init_always</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_always" title="Permalink to this definition">¶</a></dt>
<dd><p>perform inode structure initialisation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock inode belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to initialise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are initializations that need to be done on every inode
allocation as the fields are not initialised by slab allocation.</p>
</div>
<dl class="function">
<dt id="c.drop_nlink">
void <code class="sig-name descname">drop_nlink</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drop_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly drop an inode’s link count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  In cases
where we are attempting to track writes to the
filesystem, a decrement to zero means an imminent
write when the file is truncated and actually unlinked
on the filesystem.</p>
</div>
<dl class="function">
<dt id="c.clear_nlink">
void <code class="sig-name descname">clear_nlink</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly zero an inode’s link count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  See
<a class="reference internal" href="#c.drop_nlink" title="drop_nlink"><code class="xref c c-func docutils literal notranslate"><span class="pre">drop_nlink()</span></code></a> for why we care about i_nlink hitting zero.</p>
</div>
<dl class="function">
<dt id="c.set_nlink">
void <code class="sig-name descname">set_nlink</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, unsigned int<em> nlink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly set an inode’s link count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nlink</span></code></dt><dd><p>new nlink (should be non-zero)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.</p>
</div>
<dl class="function">
<dt id="c.inc_nlink">
void <code class="sig-name descname">inc_nlink</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inc_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly increment an inode’s link count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  Currently,
it is only here for parity with dec_nlink().</p>
</div>
<dl class="function">
<dt id="c.inode_sb_list_add">
void <code class="sig-name descname">inode_sb_list_add</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_sb_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add inode to the superblock list of inodes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to add</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__insert_inode_hash">
void <code class="sig-name descname">__insert_inode_hash</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, unsigned long<em> hashval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__insert_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>hash an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>unhashed inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>unsigned long value used to locate this object in the
inode_hashtable.</p>
<blockquote>
<div><p>Add an inode to the inode hash for this superblock.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__remove_inode_hash">
void <code class="sig-name descname">__remove_inode_hash</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__remove_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an inode from the hash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to unhash</p>
<p>Remove an inode from the superblock.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.evict_inodes">
void <code class="sig-name descname">evict_inodes</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.evict_inodes" title="Permalink to this definition">¶</a></dt>
<dd><p>evict all evictable inodes for a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure that no inodes with zero refcount are retained.  This is
called by superblock shutdown after having SB_ACTIVE flag removed,
so any inode reaching zero refcount during or after that call will
be immediately evicted.</p>
</div>
<dl class="function">
<dt id="c.new_inode">
struct inode * <code class="sig-name descname">new_inode</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock</p>
<p>Allocates a new inode for given superblock. The default gfp_mask
for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.
If HIGHMEM pages are unsuitable or it is known that pages allocated
for the page cache are not reclaimable or migratable,
mapping_set_gfp_mask() must be called with suitable flags on the
newly created inode’s mapping</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unlock_new_inode">
void <code class="sig-name descname">unlock_new_inode</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the I_NEW state and wake up any waiters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>new inode to unlock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when the inode is fully initialised to clear the new state of the
inode and wake up anyone waiting for the inode to finish initialisation.</p>
</div>
<dl class="function">
<dt id="c.lock_two_nondirectories">
void <code class="sig-name descname">lock_two_nondirectories</code><span class="sig-paren">(</span>struct inode<em> *inode1</em>, struct inode<em> *inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>take two i_mutexes on non-directory objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode1</span></code></dt><dd><p>first inode to lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode2</span></code></dt><dd><p>second inode to lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock any non-NULL argument that is not a directory.
Zero, one or two objects may be locked by this function.</p>
</div>
<dl class="function">
<dt id="c.unlock_two_nondirectories">
void <code class="sig-name descname">unlock_two_nondirectories</code><span class="sig-paren">(</span>struct inode<em> *inode1</em>, struct inode<em> *inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>release locks from <a class="reference internal" href="#c.lock_two_nondirectories" title="lock_two_nondirectories"><code class="xref c c-func docutils literal notranslate"><span class="pre">lock_two_nondirectories()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode1</span></code></dt><dd><p>first inode to unlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode2</span></code></dt><dd><p>second inode to unlock</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.inode_insert5">
struct inode * <code class="sig-name descname">inode_insert5</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, unsigned long<em> hashval</em>, int (<em>*test</em>)(struct inode *, void *), int (*set)(struct inode *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_insert5" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>pre-allocated inode to use for insert to cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>hash value (usually inode number) to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used for comparisons between inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*set)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used to initialize a new struct inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque data pointer to pass to <strong>test</strong> and <strong>set</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if present it is return it with an increased reference count. This is
a variant of <a class="reference internal" href="#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a> for callers that don’t want to fail on memory
allocation of inode.</p>
<p>If the inode is not in cache, insert the pre-allocated inode to cache and
return it locked, hashed, and with the I_NEW flag set. The file system gets
to fill it in before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>Note both <strong>test</strong> and <strong>set</strong> are called with the inode_hash_lock held, so can’t
sleep.</p>
</div>
<dl class="function">
<dt id="c.iget5_locked">
struct inode * <code class="sig-name descname">iget5_locked</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> hashval</em>, int (<em>*test</em>)(struct inode *, void *), int (*set)(struct inode *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget5_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>hash value (usually inode number) to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used for comparisons between inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*set)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used to initialize a new struct inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque data pointer to pass to <strong>test</strong> and <strong>set</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if present it is return it with an increased reference count. This is
a generalized version of <a class="reference internal" href="#c.iget_locked" title="iget_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget_locked()</span></code></a> for file systems where the inode
number is not sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set. The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>Note both <strong>test</strong> and <strong>set</strong> are called with the inode_hash_lock held, so can’t
sleep.</p>
</div>
<dl class="function">
<dt id="c.iget_locked">
struct inode * <code class="sig-name descname">iget_locked</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt><dd><p>inode number to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>ino</strong> in the inode cache and if present
return it with an increased reference count. This is for file systems
where the inode number is sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set.  The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.iunique">
ino_t <code class="sig-name descname">iunique</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, ino_t<em> max_reserved</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iunique" title="Permalink to this definition">¶</a></dt>
<dd><p>get a unique inode number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ino_t</span> <span class="pre">max_reserved</span></code></dt><dd><p>highest reserved inode number</p>
<p>Obtain an inode number that is unique on the system for a given
superblock. This is used by file systems that have no natural
permanent inode numbering system. An inode number is returned that
is higher than the reserved limit but unique.</p>
<p>BUGS:
With a large number of inodes live on the file system this function
currently becomes quite slow.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ilookup5_nowait">
struct inode * <code class="sig-name descname">ilookup5_nowait</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> hashval</em>, int (<em>*test</em>)(struct inode *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>hash value (usually inode number) to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used for comparisons between inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque data pointer to pass to <strong>test</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache.
If the inode is in the cache, the inode is returned with an incremented
reference count.</p>
<p>Note2: <strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
<p><strong>Note</strong></p>
<p>I_NEW is not waited upon so you have to be very careful what you do
with the returned inode.  You probably should be using <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5()</span></code></a> instead.</p>
</div>
<dl class="function">
<dt id="c.ilookup5">
struct inode * <code class="sig-name descname">ilookup5</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> hashval</em>, int (<em>*test</em>)(struct inode *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>hash value (usually inode number) to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used for comparisons between inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque data pointer to pass to <strong>test</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if the inode is in the cache, return the inode with an incremented
reference count.  Waits on I_NEW before returning the inode.
returned with an incremented reference count.</p>
<p>This is a generalized version of <a class="reference internal" href="#c.ilookup" title="ilookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup()</span></code></a> for file systems where the
inode number is not sufficient for unique identification of an inode.</p>
<p><strong>Note</strong></p>
<p><strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
</div>
<dl class="function">
<dt id="c.ilookup">
struct inode * <code class="sig-name descname">ilookup</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt><dd><p>inode number to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode <strong>ino</strong> in the inode cache, and if the inode is in the
cache, the inode is returned with an incremented reference count.</p>
</div>
<dl class="function">
<dt id="c.find_inode_nowait">
struct inode * <code class="sig-name descname">find_inode_nowait</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> hashval</em>, int (<em>*match</em>)(struct inode *, unsigned long, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>find an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>hash value (usually inode number) to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">unsigned</span> <span class="pre">long,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback used for comparisons between inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque data pointer to pass to <strong>match</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode
cache, where the helper function <strong>match</strong> will return 0 if the inode
does not match, 1 if the inode does match, and -1 if the search
should be stopped.  The <strong>match</strong> function must be responsible for
taking the i_lock spin_lock and checking i_state for an inode being
freed or being initialized, and incrementing the reference count
before returning 1.  It also must not sleep, since it is called with
the inode_hash_lock spinlock held.</p>
<p>This is a even more generalized version of <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5()</span></code></a> when the
function must never block — find_inode() can block in
__wait_on_freeing_inode() — or when the caller can not increment
the reference count because the resulting <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> might cause an
inode eviction.  The tradeoff is that the <strong>match</strong> funtion must be
very carefully implemented.</p>
</div>
<dl class="function">
<dt id="c.find_inode_rcu">
struct inode * <code class="sig-name descname">find_inode_rcu</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> hashval</em>, int (<em>*test</em>)(struct inode *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>Super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt><dd><p>Key to hash</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to test match on an inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data for test function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
where the helper function <strong>test</strong> will return 0 if the inode does not match
and 1 if it does.  The <strong>test</strong> function must be responsible for taking the
i_lock spin_lock and checking i_state for an inode being freed or being
initialized.</p>
<p>If successful, this will return the inode for which the <strong>test</strong> function
returned 1 and NULL otherwise.</p>
<p>The <strong>test</strong> function is not permitted to take a ref on any inode presented.
It is also not permitted to sleep.</p>
<p>The caller must hold the RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.find_inode_by_ino_rcu">
struct inode * <code class="sig-name descname">find_inode_by_ino_rcu</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_by_ino_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an inode in the inode cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>Super block of file system to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt><dd><p>The inode number to match</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
where the helper function <strong>test</strong> will return 0 if the inode does not match
and 1 if it does.  The <strong>test</strong> function must be responsible for taking the
i_lock spin_lock and checking i_state for an inode being freed or being
initialized.</p>
<p>If successful, this will return the inode for which the <strong>test</strong> function
returned 1 and NULL otherwise.</p>
<p>The <strong>test</strong> function is not permitted to take a ref on any inode presented.
It is also not permitted to sleep.</p>
<p>The caller must hold the RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.iput">
void <code class="sig-name descname">iput</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iput" title="Permalink to this definition">¶</a></dt>
<dd><p>put an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to put</p>
<p>Puts an inode, dropping its usage count. If the inode use count hits
zero, the inode is then freed and may also be destroyed.</p>
<p>Consequently, <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> can sleep.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.bmap">
int <code class="sig-name descname">bmap</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, sector_t<em> *block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bmap" title="Permalink to this definition">¶</a></dt>
<dd><p>find a block number in a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode owning the block number being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">*block</span></code></dt><dd><p>pointer containing the block to find</p>
<p>Replaces the value in <code class="docutils literal notranslate"><span class="pre">*block</span></code> with the block number on the device holding
corresponding to the requested block number in the file.
That is, asked for block 4 of inode 1 the function will replace the
4 in <code class="docutils literal notranslate"><span class="pre">*block</span></code>, with disk block relative to the disk start that holds that
block of the file.</p>
<p>Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a
hole, returns 0 and <code class="docutils literal notranslate"><span class="pre">*block</span></code> is also set to 0.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.file_remove_privs">
int <code class="sig-name descname">file_remove_privs</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_remove_privs" title="Permalink to this definition">¶</a></dt>
<dd><p>remove special file privileges (suid, capabilities)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to remove privileges from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When file is modified by a write or truncation ensure that special
file privileges are removed.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.file_update_time">
int <code class="sig-name descname">file_update_time</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_update_time" title="Permalink to this definition">¶</a></dt>
<dd><p>update mtime and ctime time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file accessed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the mtime and ctime members of an inode and mark the inode for
writeback. Note that this function is meant exclusively for usage in
the file write path of filesystems, and filesystems may choose to
explicitly ignore updates via this function with the _NOCMTIME inode
flag, e.g. for network filesystem where these imestamps are handled
by the server. This can return an error for file systems who need to
allocate space in order to update an inode.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.file_modified">
int <code class="sig-name descname">file_modified</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_modified" title="Permalink to this definition">¶</a></dt>
<dd><p>handle mandated vfs changes when modifying a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file that was modified</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When file has been modified ensure that special
file privileges are removed and time settings are updated.</p>
<p><strong>Context</strong></p>
<p>Caller must hold the file’s inode lock.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.kiocb_modified">
int <code class="sig-name descname">kiocb_modified</code><span class="sig-paren">(</span>struct kiocb<em> *iocb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kiocb_modified" title="Permalink to this definition">¶</a></dt>
<dd><p>handle mandated vfs changes when modifying a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>iocb that was modified</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When file has been modified ensure that special
file privileges are removed and time settings are updated.</p>
<p><strong>Context</strong></p>
<p>Caller must hold the file’s inode lock.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.inode_init_owner">
void <code class="sig-name descname">inode_init_owner</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, const struct inode<em> *dir</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Init uid,gid,mode for new inode according to posix standards</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>User namespace of the mount the inode was created from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>New inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>Directory inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the new inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the inode has been created through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions
and initializing i_uid and i_gid. On non-idmapped mounts or if permission
checking is to be performed on the raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.inode_owner_or_capable">
bool <code class="sig-name descname">inode_owner_or_capable</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_owner_or_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>check current task permissions to inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if current either has CAP_FOWNER in a namespace with the
inode owner uid mapped, or owns the file.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.inode_dio_wait">
void <code class="sig-name descname">inode_dio_wait</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_dio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for outstanding DIO requests to finish</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Waits for all pending direct I/O requests to finish so that we can
proceed with a truncate or equivalent operation.</p>
<p>Must be called under a lock that serializes taking new references
to i_dio_count, usually by inode-&gt;i_mutex.</p>
</div>
<dl class="function">
<dt id="c.timestamp_truncate">
struct timespec64 <code class="sig-name descname">timestamp_truncate</code><span class="sig-paren">(</span>struct timespec64<em> t</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timestamp_truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate timespec to a granularity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">t</span></code></dt><dd><p>Timespec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode being updated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate a timespec to the granularity supported by the fs
containing the inode. Always rounds down. gran must
not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).</p>
</div>
<dl class="function">
<dt id="c.current_time">
struct timespec64 <code class="sig-name descname">current_time</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.current_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return FS time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the current time truncated to the time granularity supported by
the fs.</p>
<p>Note that inode and inode-&gt;sb cannot be NULL.
Otherwise, the function warns and returns time without truncation.</p>
</div>
<dl class="function">
<dt id="c.mode_strip_sgid">
umode_t <code class="sig-name descname">mode_strip_sgid</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct inode<em> *dir</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mode_strip_sgid" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the sgid bit for non-directories</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>User namespace of the mount the inode was created from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the file to be created in <strong>dir</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>mode</strong> of the new file has both the S_ISGID and S_IXGRP bit
raised and <strong>dir</strong> has the S_ISGID bit raised ensure that the caller is
either in the group of the parent directory or they have CAP_FSETID
in their user namespace and are privileged over the parent directory.
In all other cases, strip the S_ISGID bit from <strong>mode</strong>.</p>
<p><strong>Return</strong></p>
<p>the new mode to use for the file</p>
</div>
<dl class="function">
<dt id="c.make_bad_inode">
void <code class="sig-name descname">make_bad_inode</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.make_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>mark an inode bad due to an I/O error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>Inode to mark bad</p>
<p>When an inode cannot be read due to a media or remote network
failure this function makes the inode “bad” and causes I/O operations
on it to fail from this point on.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.is_bad_inode">
bool <code class="sig-name descname">is_bad_inode</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>is an inode errored</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to test</p>
<p>Returns true if the inode in question has been marked as bad.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iget_failed">
void <code class="sig-name descname">iget_failed</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark an under-construction inode as dead and release it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to discard</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an under-construction inode as dead and release it.</p>
</div>
</section>
<section id="registration-and-superblocks">
<h3>Registration and Superblocks<a class="headerlink" href="#registration-and-superblocks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.deactivate_locked_super">
void <code class="sig-name descname">deactivate_locked_super</code><span class="sig-paren">(</span>struct super_block<em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_locked_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*s</span></code></dt><dd><p>superblock to deactivate</p>
<p>Drops an active reference to superblock, converting it into a temporary
one if there is no other active references left.  In that case we
tell fs driver to shut it down and drop the temporary reference we
had just acquired.</p>
<p>Caller holds exclusive lock on superblock; that lock is released.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.deactivate_super">
void <code class="sig-name descname">deactivate_super</code><span class="sig-paren">(</span>struct super_block<em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*s</span></code></dt><dd><p>superblock to deactivate</p>
<p>Variant of <a class="reference internal" href="#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">deactivate_locked_super()</span></code></a>, except that superblock is <em>not</em>
locked by caller.  If we are going to drop the final active reference,
lock will be acquired prior to that.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.retire_super">
void <code class="sig-name descname">retire_super</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.retire_super" title="Permalink to this definition">¶</a></dt>
<dd><p>prevents superblock from being reused</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock to retire</p>
<p>The function marks superblock to be ignored in superblock test, which
prevents it from being reused for any new mounts.  If the superblock has
a private bdi, it also unregisters it, but doesn’t reduce the refcount
of the superblock to prevent potential races.  The refcount is reduced
by <a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a>.  The function can not be called
concurrently with <a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a>.  It is safe to call the
function multiple times, subsequent calls have no effect.</p>
<p>The marker will affect the re-use only for block-device-based
superblocks.  Other superblocks will still get marked if this function
is used, but that will not affect their reusability.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.generic_shutdown_super">
void <code class="sig-name descname">generic_shutdown_super</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_shutdown_super" title="Permalink to this definition">¶</a></dt>
<dd><p>common helper for -&gt;kill_sb()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>superblock to kill</p>
<p><a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a> does all fs-independent work on superblock
shutdown.  Typical -&gt;kill_sb() should pick all fs-specific objects
that need destruction out of superblock, call <a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a>
and release aforementioned objects.  Note: dentries and inodes _are_
taken care of and do not need specific handling.</p>
<p>Upon calling this function, the filesystem may no longer alter or
rearrange the set of dentries belonging to this super_block, nor may it
change the attachments of dentries to inodes.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sget_fc">
struct super_block * <code class="sig-name descname">sget_fc</code><span class="sig-paren">(</span>struct fs_context<em> *fc</em>, int (<em>*test</em>)(struct super_block *, struct fs_context *), int (*set)(struct super_block *, struct fs_context *)<span class="sig-paren">)</span><a class="headerlink" href="#c.sget_fc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find or create a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>Filesystem context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span></code></dt><dd><p>Comparison callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*set)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span></code></dt><dd><p>Setup callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find or create a superblock using the parameters stored in the filesystem
context and the two callback functions.</p>
<p>If an extant superblock is matched, then that will be returned with an
elevated reference count that the caller must transfer or discard.</p>
<p>If no match is made, a new superblock will be allocated and basic
initialisation will be performed (s_type, s_fs_info and s_id will be set and
the set() callback will be invoked), the superblock will be published and it
will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
as yet unset.</p>
</div>
<dl class="function">
<dt id="c.sget">
struct super_block * <code class="sig-name descname">sget</code><span class="sig-paren">(</span>struct file_system_type<em> *type</em>, int (<em>*test</em>)(struct super_block *,void *), int (*set)(struct super_block *,void *), int<em> flags</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sget" title="Permalink to this definition">¶</a></dt>
<dd><p>find or create a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*type</span></code></dt><dd><p>filesystem type superblock should belong to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*test)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span></code></dt><dd><p>comparison callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*set)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span></code></dt><dd><p>setup callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>mount flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>argument to each of them</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iterate_supers_type">
void <code class="sig-name descname">iterate_supers_type</code><span class="sig-paren">(</span>struct file_system_type<em> *type</em>, void (<em>*f</em>)(struct super_block *, void *), void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iterate_supers_type" title="Permalink to this definition">¶</a></dt>
<dd><p>call function for superblocks of given type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*type</span></code></dt><dd><p>fs type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*f)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>argument to pass to it</p>
<p>Scans the superblock list and calls given function, passing it
locked superblock and given argument.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.get_anon_bdev">
int <code class="sig-name descname">get_anon_bdev</code><span class="sig-paren">(</span>dev_t<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_anon_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a block device for filesystems which don’t have one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*p</span></code></dt><dd><p>Pointer to a dev_t.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems which don’t use real block devices can call this function
to allocate a virtual block device.</p>
<p><strong>Context</strong></p>
<p>Any context.  Frequently called while holding sb_lock.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EMFILE if there are no anonymous bdevs left
or -ENOMEM if memory allocation failed.</p>
</div>
<dl class="function">
<dt id="c.get_tree_bdev">
int <code class="sig-name descname">get_tree_bdev</code><span class="sig-paren">(</span>struct fs_context<em> *fc</em>, int (<em>*fill_super</em>)(struct super_block *, struct fs_context *)<span class="sig-paren">)</span><a class="headerlink" href="#c.get_tree_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a superblock based on a single block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>The filesystem context holding the parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fill_super)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span></code></dt><dd><p>Helper to initialise a new superblock</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vfs_get_tree">
int <code class="sig-name descname">vfs_get_tree</code><span class="sig-paren">(</span>struct fs_context<em> *fc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mountable root</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>The superblock configuration context.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The filesystem is invoked to get or create a superblock which can then later
be used for mounting.  The filesystem places a pointer to the root to be
used for mounting in <strong>fc-&gt;root</strong>.</p>
</div>
<dl class="function">
<dt id="c.freeze_super">
int <code class="sig-name descname">freeze_super</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_super" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the filesystem and force it into a consistent state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super to lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Syncs the super to make sure the filesystem is consistent and calls the fs’s
freeze_fs.  Subsequent calls to this without first thawing the fs will return
-EBUSY.</p>
<p>During this function, sb-&gt;s_writers.frozen goes through these values:</p>
<p>SB_UNFROZEN: File system is normal, all writes progress as usual.</p>
<p>SB_FREEZE_WRITE: The file system is in the process of being frozen.  New
writes should be blocked, though page faults are still allowed. We wait for
all writes to complete and then proceed to the next stage.</p>
<p>SB_FREEZE_PAGEFAULT: Freezing continues. Now also page faults are blocked
but internal fs threads can still modify the filesystem (although they
should not dirty new pages or inodes), writeback can run etc. After waiting
for all running page faults we sync the filesystem which will clean all
dirty pages and inodes (no new dirty pages or inodes can be created when
sync is running).</p>
<p>SB_FREEZE_FS: The file system is frozen. Now all internal sources of fs
modification are blocked (e.g. XFS preallocation truncation on inode
reclaim). This is usually implemented by blocking new transactions for
filesystems that have them and need this additional guard. After all
internal writers are finished we call -&gt;freeze_fs() to finish filesystem
freezing. Then we transition to SB_FREEZE_COMPLETE state. This state is
mostly auxiliary for filesystems to verify they do not modify frozen fs.</p>
<p>sb-&gt;s_writers.frozen is protected by sb-&gt;s_umount.</p>
</div>
<dl class="function">
<dt id="c.thaw_super">
int <code class="sig-name descname">thaw_super</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_super" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>unlock filesystem</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the super to thaw</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the filesystem and marks it writeable again after <a class="reference internal" href="#c.freeze_super" title="freeze_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_super()</span></code></a>.</p>
</div>
</section>
<section id="file-locks">
<h3>File Locks<a class="headerlink" href="#file-locks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.locks_owner_has_blockers">
bool <code class="sig-name descname">locks_owner_has_blockers</code><span class="sig-paren">(</span>struct file_lock_context<em> *flctx</em>, fl_owner_t<em> owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_owner_has_blockers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for blocking lock requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock_context</span> <span class="pre">*flctx</span></code></dt><dd><p>file lock context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fl_owner_t</span> <span class="pre">owner</span></code></dt><dd><p>lock owner</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code>: <strong>owner</strong> has at least one blocker
<code class="docutils literal notranslate"><span class="pre">false</span></code>: <strong>owner</strong> has no blockers</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.locks_delete_block">
int <code class="sig-name descname">locks_delete_block</code><span class="sig-paren">(</span>struct file_lock<em> *waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_delete_block" title="Permalink to this definition">¶</a></dt>
<dd><p>stop waiting for a file lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*waiter</span></code></dt><dd><p>the lock which was waiting</p>
<p>lockd/nfsd need to disconnect the lock while working on it.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.posix_lock_file">
int <code class="sig-name descname">posix_lock_file</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct file_lock<em> *fl</em>, struct file_lock<em> *conflock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>The file to apply the lock to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be applied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*conflock</span></code></dt><dd><p>Place to return a copy of the conflicting lock, if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a POSIX style lock to a file.
We merge adjacent &amp; overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address</p>
<p>Note that if called with an FL_EXISTS argument, the caller may determine
whether or not a lock was successfully freed by testing the return
value for -ENOENT.</p>
</div>
<dl class="function">
<dt id="c.__break_lease">
int <code class="sig-name descname">__break_lease</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, unsigned int<em> mode</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__break_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>revoke all outstanding leases on file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode of the file to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>O_RDONLY: break only write leases; O_WRONLY or O_RDWR:
break all leases</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>FL_LEASE: break leases and delegations; FL_DELEG: break
only delegations</p>
<blockquote>
<div><p>break_lease (inlined for speed) has checked there already is at least
some kind of lock (maybe a lease) on this file.  Leases are broken on
a call to open() or truncate().  This function can sleep unless you
specified <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> to your open().</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.lease_get_mtime">
void <code class="sig-name descname">lease_get_mtime</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct timespec64<em> *time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lease_get_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>update modified time of an inode with exclusive lease</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*time</span></code></dt><dd><p>pointer to a timespec which contains the last modified time</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to force NFS clients to flush their caches for files with
exclusive leases.  The justification is that if someone has an
exclusive lease, then they could be modifying it.</p>
</div>
<dl class="function">
<dt id="c.generic_setlease">
int <code class="sig-name descname">generic_setlease</code><span class="sig-paren">(</span>struct file<em> *filp</em>, long<em> arg</em>, struct file_lock<em> **flp</em>, void<em> **priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>type of lease to obtain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**flp</span></code></dt><dd><p>input - file_lock to use, output - file_lock inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**priv</span></code></dt><dd><p>private data for lm_setup (may be NULL if lm_setup
doesn’t require it)</p>
<blockquote>
<div><p>The (input) flp-&gt;fl_lmops-&gt;lm_break function is required
by break_lease().</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vfs_setlease">
int <code class="sig-name descname">vfs_setlease</code><span class="sig-paren">(</span>struct file<em> *filp</em>, long<em> arg</em>, struct file_lock<em> **lease</em>, void<em> **priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>type of lease to obtain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**lease</span></code></dt><dd><p>file_lock to use when adding a lease</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**priv</span></code></dt><dd><p>private info for lm_setup when adding a lease (may be
NULL if lm_setup doesn’t require it)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this to establish a lease on the file. The “lease” argument is not
used for F_UNLCK requests and may be NULL. For commands that set or alter
an existing lease, the <code class="docutils literal notranslate"><span class="pre">(*lease)-&gt;fl_lmops-&gt;lm_break</span></code> operation must be
set; if not, this function will return -ENOLCK (and generate a scary-looking
stack trace).</p>
<p>The “priv” pointer is passed directly to the lm_setup function as-is. It
may be NULL if the lm_setup operation doesn’t require it.</p>
</div>
<dl class="function">
<dt id="c.locks_lock_inode_wait">
int <code class="sig-name descname">locks_lock_inode_wait</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct file_lock<em> *fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a lock to an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode of the file to apply to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX or FLOCK style lock request to an inode.</p>
</div>
<dl class="function">
<dt id="c.vfs_test_lock">
int <code class="sig-name descname">vfs_test_lock</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct file_lock<em> *fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_test_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>test file byte range lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>The file to test lock for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to test; also used to hold result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERRNO on failure.  Indicates presence of conflicting lock by
setting conf-&gt;fl_type to something other than F_UNLCK.</p>
</div>
<dl class="function">
<dt id="c.vfs_lock_file">
int <code class="sig-name descname">vfs_lock_file</code><span class="sig-paren">(</span>struct file<em> *filp</em>, unsigned int<em> cmd</em>, struct file_lock<em> *fl</em>, struct file_lock<em> *conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>The file to apply the lock to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>type of locking operation (F_SETLK, F_GETLK, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be applied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*conf</span></code></dt><dd><p>Place to return a copy of the conflicting lock, if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A caller that doesn’t care about the conflicting lock may pass NULL
as the final argument.</p>
<p>If the filesystem defines a private -&gt;lock() method, then <strong>conf</strong> will
be left unchanged; so a caller that cares should initialize it to
some acceptable default.</p>
<p>To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX
locks, the -&gt;lock() interface may return asynchronously, before the lock has
been granted or denied by the underlying filesystem, if (and only if)
lm_grant is set. Callers expecting -&gt;lock() to return asynchronously
will only use F_SETLK, not F_SETLKW; they will set FL_SLEEP if (and only if)
the request is for a blocking lock. When -&gt;lock() does return asynchronously,
it must return FILE_LOCK_DEFERRED, and call -&gt;lm_grant() when the lock
request completes.
If the request is for non-blocking lock the file system should return
FILE_LOCK_DEFERRED then try to get the lock and call the callback routine
with the result. If the request timed out the callback routine will return a
nonzero return code and the file system should release the lock. The file
system is also responsible to keep a corresponding posix lock when it
grants a lock so the VFS can find out which locks are locally held and do
the correct lock cleanup when required.
The underlying filesystem must not drop the kernel lock or call
-&gt;lm_grant() before returning to the caller with a FILE_LOCK_DEFERRED
return code.</p>
</div>
<dl class="function">
<dt id="c.vfs_cancel_lock">
int <code class="sig-name descname">vfs_cancel_lock</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct file_lock<em> *fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_cancel_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range unblock lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>The file to apply the unblock to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be unblocked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by lock managers to cancel blocked requests</p>
</div>
<dl class="function">
<dt id="c.vfs_inode_has_locks">
bool <code class="sig-name descname">vfs_inode_has_locks</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_inode_has_locks" title="Permalink to this definition">¶</a></dt>
<dd><p>are any file locks held on <strong>inode</strong>?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to check for locks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if there are any FL_POSIX or FL_FLOCK locks currently
set on <strong>inode</strong>.</p>
</div>
<dl class="function">
<dt id="c.posix_lock_inode_wait">
int <code class="sig-name descname">posix_lock_inode_wait</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct file_lock<em> *fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode of file to which lock request should be applied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX style lock request to an inode.</p>
</div>
<dl class="function">
<dt id="c.fcntl_getlease">
int <code class="sig-name descname">fcntl_getlease</code><span class="sig-paren">(</span>struct file<em> *filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_getlease" title="Permalink to this definition">¶</a></dt>
<dd><p>Enquire what lease is currently active</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>the file</p>
<p>The value returned by this function will be one of
(if no lease break is pending):</p>
<p><code class="docutils literal notranslate"><span class="pre">F_RDLCK</span></code> to indicate a shared lease is held.</p>
<p><code class="docutils literal notranslate"><span class="pre">F_WRLCK</span></code> to indicate an exclusive lease is held.</p>
<p><code class="docutils literal notranslate"><span class="pre">F_UNLCK</span></code> to indicate no lease is held.</p>
<p>(if a lease break is pending):</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">F_RDLCK</span></code> to indicate an exclusive lease needs to be</dt><dd><p>changed to a shared lease (or removed).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">F_UNLCK</span></code> to indicate the lease needs to be removed.</p>
<p>XXX: sfr &amp; willy disagree over whether F_INPROGRESS
should be returned to userspace.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.check_conflicting_open">
int <code class="sig-name descname">check_conflicting_open</code><span class="sig-paren">(</span>struct file<em> *filp</em>, const long<em> arg</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_conflicting_open" title="Permalink to this definition">¶</a></dt>
<dd><p>see if the given file points to an inode that has an existing open that would conflict with the desired lease.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>type of lease that we’re trying to acquire</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>current lock flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if there’s an existing open fd on this file that would
conflict with the lease we’re trying to set.</p>
</div>
<dl class="function">
<dt id="c.fcntl_setlease">
int <code class="sig-name descname">fcntl_setlease</code><span class="sig-paren">(</span>unsigned int<em> fd</em>, struct file<em> *filp</em>, long<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>open file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>type of lease to obtain</p>
<p>Call this fcntl to establish a lease on the file.
Note that you also need to call <code class="docutils literal notranslate"><span class="pre">F_SETSIG</span></code> to
receive a signal when the lease is broken.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.flock_lock_inode_wait">
int <code class="sig-name descname">flock_lock_inode_wait</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct file_lock<em> *fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flock_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a FLOCK-style lock to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode of the file to apply to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The lock to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a FLOCK style lock request to an inode.</p>
</div>
<dl class="function">
<dt id="c.sys_flock">
long <code class="sig-name descname">sys_flock</code><span class="sig-paren">(</span>unsigned int<em> fd</em>, unsigned int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_flock" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>flock() system call.</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>the file descriptor to lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>the type of lock to apply.</p>
<p>Apply a <code class="docutils literal notranslate"><span class="pre">FL_FLOCK</span></code> style lock to an open file descriptor.
The <strong>cmd</strong> can be one of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LOCK_SH</span></code> – a shared lock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOCK_EX</span></code> – an exclusive lock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOCK_UN</span></code> – remove an existing lock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LOCK_MAND</span></code> – a ‘mandatory’ flock. (DEPRECATED)</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">LOCK_MAND</span></code> support has been removed from the kernel.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.locks_translate_pid">
pid_t <code class="sig-name descname">locks_translate_pid</code><span class="sig-paren">(</span>struct file_lock<em> *fl</em>, struct pid_namespace<em> *ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_translate_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>translate a file_lock’s fl_pid number into a namespace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*fl</span></code></dt><dd><p>The file_lock who’s fl_pid should be translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>The namespace into which the pid should be translated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to tranlate a fl_pid into a namespace virtual pid number</p>
</div>
</section>
<section id="other-functions">
<h3>Other Functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.mpage_readahead">
void <code class="sig-name descname">mpage_readahead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.readahead_control" title="readahead_control">readahead_control</a><em> *rac</em>, get_block_t<em> get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>start reads against pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>Describes which pages to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt><dd><p>The filesystem’s block mapper function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the pages and the blocks within each page, building and
emitting large BIOs.</p>
<p>If anything unusual happens, such as:</p>
<ul class="simple">
<li><p>encountering a page which has buffers</p></li>
<li><p>encountering a page which has a non-hole after a hole</p></li>
<li><p>encountering a page with non-contiguous blocks</p></li>
</ul>
<p>then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_SIZE setups.</p>
<p>BH_Boundary explanation:</p>
<p>There is a problem.  The mpage read code assembles several pages, gets all
their disk mappings, and then submits them all.  That’s fine, but obtaining
the disk mappings may require I/O.  Reads of indirect blocks, for example.</p>
<p>So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
submitted in the following order:</p>
<blockquote>
<div><p>12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16</p>
</div></blockquote>
<p>because the indirect block has to be read to get the mappings of blocks
13,14,15,16.  Obviously, this impacts performance.</p>
<p>So what we do it to allow the filesystem’s get_block() function to set
BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block
after this one will require I/O against a block which is probably close to
this one.  So you should push what I/O you have currently accumulated.</p>
<p>This all causes the disk requests to be issued in the correct order.</p>
</div>
<dl class="function">
<dt id="c.mpage_writepages">
int <code class="sig-name descname">mpage_writepages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a><em> *mapping</em>, struct writeback_control<em> *wbc</em>, get_block_t<em> get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space &amp; writepage() all of them</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>subtract the number of written pages from <strong>*wbc-&gt;nr_to_write</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt><dd><p>the filesystem’s block mapper function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the writepages()
address_space_operation.</p>
<p>If a page is already under I/O, <a class="reference internal" href="../core-api/mm-api.html#c.generic_writepages" title="generic_writepages"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_writepages()</span></code></a> skips it, even
if it’s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
and msync() need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
</div>
<dl class="function">
<dt id="c.generic_permission">
int <code class="sig-name descname">generic_permission</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>check for access rights on a Posix-like filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to check access rights for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>right to check for (<code class="docutils literal notranslate"><span class="pre">MAY_READ</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_EXEC</span></code>,
<code class="docutils literal notranslate"><span class="pre">MAY_NOT_BLOCK</span></code> …)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to check for read/write/execute permissions on a file.
We use “fsuid” for this, letting us set arbitrary permissions
for filesystem access without changing the “normal” uids which
are used for other things.</p>
<p>generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
request cannot be satisfied (eg. requires blocking or too much complexity).
It would then be called again in ref-walk mode.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.inode_permission">
int <code class="sig-name descname">inode_permission</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for access rights to a given inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>User namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>Inode to check permission on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Right to check for (<code class="docutils literal notranslate"><span class="pre">MAY_READ</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_EXEC</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for read/write/execute permissions on an inode.  We use fs[ug]id for
this, letting us set arbitrary permissions for filesystem access without
changing the “normal” UIDs which are used for other things.</p>
<p>When checking for MAY_APPEND, MAY_WRITE must also be set in <strong>mask</strong>.</p>
</div>
<dl class="function">
<dt id="c.path_get">
void <code class="sig-name descname">path_get</code><span class="sig-paren">(</span>const struct path<em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a path</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>path to get the reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path increment the reference count to the dentry and the vfsmount.</p>
</div>
<dl class="function">
<dt id="c.path_put">
void <code class="sig-name descname">path_put</code><span class="sig-paren">(</span>const struct path<em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a path</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>path to put the reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path decrement the reference count to the dentry and the vfsmount.</p>
</div>
<dl class="function">
<dt id="c.vfs_path_lookup">
int <code class="sig-name descname">vfs_path_lookup</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, struct vfsmount<em> *mnt</em>, const char<em> *name</em>, unsigned int<em> flags</em>, struct path<em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_path_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a file path relative to a dentry-vfsmount pair</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>pointer to vfs mount of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pointer to file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>lookup flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>pointer to struct path to fill</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.try_lookup_one_len">
struct dentry * <code class="sig-name descname">try_lookup_one_len</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_lookup_one_len" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up a dentry by name in the dcache, returning NULL if it does not
currently exist.  The function does not try to create a dentry.</p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
</div>
<dl class="function">
<dt id="c.lookup_one_len">
struct dentry * <code class="sig-name descname">lookup_one_len</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
</div>
<dl class="function">
<dt id="c.lookup_one">
struct dentry * <code class="sig-name descname">lookup_one</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the lookup is performed from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
</div>
<dl class="function">
<dt id="c.lookup_one_unlocked">
struct dentry * <code class="sig-name descname">lookup_one_unlocked</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>idmapping of the mount the lookup is performed from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>Unlike lookup_one_len, it should be called without the parent
i_mutex held, and will take the i_mutex itself if necessary.</p>
</div>
<dl class="function">
<dt id="c.lookup_one_positive_unlocked">
struct dentry * <code class="sig-name descname">lookup_one_positive_unlocked</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_positive_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>idmapping of the mount the lookup is performed from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns
known positive or ERR_PTR(). This is what most of the users want.</p>
<p>Note that pinned negative with unlocked parent _can_ become positive at any
time, so callers of <a class="reference internal" href="#c.lookup_one_unlocked" title="lookup_one_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_one_unlocked()</span></code></a> need to be very careful; pinned
positives have &gt;d_inode stable, so this one avoids such problems.</p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The helper should be called without i_mutex held.</p>
</div>
<dl class="function">
<dt id="c.lookup_one_len_unlocked">
struct dentry * <code class="sig-name descname">lookup_one_len_unlocked</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *base</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pathname component to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*base</span></code></dt><dd><p>base directory to lookup from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum length <strong>len</strong> should be interpreted to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>Unlike lookup_one_len, it should be called without the parent
i_mutex held, and will take the i_mutex itself if necessary.</p>
</div>
<dl class="function">
<dt id="c.vfs_create">
int <code class="sig-name descname">vfs_create</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em>, umode_t<em> mode</em>, bool<em> want_excl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create new file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>inode of <strong>dentry</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">want_excl</span></code></dt><dd><p>whether the file must not yet exist</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new file.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_tmpfile_open">
struct file * <code class="sig-name descname">vfs_tmpfile_open</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, const struct path<em> *parentpath</em>, umode_t<em> mode</em>, int<em> open_flag</em>, const struct cred<em> *cred</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_tmpfile_open" title="Permalink to this definition">¶</a></dt>
<dd><p>open a tmpfile for kernel internal use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*parentpath</span></code></dt><dd><p>path of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the new tmpfile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">open_flag</span></code></dt><dd><p>flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials for open</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and open a temporary file.  The file is not accounted in nr_files,
hence this is only for kernel internal use, and must not be installed into
file tables or such.</p>
</div>
<dl class="function">
<dt id="c.vfs_mknod">
int <code class="sig-name descname">vfs_mknod</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em>, umode_t<em> mode</em>, dev_t<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_mknod" title="Permalink to this definition">¶</a></dt>
<dd><p>create device node or file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>inode of <strong>dentry</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the new device node or file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>device number of device to create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a device node or file.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_mkdir">
int <code class="sig-name descname">vfs_mkdir</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_mkdir" title="Permalink to this definition">¶</a></dt>
<dd><p>create directory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>inode of <strong>dentry</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode of the new directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a directory.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_rmdir">
int <code class="sig-name descname">vfs_rmdir</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_rmdir" title="Permalink to this definition">¶</a></dt>
<dd><p>remove directory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>inode of <strong>dentry</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a directory.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_unlink">
int <code class="sig-name descname">vfs_unlink</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em>, struct inode<em> **delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink a filesystem object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>victim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**delegated_inode</span></code></dt><dd><p>returns victim inode, if the inode is delegated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex.</p>
<p>If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
return a reference to the inode in delegated_inode.  The caller
should then break the delegation on that inode and retry.  Because
breaking a delegation may take a long time, the caller should drop
dir-&gt;i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_symlink">
int <code class="sig-name descname">vfs_symlink</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *dentry</em>, const char<em> *oldname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>inode of <strong>dentry</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>pointer to dentry of the base directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*oldname</span></code></dt><dd><p>name of the file to link to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a symlink.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_link">
int <code class="sig-name descname">vfs_link</code><span class="sig-paren">(</span>struct dentry<em> *old_dentry</em>, struct user_namespace<em> *mnt_userns</em>, struct inode<em> *dir</em>, struct dentry<em> *new_dentry</em>, struct inode<em> **delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new link</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>object to be linked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>the user namespace of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>new parent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dentry</span></code></dt><dd><p>where to create the new link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**delegated_inode</span></code></dt><dd><p>returns inode needing a delegation break</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex</p>
<p>If vfs_link discovers a delegation on the to-be-linked file in need
of breaking, it will return -EWOULDBLOCK and return a reference to the
inode in delegated_inode.  The caller should then break the delegation
and retry.  Because breaking a delegation may take a long time, the
caller should drop the i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then take
care to map the inode according to <strong>mnt_userns</strong> before checking permissions.
On non-idmapped mounts or if permission checking is to be performed on the
raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.vfs_rename">
int <code class="sig-name descname">vfs_rename</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.renamedata" title="renamedata">renamedata</a><em> *rd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a filesystem object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">renamedata</span> <span class="pre">*rd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.renamedata" title="renamedata"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">renamedata</span></code></a> info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold multiple mutexes–see lock_rename()).</p>
<p>If vfs_rename discovers a delegation in need of breaking at either
the source or destination, it will return -EWOULDBLOCK and return a
reference to the inode in delegated_inode.  The caller should then
break the delegation and retry.  Because breaking a delegation may
take a long time, the caller should drop all locks before doing
so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<p>The worst of all namespace operations - renaming directory. “Perverted”
doesn’t even start to describe it. Somebody in UCB had a heck of a trip…
Problems:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>we can get into loop creation.</p></li>
<li><p>race potential - two innocent renames can create a loop together.
That’s where 4.4 screws up. Current fix: serialization on
sb-&gt;s_vfs_rename_mutex. We might be more accurate, but that’s another
story.</p></li>
<li><p>we have to lock _four_ objects - parents and victim (if it exists),
and source (if it is not a directory).
And that - after we got -&gt;i_mutex on parents (until then we don’t know
whether the target exists).  Solution: try to be smart with locking
order for inodes.  We rely on the fact that tree topology may change
only under -&gt;s_vfs_rename_mutex _and_ that parent of the object we
move will be locked.  Thus we can rank directories by the tree
(ancestors first) and rank all non-directories after them.
That works since everybody except rename does “lock parent, lookup,
lock child” and rename is under -&gt;s_vfs_rename_mutex.
HOWEVER, it relies on the assumption that any object with -&gt;lookup()
has no more than 1 dentry.  If “hybrid” objects will ever appear,
we’d better make sure that there’s no link(2) for them.</p></li>
<li><p>conversion from fhandle to dentry may come in the wrong moment - when
we are removing the target. Solution: we will have to grab -&gt;i_mutex
in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
-&gt;i_mutex on parents, which works but leads to some truly excessive
locking].</p></li>
</ol>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.vfs_readlink">
int <code class="sig-name descname">vfs_readlink</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, char __user<em> *buffer</em>, int<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>copy symlink body into userspace buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry on which to get symbolic link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buffer</span></code></dt><dd><p>user memory pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Does not touch atime.  That’s up to the caller if necessary</p>
<p>Does not call security hook.</p>
</div>
<dl class="function">
<dt id="c.vfs_get_link">
const char * <code class="sig-name descname">vfs_get_link</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, struct delayed_call<em> *done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_link" title="Permalink to this definition">¶</a></dt>
<dd><p>get symlink body</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry on which to get symbolic link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span> <span class="pre">*done</span></code></dt><dd><p>caller needs to free returned data with this</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls security hook and i_op-&gt;get_link() on the supplied inode.</p>
<p>It does not touch atime.  That’s up to the caller if necessary.</p>
<p>Does not work on “special” symlinks like /proc/$$/fd/N</p>
</div>
<dl class="function">
<dt id="c.sync_mapping_buffers">
int <code class="sig-name descname">sync_mapping_buffers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a><em> *mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_mapping_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait upon a mapping’s “associated” buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the mapping which wants those buffers written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts I/O against the buffers at mapping-&gt;private_list, and waits upon
that I/O.</p>
<p>Basically, this is a convenience function for fsync().
<strong>mapping</strong> is a file or directory which needs those buffers to be written for
a successful fsync().</p>
</div>
<dl class="function">
<dt id="c.mark_buffer_dirty">
void <code class="sig-name descname">mark_buffer_dirty</code><span class="sig-paren">(</span>struct buffer_head<em> *bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_buffer_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a buffer_head as needing writeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>the buffer_head to mark dirty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> will set the dirty bit against the buffer, then set
its backing page dirty, then tag the page as dirty in the page cache
and then attach the address_space’s inode to its superblock’s dirty
inode list.</p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,
i_pages lock and mapping-&gt;host-&gt;i_lock.</p>
</div>
<dl class="function">
<dt id="c.__bread_gfp">
struct buffer_head * <code class="sig-name descname">__bread_gfp</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, sector_t<em> block</em>, unsigned<em> size</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bread_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>reads a specified block and returns the bh</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the block_device to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>number of block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt><dd><p>size (in bytes) to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>page allocation flag</p>
<p>Reads a specified block, and returns buffer head that contains it.
The page cache can be allocated from non-movable area
not to prevent page migration if you set gfp to zero.
It returns NULL if the block was unreadable.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.block_invalidate_folio">
void <code class="sig-name descname">block_invalidate_folio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em>, size_t<em> offset</em>, size_t<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.block_invalidate_folio" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate part or all of a buffer-backed folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which is affected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>start of the range to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of the range to invalidate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.block_invalidate_folio" title="block_invalidate_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidate_folio()</span></code></a> is called when all or part of the folio has been
invalidated by a truncate operation.</p>
<p><a class="reference internal" href="#c.block_invalidate_folio" title="block_invalidate_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidate_folio()</span></code></a> does not have to release all buffers, but it must
ensure that no dirty buffer is left outside <strong>offset</strong> and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.</p>
</div>
<dl class="function">
<dt id="c.clean_bdev_aliases">
void <code class="sig-name descname">clean_bdev_aliases</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, sector_t<em> block</em>, sector_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_bdev_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>clean a range of buffers in block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>Block device to clean buffers in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>Start of a range of blocks to clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">len</span></code></dt><dd><p>Number of blocks to clean</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We are taking a range of blocks for data and we don’t want writeback of any
buffer-cache aliases starting from return from this function and until the
moment when something will explicitly mark the buffer dirty (hopefully that
will not happen until we will free that block ;-) We don’t even need to mark
it not-uptodate - nobody can expect anything from a newly allocated buffer
anyway. We used to use unmap_buffer() for such invalidation, but that was
wrong. We definitely don’t want to mark the alias unmapped, for example - it
would confuse anyone who might pick it with bread() afterwards…</p>
<p>Also..  Note that bforget() doesn’t lock the buffer.  So there can be
writeout I/O going on against recently-freed buffers.  We don’t wait on that
I/O in bforget() - it’s more efficient to wait on the I/O only if we really
need to.  That happens here.</p>
</div>
<dl class="function">
<dt id="c.bh_uptodate_or_lock">
int <code class="sig-name descname">bh_uptodate_or_lock</code><span class="sig-paren">(</span>struct buffer_head<em> *bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_uptodate_or_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the buffer is uptodate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>struct buffer_head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the buffer is up-to-date and false,
with the buffer locked, if not.</p>
</div>
<dl class="function">
<dt id="c.__bh_read">
int <code class="sig-name descname">__bh_read</code><span class="sig-paren">(</span>struct buffer_head<em> *bh</em>, blk_opf_t<em> op_flags</em>, bool<em> wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bh_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit read for a locked buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>struct buffer_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">op_flags</span></code></dt><dd><p>appending REQ_OP_* flags besides REQ_OP_READ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait</span></code></dt><dd><p>wait until reading finish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success or don’t wait, and -EIO on error.</p>
</div>
<dl class="function">
<dt id="c.__bh_read_batch">
void <code class="sig-name descname">__bh_read_batch</code><span class="sig-paren">(</span>int<em> nr</em>, struct buffer_head<em> *bhs[]</em>, blk_opf_t<em> op_flags</em>, bool<em> force_lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bh_read_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit read for a batch of unlocked buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>entry number of the buffer batch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bhs[]</span></code></dt><dd><p>a batch of struct buffer_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">op_flags</span></code></dt><dd><p>appending REQ_OP_* flags besides REQ_OP_READ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_lock</span></code></dt><dd><p>force to get a lock on the buffer if set, otherwise drops any
buffer that cannot lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success or don’t wait, and -EIO on error.</p>
</div>
<dl class="function">
<dt id="c.bio_reset">
void <code class="sig-name descname">bio_reset</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct block_device<em> *bdev</em>, blk_opf_t<em> opf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reinitialize a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device to use the bio for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">opf</span></code></dt><dd><p>operation and flags for bio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After calling <a class="reference internal" href="#c.bio_reset" title="bio_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_reset()</span></code></a>, <strong>bio</strong> will be in the same state as a freshly
allocated bio returned bio <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_alloc_bioset()</span></code></a> - the only fields that are
preserved are the ones that are initialized by <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_alloc_bioset()</span></code></a>. See
comment in struct bio.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.bio_chain">
void <code class="sig-name descname">bio_chain</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct bio<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>chain bio completions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>the target bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*parent</span></code></dt><dd><p>the parent bio of <strong>bio</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller won’t have a bi_end_io called when <strong>bio</strong> completes - instead,
<strong>parent</strong>’s bi_end_io won’t be called until both <strong>parent</strong> and <strong>bio</strong> have
completed; the chained bio will also be freed when it completes.</p>
<p>The caller must not set bi_private or bi_end_io in <strong>bio</strong>.</p>
</div>
<dl class="function">
<dt id="c.bio_alloc_bioset">
struct bio * <code class="sig-name descname">bio_alloc_bioset</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, unsigned short<em> nr_vecs</em>, blk_opf_t<em> opf</em>, gfp_t<em> gfp_mask</em>, struct bio_set<em> *bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_alloc_bioset" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a bio for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device to allocate the bio for (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">nr_vecs</span></code></dt><dd><p>number of bvecs to pre-allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">opf</span></code></dt><dd><p>operation and flags for bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the GFP_* mask given to the slab allocator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*bs</span></code></dt><dd><p>the bio_set to allocate from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a bio from the mempools in <strong>bs</strong>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> is set then bio_alloc will always be able to
allocate a bio.  This is due to the mempool guarantees.  To make this work,
callers must never allocate more than 1 bio at a time from the general pool.
Callers that need to allocate more than 1 bio must always submit the
previously allocated bio for IO before attempting to allocate a new one.
Failure to do so can cause deadlocks under memory pressure.</p>
<p>Note that when running under <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio_noacct" title="submit_bio_noacct"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio_noacct()</span></code></a> (i.e. any block driver),
bios are not submitted until after you return - see the code in
<a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio_noacct" title="submit_bio_noacct"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio_noacct()</span></code></a> that converts recursion into iteration, to prevent
stack overflows.</p>
<p>This would normally mean allocating multiple bios under <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio_noacct" title="submit_bio_noacct"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio_noacct()</span></code></a>
would be susceptible to deadlocks, but we have
deadlock avoidance code that resubmits any blocked bios from a rescuer
thread.</p>
<p>However, we do not guarantee forward progress for allocations from other
mempools. Doing multiple allocations from the same mempool under
<a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio_noacct" title="submit_bio_noacct"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio_noacct()</span></code></a> should be avoided - instead, use bio_set’s front_pad
for per bio allocations.</p>
<p><strong>Return</strong></p>
<p>Pointer to new bio on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.bio_kmalloc">
struct bio * <code class="sig-name descname">bio_kmalloc</code><span class="sig-paren">(</span>unsigned short<em> nr_vecs</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>kmalloc a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">nr_vecs</span></code></dt><dd><p>number of bio_vecs to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the GFP_* mask given to the slab allocator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use kmalloc to allocate a bio (including bvecs).  The bio must be initialized
using bio_init() before use.  To free a bio returned from this function use
<a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> after calling bio_uninit().  A bio returned from this function can
be reused by calling bio_uninit() before calling bio_init() again.</p>
<p>Note that unlike bio_alloc() or <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_alloc_bioset()</span></code></a> allocations from this
function are not backed by a mempool can fail.  Do not use this function
for allocations in the file system I/O path.</p>
<p><strong>Return</strong></p>
<p>Pointer to new bio on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.bio_put">
void <code class="sig-name descname">bio_put</code><span class="sig-paren">(</span>struct bio<em> *bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to release reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Put a reference to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>, either one you have gotten with
bio_alloc, bio_get or bio_clone_*. The last put of a bio will free it.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.bio_alloc_clone">
struct bio * <code class="sig-name descname">bio_alloc_clone</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, struct bio<em> *bio_src</em>, gfp_t<em> gfp</em>, struct bio_set<em> *bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_alloc_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block_device to clone onto</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio_src</span></code></dt><dd><p>bio to clone from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*bs</span></code></dt><dd><p>bio_set to allocate from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new bio that is a clone of <strong>bio_src</strong>. The caller owns the returned
bio, but not the actual data it points to.</p>
<p>The caller must ensure that the return bio is not freed before <strong>bio_src</strong>.</p>
</div>
<dl class="function">
<dt id="c.bio_init_clone">
int <code class="sig-name descname">bio_init_clone</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, struct bio<em> *bio</em>, struct bio<em> *bio_src</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_init_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block_device to clone onto</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to clone into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio_src</span></code></dt><dd><p>bio to clone from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new bio in caller provided memory that is a clone of <strong>bio_src</strong>.
The caller owns the returned bio, but not the actual data it points to.</p>
<p>The caller must ensure that <strong>bio_src</strong> is not freed before <strong>bio</strong>.</p>
</div>
<dl class="function">
<dt id="c.bio_add_pc_page">
int <code class="sig-name descname">bio_add_pc_page</code><span class="sig-paren">(</span>struct request_queue<em> *q</em>, struct bio<em> *bio</em>, struct page<em> *page</em>, unsigned int<em> len</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_pc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page to passthrough bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the target queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>destination bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>vec entry length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>vec entry offset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to add a page to the bio_vec maplist. This can fail for a
number of reasons, such as the bio being full or target block device
limitations. The target block device must allow bio’s up to PAGE_SIZE,
so it is always possible to add a single page to an empty bio.</p>
<p>This should only be used by passthrough bios.</p>
</div>
<dl class="function">
<dt id="c.bio_add_zone_append_page">
int <code class="sig-name descname">bio_add_zone_append_page</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct page<em> *page</em>, unsigned int<em> len</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_zone_append_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page to zone-append bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>destination bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>vec entry length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>vec entry offset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to add a page to the bio_vec maplist of a bio that will be submitted
for a zone-append request. This can fail for a number of reasons, such as the
bio being full or the target block device is not a zoned block device or
other limitations of the target block device. The target block device must
allow bio’s up to PAGE_SIZE, so it is always possible to add a single page
to an empty bio.</p>
<p><strong>Return</strong></p>
<p>number of bytes added to the bio, or 0 in case of a failure.</p>
</div>
<dl class="function">
<dt id="c.__bio_add_page">
void <code class="sig-name descname">__bio_add_page</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct page<em> *page</em>, unsigned int<em> len</em>, unsigned int<em> off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bio_add_page" title="Permalink to this definition">¶</a></dt>
<dd><p>add page(s) to a bio in a new segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>destination bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>start page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the data to add, may cross pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>offset of the data relative to <strong>page</strong>, may cross pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the data at <strong>page</strong> + <strong>off</strong> to <strong>bio</strong> as a new bvec.  The caller must ensure
that <strong>bio</strong> has space for another bvec.</p>
</div>
<dl class="function">
<dt id="c.bio_add_page">
int <code class="sig-name descname">bio_add_page</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct page<em> *page</em>, unsigned int<em> len</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page(s) to bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>destination bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>start page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>vec entry length, may cross pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>vec entry offset relative to <strong>page</strong>, may cross pages</p>
<p>Attempt to add page(s) to the bio_vec maplist. This will only fail
if either bio-&gt;bi_vcnt == bio-&gt;bi_max_vecs or it’s a cloned bio.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.bio_iov_iter_get_pages">
int <code class="sig-name descname">bio_iov_iter_get_pages</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, struct iov_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_iov_iter_get_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>add user or kernel pages to a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to add pages to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>iov iterator describing the region to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This takes either an iterator pointing to user memory, or one pointing to
kernel pages (BVEC iterator). If we’re adding user pages, we pin them and
map them into the kernel. On IO completion, the caller should put those
pages. For bvec based iterators <a class="reference internal" href="#c.bio_iov_iter_get_pages" title="bio_iov_iter_get_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_iov_iter_get_pages()</span></code></a> uses the provided
bvecs rather than copying them. Hence anyone issuing kiocb based IO needs
to ensure the bvecs and pages stay referenced until the submitted I/O is
completed by a call to -&gt;ki_complete() or returns with an error other than
-EIOCBQUEUED. The caller needs to check if the bio is flagged BIO_NO_PAGE_REF
on IO completion. If it isn’t, then pages should be released.</p>
<p>The function tries, but does not guarantee, to pin as many pages as
fit into the bio, or are requested in <strong>iter</strong>, whatever is smaller. If
MM encounters an error pinning the requested pages, it stops. Error
is returned only if 0 pages could be pinned.</p>
</div>
<dl class="function">
<dt id="c.submit_bio_wait">
int <code class="sig-name descname">submit_bio_wait</code><span class="sig-paren">(</span>struct bio<em> *bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio, and wait until it completes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple wrapper around <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a>. Returns 0 on success, or the error from
<a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> on failure.</p>
<p>WARNING: Unlike to how <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> is usually used, this function does not
result in bio reference to be consumed. The caller must drop the reference
on his own.</p>
</div>
<dl class="function">
<dt id="c.bio_copy_data">
void <code class="sig-name descname">bio_copy_data</code><span class="sig-paren">(</span>struct bio<em> *dst</em>, struct bio<em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_copy_data" title="Permalink to this definition">¶</a></dt>
<dd><p>copy contents of data buffers from one bio to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*dst</span></code></dt><dd><p>destination bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*src</span></code></dt><dd><p>source bio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops when it reaches the end of either <strong>src</strong> or <strong>dst</strong> - that is, copies
min(src-&gt;bi_size, dst-&gt;bi_size) bytes (or the equivalent for lists of bios).</p>
</div>
<dl class="function">
<dt id="c.bio_endio">
void <code class="sig-name descname">bio_endio</code><span class="sig-paren">(</span>struct bio<em> *bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_endio" title="Permalink to this definition">¶</a></dt>
<dd><p>end I/O on a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> will end I/O on the whole bio. <a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> is the preferred
way to end I/O on a bio. No one should call bi_end_io() directly on a
bio unless they own it and thus know that it has an end_io function.</p>
<p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> can be called several times on a bio that has been chained
using <a class="reference internal" href="#c.bio_chain" title="bio_chain"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_chain()</span></code></a>.  The -&gt;bi_end_io() function will only be called the
last time.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.bio_split">
struct bio * <code class="sig-name descname">bio_split</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, int<em> sectors</em>, gfp_t<em> gfp</em>, struct bio_set<em> *bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_split" title="Permalink to this definition">¶</a></dt>
<dd><p>split a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to split</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sectors</span></code></dt><dd><p>number of sectors to split from the front of <strong>bio</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*bs</span></code></dt><dd><p>bio set to allocate from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a new bio which represents <strong>sectors</strong> from the start of
<strong>bio</strong>, and updates <strong>bio</strong> to represent the remaining sectors.</p>
<p>Unless this is a discard request the newly allocated bio will point
to <strong>bio</strong>’s bi_io_vec. It is the caller’s responsibility to ensure that
neither <strong>bio</strong> nor <strong>bs</strong> are freed before the split bio.</p>
</div>
<dl class="function">
<dt id="c.bio_trim">
void <code class="sig-name descname">bio_trim</code><span class="sig-paren">(</span>struct bio<em> *bio</em>, sector_t<em> offset</em>, sector_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>trim a bio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to trim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt><dd><p>number of sectors to trim from the front of <strong>bio</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">size</span></code></dt><dd><p>size we want to trim <strong>bio</strong> to, in sectors</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is typically used for bios that are cloned and submitted
to the underlying device in parts.</p>
</div>
<dl class="function">
<dt id="c.bioset_init">
int <code class="sig-name descname">bioset_init</code><span class="sig-paren">(</span>struct bio_set<em> *bs</em>, unsigned int<em> pool_size</em>, unsigned int<em> front_pad</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bioset_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bio_set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*bs</span></code></dt><dd><p>pool to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pool_size</span></code></dt><dd><p>Number of bio and bio_vecs to cache in the mempool</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">front_pad</span></code></dt><dd><p>Number of bytes to allocate in front of the returned bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Flags to modify behavior, currently <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_BVECS</span></code>
and <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_RESCUER</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set up a bio_set to be used with <strong>bio_alloc_bioset</strong>. Allows the caller
to ask for a number of bytes to be allocated in front of the bio.
Front pad allocation is useful for embedding the bio inside
another structure, to avoid allocating extra data to go with the bio.
Note that the bio must be embedded at the END of that structure always,
or things will break badly.
If <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_BVECS</span></code> is set in <strong>flags</strong>, a separate pool will be allocated
for allocating iovecs.  This pool is not needed e.g. for <a class="reference internal" href="#c.bio_init_clone" title="bio_init_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_init_clone()</span></code></a>.
If <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_RESCUER</span></code> is set, a workqueue is created which can be used
to dispatch queued requests when the mempool runs out of space.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.seq_open">
int <code class="sig-name descname">seq_open</code><span class="sig-paren">(</span>struct file<em> *file</em>, const struct seq_operations<em> *op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize sequential file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file we initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">seq_operations</span> <span class="pre">*op</span></code></dt><dd><p>method table describing the sequence</p>
<p><a class="reference internal" href="#c.seq_open" title="seq_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">seq_open()</span></code></a> sets <strong>file</strong>, associating it with a sequence described
by <strong>op</strong>.  <strong>op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a></strong> sets the iterator up and returns the first
element of sequence. <strong>op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a></strong> shuts it down.  <strong>op-&gt;next()</strong>
returns the next element of sequence.  <strong>op-&gt;show()</strong> prints element
into the buffer.  In case of error -&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> and -&gt;next() return
ERR_PTR(error).  In the end of sequence they return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. -&gt;show()
returns 0 in case of success and negative number in case of error.
Returning SEQ_SKIP means “discard this element and move on”.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>seq_open() will allocate a struct seq_file and store its</dt><dd><p>pointer in <strong>file-&gt;private_data</strong>. This pointer should not be modified.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_read">
ssize_t <code class="sig-name descname">seq_read</code><span class="sig-paren">(</span>struct file<em> *file</em>, char __user<em> *buf</em>, size_t<em> size</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;read() method for sequential files.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to read to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the maximum number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position in the file</p>
<p>Ready-made -&gt;f_op-&gt;read()</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_lseek">
loff_t <code class="sig-name descname">seq_lseek</code><span class="sig-paren">(</span>struct file<em> *file</em>, loff_t<em> offset</em>, int<em> whence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_lseek" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;llseek() method for sequential files.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>new position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">whence</span></code></dt><dd><p>0 for absolute, 1 for relative position</p>
<p>Ready-made -&gt;f_op-&gt;llseek()</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_release">
int <code class="sig-name descname">seq_release</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_release" title="Permalink to this definition">¶</a></dt>
<dd><p>free the structures associated with sequential file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>its inode</p>
<p>Frees the structures associated with sequential file; can be used
as -&gt;f_op-&gt;release() if you don’t have private data to destroy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file in question</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_escape_mem">
void <code class="sig-name descname">seq_escape_mem</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, const char<em> *src</em>, size_t<em> len</em>, unsigned int<em> flags</em>, const char<em> *esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_escape_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>print data into buffer, escaping some characters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>target buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags to pass to <a class="reference internal" href="../core-api/kernel-api.html#c.string_escape_mem" title="string_escape_mem"><code class="xref c c-func docutils literal notranslate"><span class="pre">string_escape_mem()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*esc</span></code></dt><dd><p>set of characters that need escaping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Puts data into buffer, replacing each occurrence of character from
given class (defined by <strong>flags</strong> and <strong>esc</strong>) with printable escaped sequence.</p>
<p>Use seq_has_overflowed() to check for errors.</p>
</div>
<dl class="function">
<dt id="c.mangle_path">
char * <code class="sig-name descname">mangle_path</code><span class="sig-paren">(</span>char<em> *s</em>, const char<em> *p</em>, const char<em> *esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mangle_path" title="Permalink to this definition">¶</a></dt>
<dd><p>mangle and copy path to buffer beginning</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>buffer start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*p</span></code></dt><dd><p>beginning of path in above buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*esc</span></code></dt><dd><p>set of characters that need escaping</p>
<p>Copy the path from <strong>p</strong> to <strong>s</strong>, replacing each occurrence of character from
<strong>esc</strong> with usual octal escape.
Returns pointer past last written character in <strong>s</strong>, or NULL in case of
failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_path">
int <code class="sig-name descname">seq_path</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, const struct path<em> *path</em>, const char<em> *esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>the seq_file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>the struct path to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*esc</span></code></dt><dd><p>set of characters to escape in the output</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path of ‘path’, as represented by the
dentry / mnt pair in the path parameter.</p>
</div>
<dl class="function">
<dt id="c.seq_file_path">
int <code class="sig-name descname">seq_file_path</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, struct file<em> *file</em>, const char<em> *esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname of a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>the seq_file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the struct file to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*esc</span></code></dt><dd><p>set of characters to escape in the output</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path to the file.</p>
</div>
<dl class="function">
<dt id="c.seq_write">
int <code class="sig-name descname">seq_write</code><span class="sig-paren">(</span>struct seq_file<em> *seq</em>, const void<em> *data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write arbitrary data to buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*seq</span></code></dt><dd><p>seq_file identifying the buffer to which data should be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, non-zero otherwise.</p>
</div>
<dl class="function">
<dt id="c.seq_pad">
void <code class="sig-name descname">seq_pad</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, char<em> c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>write padding spaces to buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>seq_file identifying the buffer to which data should be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">c</span></code></dt><dd><p>the byte to append after padding if non-zero</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.seq_hlist_start">
struct hlist_node * <code class="sig-name descname">seq_hlist_start</code><span class="sig-paren">(</span>struct hlist_head<em> *head</em>, loff_t<em> pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>the start position of the sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_start_head">
struct hlist_node * <code class="sig-name descname">seq_hlist_start_head</code><span class="sig-paren">(</span>struct hlist_head<em> *head</em>, loff_t<em> pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>the start position of the sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a>. Call this function if you want to
print a header at the top of the output.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_next">
struct hlist_node * <code class="sig-name descname">seq_hlist_next</code><span class="sig-paren">(</span>void<em> *v</em>, struct hlist_head<em> *head</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*v</span></code></dt><dd><p>the current iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_start_rcu">
struct hlist_node * <code class="sig-name descname">seq_hlist_start_rcu</code><span class="sig-paren">(</span>struct hlist_head<em> *head</em>, loff_t<em> pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>the start position of the sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a>.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_start_head_rcu">
struct hlist_node * <code class="sig-name descname">seq_hlist_start_head_rcu</code><span class="sig-paren">(</span>struct hlist_head<em> *head</em>, loff_t<em> pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>the start position of the sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a>. Call this function if you want to
print a header at the top of the output.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_next_rcu">
struct hlist_node * <code class="sig-name descname">seq_hlist_next_rcu</code><span class="sig-paren">(</span>void<em> *v</em>, struct hlist_head<em> *head</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist protected by RCU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*v</span></code></dt><dd><p>the current iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the hlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_start_percpu">
struct hlist_node * <code class="sig-name descname">seq_hlist_start_percpu</code><span class="sig-paren">(</span>struct hlist_head __percpu<em> *head</em>, int<em> *cpu</em>, loff_t<em> pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a percpu hlist array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*head</span></code></dt><dd><p>pointer to percpu array of struct hlist_heads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*cpu</span></code></dt><dd><p>pointer to cpu “cursor”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>start position of sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;<a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.seq_hlist_next_percpu">
struct hlist_node * <code class="sig-name descname">seq_hlist_next_percpu</code><span class="sig-paren">(</span>void<em> *v</em>, struct hlist_head __percpu<em> *head</em>, int<em> *cpu</em>, loff_t<em> *pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the percpu hlist array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*v</span></code></dt><dd><p>pointer to current hlist_node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*head</span></code></dt><dd><p>pointer to percpu array of struct hlist_heads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*cpu</span></code></dt><dd><p>pointer to cpu “cursor”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*pos</span></code></dt><dd><p>start position of sequence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
</div>
<dl class="function">
<dt id="c.register_filesystem">
int <code class="sig-name descname">register_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em> fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt><dd><p>the file system structure</p>
<p>Adds the file system passed to the list of file systems the kernel
is aware of for mount and other syscalls. Returns 0 on success,
or a negative errno code on an error.</p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> that is passed is linked into the kernel
structures and must not be freed until the file system has been
unregistered.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_filesystem">
int <code class="sig-name descname">unregister_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em> fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a file system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt><dd><p>filesystem to unregister</p>
<p>Remove a file system that was previously successfully registered
with the kernel. An error is returned if the file system is not found.
Zero is returned on a success.</p>
<p>Once this function has returned the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> structure
may be freed or reused.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.wbc_attach_and_unlock_inode">
void <code class="sig-name descname">wbc_attach_and_unlock_inode</code><span class="sig-paren">(</span>struct writeback_control<em> *wbc</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_attach_and_unlock_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>associate wbc with target inode and unlock it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>writeback_control of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>target inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>inode</strong> is locked and about to be written back under the control of <strong>wbc</strong>.
Record <strong>inode</strong>’s writeback context into <strong>wbc</strong> and unlock the i_lock.  On
writeback completion, <a class="reference internal" href="#c.wbc_detach_inode" title="wbc_detach_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_detach_inode()</span></code></a> should be called.  This is used
to track the cgroup writeback context.</p>
</div>
<dl class="function">
<dt id="c.wbc_detach_inode">
void <code class="sig-name descname">wbc_detach_inode</code><span class="sig-paren">(</span>struct writeback_control<em> *wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_detach_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>disassociate wbc from inode and perform foreign detection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>writeback_control of the just finished writeback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be called after a writeback attempt of an inode finishes and undoes
<a class="reference internal" href="#c.wbc_attach_and_unlock_inode" title="wbc_attach_and_unlock_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_attach_and_unlock_inode()</span></code></a>.  Can be called under any context.</p>
<p>As concurrent write sharing of an inode is expected to be very rare and
memcg only tracks page ownership on first-use basis severely confining
the usefulness of such sharing, cgroup writeback tracks ownership
per-inode.  While the support for concurrent write sharing of an inode
is deemed unnecessary, an inode being written to by different cgroups at
different points in time is a lot more common, and, more importantly,
charging only by first-use can too readily lead to grossly incorrect
behaviors (single foreign page can lead to gigabytes of writeback to be
incorrectly attributed).</p>
<p>To resolve this issue, cgroup writeback detects the majority dirtier of
an inode and transfers the ownership to it.  To avoid unnecessary
oscillation, the detection mechanism keeps track of history and gives
out the switch verdict only if the foreign usage pattern is stable over
a certain amount of time and/or writeback attempts.</p>
<p>On each writeback attempt, <strong>wbc</strong> tries to detect the majority writer
using Boyer-Moore majority vote algorithm.  In addition to the byte
count from the majority voting, it also counts the bytes written for the
current wb and the last round’s winner wb (max of last round’s current
wb, the winner from two rounds ago, and the last round’s majority
candidate).  Keeping track of the historical winner helps the algorithm
to semi-reliably detect the most active writer even when it’s not the
absolute majority.</p>
<p>Once the winner of the round is determined, whether the winner is
foreign or not and how much IO time the round consumed is recorded in
inode-&gt;i_wb_frn_history.  If the amount of recorded foreign IO time is
over a certain threshold, the switch verdict is given.</p>
</div>
<dl class="function">
<dt id="c.wbc_account_cgroup_owner">
void <code class="sig-name descname">wbc_account_cgroup_owner</code><span class="sig-paren">(</span>struct writeback_control<em> *wbc</em>, struct page<em> *page</em>, size_t<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_account_cgroup_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>account writeback to update inode cgroup ownership</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>writeback_control of the writeback in progress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page being written out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt><dd><p>number of bytes being written out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>bytes</strong> from <strong>page</strong> are about to written out during the writeback
controlled by <strong>wbc</strong>.  Keep the book for foreign inode detection.  See
<a class="reference internal" href="#c.wbc_detach_inode" title="wbc_detach_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_detach_inode()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.__mark_inode_dirty">
void <code class="sig-name descname">__mark_inode_dirty</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mark_inode_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>internal function to mark an inode dirty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to mark</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>what kind of dirty, e.g. I_DIRTY_SYNC.  This can be a combination of
multiple I_DIRTY_* flags, except that I_DIRTY_TIME can’t be combined
with I_DIRTY_PAGES.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an inode as dirty.  We notify the filesystem, then update the inode’s
dirty flags.  Then, if needed we add the inode to the appropriate dirty list.</p>
<p>Most callers should use mark_inode_dirty() or mark_inode_dirty_sync()
instead of calling this directly.</p>
<p>CAREFUL!  We only add the inode to the dirty list if it is hashed or if it
refers to a blockdev.  Unhashed inodes will never be added to the dirty list
even if they are later hashed, as they will have been marked dirty already.</p>
<p>In short, ensure you hash any inodes _before_ you start marking them dirty.</p>
<p>Note that for blockdevs, inode-&gt;dirtied_when represents the dirtying time of
the block-special inode (/dev/hda1) itself.  And the -&gt;dirtied_when field of
the kernel-internal blockdev inode represents the dirtying time of the
blockdev’s pages.  This is why for I_DIRTY_PAGES we always use
page-&gt;mapping-&gt;host, so the page-dirtying time is recorded in the internal
blockdev inode.</p>
</div>
<dl class="function">
<dt id="c.writeback_inodes_sb_nr">
void <code class="sig-name descname">writeback_inodes_sb_nr</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, unsigned long<em> nr</em>, enum wb_reason<em> reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the number of pages to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt><dd><p>reason why some writeback work initiated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
</div>
<dl class="function">
<dt id="c.writeback_inodes_sb">
void <code class="sig-name descname">writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, enum wb_reason<em> reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt><dd><p>reason why some writeback work was initiated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
</div>
<dl class="function">
<dt id="c.try_to_writeback_inodes_sb">
void <code class="sig-name descname">try_to_writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, enum wb_reason<em> reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>try to start writeback if none underway</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt><dd><p>reason why some writeback work was initiated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke __writeback_inodes_sb_nr if no writeback is currently underway.</p>
</div>
<dl class="function">
<dt id="c.sync_inodes_sb">
void <code class="sig-name descname">sync_inodes_sb</code><span class="sig-paren">(</span>struct super_block<em> *sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>sync sb inode pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes and waits on any dirty inode belonging to this
super_block.</p>
</div>
<dl class="function">
<dt id="c.write_inode_now">
int <code class="sig-name descname">write_inode_now</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, int<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_inode_now" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to write to disk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sync</span></code></dt><dd><p>whether the write should be synchronous or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits an inode to disk immediately if it is dirty. This is
primarily needed by knfsd.</p>
<p>The caller must either have a ref on the inode or must have set I_WILL_FREE.</p>
</div>
<dl class="function">
<dt id="c.sync_inode_metadata">
int <code class="sig-name descname">sync_inode_metadata</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, int<em> wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inode_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">wait</span></code></dt><dd><p>wait for I/O to complete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write an inode to disk and adjust its dirty state after completion.</p>
<p><strong>Note</strong></p>
<p>only writes the actual inode, no associated data or other metadata.</p>
</div>
<dl class="function">
<dt id="c.anon_inode_getfile">
struct file * <code class="sig-name descname">anon_inode_getfile</code><span class="sig-paren">(</span>const char<em> *name</em>, const struct file_operations<em> *fops</em>, void<em> *priv</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_inode_getfile" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new file instance by hooking it up to an anonymous inode, and a dentry that describe the “class” of the file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>[in]    name of the “class” of the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>[in]    file operations for the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>[in]    private data for the new file (will be file’s private_data)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>[in]    flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new file by hooking it on a single inode. This is useful for files
that do not need to have a full-fledged inode in order to operate correctly.
All the files created with <a class="reference internal" href="#c.anon_inode_getfile" title="anon_inode_getfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">anon_inode_getfile()</span></code></a> will share a single inode,
hence saving memory and avoiding code duplication for the file/inode/dentry
setup.  Returns the newly created file* or an error pointer.</p>
</div>
<dl class="function">
<dt id="c.anon_inode_getfd">
int <code class="sig-name descname">anon_inode_getfd</code><span class="sig-paren">(</span>const char<em> *name</em>, const struct file_operations<em> *fops</em>, void<em> *priv</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_inode_getfd" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new file instance by hooking it up to an anonymous inode and a dentry that describe the “class” of the file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>[in]    name of the “class” of the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>[in]    file operations for the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>[in]    private data for the new file (will be file’s private_data)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>[in]    flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new file by hooking it on a single inode. This is
useful for files that do not need to have a full-fledged inode in
order to operate correctly.  All the files created with
<a class="reference internal" href="#c.anon_inode_getfd" title="anon_inode_getfd"><code class="xref c c-func docutils literal notranslate"><span class="pre">anon_inode_getfd()</span></code></a> will use the same singleton inode, reducing
memory use and avoiding code duplication for the file/inode/dentry
setup.  Returns a newly created file descriptor or an error code.</p>
</div>
<dl class="function">
<dt id="c.anon_inode_getfd_secure">
int <code class="sig-name descname">anon_inode_getfd_secure</code><span class="sig-paren">(</span>const char<em> *name</em>, const struct file_operations<em> *fops</em>, void<em> *priv</em>, int<em> flags</em>, const struct inode<em> *context_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_inode_getfd_secure" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#c.anon_inode_getfd" title="anon_inode_getfd"><code class="xref c c-func docutils literal notranslate"><span class="pre">anon_inode_getfd()</span></code></a>, but creates a new !S_PRIVATE anon inode rather than reuse the singleton anon inode, and calls the inode_init_security_anon() LSM hook. This allows the inode to have its own security context and for a LSM to reject creation of the inode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>[in]    name of the “class” of the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>[in]    file operations for the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>[in]    private data for the new file (will be file’s private_data)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>[in]    flags</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*context_inode</span></code></p>
<blockquote>
<div><p>[in]    the logical relationship with the new inode (optional)</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>The LSM may use <strong>context_inode</strong> in inode_init_security_anon(), but a
reference to it is not held.</p>
</div>
<dl class="function">
<dt id="c.setattr_should_drop_suidgid">
int <code class="sig-name descname">setattr_should_drop_suidgid</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattr_should_drop_suidgid" title="Permalink to this definition">¶</a></dt>
<dd><p>determine whether the set{g,u}id bit needs to be dropped</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount <strong>inode</strong> was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines whether the set{g,u}id bits need to be removed.
If the setuid bit needs to be removed ATTR_KILL_SUID is returned. If the
setgid bit needs to be removed ATTR_KILL_SGID is returned. If both
set{g,u}id bits need to be removed the corresponding mask of both flags is
returned.</p>
<p><strong>Return</strong></p>
<p>A mask of ATTR_KILL_S{G,U}ID indicating which - if any - setid bits
to remove, 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.setattr_prepare">
int <code class="sig-name descname">setattr_prepare</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, struct iattr<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattr_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>check if attribute changes to a dentry are allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>attributes to change</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if we are allowed to change the attributes contained in <strong>attr</strong>
in the given dentry.  This includes the normal unix access permission
checks, as well as checks for rlimits and others. The function also clears
SGID bit from mode if user is not allowed to set it. Also file capabilities
and IMA extended attributes are cleared if ATTR_KILL_PRIV is set.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before checking
permissions. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
<p>Should be called as the first thing in -&gt;setattr implementations,
possibly after taking additional locks.</p>
</div>
<dl class="function">
<dt id="c.inode_newsize_ok">
int <code class="sig-name descname">inode_newsize_ok</code><span class="sig-paren">(</span>const struct inode<em> *inode</em>, loff_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_newsize_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>may this inode be truncated to a given size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to be truncated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>the new size to assign to the inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode_newsize_ok must be called with i_mutex held.</p>
<p>inode_newsize_ok will check filesystem limits and ulimits to check that the
new inode size is within limits. inode_newsize_ok will also send SIGXFSZ
when necessary. Caller must not proceed with inode size change if failure is
returned. <strong>inode</strong> must be a file (not directory), with appropriate
permissions to allow truncate (inode_newsize_ok does NOT check these
conditions).</p>
<p><strong>Return</strong></p>
<p>0 on success, -ve errno on failure</p>
</div>
<dl class="function">
<dt id="c.setattr_copy">
void <code class="sig-name descname">setattr_copy</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, const struct iattr<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattr_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>copy simple metadata updates into the generic inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to be updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>the new attributes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>setattr_copy must be called with i_mutex held.</p>
<p>setattr_copy updates the inode’s metadata with that specified
in attr on idmapped mounts. Necessary permission checks to determine
whether or not the S_ISGID property needs to be removed are performed with
the correct idmapped mount permission helpers.
Noticeably missing is inode size update, which is more complex
as it requires pagecache updates.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before checking
permissions. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
<p>The inode is not marked as dirty after this operation. The rationale is
that for “simple” filesystems, the struct inode is the inode storage.
The caller is free to mark the inode dirty afterwards if needed.</p>
</div>
<dl class="function">
<dt id="c.notify_change">
int <code class="sig-name descname">notify_change</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, struct iattr<em> *attr</em>, struct inode<em> **delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.notify_change" title="Permalink to this definition">¶</a></dt>
<dd><p>modify attributes of a filesytem object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>object affected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*attr</span></code></dt><dd><p>new attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**delegated_inode</span></code></dt><dd><p>returns inode, if the inode is delegated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold the i_mutex on the affected object.</p>
<p>If notify_change discovers a delegation in need of breaking,
it will return -EWOULDBLOCK and return a reference to the inode in
delegated_inode.  The caller should then break the delegation and
retry.  Because breaking a delegation may take a long time, the
caller should drop the i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.  Also, passing NULL is fine for callers holding
the file open for write, as there can be no conflicting delegation in
that case.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before checking
permissions. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.d_path">
char * <code class="sig-name descname">d_path</code><span class="sig-paren">(</span>const struct path<em> *path</em>, char<em> *buf</em>, int<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_path" title="Permalink to this definition">¶</a></dt>
<dd><p>return the path of a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>path to report</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to return value in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>buffer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert a dentry into an ASCII path name. If the entry has been deleted
the string ” (deleted)” is appended. Note that this is ambiguous.</p>
<p>Returns a pointer into the buffer or an error code if the path was
too long. Note: Callers should use the returned pointer, not the passed
in buffer, to use the name! The implementation often starts at an offset
into the buffer, and may leave 0 bytes at the start.</p>
<p>“buflen” should be positive.</p>
</div>
<dl class="function">
<dt id="c.dax_layout_busy_page_range">
struct page * <code class="sig-name descname">dax_layout_busy_page_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a><em> *mapping</em>, loff_t<em> start</em>, loff_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_layout_busy_page_range" title="Permalink to this definition">¶</a></dt>
<dd><p>find first pinned page in <strong>mapping</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space to scan for a page with ref count &gt; 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>Starting offset. Page containing ‘start’ is included.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>End offset. Page containing ‘end’ is included. If ‘end’ is LLONG_MAX,
pages from ‘start’ till the end of file are included.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DAX requires ZONE_DEVICE mapped pages. These pages are never
‘onlined’ to the page allocator so they are considered idle when
page-&gt;count == 1. A filesystem uses this interface to determine if
any page in the mapping is busy, i.e. for DMA, or other
get_user_pages() usages.</p>
<p>It is expected that the filesystem is holding locks to block the
establishment of new mappings in this address_space. I.e. it expects
to be able to run <a class="reference internal" href="../core-api/mm-api.html#c.unmap_mapping_range" title="unmap_mapping_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">unmap_mapping_range()</span></code></a> and subsequently not race
mapping_mapped() becoming true.</p>
</div>
<dl class="function">
<dt id="c.dax_iomap_rw">
ssize_t <code class="sig-name descname">dax_iomap_rw</code><span class="sig-paren">(</span>struct kiocb<em> *iocb</em>, struct iov_iter<em> *iter</em>, const struct iomap_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_iomap_rw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform I/O to a DAX file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>The control block for this I/O</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>The addresses to do I/O from or to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iomap_ops</span> <span class="pre">*ops</span></code></dt><dd><p>iomap ops passed from the file system</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs read and write operations to directly mapped
persistent memory.  The callers needs to take care of read/write exclusion
and evicting any page cache pages in the region under I/O.</p>
</div>
<dl class="function">
<dt id="c.dax_iomap_fault">
<a class="reference internal" href="../core-api/mm-api.html#c.vm_fault_t" title="vm_fault_t">vm_fault_t</a> <code class="sig-name descname">dax_iomap_fault</code><span class="sig-paren">(</span>struct vm_fault<em> *vmf</em>, enum page_entry_size<em> pe_size</em>, pfn_t<em> *pfnp</em>, int<em> *iomap_errp</em>, const struct iomap_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_iomap_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a page fault on a DAX file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>The description of the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">page_entry_size</span> <span class="pre">pe_size</span></code></dt><dd><p>Size of the page to fault in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">*pfnp</span></code></dt><dd><p>PFN to insert for synchronous faults if fsync is required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*iomap_errp</span></code></dt><dd><p>Storage for detailed error code in case of error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iomap_ops</span> <span class="pre">*ops</span></code></dt><dd><p>Iomap ops passed from the file system</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a page fault occurs, filesystems may call this helper in
their fault handler for DAX files. <a class="reference internal" href="#c.dax_iomap_fault" title="dax_iomap_fault"><code class="xref c c-func docutils literal notranslate"><span class="pre">dax_iomap_fault()</span></code></a> assumes the caller
has done all the necessary locking for page fault to proceed
successfully.</p>
</div>
<dl class="function">
<dt id="c.dax_finish_sync_fault">
<a class="reference internal" href="../core-api/mm-api.html#c.vm_fault_t" title="vm_fault_t">vm_fault_t</a> <code class="sig-name descname">dax_finish_sync_fault</code><span class="sig-paren">(</span>struct vm_fault<em> *vmf</em>, enum page_entry_size<em> pe_size</em>, pfn_t<em> pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_finish_sync_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>finish synchronous page fault</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>The description of the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">page_entry_size</span> <span class="pre">pe_size</span></code></dt><dd><p>Size of entry to be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">pfn</span></code></dt><dd><p>PFN to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ensures that the file range touched by the page fault is
stored persistently on the media and handles inserting of appropriate page
table entry.</p>
</div>
<dl class="function">
<dt id="c.simple_setattr">
int <code class="sig-name descname">simple_setattr</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, struct iattr<em> *iattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_setattr" title="Permalink to this definition">¶</a></dt>
<dd><p>setattr for simple filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the target mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*iattr</span></code></dt><dd><p>iattr structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -error on failure.</p>
<p>simple_setattr is a simple -&gt;setattr implementation without a proper
implementation of size changes.</p>
<p>It can either be used for in-memory filesystems or special files
on simple regular filesystems.  Anything that needs to change on-disk
or wire state on size changes needs its own setattr method.</p>
</div>
<dl class="function">
<dt id="c.simple_read_from_buffer">
ssize_t <code class="sig-name descname">simple_read_from_buffer</code><span class="sig-paren">(</span>void __user<em> *to</em>, size_t<em> count</em>, loff_t<em> *ppos</em>, const void<em> *from</em>, size_t<em> available</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_read_from_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the buffer to user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*to</span></code></dt><dd><p>the user space buffer to read to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position in the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*from</span></code></dt><dd><p>the buffer to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt><dd><p>the size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.simple_read_from_buffer" title="simple_read_from_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_read_from_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the
buffer <strong>from</strong> at offset <strong>ppos</strong> into the user space address starting at <strong>to</strong>.</p>
<p>On success, the number of bytes read is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
</div>
<dl class="function">
<dt id="c.simple_write_to_buffer">
ssize_t <code class="sig-name descname">simple_write_to_buffer</code><span class="sig-paren">(</span>void<em> *to</em>, size_t<em> available</em>, loff_t<em> *ppos</em>, const void __user<em> *from</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_write_to_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from user space to the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*to</span></code></dt><dd><p>the buffer to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt><dd><p>the size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position in the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*from</span></code></dt><dd><p>the user space buffer to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.simple_write_to_buffer" title="simple_write_to_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_write_to_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the user
space address starting at <strong>from</strong> into the buffer <strong>to</strong> at offset <strong>ppos</strong>.</p>
<p>On success, the number of bytes written is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
</div>
<dl class="function">
<dt id="c.memory_read_from_buffer">
ssize_t <code class="sig-name descname">memory_read_from_buffer</code><span class="sig-paren">(</span>void<em> *to</em>, size_t<em> count</em>, loff_t<em> *ppos</em>, const void<em> *from</em>, size_t<em> available</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memory_read_from_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*to</span></code></dt><dd><p>the kernel space buffer to read to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position in the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*from</span></code></dt><dd><p>the buffer to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt><dd><p>the size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.memory_read_from_buffer" title="memory_read_from_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">memory_read_from_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the
buffer <strong>from</strong> at offset <strong>ppos</strong> into the kernel space address starting at <strong>to</strong>.</p>
<p>On success, the number of bytes read is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
</div>
<dl class="function">
<dt id="c.generic_fh_to_dentry">
struct dentry * <code class="sig-name descname">generic_fh_to_dentry</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, struct fid<em> *fid</em>, int<em> fh_len</em>, int<em> fh_type</em>, struct inode *(<em>*get_inode</em>)(struct super_block *sb, u64 ino, u32 gen)<span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fh_to_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for the fh_to_dentry export operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem to do the file handle conversion on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fid</span> <span class="pre">*fid</span></code></dt><dd><p>file handle to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_len</span></code></dt><dd><p>length of the file handle in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_type</span></code></dt><dd><p>type of file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*(*get_inode)</span> <span class="pre">(struct</span> <span class="pre">super_block</span> <span class="pre">*sb,</span> <span class="pre">u64</span> <span class="pre">ino,</span> <span class="pre">u32</span> <span class="pre">gen)</span></code></dt><dd><p>filesystem callback to retrieve inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decodes <strong>fid</strong> as long as it has one of the well-known
Linux filehandle types and calls <strong>get_inode</strong> on it to retrieve the
inode for the object specified in the file handle.</p>
</div>
<dl class="function">
<dt id="c.generic_fh_to_parent">
struct dentry * <code class="sig-name descname">generic_fh_to_parent</code><span class="sig-paren">(</span>struct super_block<em> *sb</em>, struct fid<em> *fid</em>, int<em> fh_len</em>, int<em> fh_type</em>, struct inode *(<em>*get_inode</em>)(struct super_block *sb, u64 ino, u32 gen)<span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fh_to_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for the fh_to_parent export operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem to do the file handle conversion on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fid</span> <span class="pre">*fid</span></code></dt><dd><p>file handle to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_len</span></code></dt><dd><p>length of the file handle in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_type</span></code></dt><dd><p>type of file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*(*get_inode)</span> <span class="pre">(struct</span> <span class="pre">super_block</span> <span class="pre">*sb,</span> <span class="pre">u64</span> <span class="pre">ino,</span> <span class="pre">u32</span> <span class="pre">gen)</span></code></dt><dd><p>filesystem callback to retrieve inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decodes <strong>fid</strong> as long as it has one of the well-known
Linux filehandle types and calls <strong>get_inode</strong> on it to retrieve the
inode for the _parent_ object specified in the file handle if it
is specified in the file handle, or NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.__generic_file_fsync">
int <code class="sig-name descname">__generic_file_fsync</code><span class="sig-paren">(</span>struct file<em> *file</em>, loff_t<em> start</em>, loff_t<em> end</em>, int<em> datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>generic fsync implementation for simple filesystems</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>start offset in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>end offset in bytes (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt><dd><p>only synchronize essential metadata if true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation of the fsync method for simple
filesystems which track all non-inode metadata in the buffers list
hanging off the address_space structure.</p>
</div>
<dl class="function">
<dt id="c.generic_file_fsync">
int <code class="sig-name descname">generic_file_fsync</code><span class="sig-paren">(</span>struct file<em> *file</em>, loff_t<em> start</em>, loff_t<em> end</em>, int<em> datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>generic fsync implementation for simple filesystems with flush</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>start offset in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>end offset in bytes (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt><dd><p>only synchronize essential metadata if true</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.generic_check_addressable">
int <code class="sig-name descname">generic_check_addressable</code><span class="sig-paren">(</span>unsigned<em> blocksize_bits</em>, u64<em> num_blocks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_check_addressable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check addressability of file system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">blocksize_bits</span></code></dt><dd><p>log of file system block size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">num_blocks</span></code></dt><dd><p>number of blocks in file system</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether a file system with <strong>num_blocks</strong> blocks (and a
block size of 2****blocksize_bits**) is addressable by the sector_t
and page cache of the system.  Return 0 if so and -EFBIG otherwise.</p>
</div>
<dl class="function">
<dt id="c.simple_nosetlease">
int <code class="sig-name descname">simple_nosetlease</code><span class="sig-paren">(</span>struct file<em> *filp</em>, long<em> arg</em>, struct file_lock<em> **flp</em>, void<em> **priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_nosetlease" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for prohibiting leases</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>type of lease to obtain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**flp</span></code></dt><dd><p>new lease supplied for insertion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**priv</span></code></dt><dd><p>private data for lm_setup operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic helper for filesystems that do not wish to allow leases to be set.
All arguments are ignored and it just returns -EINVAL.</p>
</div>
<dl class="function">
<dt id="c.simple_get_link">
const char * <code class="sig-name descname">simple_get_link</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em>, struct inode<em> *inode</em>, struct delayed_call<em> *done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_get_link" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper to get the target of “fast” symlinks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>not used here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the symlink inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span> <span class="pre">*done</span></code></dt><dd><p>not used here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic helper for filesystems to use for symlink inodes where a pointer to
the symlink target is stored in -&gt;i_link.  NOTE: this isn’t normally called,
since as an optimization the path lookup code uses any non-NULL -&gt;i_link
directly, without calling -&gt;get_link().  But -&gt;get_link() still must be set,
to mark the inode_operations as being for a symlink.</p>
<p><strong>Return</strong></p>
<p>the symlink target</p>
</div>
<dl class="function">
<dt id="c.generic_set_encrypted_ci_d_ops">
void <code class="sig-name descname">generic_set_encrypted_ci_d_ops</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_set_encrypted_ci_d_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for setting d_ops for given dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry to set ops on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Casefolded directories need d_hash and d_compare set, so that the dentries
contained in them are handled case-insensitively.  Note that these operations
are needed on the parent directory rather than on the dentries in it, and
while the casefolding flag can be toggled on and off on an empty directory,
dentry_operations can’t be changed later.  As a result, if the filesystem has
casefolding support enabled at all, we have to give all dentries the
casefolding operations even if their inode doesn’t have the casefolding flag
currently (and thus the casefolding ops would be no-ops for now).</p>
<p>Encryption works differently in that the only dentry operation it needs is
d_revalidate, which it only needs on dentries that have the no-key name flag.
The no-key flag can’t be set “later”, so we don’t have to worry about that.</p>
<p>Finally, to maximize compatibility with overlayfs (which isn’t compatible
with certain dentry operations) and to avoid taking an unnecessary
performance hit, we use custom dentry_operations for each possible
combination rather than always installing all operations.</p>
</div>
<dl class="function">
<dt id="c.inode_maybe_inc_iversion">
bool <code class="sig-name descname">inode_maybe_inc_iversion</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, bool<em> force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_maybe_inc_iversion" title="Permalink to this definition">¶</a></dt>
<dd><p>increments i_version</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode with the i_version that should be updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force</span></code></dt><dd><p>increment the counter even if it’s not necessary?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every time the inode is modified, the i_version field must be seen to have
changed by any observer.</p>
<p>If “force” is set or the QUERIED flag is set, then ensure that we increment
the value, and clear the queried flag.</p>
<p>In the common case where neither is set, then we can return “false” without
updating i_version.</p>
<p>If this function returns false, and no other metadata has changed, then we
can avoid logging the metadata.</p>
</div>
<dl class="function">
<dt id="c.posix_acl_chmod">
int  <code class="sig-name descname">posix_acl_chmod</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_acl_chmod" title="Permalink to this definition">¶</a></dt>
<dd><p>chmod a posix acl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount <strong>inode</strong> was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry to check permissions on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the new mode of <strong>inode</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the dentry has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before checking
permissions. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.posix_acl_update_mode">
int <code class="sig-name descname">posix_acl_update_mode</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, umode_t<em> *mode_p</em>, struct posix_acl<em> **acl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_acl_update_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>update mode in set_acl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount <strong>inode</strong> was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>target inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">*mode_p</span></code></dt><dd><p>mode (pointer) for update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">posix_acl</span> <span class="pre">**acl</span></code></dt><dd><p>acl pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the file mode when setting an ACL: compute the new file permission
bits based on the ACL.  In addition, if the ACL is equivalent to the new
file mode, set <strong>*acl</strong> to NULL to indicate that no ACL should be set.</p>
<p>As with chmod, clear the setgid bit if the caller is not in the owning group
or capable of CAP_FSETID (see inode_change_ok).</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before checking
permissions. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
<p>Called from set_acl inode operations.</p>
</div>
<dl class="function">
<dt id="c.posix_acl_from_xattr">
struct posix_acl * <code class="sig-name descname">posix_acl_from_xattr</code><span class="sig-paren">(</span>struct user_namespace<em> *userns</em>, const void<em> *value</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_acl_from_xattr" title="Permalink to this definition">¶</a></dt>
<dd><p>convert POSIX ACLs from backing store to VFS format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*userns</span></code></dt><dd><p>the filesystem’s idmapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>the uapi representation of POSIX ACLs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the size of <strong>void</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems that store POSIX ACLs in the unaltered uapi format should use
<a class="reference internal" href="#c.posix_acl_from_xattr" title="posix_acl_from_xattr"><code class="xref c c-func docutils literal notranslate"><span class="pre">posix_acl_from_xattr()</span></code></a> when reading them from the backing store and
converting them into the struct posix_acl VFS format. The helper is
specifically intended to be called from the acl inode operation.</p>
<p>The <a class="reference internal" href="#c.posix_acl_from_xattr" title="posix_acl_from_xattr"><code class="xref c c-func docutils literal notranslate"><span class="pre">posix_acl_from_xattr()</span></code></a> function will map the raw {g,u}id values stored
in ACL_{GROUP,USER} entries into idmapping in <strong>userns</strong>.</p>
<p>Note that <a class="reference internal" href="#c.posix_acl_from_xattr" title="posix_acl_from_xattr"><code class="xref c c-func docutils literal notranslate"><span class="pre">posix_acl_from_xattr()</span></code></a> does not take idmapped mounts into account.
If it did it calling it from the get acl inode operation would return POSIX
ACLs mapped according to an idmapped mount which would mean that the value
couldn’t be cached for the filesystem. Idmapped mounts are taken into
account on the fly during permission checking or right at the VFS -
userspace boundary before reporting them to the user.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Allocated struct posix_acl on success, NULL for a valid header but</dt><dd><p>without actual POSIX ACL entries, or ERR_PTR() encoded error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vfs_set_acl">
int <code class="sig-name descname">vfs_set_acl</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, const char<em> *acl_name</em>, struct posix_acl<em> *kacl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_set_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>set posix acls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry based on which to set the posix acls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>the name of the posix acl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">posix_acl</span> <span class="pre">*kacl</span></code></dt><dd><p>the posix acls in the appropriate VFS format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets <strong>kacl</strong>. The caller must all posix_acl_release() on <strong>kacl</strong>
afterwards.</p>
<p><strong>Return</strong></p>
<p>On success 0, on error negative errno.</p>
</div>
<dl class="function">
<dt id="c.vfs_get_acl">
struct posix_acl * <code class="sig-name descname">vfs_get_acl</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, const char<em> *acl_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>get posix acls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry based on which to retrieve the posix acls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>the name of the posix acl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves <strong>kacl</strong> from the filesystem. The caller must all
posix_acl_release() on <strong>kacl</strong>.</p>
<p><strong>Return</strong></p>
<p>On success POSIX ACLs in VFS format, on error negative errno.</p>
</div>
<dl class="function">
<dt id="c.vfs_remove_acl">
int <code class="sig-name descname">vfs_remove_acl</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, const char<em> *acl_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_remove_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>remove posix acls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry based on which to retrieve the posix acls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>the name of the posix acl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes posix acls.</p>
<p><strong>Return</strong></p>
<p>On success 0, on error negative errno.</p>
</div>
<dl class="function">
<dt id="c.generic_fillattr">
void <code class="sig-name descname">generic_fillattr</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct inode<em> *inode</em>, struct kstat<em> *stat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fillattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in the basic attributes from the inode struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount the inode was found from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>Inode to use as the source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*stat</span></code></dt><dd><p>Where to fill in the attributes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the basic attributes in the kstat structure from data that’s to be
found on the VFS inode structure.  This is the default if no getattr inode
operation is supplied.</p>
<p>If the inode has been found through an idmapped mount the user namespace of
the vfsmount must be passed through <strong>mnt_userns</strong>. This function will then
take care to map the inode according to <strong>mnt_userns</strong> before filling in the
uid and gid filds. On non-idmapped mounts or if permission checking is to be
performed on the raw inode simply passs init_user_ns.</p>
</div>
<dl class="function">
<dt id="c.generic_fill_statx_attr">
void <code class="sig-name descname">generic_fill_statx_attr</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct kstat<em> *stat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fill_statx_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in the statx attributes from the inode flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>Inode to use as the source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*stat</span></code></dt><dd><p>Where to fill in the attribute flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the STATX_ATTR_* flags in the kstat structure for properties of the
inode that are published on i_flags and enforced by the VFS.</p>
</div>
<dl class="function">
<dt id="c.vfs_getattr_nosec">
int <code class="sig-name descname">vfs_getattr_nosec</code><span class="sig-paren">(</span>const struct path<em> *path</em>, struct kstat<em> *stat</em>, u32<em> request_mask</em>, unsigned int<em> query_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_getattr_nosec" title="Permalink to this definition">¶</a></dt>
<dd><p>getattr without security checks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file to get attributes from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*stat</span></code></dt><dd><p>structure to return attributes in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">request_mask</span></code></dt><dd><p>STATX_xxx flags indicating what the caller wants</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">query_flags</span></code></dt><dd><p>Query mode (AT_STATX_SYNC_TYPE)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get attributes without calling security_inode_getattr.</p>
<p>Currently the only caller other than vfs_getattr is internal to the
filehandle lookup code, which uses only the inode number and returns no
attributes to any user.  Any other code probably wants vfs_getattr.</p>
</div>
<dl class="function">
<dt id="c.vfs_fsync_range">
int <code class="sig-name descname">vfs_fsync_range</code><span class="sig-paren">(</span>struct file<em> *file</em>, loff_t<em> start</em>, loff_t<em> end</em>, int<em> datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_fsync_range" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to sync a range of data &amp; metadata to disk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>offset in bytes of the beginning of data range to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>offset in bytes of the end of data range (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt><dd><p>perform only datasync</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write back data in range <strong>start</strong>..**end** and metadata for <strong>file</strong> to disk.  If
<strong>datasync</strong> is set only metadata needed to access modified file data is
written.</p>
</div>
<dl class="function">
<dt id="c.vfs_fsync">
int <code class="sig-name descname">vfs_fsync</code><span class="sig-paren">(</span>struct file<em> *file</em>, int<em> datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a fsync or fdatasync on a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt><dd><p>only perform a fdatasync operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write back data and metadata for <strong>file</strong> to disk.  If <strong>datasync</strong> is
set only metadata needed to access modified file data is written.</p>
</div>
<dl class="function">
<dt id="c.__vfs_setxattr_locked">
int <code class="sig-name descname">__vfs_setxattr_locked</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, const char<em> *name</em>, const void<em> *value</em>, size_t<em> size</em>, int<em> flags</em>, struct inode<em> **delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__vfs_setxattr_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>set an extended attribute while holding the inode lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount of the target inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>object to perform setxattr on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>value to set <strong>name</strong> to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of <strong>value</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags to pass into filesystem operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**delegated_inode</span></code></dt><dd><p>on return, will contain an inode pointer that
a delegation was broken on, NULL if none.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__vfs_removexattr_locked">
int <code class="sig-name descname">__vfs_removexattr_locked</code><span class="sig-paren">(</span>struct user_namespace<em> *mnt_userns</em>, struct dentry<em> *dentry</em>, const char<em> *name</em>, struct inode<em> **delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__vfs_removexattr_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>set an extended attribute while holding the inode lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*mnt_userns</span></code></dt><dd><p>user namespace of the mount of the target inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>object to perform setxattr on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of xattr to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**delegated_inode</span></code></dt><dd><p>on return, will contain an inode pointer that
a delegation was broken on, NULL if none.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xattr_full_name">
const char * <code class="sig-name descname">xattr_full_name</code><span class="sig-paren">(</span>const struct xattr_handler<em> *handler</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xattr_full_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute full attribute name from suffix</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xattr_handler</span> <span class="pre">*handler</span></code></dt><dd><p>handler of the xattr_handler operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name passed to the xattr_handler operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The get and set xattr handler operations are called with the remainder of
the attribute name after skipping the handler’s prefix: for example, “foo”
is passed to the get operation of a handler with prefix “user.” to get
attribute “user.foo”.  The full name is still “there” in the name though.</p>
<p><strong>Note</strong></p>
<p>the list xattr handler operation when called from the vfs is passed a
NULL name; some file systems use this operation internally, with varying
semantics.</p>
</div>
<dl class="function">
<dt id="c.mnt_idmap_owner">
struct user_namespace * <code class="sig-name descname">mnt_idmap_owner</code><span class="sig-paren">(</span>const struct mnt_idmap<em> *idmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_idmap_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve owner of the mount’s idmapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>mount idmapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper will go away once the conversion to use struct mnt_idmap
everywhere has finished at which point the helper will be unexported.</p>
<p>Only code that needs to perform permission checks based on the owner of the
idmapping will get access to it. All other code will solely rely on
idmappings. This will get us type safety so it’s impossible to conflate
filesystems idmappings with mount idmappings.</p>
<p><strong>Return</strong></p>
<p>The owner of the idmapping.</p>
</div>
<dl class="function">
<dt id="c.mnt_user_ns">
struct user_namespace * <code class="sig-name descname">mnt_user_ns</code><span class="sig-paren">(</span>const struct vfsmount<em> *mnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_user_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve owner of an idmapped mount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>the relevant vfsmount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper will go away once the conversion to use struct mnt_idmap
everywhere has finished at which point the helper will be unexported.</p>
<p>Only code that needs to perform permission checks based on the owner of the
idmapping will get access to it. All other code will solely rely on
idmappings. This will get us type safety so it’s impossible to conflate
filesystems idmappings with mount idmappings.</p>
<p><strong>Return</strong></p>
<p>The owner of the idmapped.</p>
</div>
<dl class="function">
<dt id="c.mnt_want_write">
int <code class="sig-name descname">mnt_want_write</code><span class="sig-paren">(</span>struct vfsmount<em> *m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_want_write" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a mount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*m</span></code></dt><dd><p>the mount on which to take a write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This tells the low-level filesystem that a write is about to be performed to
it, and makes sure that writes are allowed (mount is read-write, filesystem
is not frozen) before returning success.  When the write operation is
finished, <a class="reference internal" href="#c.mnt_drop_write" title="mnt_drop_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">mnt_drop_write()</span></code></a> must be called.  This is effectively a refcount.</p>
</div>
<dl class="function">
<dt id="c.mnt_want_write_file">
int <code class="sig-name descname">mnt_want_write_file</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_want_write_file" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a file’s mount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file who’s mount on which to take a write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is like mnt_want_write, but if the file is already open for writing it
skips incrementing mnt_writers (since the open file already has a reference)
and instead only does the freeze protection and the check for emergency r/o
remounts.  This must be paired with mnt_drop_write_file.</p>
</div>
<dl class="function">
<dt id="c.mnt_drop_write">
void <code class="sig-name descname">mnt_drop_write</code><span class="sig-paren">(</span>struct vfsmount<em> *mnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_drop_write" title="Permalink to this definition">¶</a></dt>
<dd><p>give up write access to a mount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>the mount on which to give up write access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tells the low-level filesystem that we are done performing writes to it and
also allows filesystem to be frozen again.  Must be matched with
<a class="reference internal" href="#c.mnt_want_write" title="mnt_want_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">mnt_want_write()</span></code></a> call above.</p>
</div>
<dl class="function">
<dt id="c.vfs_create_mount">
struct vfsmount * <code class="sig-name descname">vfs_create_mount</code><span class="sig-paren">(</span>struct fs_context<em> *fc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_create_mount" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mount for a configured superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>The configuration context with the superblock attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a mount to an already configured superblock.  If necessary, the
caller should invoke <a class="reference internal" href="#c.vfs_get_tree" title="vfs_get_tree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_get_tree()</span></code></a> before calling this.</p>
<p>Note that this does not attach the mount to anything.</p>
</div>
<dl class="function">
<dt id="c.path_is_mountpoint">
bool <code class="sig-name descname">path_is_mountpoint</code><span class="sig-paren">(</span>const struct path<em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_is_mountpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if path is a mount in the current namespace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>path to check</p>
<p>d_mountpoint() can only be used reliably to establish if a dentry is
not mounted in any namespace and that common case is handled inline.
d_mountpoint() isn’t aware of the possibility there may be multiple
mounts using a given dentry in a different namespace. This function
checks if the passed in path is a mountpoint rather than the dentry
alone.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.may_umount_tree">
int <code class="sig-name descname">may_umount_tree</code><span class="sig-paren">(</span>struct vfsmount<em> *m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.may_umount_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a mount tree is busy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*m</span></code></dt><dd><p>root of mount tree</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called to check if a tree of mounts has any
open files, pwds, chroots or sub mounts that are
busy.</p>
</div>
<dl class="function">
<dt id="c.may_umount">
int <code class="sig-name descname">may_umount</code><span class="sig-paren">(</span>struct vfsmount<em> *mnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.may_umount" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a mount point is busy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>root of mount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called to check if a mount point has any
open files, pwds, chroots or sub mounts. If the
mount has sub mounts this will return busy
regardless of whether the sub mounts are busy.</p>
<p>Doesn’t take quota and stuff into account. IOW, in some cases it will
give false negatives. The main reason why it’s here is that we need
a non-destructive way to look for easily umountable filesystems.</p>
</div>
<dl class="function">
<dt id="c.clone_private_mount">
struct vfsmount * <code class="sig-name descname">clone_private_mount</code><span class="sig-paren">(</span>const struct path<em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clone_private_mount" title="Permalink to this definition">¶</a></dt>
<dd><p>create a private clone of a path</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>path to clone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new vfsmount, which will be the clone of <strong>path</strong>.  The new mount
will not be attached anywhere in the namespace and will be private (i.e.
changes to the originating mount won’t be propagated into this).</p>
<p>Release with mntput().</p>
</div>
<dl class="function">
<dt id="c.mnt_set_expiry">
void <code class="sig-name descname">mnt_set_expiry</code><span class="sig-paren">(</span>struct vfsmount<em> *mnt</em>, struct list_head<em> *expiry_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mnt_set_expiry" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a mount on an expiration list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>The mount to list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*expiry_list</span></code></dt><dd><p>The list to add the mount to.</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="the-proc-filesystem">
<h2>The proc filesystem<a class="headerlink" href="#the-proc-filesystem" title="Permalink to this headline">¶</a></h2>
<section id="sysctl-interface">
<h3>sysctl interface<a class="headerlink" href="#sysctl-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_dostring">
int <code class="sig-name descname">proc_dostring</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dostring" title="Permalink to this definition">¶</a></dt>
<dd><p>read a string sysctl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes a string from/to the user buffer. If the kernel
buffer provided is not large enough to hold the string, the
string is truncated. The copied string is <code class="docutils literal notranslate"><span class="pre">NULL-terminated</span></code>.
If the string is being read by the user process, it is copied
and a newline ‘n’ is added. It is truncated if the buffer is
not large enough.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dobool">
int <code class="sig-name descname">proc_dobool</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dobool" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write a bool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dointvec">
int <code class="sig-name descname">proc_dointvec</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_douintvec">
int <code class="sig-name descname">proc_douintvec</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned integers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dointvec_minmax">
int <code class="sig-name descname">proc_dointvec_minmax</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers with min/max values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success or -EINVAL on write when the range check fails.</p>
</div>
<dl class="function">
<dt id="c.proc_douintvec_minmax">
int <code class="sig-name descname">proc_douintvec_minmax</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned ints with min/max values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string. Negative
strings are not allowed.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max). There is a final sanity
check for UINT_MAX to avoid having to support wrap around uses from
userspace.</p>
<p>Returns 0 on success or -ERANGE on write when the range check fails.</p>
</div>
<dl class="function">
<dt id="c.proc_dou8vec_minmax">
int <code class="sig-name descname">proc_dou8vec_minmax</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dou8vec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned chars with min/max values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(u8) unsigned chars
values from/to the user buffer, treated as an ASCII string. Negative
strings are not allowed.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success or an error on write when the range check fails.</p>
</div>
<dl class="function">
<dt id="c.proc_doulongvec_minmax">
int <code class="sig-name descname">proc_doulongvec_minmax</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of long integers with min/max values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_doulongvec_ms_jiffies_minmax">
int <code class="sig-name descname">proc_doulongvec_ms_jiffies_minmax</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_ms_jiffies_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of millisecond values with min/max values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string. The values
are treated as milliseconds, and converted to jiffies when they are stored.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dointvec_jiffies">
int <code class="sig-name descname">proc_dointvec_jiffies</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as seconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in seconds, and are converted into
jiffies.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dointvec_userhz_jiffies">
int <code class="sig-name descname">proc_dointvec_userhz_jiffies</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_userhz_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1/USER_HZ seconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>pointer to the file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/USER_HZ seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_dointvec_ms_jiffies">
int <code class="sig-name descname">proc_dointvec_ms_jiffies</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_ms_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1 milliseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>the current position in the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/1000 seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.proc_do_large_bitmap">
int <code class="sig-name descname">proc_do_large_bitmap</code><span class="sig-paren">(</span>struct ctl_table<em> *table</em>, int<em> write</em>, void<em> *buffer</em>, size_t<em> *lenp</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_do_large_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write from/to a large bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*table</span></code></dt><dd><p>the sysctl table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*lenp</span></code></dt><dd><p>the size of the user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bitmap is stored at table-&gt;data and the bitmap length (in bits)
in table-&gt;maxlen.</p>
<p>We use a range comma separated format (e.g. 1,3-4,10-10) so that
large bitmaps may be represented in a compact manner. Writing into
the file will clear the bitmap then update it with the given input.</p>
<p>Returns 0 on success.</p>
</div>
</section>
<section id="proc-filesystem-interface">
<h3>proc filesystem interface<a class="headerlink" href="#proc-filesystem-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_flush_pid">
void <code class="sig-name descname">proc_flush_pid</code><span class="sig-paren">(</span>struct pid<em> *pid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_flush_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove dcache entries for <strong>pid</strong> from the /proc dcache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid</span> <span class="pre">*pid</span></code></dt><dd><p>pid that should be flushed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks a list of inodes (that belong to any proc
filesystem) that are attached to the pid and flushes them from
the dentry cache.</p>
<p>It is safe and reasonable to cache /proc entries for a task until
that task exits.  After that they just clog up the dcache with
useless entries, possibly causing useful dcache entries to be
flushed instead.  This routine is provided to flush those useless
dcache entries when a process is reaped.</p>
<p><strong>NOTE</strong></p>
<dl class="simple">
<dt>This routine is just an optimization so it does not guarantee</dt><dd><p>that no dcache entries will exist after a process is reaped
it just makes it very unlikely that any will persist.</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="events-based-on-file-descriptors">
<h2>Events based on file descriptors<a class="headerlink" href="#events-based-on-file-descriptors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.eventfd_signal">
__u64 <code class="sig-name descname">eventfd_signal</code><span class="sig-paren">(</span>struct eventfd_ctx<em> *ctx</em>, __u64<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <strong>n</strong> to the eventfd counter.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>[in] Pointer to the eventfd context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">n</span></code></dt><dd><p>[in] Value of the counter to be added to the eventfd internal counter.
The value cannot be negative.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is supposed to be called by the kernel in paths that do not
allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
value, and we signal this as overflow condition by returning a EPOLLERR
to poll(2).</p>
<p>Returns the amount by which the counter was incremented.  This will be less
than <strong>n</strong> if the counter has overflowed.</p>
</div>
<dl class="function">
<dt id="c.eventfd_ctx_put">
void <code class="sig-name descname">eventfd_ctx_put</code><span class="sig-paren">(</span>struct eventfd_ctx<em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases a reference to the internal eventfd context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>[in] Pointer to eventfd context.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The eventfd context reference must have been previously acquired either
with <a class="reference internal" href="#c.eventfd_ctx_fdget" title="eventfd_ctx_fdget"><code class="xref c c-func docutils literal notranslate"><span class="pre">eventfd_ctx_fdget()</span></code></a> or <a class="reference internal" href="#c.eventfd_ctx_fileget" title="eventfd_ctx_fileget"><code class="xref c c-func docutils literal notranslate"><span class="pre">eventfd_ctx_fileget()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.eventfd_ctx_remove_wait_queue">
int <code class="sig-name descname">eventfd_ctx_remove_wait_queue</code><span class="sig-paren">(</span>struct eventfd_ctx<em> *ctx</em>, wait_queue_entry_t<em> *wait</em>, __u64<em> *cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_remove_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current counter and removes wait queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>[in] Pointer to eventfd context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_queue_entry_t</span> <span class="pre">*wait</span></code></dt><dd><p>[in] Wait queue to be removed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">*cnt</span></code></dt><dd><p>[out] Pointer to the 64-bit counter value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> if successful, or the following error codes:</p>
<dl class="option-list">
<dt><kbd><span class="option">-E<var>AGAIN</var></span></kbd></dt>
<dd><p>: The operation would have blocked.</p>
</dd>
</dl>
<p>This is used to atomically remove a wait queue entry from the eventfd wait
queue head, and read/reset the counter value.</p>
</div>
<dl class="function">
<dt id="c.eventfd_fget">
struct file * <code class="sig-name descname">eventfd_fget</code><span class="sig-paren">(</span>int<em> fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_fget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a reference of an eventfd file descriptor.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>[in] Eventfd file descriptor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the eventfd file structure in case of success, or the
following error pointer:</p>
<dl class="option-list">
<dt><kbd><span class="option">-E<var>BADF</var></span></kbd></dt>
<dd><p>: Invalid <strong>fd</strong> file descriptor.</p>
</dd>
<dt><kbd><span class="option">-E<var>INVAL</var></span></kbd></dt>
<dd><p>: The <strong>fd</strong> file descriptor is not an eventfd file.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eventfd_ctx_fdget">
struct eventfd_ctx * <code class="sig-name descname">eventfd_ctx_fdget</code><span class="sig-paren">(</span>int<em> fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fdget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>[in] Eventfd file descriptor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointers returned by the following functions:</p>
<p>eventfd_fget</p>
</div>
<dl class="function">
<dt id="c.eventfd_ctx_fileget">
struct eventfd_ctx * <code class="sig-name descname">eventfd_ctx_fileget</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fileget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>[in] Eventfd file pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointer:</p>
<dl class="option-list">
<dt><kbd><span class="option">-E<var>INVAL</var></span></kbd></dt>
<dd><p>: The <strong>fd</strong> file descriptor is not an eventfd file.</p>
</dd>
</dl>
</div>
</section>
<section id="eventpoll-epoll-interfaces">
<h2>eventpoll (epoll) interfaces<a class="headerlink" href="#eventpoll-epoll-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ep_events_available">
int <code class="sig-name descname">ep_events_available</code><span class="sig-paren">(</span>struct eventpoll<em> *ep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ep_events_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if ready events might be available.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span> <span class="pre">*ep</span></code></dt><dd><p>Pointer to the eventpoll context.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>a value different than <code class="docutils literal notranslate"><span class="pre">zero</span></code> if ready events are available,</dt><dd><p>or <code class="docutils literal notranslate"><span class="pre">zero</span></code> otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.reverse_path_check">
int <code class="sig-name descname">reverse_path_check</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.reverse_path_check" title="Permalink to this definition">¶</a></dt>
<dd><p>The tfile_check_list is list of epitem_head, which have links that are proposed to be newly added. We need to make sure that those added links don’t add too many paths such that we will spend all our time waking up eventpoll objects.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zero</span></code> if the proposed links don’t create too many paths,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">-1</span></code> otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ep_poll">
int <code class="sig-name descname">ep_poll</code><span class="sig-paren">(</span>struct eventpoll<em> *ep</em>, struct epoll_event __user<em> *events</em>, int<em> maxevents</em>, struct timespec64<em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ep_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves ready events, and delivers them to the caller-supplied event buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span> <span class="pre">*ep</span></code></dt><dd><p>Pointer to the eventpoll context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">epoll_event</span> <span class="pre">__user</span> <span class="pre">*events</span></code></dt><dd><p>Pointer to the userspace buffer where the ready events should be
stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxevents</span></code></dt><dd><p>Size (in terms of number of events) of the caller event buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*timeout</span></code></dt><dd><p>Maximum timeout for the ready events fetch operation, in
timespec. If the timeout is zero, the function will not block,
while if the <strong>timeout</strong> ptr is NULL, the function will block
until at least one event has been retrieved (or an error
occurred).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>the number of ready events which have been fetched, or an</dt><dd><p>error code, in case of error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ep_loop_check_proc">
int <code class="sig-name descname">ep_loop_check_proc</code><span class="sig-paren">(</span>struct eventpoll<em> *ep</em>, int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ep_loop_check_proc" title="Permalink to this definition">¶</a></dt>
<dd><p>verify that adding an epoll file inside another epoll structure does not violate the constraints, in terms of closed loops, or too deep chains (which can result in excessive stack usage).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span> <span class="pre">*ep</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span></code> to be currently checked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>Current depth of the path being checked.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zero</span></code> if adding the epoll <strong>file</strong> inside current epoll</dt><dd><p>structure <strong>ep</strong> does not violate the constraints, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ep_loop_check">
int <code class="sig-name descname">ep_loop_check</code><span class="sig-paren">(</span>struct eventpoll<em> *ep</em>, struct eventpoll<em> *to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ep_loop_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a check to verify that adding an epoll file (<strong>to</strong>) into another epoll file (represented by <strong>ep</strong>) does not create closed loops or too deep chains.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span> <span class="pre">*ep</span></code></dt><dd><p>Pointer to the epoll we are inserting into.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventpoll</span> <span class="pre">*to</span></code></dt><dd><p>Pointer to the epoll to be inserted.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">zero</span></code> if adding the epoll <strong>to</strong> inside the epoll <strong>from</strong>
does not violate the constraints, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> otherwise.</p>
</div>
</section>
<section id="the-filesystem-for-exporting-kernel-objects">
<h2>The Filesystem for Exporting Kernel Objects<a class="headerlink" href="#the-filesystem-for-exporting-kernel-objects" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sysfs_create_file_ns">
int <code class="sig-name descname">sysfs_create_file_ns</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em>, const void<em> *ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>create an attribute file for an object with custom ns</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re creating for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ns</span></code></dt><dd><p>namespace the new file should belong to</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_add_file_to_group">
int <code class="sig-name descname">sysfs_add_file_to_group</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em>, const char<em> *group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_add_file_to_group" title="Permalink to this definition">¶</a></dt>
<dd><p>add an attribute file to a pre-existing group.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*group</span></code></dt><dd><p>group name.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_chmod_file">
int <code class="sig-name descname">sysfs_chmod_file</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_chmod_file" title="Permalink to this definition">¶</a></dt>
<dd><p>update the modified mode value on an object attribute.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>file permissions.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_break_active_protection">
struct kernfs_node * <code class="sig-name descname">sysfs_break_active_protection</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_break_active_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>break “active” protection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>The kernel object <strong>attr</strong> is associated with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>The attribute to break the “active” protection for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>With sysfs, just like kernfs, deletion of an attribute is postponed until
all active .show() and .store() callbacks have finished unless this function
is called. Hence this function is useful in methods that implement self
deletion.</p>
</div>
<dl class="function">
<dt id="c.sysfs_unbreak_active_protection">
void <code class="sig-name descname">sysfs_unbreak_active_protection</code><span class="sig-paren">(</span>struct kernfs_node<em> *kn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_unbreak_active_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>restore “active” protection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kernfs_node</span> <span class="pre">*kn</span></code></dt><dd><p>Pointer returned by <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the effects of <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a>. Since this function
calls kernfs_put() on the kernfs node that corresponds to the ‘attr’
argument passed to <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a> that attribute may have
been removed between the <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a> and
<a class="reference internal" href="#c.sysfs_unbreak_active_protection" title="sysfs_unbreak_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_unbreak_active_protection()</span></code></a> calls, it is not safe to access <strong>kn</strong> after
this function has returned.</p>
</div>
<dl class="function">
<dt id="c.sysfs_remove_file_ns">
void <code class="sig-name descname">sysfs_remove_file_ns</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em>, const void<em> *ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an object attribute with a custom ns tag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ns</span></code></dt><dd><p>namespace tag of the file to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hash the attribute name and namespace tag and kill the victim.</p>
</div>
<dl class="function">
<dt id="c.sysfs_remove_file_self">
bool <code class="sig-name descname">sysfs_remove_file_self</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_self" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an object attribute from its own method</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See kernfs_remove_self() for details.</p>
</div>
<dl class="function">
<dt id="c.sysfs_remove_file_from_group">
void <code class="sig-name descname">sysfs_remove_file_from_group</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct attribute<em> *attr</em>, const char<em> *group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an attribute file from a group.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*group</span></code></dt><dd><p>group name.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_create_bin_file">
int <code class="sig-name descname">sysfs_create_bin_file</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct bin_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create binary file for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_remove_bin_file">
void <code class="sig-name descname">sysfs_remove_bin_file</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct bin_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove binary file for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_file_change_owner">
int <code class="sig-name descname">sysfs_file_change_owner</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const char<em> *name</em>, kuid_t<em> kuid</em>, kgid_t<em> kgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_file_change_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>change owner of a sysfs file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the file to change.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt><dd><p>new owner’s kuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt><dd><p>new owner’s kgid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the sysfs entry <strong>name</strong> under <strong>kobj</strong> and changes the
ownership to <strong>kuid</strong>/<strong>kgid</strong>.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="function">
<dt id="c.sysfs_change_owner">
int <code class="sig-name descname">sysfs_change_owner</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, kuid_t<em> kuid</em>, kgid_t<em> kgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_change_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>change owner of the given object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt><dd><p>new owner’s kuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt><dd><p>new owner’s kgid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the owner of the default directory, files, groups, and attributes of
<strong>kobj</strong> to <strong>kuid</strong>/<strong>kgid</strong>. Note that sysfs_change_owner mirrors how the sysfs
entries for a kobject are added by driver core. In summary,
<a class="reference internal" href="#c.sysfs_change_owner" title="sysfs_change_owner"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_change_owner()</span></code></a> takes care of the default directory entry for <strong>kobj</strong>,
the default attributes associated with the ktype of <strong>kobj</strong> and the default
attributes associated with the ktype of <strong>kobj</strong>.
Additional properties not added by driver core have to be changed by the
driver or subsystem which created them. This is similar to how
driver/subsystem specific entries are removed.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="function">
<dt id="c.sysfs_emit">
int <code class="sig-name descname">sysfs_emit</code><span class="sig-paren">(</span>char<em> *buf</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_emit" title="Permalink to this definition">¶</a></dt>
<dd><p>scnprintf equivalent, aware of PAGE_SIZE buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>start of PAGE_SIZE buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>optional arguments to <strong>format</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of characters written to <strong>buf</strong>.</p>
</div>
<dl class="function">
<dt id="c.sysfs_emit_at">
int <code class="sig-name descname">sysfs_emit_at</code><span class="sig-paren">(</span>char<em> *buf</em>, int<em> at</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_emit_at" title="Permalink to this definition">¶</a></dt>
<dd><p>scnprintf equivalent, aware of PAGE_SIZE buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>start of PAGE_SIZE buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">at</span></code></dt><dd><p>offset in <strong>buf</strong> to start write in bytes
<strong>at</strong> must be &gt;= 0 &amp;&amp; &lt; PAGE_SIZE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>optional arguments to <strong>fmt</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of characters written starting at &amp;**buf**[<strong>at</strong>].</p>
</div>
<dl class="function">
<dt id="c.sysfs_create_link">
int <code class="sig-name descname">sysfs_create_link</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct kobject<em> *target</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink between two objects.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object whose directory we’re creating the link in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*target</span></code></dt><dd><p>object we’re pointing to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the symlink.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_create_link_nowarn">
int <code class="sig-name descname">sysfs_create_link_nowarn</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct kobject<em> *target</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_link_nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink between two objects.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object whose directory we’re creating the link in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*target</span></code></dt><dd><p>object we’re pointing to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the symlink.</p>
<p>This function does the same as <a class="reference internal" href="#c.sysfs_create_link" title="sysfs_create_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_create_link()</span></code></a>, but it
doesn’t warn if the link already exists.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_remove_link">
void <code class="sig-name descname">sysfs_remove_link</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove symlink in object’s directory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the symlink to remove.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sysfs_rename_link_ns">
int <code class="sig-name descname">sysfs_rename_link_ns</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct kobject<em> *targ</em>, const char<em> *old</em>, const char<em> *new</em>, const void<em> *new_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_rename_link_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>rename symlink in object’s directory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object we’re acting for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*targ</span></code></dt><dd><p>object we’re pointing to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*old</span></code></dt><dd><p>previous name of the symlink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new</span></code></dt><dd><p>new name of the symlink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*new_ns</span></code></dt><dd><p>new namespace of the symlink.</p>
<p>A helper function for the common rename symlink idiom.</p>
</dd>
</dl>
</div>
</section>
<section id="the-debugfs-filesystem">
<h2>The debugfs filesystem<a class="headerlink" href="#the-debugfs-filesystem" title="Permalink to this headline">¶</a></h2>
<section id="debugfs-interface">
<h3>debugfs interface<a class="headerlink" href="#debugfs-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.debugfs_lookup">
struct dentry * <code class="sig-name descname">debugfs_lookup</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>look up an existing debugfs file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to look up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry of the file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return a pointer to a dentry if it succeeds.  If the file
doesn’t exist or an error occurs, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be returned.  The returned
dentry must be passed to dput() when it is no longer needed.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_file">
struct dentry * <code class="sig-name descname">debugfs_create_file</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, void<em> *data</em>, const struct file_operations<em> *fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>a pointer to a struct file_operations that should be used for
this file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<p><strong>NOTE</strong></p>
<p>it’s expected that most callers should _ignore_ the errors returned
by this function. Other debugfs functions handle the fact that the “dentry”
passed to them could be an error and they don’t crash in that case.
Drivers should generally work fine even if debugfs fails to init anyway.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_file_unsafe">
struct dentry * <code class="sig-name descname">debugfs_create_file_unsafe</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, void<em> *data</em>, const struct file_operations<em> *fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_unsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>a pointer to a struct file_operations that should be used for
this file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.debugfs_create_file_unsafe" title="debugfs_create_file_unsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file_unsafe()</span></code></a> is completely analogous to
<a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file()</span></code></a>, the only difference being that the fops
handed it will not get protected against file removals by the
debugfs core.</p>
<p>It is your responsibility to protect your struct file_operation
methods against file removals by means of <a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a>
and <a class="reference internal" href="#c.debugfs_file_put" title="debugfs_file_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_put()</span></code></a>. -&gt;open() is still protected by
debugfs though.</p>
<p>Any struct file_operations defined by means of
DEFINE_DEBUGFS_ATTRIBUTE() is protected against file removals and
thus, may be used here.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_file_size">
void <code class="sig-name descname">debugfs_create_file_size</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, void<em> *data</em>, const struct file_operations<em> *fops</em>, loff_t<em> file_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_size" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>a pointer to a struct file_operations that should be used for
this file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">file_size</span></code></dt><dd><p>initial file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_dir">
struct dentry * <code class="sig-name descname">debugfs_create_dir</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the directory to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
directory will be created in the root of the debugfs filesystem.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in debugfs with the given name.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<p><strong>NOTE</strong></p>
<p>it’s expected that most callers should _ignore_ the errors returned
by this function. Other debugfs functions handle the fact that the “dentry”
passed to them could be an error and they don’t crash in that case.
Drivers should generally work fine even if debugfs fails to init anyway.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_automount">
struct dentry * <code class="sig-name descname">debugfs_create_automount</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *parent</em>, debugfs_automount_t<em> f</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_automount" title="Permalink to this definition">¶</a></dt>
<dd><p>create automount point in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_automount_t</span> <span class="pre">f</span></code></dt><dd><p>function to be called when pathname resolution steps on that one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque argument to pass to f().</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>f</strong> should return what -&gt;d_automount() would.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_symlink">
struct dentry * <code class="sig-name descname">debugfs_create_symlink</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *parent</em>, const char<em> *target</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symbolic link in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the symbolic link to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this symbolic link.  This
should be a directory dentry if set.  If this parameter is NULL,
then the symbolic link will be created in the root of the debugfs
filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*target</span></code></dt><dd><p>a pointer to a string containing the path to the target of the
symbolic link.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symbolic link with the given name in debugfs that
links to the given target path.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the symbolic
link is to be removed (no automatic cleanup happens if your module is
unloaded, you are responsible here.)  If an error occurs, ERR_PTR(-ERROR)
will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
</div>
<dl class="function">
<dt id="c.debugfs_remove">
void <code class="sig-name descname">debugfs_remove</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>recursively removes a directory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>a pointer to a the dentry of the directory to be removed.  If this
parameter is NULL or an error value, nothing will be done.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function recursively removes a directory tree in debugfs that
was previously created with a call to another debugfs function
(like <a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.</p>
</div>
<dl class="function">
<dt id="c.debugfs_lookup_and_remove">
void <code class="sig-name descname">debugfs_lookup_and_remove</code><span class="sig-paren">(</span>const char<em> *name</em>, struct dentry<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_lookup_and_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a directory or file and recursively remove it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the item to look up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry of the item.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the equlivant of doing something like
debugfs_remove(debugfs_lookup(..)) but with the proper reference counting
handled for the directory being looked up.</p>
</div>
<dl class="function">
<dt id="c.debugfs_rename">
struct dentry * <code class="sig-name descname">debugfs_rename</code><span class="sig-paren">(</span>struct dentry<em> *old_dir</em>, struct dentry<em> *old_dentry</em>, struct dentry<em> *new_dir</em>, const char<em> *new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a file/directory in the debugfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dir</span></code></dt><dd><p>a pointer to the parent dentry for the renamed object. This
should be a directory dentry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>dentry of an object to be renamed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dir</span></code></dt><dd><p>a pointer to the parent dentry where the object should be
moved. This should be a directory dentry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>a pointer to a string containing the target name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function renames a file/directory in debugfs.  The target must not
exist for rename to succeed.</p>
<p>This function will return a pointer to old_dentry (which is updated to
reflect renaming) if it succeeds. If an error occurs, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
</div>
<dl class="function">
<dt id="c.debugfs_initialized">
bool <code class="sig-name descname">debugfs_initialized</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether debugfs has been registered</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_file_get">
int <code class="sig-name descname">debugfs_file_get</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_file_get" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of file data access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry object whose data is being accessed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Up to a matching call to <a class="reference internal" href="#c.debugfs_file_put" title="debugfs_file_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_put()</span></code></a>, any successive call
into the file removing functions <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> and
debugfs_remove_recursive() will block. Since associated private
file data may only get freed after a successful return of any of
the removal functions, you may safely access it after a successful
call to <a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a> without worrying about lifetime issues.</p>
<p>If -<code class="docutils literal notranslate"><span class="pre">EIO</span></code> is returned, the file has already been removed and thus,
it is not safe to access any of its data. If, on the other hand,
it is allowed to access the file data, zero is returned.</p>
</div>
<dl class="function">
<dt id="c.debugfs_file_put">
void <code class="sig-name descname">debugfs_file_put</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_file_put" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the end of file data access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>the dentry object formerly passed to
<a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow any ongoing concurrent call into <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> or
debugfs_remove_recursive() blocked by a former call to
<a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a> to proceed and return to its caller.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_u8">
void <code class="sig-name descname">debugfs_create_u8</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u8<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_u16">
void <code class="sig-name descname">debugfs_create_u16</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u16<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_u32">
void <code class="sig-name descname">debugfs_create_u32</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u32<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_u64">
void <code class="sig-name descname">debugfs_create_u64</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u64<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_ulong">
void <code class="sig-name descname">debugfs_create_ulong</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, unsigned long<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_ulong" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned long value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_x8">
void <code class="sig-name descname">debugfs_create_x8</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u8<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_x16">
void <code class="sig-name descname">debugfs_create_x16</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u16<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_x32">
void <code class="sig-name descname">debugfs_create_x32</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u32<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_x64">
void <code class="sig-name descname">debugfs_create_x64</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, u64<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_size_t">
void <code class="sig-name descname">debugfs_create_size_t</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, size_t<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an size_t value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_atomic_t">
void <code class="sig-name descname">debugfs_create_atomic_t</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, atomic_t<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_atomic_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an atomic_t value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.debugfs_create_bool">
void <code class="sig-name descname">debugfs_create_bool</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, bool<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write a boolean value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*value</span></code></dt><dd><p>a pointer to the variable that the file should read to and write
from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_blob">
struct dentry * <code class="sig-name descname">debugfs_create_blob</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, struct debugfs_blob_wrapper<em> *blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read a binary blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the read permission that the file should have (other permissions are
masked out)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">debugfs_blob_wrapper</span> <span class="pre">*blob</span></code></dt><dd><p>a pointer to a struct debugfs_blob_wrapper which contains a pointer
to the blob data and the size of the data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>blob-&gt;data</strong> as a binary blob. If the <strong>mode</strong> variable is so set it can be
read from. Writing is not supported.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will
be returned.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_u32_array">
void <code class="sig-name descname">debugfs_create_u32_array</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, struct debugfs_u32_array<em> *array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32_array" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read u32 array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">debugfs_u32_array</span> <span class="pre">*array</span></code></dt><dd><p>wrapper struct containing data pointer and size of the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>array</strong> as data. If the <strong>mode</strong> variable is so set it can be read from.
Writing is not supported. Seek within the file is also not supported.
Once array is created its size can not be changed.</p>
</div>
<dl class="function">
<dt id="c.debugfs_print_regs32">
void <code class="sig-name descname">debugfs_print_regs32</code><span class="sig-paren">(</span>struct seq_file<em> *s</em>, const struct debugfs_reg32<em> *regs</em>, int<em> nregs</em>, void __iomem<em> *base</em>, char<em> *prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_print_regs32" title="Permalink to this definition">¶</a></dt>
<dd><p>use seq_print to describe a set of registers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*s</span></code></dt><dd><p>the seq_file structure being used to generate output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">debugfs_reg32</span> <span class="pre">*regs</span></code></dt><dd><p>an array if struct debugfs_reg32 structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nregs</span></code></dt><dd><p>the length of the above array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*base</span></code></dt><dd><p>the base address to be used in reading the registers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>a string to be prefixed to every output line</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function outputs a text block describing the current values of
some 32-bit hardware registers. It is meant to be used within debugfs
files based on seq_file that need to show registers, intermixed with other
information. The prefix argument may be used to specify a leading string,
because some peripherals have several blocks of identical registers,
for example configuration of dma channels</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_regset32">
void <code class="sig-name descname">debugfs_create_regset32</code><span class="sig-paren">(</span>const char<em> *name</em>, umode_t<em> mode</em>, struct dentry<em> *parent</em>, struct debugfs_regset32<em> *regset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_regset32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that returns register values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">debugfs_regset32</span> <span class="pre">*regset</span></code></dt><dd><p>a pointer to a struct debugfs_regset32, which contains a pointer
to an array of register definitions, the array size and the base
address where the register bank is to be found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that reports
the names and values of a set of 32-bit registers. If the <strong>mode</strong> variable
is so set it can be read from. Writing is not supported.</p>
</div>
<dl class="function">
<dt id="c.debugfs_create_devm_seqfile">
void <code class="sig-name descname">debugfs_create_devm_seqfile</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *name</em>, struct dentry<em> *parent</em>, int (<em>*read_fn</em>)(struct seq_file *s, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_devm_seqfile" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is bound to device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device related to this debugfs file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the debugfs file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*read_fn)(struct</span> <span class="pre">seq_file</span> <span class="pre">*s,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function pointer called to print the seq_file content.</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Linux Filesystems API summary</a><ul>
<li><a class="reference internal" href="#the-linux-vfs">The Linux VFS</a><ul>
<li><a class="reference internal" href="#the-filesystem-types">The Filesystem types</a></li>
<li><a class="reference internal" href="#the-directory-cache">The Directory Cache</a></li>
<li><a class="reference internal" href="#inode-handling">Inode Handling</a></li>
<li><a class="reference internal" href="#registration-and-superblocks">Registration and Superblocks</a></li>
<li><a class="reference internal" href="#file-locks">File Locks</a></li>
<li><a class="reference internal" href="#other-functions">Other Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-proc-filesystem">The proc filesystem</a><ul>
<li><a class="reference internal" href="#sysctl-interface">sysctl interface</a></li>
<li><a class="reference internal" href="#proc-filesystem-interface">proc filesystem interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#events-based-on-file-descriptors">Events based on file descriptors</a></li>
<li><a class="reference internal" href="#eventpoll-epoll-interfaces">eventpoll (epoll) interfaces</a></li>
<li><a class="reference internal" href="#the-filesystem-for-exporting-kernel-objects">The Filesystem for Exporting Kernel Objects</a></li>
<li><a class="reference internal" href="#the-debugfs-filesystem">The debugfs filesystem</a><ul>
<li><a class="reference internal" href="#debugfs-interface">debugfs interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/api-summary.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/api-summary.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>