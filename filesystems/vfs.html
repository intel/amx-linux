
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Overview of the Linux Virtual File System &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pathname lookup" href="path-lookup.html" />
    <link rel="prev" title="Filesystems in the Linux kernel" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="overview-of-the-linux-virtual-file-system">
<h1>Overview of the Linux Virtual File System<a class="headerlink" href="#overview-of-the-linux-virtual-file-system" title="Permalink to this headline">¶</a></h1>
<p>Original author: Richard Gooch &lt;<a class="reference external" href="mailto:rgooch&#37;&#52;&#48;atnf&#46;csiro&#46;au">rgooch<span>&#64;</span>atnf<span>&#46;</span>csiro<span>&#46;</span>au</a>&gt;</p>
<ul class="simple">
<li><p>Copyright (C) 1999 Richard Gooch</p></li>
<li><p>Copyright (C) 2005 Pekka Enberg</p></li>
</ul>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Virtual File System (also known as the Virtual Filesystem Switch) is
the software layer in the kernel that provides the filesystem interface
to userspace programs.  It also provides an abstraction within the
kernel which allows different filesystem implementations to coexist.</p>
<p>VFS system calls open(2), stat(2), read(2), write(2), chmod(2) and so on
are called from a process context.  Filesystem locking is described in
the document <a class="reference internal" href="locking.html"><span class="doc">Locking</span></a>.</p>
<section id="directory-entry-cache-dcache">
<h3>Directory Entry Cache (dcache)<a class="headerlink" href="#directory-entry-cache-dcache" title="Permalink to this headline">¶</a></h3>
<p>The VFS implements the open(2), stat(2), chmod(2), and similar system
calls.  The pathname argument that is passed to them is used by the VFS
to search through the directory entry cache (also known as the dentry
cache or dcache).  This provides a very fast look-up mechanism to
translate a pathname (filename) into a specific dentry.  Dentries live
in RAM and are never saved to disc: they exist only for performance.</p>
<p>The dentry cache is meant to be a view into your entire filespace.  As
most computers cannot fit all dentries in the RAM at the same time, some
bits of the cache are missing.  In order to resolve your pathname into a
dentry, the VFS may have to resort to creating dentries along the way,
and then loading the inode.  This is done by looking up the inode.</p>
</section>
<section id="the-inode-object">
<h3>The Inode Object<a class="headerlink" href="#the-inode-object" title="Permalink to this headline">¶</a></h3>
<p>An individual dentry usually has a pointer to an inode.  Inodes are
filesystem objects such as regular files, directories, FIFOs and other
beasts.  They live either on the disc (for block device filesystems) or
in the memory (for pseudo filesystems).  Inodes that live on the disc
are copied into the memory when required and changes to the inode are
written back to disc.  A single inode can be pointed to by multiple
dentries (hard links, for example, do this).</p>
<p>To look up an inode requires that the VFS calls the lookup() method of
the parent directory inode.  This method is installed by the specific
filesystem implementation that the inode lives in.  Once the VFS has the
required dentry (and hence the inode), we can do all those boring things
like open(2) the file, or stat(2) it to peek at the inode data.  The
stat(2) operation is fairly simple: once the VFS has the dentry, it
peeks at the inode data and passes some of it back to userspace.</p>
</section>
<section id="the-file-object">
<h3>The File Object<a class="headerlink" href="#the-file-object" title="Permalink to this headline">¶</a></h3>
<p>Opening a file requires another operation: allocation of a file
structure (this is the kernel-side implementation of file descriptors).
The freshly allocated file structure is initialized with a pointer to
the dentry and a set of file operation member functions.  These are
taken from the inode data.  The open() file method is then called so the
specific filesystem implementation can do its work.  You can see that
this is another switch performed by the VFS.  The file structure is
placed into the file descriptor table for the process.</p>
<p>Reading, writing and closing files (and other assorted VFS operations)
is done by using the userspace file descriptor to grab the appropriate
file structure, and then calling the required file structure method to
do whatever is required.  For as long as the file is open, it keeps the
dentry in use, which in turn means that the VFS inode is still in use.</p>
</section>
</section>
<section id="registering-and-mounting-a-filesystem">
<h2>Registering and Mounting a Filesystem<a class="headerlink" href="#registering-and-mounting-a-filesystem" title="Permalink to this headline">¶</a></h2>
<p>To register and unregister a filesystem, use the following API
functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">register_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">unregister_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The passed struct file_system_type describes your filesystem.  When a
request is made to mount a filesystem onto a directory in your
namespace, the VFS will call the appropriate mount() method for the
specific filesystem.  New vfsmount referring to the tree returned by
-&gt;mount() will be attached to the mountpoint, so that when pathname
resolution reaches the mountpoint it will jump into the root of that
vfsmount.</p>
<p>You can see all filesystems that are registered to the kernel in the
file /proc/filesystems.</p>
<section id="struct-file-system-type">
<h3>struct file_system_type<a class="headerlink" href="#struct-file-system-type" title="Permalink to this headline">¶</a></h3>
<p>This describes the filesystem.  As of kernel 2.6.39, the following
members are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">fs_flags</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">fs_supers</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_lock_key</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_umount_key</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>the name of the filesystem type, such as “ext2”, “iso9660”,
“msdos” and so on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_flags</span></code></dt><dd><p>various flags (i.e. FS_REQUIRES_DEV, FS_NO_DCACHE, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mount</span></code></dt><dd><p>the method to call when a new instance of this filesystem should
be mounted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kill_sb</span></code></dt><dd><p>the method to call when an instance of this filesystem should be
shut down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>for internal VFS use: you should initialize this to THIS_MODULE
in most cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><blockquote>
<div><p>for internal VFS use: you should initialize this to NULL</p>
</div></blockquote>
<p>s_lock_key, s_umount_key: lockdep-specific</p>
</dd>
</dl>
<p>The mount() method has the following arguments:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*fs_type</span></code></dt><dd><p>describes the filesystem, partly initialized by the specific
filesystem code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>mount flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*dev_name</span></code></dt><dd><p>the device name we are mounting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>arbitrary mount options, usually comes as an ASCII string (see
“Mount Options” section)</p>
</dd>
</dl>
<p>The mount() method must return the root dentry of the tree requested by
caller.  An active reference to its superblock must be grabbed and the
superblock must be locked.  On failure it should return ERR_PTR(error).</p>
<p>The arguments match those of mount(2) and their interpretation depends
on filesystem type.  E.g. for block filesystems, dev_name is interpreted
as block device name, that device is opened and if it contains a
suitable filesystem image the method creates and initializes struct
super_block accordingly, returning its root dentry to caller.</p>
<p>-&gt;mount() may choose to return a subtree of existing filesystem - it
doesn’t have to create a new one.  The main result from the caller’s
point of view is a reference to dentry at the root of (sub)tree to be
attached; creation of new superblock is a common side effect.</p>
<p>The most interesting member of the superblock structure that the mount()
method fills in is the “s_op” field.  This is a pointer to a “struct
super_operations” which describes the next level of the filesystem
implementation.</p>
<p>Usually, a filesystem uses one of the generic mount() implementations
and provides a fill_super() callback instead.  The generic variants are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mount_bdev</span></code></dt><dd><p>mount a filesystem residing on a block device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mount_nodev</span></code></dt><dd><p>mount a filesystem that is not backed by a device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mount_single</span></code></dt><dd><p>mount a filesystem which shares the instance between all mounts</p>
</dd>
</dl>
<p>A fill_super() callback implementation has the following arguments:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock structure.  The callback must initialize this
properly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>arbitrary mount options, usually comes as an ASCII string (see
“Mount Options” section)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">silent</span></code></dt><dd><p>whether or not to be silent on error</p>
</dd>
</dl>
</section>
</section>
<section id="the-superblock-object">
<h2>The Superblock Object<a class="headerlink" href="#the-superblock-object" title="Permalink to this headline">¶</a></h2>
<p>A superblock object represents a mounted filesystem.</p>
<section id="struct-super-operations">
<h3>struct super_operations<a class="headerlink" href="#struct-super-operations" title="Permalink to this headline">¶</a></h3>
<p>This describes how the VFS can manipulate the superblock of your
filesystem.  As of kernel 2.6.22, the following members are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">super_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">sb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">delete_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">sb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">kstatfs</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clear_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_options</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_read</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_write</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nr_cached_objects</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">free_cached_objects</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>All methods are called without any locks being held, unless otherwise
noted.  This means that most methods can block safely.  All methods are
only called from a process context (i.e. not from an interrupt handler
or bottom half).</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">alloc_inode</span></code></dt><dd><p>this method is called by alloc_inode() to allocate memory for
struct inode and initialize it.  If this function is not
defined, a simple ‘struct inode’ is allocated.  Normally
alloc_inode will be used to allocate a larger structure which
contains a ‘struct inode’ embedded within it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_inode</span></code></dt><dd><p>this method is called by destroy_inode() to release resources
allocated for struct inode.  It is only required if
-&gt;alloc_inode was defined and simply undoes anything done by
-&gt;alloc_inode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty_inode</span></code></dt><dd><p>this method is called by the VFS when an inode is marked dirty.
This is specifically for the inode itself being marked dirty,
not its data.  If the update needs to be persisted by fdatasync(),
then I_DIRTY_DATASYNC will be set in the flags argument.
I_DIRTY_TIME will be set in the flags in case lazytime is enabled
and struct inode has times updated since the last -&gt;dirty_inode
call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_inode</span></code></dt><dd><p>this method is called when the VFS needs to write an inode to
disc.  The second parameter indicates whether the write should
be synchronous or not, not all filesystems check this flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drop_inode</span></code></dt><dd><p>called when the last access to the inode is dropped, with the
inode-&gt;i_lock spinlock held.</p>
<p>This method should be either NULL (normal UNIX filesystem
semantics) or “generic_delete_inode” (for filesystems that do
not want to cache inodes - causing “delete_inode” to always be
called regardless of the value of i_nlink)</p>
<p>The “generic_delete_inode()” behavior is equivalent to the old
practice of using “force_delete” in the put_inode() case, but
does not have the races that the “force_delete()” approach had.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delete_inode</span></code></dt><dd><p>called when the VFS wants to delete an inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_super</span></code></dt><dd><p>called when the VFS wishes to free the superblock
(i.e. unmount).  This is called with the superblock lock held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_fs</span></code></dt><dd><p>called when VFS is writing out all dirty data associated with a
superblock.  The second parameter indicates whether the method
should wait until the write out has been completed.  Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freeze_fs</span></code></dt><dd><p>called when VFS is locking a filesystem and forcing it into a
consistent state.  This method is currently used by the Logical
Volume Manager (LVM).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unfreeze_fs</span></code></dt><dd><p>called when VFS is unlocking a filesystem and making it writable
again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">statfs</span></code></dt><dd><p>called when the VFS needs to get filesystem statistics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remount_fs</span></code></dt><dd><p>called when the filesystem is remounted.  This is called with
the kernel lock held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clear_inode</span></code></dt><dd><p>called then the VFS clears the inode.  Optional</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umount_begin</span></code></dt><dd><p>called when the VFS is unmounting a filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show_options</span></code></dt><dd><p>called by the VFS to show mount options for /proc/&lt;pid&gt;/mounts.
(see “Mount Options” section)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quota_read</span></code></dt><dd><p>called by the VFS to read from filesystem quota file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quota_write</span></code></dt><dd><p>called by the VFS to write to filesystem quota file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_cached_objects</span></code></dt><dd><p>called by the sb cache shrinking function for the filesystem to
return the number of freeable cached objects it contains.
Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_cache_objects</span></code></dt><dd><p>called by the sb cache shrinking function for the filesystem to
scan the number of objects indicated to try to free them.
Optional, but any filesystem implementing this method needs to
also implement -&gt;nr_cached_objects for it to be called
correctly.</p>
<p>We can’t do anything with any errors that the filesystem might
encountered, hence the void return type.  This will never be
called if the VM is trying to reclaim under GFP_NOFS conditions,
hence this method does not need to handle that situation itself.</p>
<p>Implementations must include conditional reschedule calls inside
any scanning loop that is done.  This allows the VFS to
determine appropriate scan batch sizes without having to worry
about whether implementations will cause holdoff problems due to
large scan batch sizes.</p>
</dd>
</dl>
<p>Whoever sets up the inode is responsible for filling in the “i_op”
field.  This is a pointer to a “struct inode_operations” which describes
the methods that can be performed on individual inodes.</p>
</section>
<section id="struct-xattr-handlers">
<h3>struct xattr_handlers<a class="headerlink" href="#struct-xattr-handlers" title="Permalink to this headline">¶</a></h3>
<p>On filesystems that support extended attributes (xattrs), the s_xattr
superblock field points to a NULL-terminated array of xattr handlers.
Extended attributes are name:value pairs.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Indicates that the handler matches attributes with the specified
name (such as “system.posix_acl_access”); the prefix field must
be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefix</span></code></dt><dd><p>Indicates that the handler matches all attributes with the
specified name prefix (such as “user.”); the name field must be
NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Determine if attributes matching this xattr handler should be
listed for a particular dentry.  Used by some listxattr
implementations like generic_listxattr.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>Called by the VFS to get the value of a particular extended
attribute.  This method is called by the getxattr(2) system
call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>Called by the VFS to set the value of a particular extended
attribute.  When the new value is NULL, called to remove a
particular extended attribute.  This method is called by the
setxattr(2) and removexattr(2) system calls.</p>
</dd>
</dl>
<p>When none of the xattr handlers of a filesystem match the specified
attribute name or when a filesystem doesn’t support extended attributes,
the various <code class="docutils literal notranslate"><span class="pre">*xattr(2)</span></code> system calls return -EOPNOTSUPP.</p>
</section>
</section>
<section id="id1">
<h2>The Inode Object<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>An inode object represents an object within the filesystem.</p>
<section id="struct-inode-operations">
<h3>struct inode_operations<a class="headerlink" href="#struct-inode-operations" title="Permalink to this headline">¶</a></h3>
<p>This describes how the VFS can manipulate an inode in your filesystem.
As of kernel 2.6.22, the following members are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">inode_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">umode_t</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">symlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="n">umode_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rmdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mknod</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="n">umode_t</span><span class="p">,</span><span class="kt">dev_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">readlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">struct</span> <span class="nc">delayed_call</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">permission</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">posix_acl</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_inode_acl</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iattr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">kstat</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">listxattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">update_time</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">timespec</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">atomic_open</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">open_flag</span><span class="p">,</span><span class="w"> </span><span class="n">umode_t</span><span class="w"> </span><span class="n">create_mode</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">tmpfile</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">umode_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">posix_acl</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_acl</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_acl</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">posix_acl</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fileattr_set</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">mnt_userns</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">dentry</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">fileattr</span><span class="w"> </span><span class="o">*</span><span class="n">fa</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fileattr_get</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">dentry</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">fileattr</span><span class="w"> </span><span class="o">*</span><span class="n">fa</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Again, all methods are called without any locks being held, unless
otherwise noted.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">create</span></code></dt><dd><p>called by the open(2) and creat(2) system calls.  Only required
if you want to support regular files.  The dentry you get should
not have an inode (i.e. it should be a negative dentry).  Here
you will probably call <a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> with the dentry and the
newly created inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lookup</span></code></dt><dd><p>called when the VFS needs to look up an inode in a parent
directory.  The name to look for is found in the dentry.  This
method must call <a class="reference internal" href="api-summary.html#c.d_add" title="d_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_add()</span></code></a> to insert the found inode into the
dentry.  The “i_count” field in the inode structure should be
incremented.  If the named inode does not exist a NULL inode
should be inserted into the dentry (this is called a negative
dentry).  Returning an error code from this routine must only be
done on a real error, otherwise creating inodes with system
calls like create(2), mknod(2), mkdir(2) and so on will fail.
If you wish to overload the dentry methods then you should
initialise the “d_dop” field in the dentry; this is a pointer to
a struct “dentry_operations”.  This method is called with the
directory inode semaphore held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>called by the link(2) system call.  Only required if you want to
support hard links.  You will probably need to call
<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> just as you would in the create() method</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlink</span></code></dt><dd><p>called by the unlink(2) system call.  Only required if you want
to support deleting inodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symlink</span></code></dt><dd><p>called by the symlink(2) system call.  Only required if you want
to support symlinks.  You will probably need to call
<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> just as you would in the create() method</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mkdir</span></code></dt><dd><p>called by the mkdir(2) system call.  Only required if you want
to support creating subdirectories.  You will probably need to
call <a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> just as you would in the create() method</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmdir</span></code></dt><dd><p>called by the rmdir(2) system call.  Only required if you want
to support deleting subdirectories</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mknod</span></code></dt><dd><p>called by the mknod(2) system call to create a device (char,
block) inode or a named pipe (FIFO) or socket.  Only required if
you want to support creating these types of inodes.  You will
probably need to call <a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> just as you would in the
create() method</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rename</span></code></dt><dd><p>called by the rename(2) system call to rename the object to have
the parent and name given by the second inode and dentry.</p>
<p>The filesystem must return -EINVAL for any unsupported or
unknown flags.  Currently the following flags are implemented:
(1) RENAME_NOREPLACE: this flag indicates that if the target of
the rename exists the rename should fail with -EEXIST instead of
replacing the target.  The VFS already checks for existence, so
for local filesystems the RENAME_NOREPLACE implementation is
equivalent to plain rename.
(2) RENAME_EXCHANGE: exchange source and target.  Both must
exist; this is checked by the VFS.  Unlike plain rename, source
and target may be of different type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_link</span></code></dt><dd><p>called by the VFS to follow a symbolic link to the inode it
points to.  Only required if you want to support symbolic links.
This method returns the symlink body to traverse (and possibly
resets the current position with nd_jump_link()).  If the body
won’t go away until the inode is gone, nothing else is needed;
if it needs to be otherwise pinned, arrange for its release by
having get_link(…, …, done) do set_delayed_call(done,
destructor, argument).  In that case destructor(argument) will
be called once VFS is done with the body you’ve returned.  May
be called in RCU mode; that is indicated by NULL dentry
argument.  If request can’t be handled without leaving RCU mode,
have it return ERR_PTR(-ECHILD).</p>
<p>If the filesystem stores the symlink target in -&gt;i_link, the
VFS may use it directly without calling -&gt;get_link(); however,
-&gt;get_link() must still be provided.  -&gt;i_link must not be
freed until after an RCU grace period.  Writing to -&gt;i_link
post-iget() time requires a ‘release’ memory barrier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">readlink</span></code></dt><dd><p>this is now just an override for use by readlink(2) for the
cases when -&gt;get_link uses nd_jump_link() or object is not in
fact a symlink.  Normally filesystems should only implement
-&gt;get_link for symlinks and readlink(2) will automatically use
that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">permission</span></code></dt><dd><p>called by the VFS to check for access rights on a POSIX-like
filesystem.</p>
<p>May be called in rcu-walk mode (mask &amp; MAY_NOT_BLOCK).  If in
rcu-walk mode, the filesystem must check the permission without
blocking or storing to the inode.</p>
<p>If a situation is encountered that rcu-walk cannot handle,
return
-ECHILD and it will be called again in ref-walk mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setattr</span></code></dt><dd><p>called by the VFS to set attributes for a file.  This method is
called by chmod(2) and related system calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">getattr</span></code></dt><dd><p>called by the VFS to get attributes of a file.  This method is
called by stat(2) and related system calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">listxattr</span></code></dt><dd><p>called by the VFS to list all extended attributes for a given
file.  This method is called by the listxattr(2) system call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_time</span></code></dt><dd><p>called by the VFS to update a specific time or the i_version of
an inode.  If this is not defined the VFS will update the inode
itself and call mark_inode_dirty_sync.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_open</span></code></dt><dd><p>called on the last component of an open.  Using this optional
method the filesystem can look up, possibly create and open the
file in one atomic operation.  If it wants to leave actual
opening to the caller (e.g. if the file turned out to be a
symlink, device, or just something filesystem won’t do atomic
open for), it may signal this by returning finish_no_open(file,
dentry).  This method is only called if the last component is
negative or needs lookup.  Cached positive dentries are still
handled by f_op-&gt;open().  If the file was created, FMODE_CREATED
flag should be set in file-&gt;f_mode.  In case of O_EXCL the
method must only succeed if the file didn’t exist and hence
FMODE_CREATED shall always be set on success.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmpfile</span></code></dt><dd><p>called in the end of O_TMPFILE open().  Optional, equivalent to
atomically creating, opening and unlinking a file in given
directory.  On success needs to return with the file already
open; this can be done by calling finish_open_simple() right at
the end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fileattr_get</span></code></dt><dd><p>called on ioctl(FS_IOC_GETFLAGS) and ioctl(FS_IOC_FSGETXATTR) to
retrieve miscellaneous file flags and attributes.  Also called
before the relevant SET operation to check what is being changed
(in this case with i_rwsem locked exclusive).  If unset, then
fall back to f_op-&gt;ioctl().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fileattr_set</span></code></dt><dd><p>called on ioctl(FS_IOC_SETFLAGS) and ioctl(FS_IOC_FSSETXATTR) to
change miscellaneous file flags and attributes.  Callers hold
i_rwsem exclusive.  If unset, then fall back to f_op-&gt;ioctl().</p>
</dd>
</dl>
</section>
</section>
<section id="the-address-space-object">
<h2>The Address Space Object<a class="headerlink" href="#the-address-space-object" title="Permalink to this headline">¶</a></h2>
<p>The address space object is used to group and manage pages in the page
cache.  It can be used to keep track of the pages in a file (or anything
else) and also track the mapping of sections of the file into process
address spaces.</p>
<p>There are a number of distinct yet related services that an
address-space can provide.  These include communicating memory pressure,
page lookup by address, and keeping track of pages tagged as Dirty or
Writeback.</p>
<p>The first can be used independently to the others.  The VM can try to
either write dirty pages in order to clean them, or release clean pages
in order to reuse them.  To do this it can call the -&gt;writepage method
on dirty pages, and -&gt;release_folio on clean folios with the private
flag set.  Clean pages without PagePrivate and with no external references
will be released without notice being given to the address_space.</p>
<p>To achieve this functionality, pages need to be placed on an LRU with
lru_cache_add and mark_page_active needs to be called whenever the page
is used.</p>
<p>Pages are normally kept in a radix tree index by -&gt;index.  This tree
maintains information about the PG_Dirty and PG_Writeback status of each
page, so that pages with either of these flags can be found quickly.</p>
<p>The Dirty tag is primarily used by mpage_writepages - the default
-&gt;writepages method.  It uses the tag to find dirty pages to call
-&gt;writepage on.  If mpage_writepages is not used (i.e. the address
provides its own -&gt;writepages) , the PAGECACHE_TAG_DIRTY tag is almost
unused.  write_inode_now and sync_inode do use it (through
__sync_single_inode) to check if -&gt;writepages has been successful in
writing out the whole address_space.</p>
<p>The Writeback tag is used by filemap*wait* and sync_page* functions, via
filemap_fdatawait_range, to wait for all writeback to complete.</p>
<p>An address_space handler may attach extra information to a page,
typically using the ‘private’ field in the ‘struct page’.  If such
information is attached, the PG_Private flag should be set.  This will
cause various VM routines to make extra calls into the address_space
handler to deal with that data.</p>
<p>An address space acts as an intermediate between storage and
application.  Data is read into the address space a whole page at a
time, and provided to the application either by copying of the page, or
by memory-mapping the page.  Data is written into the address space by
the application, and then written-back to storage typically in whole
pages, however the address_space has finer control of write sizes.</p>
<p>The read process essentially only requires ‘read_folio’.  The write
process is more complicated and uses write_begin/write_end or
dirty_folio to write data into the address_space, and writepage and
writepages to writeback data to storage.</p>
<p>Adding and removing pages to/from an address_space is protected by the
inode’s i_mutex.</p>
<p>When data is written to a page, the PG_Dirty flag should be set.  It
typically remains set until writepage asks for it to be written.  This
should clear PG_Dirty and set PG_Writeback.  It can be actually written
at any point after PG_Dirty is clear.  Once it is known to be safe,
PG_Writeback is cleared.</p>
<p>Writeback makes use of a writeback_control structure to direct the
operations.  This gives the writepage and writepages operations some
information about the nature of and reason for the writeback request,
and the constraints under which it is being done.  It is also used to
return information back to the caller about the result of a writepage or
writepages request.</p>
<section id="handling-errors-during-writeback">
<h3>Handling errors during writeback<a class="headerlink" href="#handling-errors-during-writeback" title="Permalink to this headline">¶</a></h3>
<p>Most applications that do buffered I/O will periodically call a file
synchronization call (fsync, fdatasync, msync or sync_file_range) to
ensure that data written has made it to the backing store.  When there
is an error during writeback, they expect that error to be reported when
a file sync request is made.  After an error has been reported on one
request, subsequent requests on the same file descriptor should return
0, unless further writeback errors have occurred since the previous file
syncronization.</p>
<p>Ideally, the kernel would report errors only on file descriptions on
which writes were done that subsequently failed to be written back.  The
generic pagecache infrastructure does not track the file descriptions
that have dirtied each individual page however, so determining which
file descriptors should get back an error is not possible.</p>
<p>Instead, the generic writeback error tracking infrastructure in the
kernel settles for reporting errors to fsync on all file descriptions
that were open at the time that the error occurred.  In a situation with
multiple writers, all of them will get back an error on a subsequent
fsync, even if all of the writes done through that particular file
descriptor succeeded (or even if there were no writes on that file
descriptor at all).</p>
<p>Filesystems that wish to use this infrastructure should call
mapping_set_error to record the error in the address_space when it
occurs.  Then, after writing back data from the pagecache in their
file-&gt;fsync operation, they should call file_check_and_advance_wb_err to
ensure that the struct file’s error cursor has advanced to the correct
point in the stream of errors emitted by the backing device(s).</p>
</section>
<section id="struct-address-space-operations">
<h3>struct address_space_operations<a class="headerlink" href="#struct-address-space-operations" title="Permalink to this headline">¶</a></h3>
<p>This describes how the VFS can manipulate mapping of a file to page
cache in your filesystem.  The following members are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">address_space_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">writepage</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">writeback_control</span><span class="w"> </span><span class="o">*</span><span class="n">wbc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read_folio</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">writepages</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">writeback_control</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">dirty_folio</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">readahead</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">readahead_control</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_begin</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="n">mapping</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">**</span><span class="n">pagep</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">fsdata</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_end</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="n">mapping</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">copied</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fsdata</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">sector_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">sector_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">invalidate_folio</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release_folio</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">free_folio</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">direct_IO</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">migrate_folio</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">mapping</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">migrate_mode</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">launder_folio</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">is_partially_uptodate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">is_dirty_writeback</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">error_remove_page</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">mapping</span><span class="w"> </span><span class="o">*</span><span class="n">mapping</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">swap_activate</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">swap_info_struct</span><span class="w"> </span><span class="o">*</span><span class="n">sis</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">sector_t</span><span class="w"> </span><span class="o">*</span><span class="n">span</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">swap_deactivate</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">swap_rw</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">writepage</span></code></dt><dd><p>called by the VM to write a dirty page to backing store.  This
may happen for data integrity reasons (i.e. ‘sync’), or to free
up memory (flush).  The difference can be seen in
wbc-&gt;sync_mode.  The PG_Dirty flag has been cleared and
PageLocked is true.  writepage should start writeout, should set
PG_Writeback, and should make sure the page is unlocked, either
synchronously or asynchronously when the write operation
completes.</p>
<p>If wbc-&gt;sync_mode is WB_SYNC_NONE, -&gt;writepage doesn’t have to
try too hard if there are problems, and may choose to write out
other pages from the mapping if that is easier (e.g. due to
internal dependencies).  If it chooses not to start writeout, it
should return AOP_WRITEPAGE_ACTIVATE so that the VM will not
keep calling -&gt;writepage on that page.</p>
<p>See the file “Locking” for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_folio</span></code></dt><dd><p>Called by the page cache to read a folio from the backing store.
The ‘file’ argument supplies authentication information to network
filesystems, and is generally not used by block based filesystems.
It may be NULL if the caller does not have an open file (eg if
the kernel is performing a read for itself rather than on behalf
of a userspace process with an open file).</p>
<p>If the mapping does not support large folios, the folio will
contain a single page.  The folio will be locked when read_folio
is called.  If the read completes successfully, the folio should
be marked uptodate.  The filesystem should unlock the folio
once the read has completed, whether it was successful or not.
The filesystem does not need to modify the refcount on the folio;
the page cache holds a reference count and that will not be
released until the folio is unlocked.</p>
<p>Filesystems may implement -&gt;read_folio() synchronously.
In normal operation, folios are read through the -&gt;readahead()
method.  Only if this fails, or if the caller needs to wait for
the read to complete will the page cache call -&gt;read_folio().
Filesystems should not attempt to perform their own readahead
in the -&gt;read_folio() operation.</p>
<p>If the filesystem cannot perform the read at this time, it can
unlock the folio, do whatever action it needs to ensure that the
read will succeed in the future and return AOP_TRUNCATED_PAGE.
In this case, the caller should look up the folio, lock it,
and call -&gt;read_folio again.</p>
<p>Callers may invoke the -&gt;read_folio() method directly, but using
read_mapping_folio() will take care of locking, waiting for the
read to complete and handle cases such as AOP_TRUNCATED_PAGE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writepages</span></code></dt><dd><p>called by the VM to write out pages associated with the
address_space object.  If wbc-&gt;sync_mode is WB_SYNC_ALL, then
the writeback_control will specify a range of pages that must be
written out.  If it is WB_SYNC_NONE, then a nr_to_write is
given and that many pages should be written if possible.  If no
-&gt;writepages is given, then mpage_writepages is used instead.
This will choose pages from the address space that are tagged as
DIRTY and will pass them to -&gt;writepage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty_folio</span></code></dt><dd><p>called by the VM to mark a folio as dirty.  This is particularly
needed if an address space attaches private data to a folio, and
that data needs to be updated when a folio is dirtied.  This is
called, for example, when a memory mapped page gets modified.
If defined, it should set the folio dirty flag, and the
PAGECACHE_TAG_DIRTY search mark in i_pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">readahead</span></code></dt><dd><p>Called by the VM to read pages associated with the address_space
object.  The pages are consecutive in the page cache and are
locked.  The implementation should decrement the page refcount
after starting I/O on each page.  Usually the page will be
unlocked by the I/O completion handler.  The set of pages are
divided into some sync pages followed by some async pages,
rac-&gt;ra-&gt;async_size gives the number of async pages.  The
filesystem should attempt to read all sync pages but may decide
to stop once it reaches the async pages.  If it does decide to
stop attempting I/O, it can simply return.  The caller will
remove the remaining pages from the address space, unlock them
and decrement the page refcount.  Set PageUptodate if the I/O
completes successfully.  Setting PageError on any page will be
ignored; simply unlock the page if an I/O error occurs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_begin</span></code></dt><dd><p>Called by the generic buffered write code to ask the filesystem
to prepare to write len bytes at the given offset in the file.
The address_space should check that the write will be able to
complete, by allocating space if necessary and doing any other
internal housekeeping.  If the write will update parts of any
basic-blocks on storage, then those blocks should be pre-read
(if they haven’t been read already) so that the updated blocks
can be written out properly.</p>
<p>The filesystem must return the locked pagecache page for the
specified offset, in <code class="docutils literal notranslate"><span class="pre">*pagep</span></code>, for the caller to write into.</p>
<p>It must be able to cope with short writes (where the length
passed to write_begin is greater than the number of bytes copied
into the page).</p>
<p>A void * may be returned in fsdata, which then gets passed into
write_end.</p>
<p>Returns 0 on success; &lt; 0 on failure (which is the error code),
in which case write_end is not called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_end</span></code></dt><dd><p>After a successful write_begin, and data copy, write_end must be
called.  len is the original len passed to write_begin, and
copied is the amount that was able to be copied.</p>
<p>The filesystem must take care of unlocking the page and
releasing it refcount, and updating i_size.</p>
<p>Returns &lt; 0 on failure, otherwise the number of bytes (&lt;=
‘copied’) that were able to be copied into pagecache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bmap</span></code></dt><dd><p>called by the VFS to map a logical block offset within object to
physical block number.  This method is used by the FIBMAP ioctl
and for working with swap-files.  To be able to swap to a file,
the file must have a stable mapping to a block device.  The swap
system does not go through the filesystem but instead uses bmap
to find out where the blocks in the file are and uses those
addresses directly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invalidate_folio</span></code></dt><dd><p>If a folio has private data, then invalidate_folio will be
called when part or all of the folio is to be removed from the
address space.  This generally corresponds to either a
truncation, punch hole or a complete invalidation of the address
space (in the latter case ‘offset’ will always be 0 and ‘length’
will be <a class="reference internal" href="../core-api/mm-api.html#c.folio_size" title="folio_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_size()</span></code></a>).  Any private data associated with the folio
should be updated to reflect this truncation.  If offset is 0
and length is <a class="reference internal" href="../core-api/mm-api.html#c.folio_size" title="folio_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_size()</span></code></a>, then the private data should be
released, because the folio must be able to be completely
discarded.  This may be done by calling the -&gt;release_folio
function, but in this case the release MUST succeed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_folio</span></code></dt><dd><p>release_folio is called on folios with private data to tell the
filesystem that the folio is about to be freed.  -&gt;release_folio
should remove any private data from the folio and clear the
private flag.  If release_folio() fails, it should return false.
release_folio() is used in two distinct though related cases.
The first is when the VM wants to free a clean folio with no
active users.  If -&gt;release_folio succeeds, the folio will be
removed from the address_space and be freed.</p>
<p>The second case is when a request has been made to invalidate
some or all folios in an address_space.  This can happen
through the fadvise(POSIX_FADV_DONTNEED) system call or by the
filesystem explicitly requesting it as nfs and 9p do (when they
believe the cache may be out of date with storage) by calling
<a class="reference internal" href="../core-api/mm-api.html#c.invalidate_inode_pages2" title="invalidate_inode_pages2"><code class="xref c c-func docutils literal notranslate"><span class="pre">invalidate_inode_pages2()</span></code></a>.  If the filesystem makes such a call,
and needs to be certain that all folios are invalidated, then
its release_folio will need to ensure this.  Possibly it can
clear the uptodate flag if it cannot free private data yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_folio</span></code></dt><dd><p>free_folio is called once the folio is no longer visible in the
page cache in order to allow the cleanup of any private data.
Since it may be called by the memory reclaimer, it should not
assume that the original address_space mapping still exists, and
it should not block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direct_IO</span></code></dt><dd><p>called by the generic read/write routines to perform direct_IO -
that is IO requests which bypass the page cache and transfer
data directly between the storage and the application’s address
space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">migrate_folio</span></code></dt><dd><p>This is used to compact the physical memory usage.  If the VM
wants to relocate a folio (maybe from a memory device that is
signalling imminent failure) it will pass a new folio and an old
folio to this function.  migrate_folio should transfer any private
data across and update any references that it has to the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">launder_folio</span></code></dt><dd><p>Called before freeing a folio - it writes back the dirty folio.
To prevent redirtying the folio, it is kept locked during the
whole operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_partially_uptodate</span></code></dt><dd><p>Called by the VM when reading a file through the pagecache when
the underlying blocksize is smaller than the size of the folio.
If the required block is up to date then the read can complete
without needing I/O to bring the whole page up to date.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_dirty_writeback</span></code></dt><dd><p>Called by the VM when attempting to reclaim a folio.  The VM uses
dirty and writeback information to determine if it needs to
stall to allow flushers a chance to complete some IO.
Ordinarily it can use folio_test_dirty and folio_test_writeback but
some filesystems have more complex state (unstable folios in NFS
prevent reclaim) or do not set those flags due to locking
problems.  This callback allows a filesystem to indicate to the
VM if a folio should be treated as dirty or writeback for the
purposes of stalling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_remove_page</span></code></dt><dd><p>normally set to generic_error_remove_page if truncation is ok
for this address space.  Used for memory failure handling.
Setting this implies you deal with pages going away under you,
unless you have them locked or reference counts increased.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">swap_activate</span></code></p>
<blockquote>
<div><p>Called to prepare the given file for swap.  It should perform
any validation and preparation necessary to ensure that writes
can be performed with minimal memory allocation.  It should call
add_swap_extent(), or the helper iomap_swapfile_activate(), and
return the number of extents added.  If IO should be submitted
through -&gt;swap_rw(), it should set SWP_FS_OPS, otherwise IO will
be submitted directly to the block device <code class="docutils literal notranslate"><span class="pre">sis-&gt;bdev</span></code>.</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">swap_deactivate</span></code></dt><dd><p>Called during swapoff on files where swap_activate was
successful.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_rw</span></code></dt><dd><p>Called to read or write swap pages when SWP_FS_OPS is set.</p>
</dd>
</dl>
</section>
</section>
<section id="id2">
<h2>The File Object<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>A file object represents a file opened by a process.  This is also known
as an “open file description” in POSIX parlance.</p>
<section id="struct-file-operations">
<h3>struct file_operations<a class="headerlink" href="#struct-file-operations" title="Permalink to this headline">¶</a></h3>
<p>This describes how the VFS can manipulate an open file.  As of kernel
4.18, the following members are defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">file_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">loff_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read_iter</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_iter</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iopoll</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">kiocb</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">spin</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iterate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dir_context</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iterate_shared</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dir_context</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">__poll_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">poll_table_struct</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">vm_area_struct</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fl_owner_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fsync</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">datasync</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fasync</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_lock</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">check_flags</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flock</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_lock</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">splice_write</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">splice_read</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setlease</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_lock</span><span class="w"> </span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fallocate</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">loff_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_fdinfo</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifndef CONFIG_MMU</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mmap_capabilities</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">copy_file_range</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">loff_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remap_file_range</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file_in</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos_in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file_out</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos_out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="n">loff_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remap_flags</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fadvise</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Again, all methods are called without any locks being held, unless
otherwise noted.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">llseek</span></code></dt><dd><p>called when the VFS needs to move the file position index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>called by read(2) and related system calls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_iter</span></code></dt><dd><p>possibly asynchronous read with iov_iter as destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>called by write(2) and related system calls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_iter</span></code></dt><dd><p>possibly asynchronous write with iov_iter as source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iopoll</span></code></dt><dd><p>called when aio wants to poll for completions on HIPRI iocbs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iterate</span></code></dt><dd><p>called when the VFS needs to read the directory contents</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iterate_shared</span></code></dt><dd><p>called when the VFS needs to read the directory contents when
filesystem supports concurrent dir iterators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>called by the VFS when a process wants to check if there is
activity on this file and (optionally) go to sleep until there
is activity.  Called by the select(2) and poll(2) system calls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlocked_ioctl</span></code></dt><dd><p>called by the ioctl(2) system call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl</span></code></dt><dd><dl class="simple">
<dt>called by the ioctl(2) system call when 32 bit system calls are</dt><dd><p>used on 64 bit kernels.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>called by the mmap(2) system call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>called by the VFS when an inode should be opened.  When the VFS
opens a file, it creates a new “struct file”.  It then calls the
open method for the newly allocated file structure.  You might
think that the open method really belongs in “struct
inode_operations”, and you may be right.  I think it’s done the
way it is because it makes filesystems simpler to implement.
The open() method is a good place to initialize the
“private_data” member in the file structure if you want to point
to a device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush</span></code></dt><dd><p>called by the close(2) system call to flush a file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>called when the last reference to an open file is closed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fsync</span></code></dt><dd><p>called by the fsync(2) system call.  Also see the section above
entitled “Handling errors during writeback”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fasync</span></code></dt><dd><p>called by the fcntl(2) system call when asynchronous
(non-blocking) mode is enabled for a file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>called by the fcntl(2) system call for F_GETLK, F_SETLK, and
F_SETLKW commands</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_unmapped_area</span></code></dt><dd><p>called by the mmap(2) system call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check_flags</span></code></dt><dd><p>called by the fcntl(2) system call for F_SETFL command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flock</span></code></dt><dd><p>called by the flock(2) system call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_write</span></code></dt><dd><p>called by the VFS to splice data from a pipe to a file.  This
method is used by the splice(2) system call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_read</span></code></dt><dd><p>called by the VFS to splice data from file to a pipe.  This
method is used by the splice(2) system call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setlease</span></code></dt><dd><p>called by the VFS to set or release a file lock lease.  setlease
implementations should call generic_setlease to record or remove
the lease in the inode after setting it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fallocate</span></code></dt><dd><p>called by the VFS to preallocate blocks or punch a hole.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copy_file_range</span></code></dt><dd><p>called by the copy_file_range(2) system call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remap_file_range</span></code></dt><dd><p>called by the ioctl(2) system call for FICLONERANGE and FICLONE
and FIDEDUPERANGE commands to remap file ranges.  An
implementation should remap len bytes at pos_in of the source
file into the dest file at pos_out.  Implementations must handle
callers passing in len == 0; this means “remap to the end of the
source file”.  The return value should the number of bytes
remapped, or the usual negative error code if errors occurred
before any bytes were remapped.  The remap_flags parameter
accepts REMAP_FILE_* flags.  If REMAP_FILE_DEDUP is set then the
implementation must only remap if the requested file ranges have
identical contents.  If REMAP_FILE_CAN_SHORTEN is set, the caller is
ok with the implementation shortening the request length to
satisfy alignment or EOF requirements (or any other reason).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fadvise</span></code></dt><dd><p>possibly called by the fadvise64() system call.</p>
</dd>
</dl>
<p>Note that the file operations are implemented by the specific
filesystem in which the inode resides.  When opening a device node
(character or block special) most filesystems will call special
support routines in the VFS which will locate the required device
driver information.  These support routines replace the filesystem file
operations with those for the device driver, and then proceed to call
the new open() method for the file.  This is how opening a device file
in the filesystem eventually ends up calling the device driver open()
method.</p>
</section>
</section>
<section id="id3">
<h2>Directory Entry Cache (dcache)<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<section id="struct-dentry-operations">
<h3>struct dentry_operations<a class="headerlink" href="#struct-dentry-operations" title="Permalink to this headline">¶</a></h3>
<p>This describes how a filesystem can overload the standard dentry
operations.  Dentries and the dcache are the domain of the VFS and the
individual filesystem implementations.  Device drivers have no business
here.  These methods may be set to NULL, as they are either optional or
the VFS uses a default.  As of kernel 2.6.22, the following members are
defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">dentry_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_revalidate</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_weak_revalidate</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_hash</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">qstr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_compare</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">qstr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_delete</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_init</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_release</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_iput</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_dname</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_automount</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_manage</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_real</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">d_revalidate</span></code></dt><dd><p>called when the VFS needs to revalidate a dentry.  This is
called whenever a name look-up finds a dentry in the dcache.
Most local filesystems leave this as NULL, because all their
dentries in the dcache are valid.  Network filesystems are
different since things can change on the server without the
client necessarily being aware of it.</p>
<p>This function should return a positive value if the dentry is
still valid, and zero or a negative error code if it isn’t.</p>
<p>d_revalidate may be called in rcu-walk mode (flags &amp;
LOOKUP_RCU).  If in rcu-walk mode, the filesystem must
revalidate the dentry without blocking or storing to the dentry,
d_parent and d_inode should not be used without care (because
they can change and, in d_inode case, even become NULL under
us).</p>
<p>If a situation is encountered that rcu-walk cannot handle,
return
-ECHILD and it will be called again in ref-walk mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_weak_revalidate</span></code></dt><dd><p>called when the VFS needs to revalidate a “jumped” dentry.  This
is called when a path-walk ends at dentry that was not acquired
by doing a lookup in the parent directory.  This includes “/”,
“.” and “..”, as well as procfs-style symlinks and mountpoint
traversal.</p>
<p>In this case, we are less concerned with whether the dentry is
still fully correct, but rather that the inode is still valid.
As with d_revalidate, most local filesystems will set this to
NULL since their dcache entries are always valid.</p>
<p>This function has the same return code semantics as
d_revalidate.</p>
<p>d_weak_revalidate is only called after leaving rcu-walk mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_hash</span></code></dt><dd><p>called when the VFS adds a dentry to the hash table.  The first
dentry passed to d_hash is the parent directory that the name is
to be hashed into.</p>
<p>Same locking and synchronisation rules as d_compare regarding
what is safe to dereference etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_compare</span></code></dt><dd><p>called to compare a dentry name with a given name.  The first
dentry is the parent of the dentry to be compared, the second is
the child dentry.  len and name string are properties of the
dentry to be compared.  qstr is the name to compare it with.</p>
<p>Must be constant and idempotent, and should not take locks if
possible, and should not or store into the dentry.  Should not
dereference pointers outside the dentry without lots of care
(eg.  d_parent, d_inode, d_name should not be used).</p>
<p>However, our vfsmount is pinned, and RCU held, so the dentries
and inodes won’t disappear, neither will our sb or filesystem
module.  -&gt;d_sb may be used.</p>
<p>It is a tricky calling convention because it needs to be called
under “rcu-walk”, ie. without any locks or references on things.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_delete</span></code></dt><dd><p>called when the last reference to a dentry is dropped and the
dcache is deciding whether or not to cache it.  Return 1 to
delete immediately, or 0 to cache the dentry.  Default is NULL
which means to always cache a reachable dentry.  d_delete must
be constant and idempotent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_init</span></code></dt><dd><p>called when a dentry is allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_release</span></code></dt><dd><p>called when a dentry is really deallocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_iput</span></code></dt><dd><p>called when a dentry loses its inode (just prior to its being
deallocated).  The default when this is NULL is that the VFS
calls <a class="reference internal" href="api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a>.  If you define this method, you must call <a class="reference internal" href="api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a>
yourself</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_dname</span></code></dt><dd><p>called when the pathname of a dentry should be generated.
Useful for some pseudo filesystems (sockfs, pipefs, …) to
delay pathname generation.  (Instead of doing it when dentry is
created, it’s done only when the path is needed.).  Real
filesystems probably dont want to use it, because their dentries
are present in global dcache hash, so their hash should be an
invariant.  As no lock is held, d_dname() should not try to
modify the dentry itself, unless appropriate SMP safety is used.
CAUTION : <a class="reference internal" href="api-summary.html#c.d_path" title="d_path"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_path()</span></code></a> logic is quite tricky.  The correct way to
return for example “Hello” is to put it at the end of the
buffer, and returns a pointer to the first char.
dynamic_dname() helper function is provided to take care of
this.</p>
<p>Example :</p>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">pipefs_dname</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">dent</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buflen</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">dynamic_dname</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buflen</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pipe:[%lu]&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">d_automount</span></code></dt><dd><p>called when an automount dentry is to be traversed (optional).
This should create a new VFS mount record and return the record
to the caller.  The caller is supplied with a path parameter
giving the automount directory to describe the automount target
and the parent VFS mount record to provide inheritable mount
parameters.  NULL should be returned if someone else managed to
make the automount first.  If the vfsmount creation failed, then
an error code should be returned.  If -EISDIR is returned, then
the directory will be treated as an ordinary directory and
returned to pathwalk to continue walking.</p>
<p>If a vfsmount is returned, the caller will attempt to mount it
on the mountpoint and will remove the vfsmount from its
expiration list in the case of failure.  The vfsmount should be
returned with 2 refs on it to prevent automatic expiration - the
caller will clean up the additional ref.</p>
<p>This function is only used if DCACHE_NEED_AUTOMOUNT is set on
the dentry.  This is set by __d_instantiate() if S_AUTOMOUNT is
set on the inode being added.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_manage</span></code></dt><dd><p>called to allow the filesystem to manage the transition from a
dentry (optional).  This allows autofs, for example, to hold up
clients waiting to explore behind a ‘mountpoint’ while letting
the daemon go past and construct the subtree there.  0 should be
returned to let the calling process continue.  -EISDIR can be
returned to tell pathwalk to use this directory as an ordinary
directory and to ignore anything mounted on it and not to check
the automount flag.  Any other error code will abort pathwalk
completely.</p>
<p>If the ‘rcu_walk’ parameter is true, then the caller is doing a
pathwalk in RCU-walk mode.  Sleeping is not permitted in this
mode, and the caller can be asked to leave it and call again by
returning -ECHILD.  -EISDIR may also be returned to tell
pathwalk to ignore d_automount or any mounts.</p>
<p>This function is only used if DCACHE_MANAGE_TRANSIT is set on
the dentry being transited from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_real</span></code></dt><dd><p>overlay/union type filesystems implement this method to return
one of the underlying dentries hidden by the overlay.  It is
used in two different modes:</p>
<p>Called from file_dentry() it returns the real dentry matching
the inode argument.  The real dentry may be from a lower layer
already copied up, but still referenced from the file.  This
mode is selected with a non-NULL inode argument.</p>
<p>With NULL inode the topmost real underlying dentry is returned.</p>
</dd>
</dl>
<p>Each dentry has a pointer to its parent dentry, as well as a hash list
of child dentries.  Child dentries are basically like files in a
directory.</p>
</section>
<section id="directory-entry-cache-api">
<h3>Directory Entry Cache API<a class="headerlink" href="#directory-entry-cache-api" title="Permalink to this headline">¶</a></h3>
<p>There are a number of functions defined which permit a filesystem to
manipulate dentries:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dget</span></code></dt><dd><p>open a new handle for an existing dentry (this just increments
the usage count)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dput</span></code></dt><dd><p>close a handle for a dentry (decrements the usage count).  If
the usage count drops to 0, and the dentry is still in its
parent’s hash, the “d_delete” method is called to check whether
it should be cached.  If it should not be cached, or if the
dentry is not hashed, it is deleted.  Otherwise cached dentries
are put into an LRU list to be reclaimed on memory shortage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_drop</span></code></dt><dd><p>this unhashes a dentry from its parents hash list.  A subsequent
call to dput() will deallocate the dentry if its usage count
drops to 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_delete</span></code></dt><dd><p>delete a dentry.  If there are no other open references to the
dentry then the dentry is turned into a negative dentry (the
d_iput() method is called).  If there are other references, then
<a class="reference internal" href="api-summary.html#c.d_drop" title="d_drop"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_drop()</span></code></a> is called instead</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_add</span></code></dt><dd><p>add a dentry to its parents hash list and then calls
<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_instantiate</span></code></dt><dd><p>add a dentry to the alias hash list for the inode and updates
the “d_inode” member.  The “i_count” member in the inode
structure should be set/incremented.  If the inode pointer is
NULL, the dentry is called a “negative dentry”.  This function
is commonly called when an inode is created for an existing
negative dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_lookup</span></code></dt><dd><p>look up a dentry given its parent and path name component It
looks up the child of that given name from the dcache hash
table.  If it is found, the reference count is incremented and
the dentry is returned.  The caller must use dput() to free the
dentry when it finishes using it.</p>
</dd>
</dl>
</section>
</section>
<section id="mount-options">
<h2>Mount Options<a class="headerlink" href="#mount-options" title="Permalink to this headline">¶</a></h2>
<section id="parsing-options">
<h3>Parsing options<a class="headerlink" href="#parsing-options" title="Permalink to this headline">¶</a></h3>
<p>On mount and remount the filesystem is passed a string containing a
comma separated list of mount options.  The options can have either of
these forms:</p>
<blockquote>
<div><p>option
option=value</p>
</div></blockquote>
<p>The &lt;linux/parser.h&gt; header defines an API that helps parse these
options.  There are plenty of examples on how to use it in existing
filesystems.</p>
</section>
<section id="showing-options">
<h3>Showing options<a class="headerlink" href="#showing-options" title="Permalink to this headline">¶</a></h3>
<p>If a filesystem accepts mount options, it must define show_options() to
show all the currently active options.  The rules are:</p>
<blockquote>
<div><ul class="simple">
<li><p>options MUST be shown which are not default or their values differ
from the default</p></li>
<li><p>options MAY be shown which are enabled by default or have their
default value</p></li>
</ul>
</div></blockquote>
<p>Options used only internally between a mount helper and the kernel (such
as file descriptors), or which only have an effect during the mounting
(such as ones controlling the creation of a journal) are exempt from the
above rules.</p>
<p>The underlying reason for the above rules is to make sure, that a mount
can be accurately replicated (e.g. umounting and mounting again) based
on the information found in /proc/mounts.</p>
</section>
</section>
<section id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>(Note some of these resources are not up-to-date with the latest kernel</dt><dd><p>version.)</p>
</dd>
<dt>Creating Linux virtual filesystems. 2002</dt><dd><p>&lt;<a class="reference external" href="https://lwn.net/Articles/13325/">https://lwn.net/Articles/13325/</a>&gt;</p>
</dd>
<dt>The Linux Virtual File-system Layer by Neil Brown. 1999</dt><dd><p>&lt;<a class="reference external" href="http://www.cse.unsw.edu.au/~neilb/oss/linux-commentary/vfs.html">http://www.cse.unsw.edu.au/~neilb/oss/linux-commentary/vfs.html</a>&gt;</p>
</dd>
<dt>A tour of the Linux VFS by Michael K. Johnson. 1996</dt><dd><p>&lt;<a class="reference external" href="https://www.tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html">https://www.tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html</a>&gt;</p>
</dd>
<dt>A small trail through the Linux kernel by Andries Brouwer. 2001</dt><dd><p>&lt;<a class="reference external" href="https://www.win.tue.nl/~aeb/linux/vfs/trail.html">https://www.win.tue.nl/~aeb/linux/vfs/trail.html</a>&gt;</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Overview of the Linux Virtual File System</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#directory-entry-cache-dcache">Directory Entry Cache (dcache)</a></li>
<li><a class="reference internal" href="#the-inode-object">The Inode Object</a></li>
<li><a class="reference internal" href="#the-file-object">The File Object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registering-and-mounting-a-filesystem">Registering and Mounting a Filesystem</a><ul>
<li><a class="reference internal" href="#struct-file-system-type">struct file_system_type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-superblock-object">The Superblock Object</a><ul>
<li><a class="reference internal" href="#struct-super-operations">struct super_operations</a></li>
<li><a class="reference internal" href="#struct-xattr-handlers">struct xattr_handlers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">The Inode Object</a><ul>
<li><a class="reference internal" href="#struct-inode-operations">struct inode_operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-address-space-object">The Address Space Object</a><ul>
<li><a class="reference internal" href="#handling-errors-during-writeback">Handling errors during writeback</a></li>
<li><a class="reference internal" href="#struct-address-space-operations">struct address_space_operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">The File Object</a><ul>
<li><a class="reference internal" href="#struct-file-operations">struct file_operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">Directory Entry Cache (dcache)</a><ul>
<li><a class="reference internal" href="#struct-dentry-operations">struct dentry_operations</a></li>
<li><a class="reference internal" href="#directory-entry-cache-api">Directory Entry Cache API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mount-options">Mount Options</a><ul>
<li><a class="reference internal" href="#parsing-options">Parsing options</a></li>
<li><a class="reference internal" href="#showing-options">Showing options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resources">Resources</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/vfs.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/vfs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>