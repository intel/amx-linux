
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>splice and pipes &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Locking" href="locking.html" />
    <link rel="prev" title="Linux Filesystems API summary" href="api-summary.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="splice-and-pipes">
<h1>splice and pipes<a class="headerlink" href="#splice-and-pipes" title="Permalink to this headline">¶</a></h1>
<section id="splice-api">
<h2>splice API<a class="headerlink" href="#splice-api" title="Permalink to this headline">¶</a></h2>
<p>splice is a method for moving blocks of data around inside the kernel,
without continually transferring them between the kernel and user space.</p>
<dl class="function">
<dt id="c.splice_to_pipe">
ssize_t <code class="sig-name descname">splice_to_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct splice_pipe_desc<em> *spd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_to_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>fill passed data into a pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_pipe_desc</span> <span class="pre">*spd</span></code></dt><dd><p>data to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>spd</strong> contains a map of pages and len/offset tuples, along with
the struct pipe_buf_operations associated with these pages. This
function will link that data to the pipe.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_file_splice_read">
ssize_t <code class="sig-name descname">generic_file_splice_read</code><span class="sig-paren">(</span>struct file<em> *in</em>, loff_t<em> *ppos</em>, struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, size_t<em> len</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_splice_read" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from file to a pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*in</span></code></dt><dd><p>file to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>position in <strong>in</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>splice modifier flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Will read pages from given file and fill them into a pipe. Can be
used as long as it has more or less sane -&gt;read_iter().</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_from_pipe_feed">
int <code class="sig-name descname">splice_from_pipe_feed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct splice_desc<em> *sd</em>, splice_actor<em> *actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>feed available data from a pipe to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>information to <strong>actor</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*actor</span></code></dt><dd><p>handler that splices the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function loops over the pipe and calls <strong>actor</strong> to do the
actual moving of a single <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a> to the desired
destination.  It returns when there’s no more buffers left in
the pipe or if the requested number of bytes (<strong>sd-&gt;total_len</strong>)
have been copied.  It returns a positive number (one) if the
pipe needs to be filled with more data, zero if the required
number of bytes have been copied and -errno on error.</p>
<p>This, together with splice_from_pipe_{begin,end,next}, may be
used to implement the functionality of <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal notranslate"><span class="pre">__splice_from_pipe()</span></code></a> when
locking is required around copying the pipe buffers to the
destination.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_from_pipe_next">
int <code class="sig-name descname">splice_from_pipe_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct splice_desc<em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_next" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for some data to splice from</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>information about the splice operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function will wait for some data and return a positive
value (one) if pipe buffers are available.  It will return zero
or -errno if no more data needs to be spliced.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_from_pipe_begin">
void <code class="sig-name descname">splice_from_pipe_begin</code><span class="sig-paren">(</span>struct splice_desc<em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>start splicing from pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>information about the splice operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function should be called before a loop containing
<a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_next()</span></code></a> and <a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_feed()</span></code></a> to
initialize the necessary fields of <strong>sd</strong>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_from_pipe_end">
void <code class="sig-name descname">splice_from_pipe_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct splice_desc<em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_end" title="Permalink to this definition">¶</a></dt>
<dd><p>finish splicing from pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>information about the splice operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function will wake up pipe writers if necessary.  It should
be called after a loop containing <a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_next()</span></code></a> and
<a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_feed()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.__splice_from_pipe">
ssize_t <code class="sig-name descname">__splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct splice_desc<em> *sd</em>, splice_actor<em> *actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to given actor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>information to <strong>actor</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*actor</span></code></dt><dd><p>handler that splices the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function does little more than loop over the pipe and call
<strong>actor</strong> to do the actual moving of a single <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a> to
the desired destination. See pipe_to_file, pipe_to_sendpage, or
pipe_to_user.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_from_pipe">
ssize_t <code class="sig-name descname">splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct file<em> *out</em>, loff_t<em> *ppos</em>, size_t<em> len</em>, unsigned int<em> flags</em>, splice_actor<em> *actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*out</span></code></dt><dd><p>file to splice to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>position in <strong>out</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>how many bytes to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>splice modifier flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*actor</span></code></dt><dd><p>handler that splices the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>See __splice_from_pipe. This function locks the pipe inode,
otherwise it’s identical to <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal notranslate"><span class="pre">__splice_from_pipe()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.iter_file_splice_write">
ssize_t <code class="sig-name descname">iter_file_splice_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct file<em> *out</em>, loff_t<em> *ppos</em>, size_t<em> len</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iter_file_splice_write" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*out</span></code></dt><dd><p>file to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>position in <strong>out</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>splice modifier flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Will either move or copy pages (determined by <strong>flags</strong> options) from
the given pipe inode to the given file.
This one is -&gt;write_iter-based.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_splice_sendpage">
ssize_t <code class="sig-name descname">generic_splice_sendpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct file<em> *out</em>, loff_t<em> *ppos</em>, size_t<em> len</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_splice_sendpage" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>pipe to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*out</span></code></dt><dd><p>socket to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>position in <strong>out</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>splice modifier flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Will send <strong>len</strong> bytes from the pipe to a network socket. No data copying
is involved.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.splice_direct_to_actor">
ssize_t <code class="sig-name descname">splice_direct_to_actor</code><span class="sig-paren">(</span>struct file<em> *in</em>, struct splice_desc<em> *sd</em>, splice_direct_actor<em> *actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_direct_to_actor" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two non-pipes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*in</span></code></dt><dd><p>file to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*sd</span></code></dt><dd><p>actor information on where to splice to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_direct_actor</span> <span class="pre">*actor</span></code></dt><dd><p>handles the data splicing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is a special case helper to splice directly between two
points, without requiring an explicit pipe. Internally an allocated
pipe is cached in the process, and reused during the lifetime of
that process.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.do_splice_direct">
long <code class="sig-name descname">do_splice_direct</code><span class="sig-paren">(</span>struct file<em> *in</em>, loff_t<em> *ppos</em>, struct file<em> *out</em>, loff_t<em> *opos</em>, size_t<em> len</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_splice_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*in</span></code></dt><dd><p>file to splice from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>input file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*out</span></code></dt><dd><p>file to splice to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*opos</span></code></dt><dd><p>output file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>splice modifier flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For use by do_sendfile(). splice can easily emulate sendfile, but
doing it in the application would incur an extra system call
(splice in + splice out, as compared to just sendfile()). So this helper
can splice directly through a process-private pipe.</p>
</div></blockquote>
</div>
</section>
<section id="pipes-api">
<h2>pipes API<a class="headerlink" href="#pipes-api" title="Permalink to this headline">¶</a></h2>
<p>Pipe interfaces are all for in-kernel (builtin image) use. They are not
exported for use by modules.</p>
<dl class="type">
<dt id="c.pipe_buffer">
struct <code class="sig-name descname">pipe_buffer</code><a class="headerlink" href="#c.pipe_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pipe_buffer {
    struct page *page;
    unsigned int offset, len;
    const struct pipe_buf_operations *ops;
    unsigned int flags;
    unsigned long private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">page</span></code></dt><dd><p>the page containing the data for the pipe buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of data inside the <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>length of data inside the <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>operations associated with this buffer. See <strong>pipe_buf_operations</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>pipe buffer flags. See above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>private data owned by the ops.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pipe_inode_info">
struct <code class="sig-name descname">pipe_inode_info</code><a class="headerlink" href="#c.pipe_inode_info" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pipe_inode_info {
    struct mutex mutex;
    wait_queue_head_t rd_wait, wr_wait;
    unsigned int head;
    unsigned int tail;
    unsigned int max_usage;
    unsigned int ring_size;
#ifdef CONFIG_WATCH_QUEUE;
    bool note_loss;
#endif;
    unsigned int nr_accounted;
    unsigned int readers;
    unsigned int writers;
    unsigned int files;
    unsigned int r_counter;
    unsigned int w_counter;
    bool poll_usage;
    struct page *tmp_page;
    struct fasync_struct *fasync_readers;
    struct fasync_struct *fasync_writers;
    struct pipe_buffer *bufs;
    struct user_struct *user;
#ifdef CONFIG_WATCH_QUEUE;
    struct watch_queue *watch_queue;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>mutex protecting the whole thing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rd_wait</span></code></dt><dd><p>reader wait point in case of empty pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wr_wait</span></code></dt><dd><p>writer wait point in case of full pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>The point of buffer production</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail</span></code></dt><dd><p>The point of buffer consumption</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_usage</span></code></dt><dd><p>The maximum number of slots that may be used in the ring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ring_size</span></code></dt><dd><p>total number of buffers (should be a power of 2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">note_loss</span></code></dt><dd><p>The next read() should insert a data-lost message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_accounted</span></code></dt><dd><p>The amount this pipe accounts for in user-&gt;pipe_bufs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">readers</span></code></dt><dd><p>number of current readers of this pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writers</span></code></dt><dd><p>number of current writers of this pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">files</span></code></dt><dd><p>number of struct file referring this pipe (protected by -&gt;i_lock)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r_counter</span></code></dt><dd><p>reader counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w_counter</span></code></dt><dd><p>writer counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_usage</span></code></dt><dd><p>is this pipe used for epoll, which has crazy wakeups?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp_page</span></code></dt><dd><p>cached released page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fasync_readers</span></code></dt><dd><p>reader side fasync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fasync_writers</span></code></dt><dd><p>writer side fasync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bufs</span></code></dt><dd><p>the circular array of pipe buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user</span></code></dt><dd><p>the user who created this pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watch_queue</span></code></dt><dd><p>If this pipe is a watch_queue, this is the stuff for that</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_empty">
bool <code class="sig-name descname">pipe_empty</code><span class="sig-paren">(</span>unsigned int<em> head</em>, unsigned int<em> tail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the pipe is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt><dd><p>The pipe ring head pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt><dd><p>The pipe ring tail pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_occupancy">
unsigned int <code class="sig-name descname">pipe_occupancy</code><span class="sig-paren">(</span>unsigned int<em> head</em>, unsigned int<em> tail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of slots used in the pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt><dd><p>The pipe ring head pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt><dd><p>The pipe ring tail pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_full">
bool <code class="sig-name descname">pipe_full</code><span class="sig-paren">(</span>unsigned int<em> head</em>, unsigned int<em> tail</em>, unsigned int<em> limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the pipe is full</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt><dd><p>The pipe ring head pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt><dd><p>The pipe ring tail pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">limit</span></code></dt><dd><p>The maximum amount of slots available.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_buf_get">
bool <code class="sig-name descname">pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a pipe_buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to get a reference to</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the reference was successfully obtained.</p>
</div>
<dl class="function">
<dt id="c.pipe_buf_release">
void <code class="sig-name descname">pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a pipe_buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to put a reference to</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_buf_confirm">
int <code class="sig-name descname">pipe_buf_confirm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_confirm" title="Permalink to this definition">¶</a></dt>
<dd><p>verify contents of the pipe buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to confirm</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pipe_buf_try_steal">
bool <code class="sig-name descname">pipe_buf_try_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_try_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a pipe_buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to attempt to steal</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.generic_pipe_buf_try_steal">
bool <code class="sig-name descname">generic_pipe_buf_try_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_try_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to attempt to steal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function attempts to steal the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> attached to
<strong>buf</strong>. If successful, this function returns 0 and returns with
the page locked. The caller may then reuse the page for whatever
he wishes; the typical use is insertion into a different file
page cache.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_pipe_buf_get">
bool <code class="sig-name descname">generic_pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to get a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function grabs an extra reference to <strong>buf</strong>. It’s used in
the tee() system call, when we duplicate the buffers in one
pipe into another.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_pipe_buf_release">
void <code class="sig-name descname">generic_pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a><em> *pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a><em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>the pipe that the buffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to put a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function releases a reference to <strong>buf</strong>.</p>
</div></blockquote>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">splice and pipes</a><ul>
<li><a class="reference internal" href="#splice-api">splice API</a></li>
<li><a class="reference internal" href="#pipes-api">pipes API</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/splice.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/splice.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>