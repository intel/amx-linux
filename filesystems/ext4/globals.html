
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3. Global Structures &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4. Dynamic Structures" href="dynamic.html" />
    <link rel="prev" title="2. High Level Design" href="overview.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="global-structures">
<h1><span class="section-number">3. </span>Global Structures<a class="headerlink" href="#global-structures" title="Permalink to this headline">¶</a></h1>
<p>The filesystem is sharded into a number of block groups, each of which
have static metadata at fixed locations.</p>
<section id="super-block">
<h2><span class="section-number">3.1. </span>Super Block<a class="headerlink" href="#super-block" title="Permalink to this headline">¶</a></h2>
<p>The superblock records various information about the enclosing
filesystem, such as block counts, inode counts, supported features,
maintenance information, and more.</p>
<p>If the sparse_super feature flag is set, redundant copies of the
superblock and group descriptors are kept only in the groups whose group
number is either 0 or a power of 3, 5, or 7. If the flag is not set,
redundant copies are kept in all groups.</p>
<p>The superblock checksum is calculated against the superblock structure,
which includes the FS UUID.</p>
<p>The ext4 superblock is laid out as follows in
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_super_block</span></code>:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>s_inodes_count</p></td>
<td><p>Total inode count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>s_blocks_count_lo</p></td>
<td><p>Total block count.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>s_r_blocks_count_lo</p></td>
<td><p>This number of blocks can only be allocated by the super-user.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__le32</p></td>
<td><p>s_free_blocks_count_lo</p></td>
<td><p>Free block count.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>__le32</p></td>
<td><p>s_free_inodes_count</p></td>
<td><p>Free inode count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x14</p></td>
<td><p>__le32</p></td>
<td><p>s_first_data_block</p></td>
<td><p>First data block. This must be at least 1 for 1k-block filesystems and
is typically 0 for all other block sizes.</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>__le32</p></td>
<td><p>s_log_block_size</p></td>
<td><p>Block size is 2 ^ (10 + s_log_block_size).</p></td>
</tr>
<tr class="row-odd"><td><p>0x1C</p></td>
<td><p>__le32</p></td>
<td><p>s_log_cluster_size</p></td>
<td><p>Cluster size is 2 ^ (10 + s_log_cluster_size) blocks if bigalloc is
enabled. Otherwise s_log_cluster_size must equal s_log_block_size.</p></td>
</tr>
<tr class="row-even"><td><p>0x20</p></td>
<td><p>__le32</p></td>
<td><p>s_blocks_per_group</p></td>
<td><p>Blocks per group.</p></td>
</tr>
<tr class="row-odd"><td><p>0x24</p></td>
<td><p>__le32</p></td>
<td><p>s_clusters_per_group</p></td>
<td><p>Clusters per group, if bigalloc is enabled. Otherwise
s_clusters_per_group must equal s_blocks_per_group.</p></td>
</tr>
<tr class="row-even"><td><p>0x28</p></td>
<td><p>__le32</p></td>
<td><p>s_inodes_per_group</p></td>
<td><p>Inodes per group.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2C</p></td>
<td><p>__le32</p></td>
<td><p>s_mtime</p></td>
<td><p>Mount time, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x30</p></td>
<td><p>__le32</p></td>
<td><p>s_wtime</p></td>
<td><p>Write time, in seconds since the epoch.</p></td>
</tr>
<tr class="row-odd"><td><p>0x34</p></td>
<td><p>__le16</p></td>
<td><p>s_mnt_count</p></td>
<td><p>Number of mounts since the last fsck.</p></td>
</tr>
<tr class="row-even"><td><p>0x36</p></td>
<td><p>__le16</p></td>
<td><p>s_max_mnt_count</p></td>
<td><p>Number of mounts beyond which a fsck is needed.</p></td>
</tr>
<tr class="row-odd"><td><p>0x38</p></td>
<td><p>__le16</p></td>
<td><p>s_magic</p></td>
<td><p>Magic signature, 0xEF53</p></td>
</tr>
<tr class="row-even"><td><p>0x3A</p></td>
<td><p>__le16</p></td>
<td><p>s_state</p></td>
<td><p>File system state. See <a class="reference internal" href="#super-state">super_state</a> for more info.</p></td>
</tr>
<tr class="row-odd"><td><p>0x3C</p></td>
<td><p>__le16</p></td>
<td><p>s_errors</p></td>
<td><p>Behaviour when detecting errors. See <a class="reference internal" href="#super-errors">super_errors</a> for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x3E</p></td>
<td><p>__le16</p></td>
<td><p>s_minor_rev_level</p></td>
<td><p>Minor revision level.</p></td>
</tr>
<tr class="row-odd"><td><p>0x40</p></td>
<td><p>__le32</p></td>
<td><p>s_lastcheck</p></td>
<td><p>Time of last check, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x44</p></td>
<td><p>__le32</p></td>
<td><p>s_checkinterval</p></td>
<td><p>Maximum time between checks, in seconds.</p></td>
</tr>
<tr class="row-odd"><td><p>0x48</p></td>
<td><p>__le32</p></td>
<td><p>s_creator_os</p></td>
<td><p>Creator OS. See the table <a class="reference internal" href="#super-creator">super_creator</a> for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x4C</p></td>
<td><p>__le32</p></td>
<td><p>s_rev_level</p></td>
<td><p>Revision level. See the table <a class="reference internal" href="#super-revision">super_revision</a> for more info.</p></td>
</tr>
<tr class="row-odd"><td><p>0x50</p></td>
<td><p>__le16</p></td>
<td><p>s_def_resuid</p></td>
<td><p>Default uid for reserved blocks.</p></td>
</tr>
<tr class="row-even"><td><p>0x52</p></td>
<td><p>__le16</p></td>
<td><p>s_def_resgid</p></td>
<td><p>Default gid for reserved blocks.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>These fields are for EXT4_DYNAMIC_REV superblocks only.</p>
<p>Note: the difference between the compatible feature set and the
incompatible feature set is that if there is a bit set in the
incompatible feature set that the kernel doesn’t know about, it should
refuse to mount the filesystem.</p>
<p>e2fsck’s requirements are more strict; if it doesn’t know
about a feature in either the compatible or incompatible feature set, it
must abort and not try to meddle with things it doesn’t understand…</p>
</td>
</tr>
<tr class="row-even"><td><p>0x54</p></td>
<td><p>__le32</p></td>
<td><p>s_first_ino</p></td>
<td><p>First non-reserved inode.</p></td>
</tr>
<tr class="row-odd"><td><p>0x58</p></td>
<td><p>__le16</p></td>
<td><p>s_inode_size</p></td>
<td><p>Size of inode structure, in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>0x5A</p></td>
<td><p>__le16</p></td>
<td><p>s_block_group_nr</p></td>
<td><p>Block group # of this superblock.</p></td>
</tr>
<tr class="row-odd"><td><p>0x5C</p></td>
<td><p>__le32</p></td>
<td><p>s_feature_compat</p></td>
<td><p>Compatible feature set flags. Kernel can still read/write this fs even
if it doesn’t understand a flag; fsck should not do that. See the
<a class="reference internal" href="#super-compat">super_compat</a> table for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x60</p></td>
<td><p>__le32</p></td>
<td><p>s_feature_incompat</p></td>
<td><p>Incompatible feature set. If the kernel or fsck doesn’t understand one
of these bits, it should stop. See the <a class="reference internal" href="#super-incompat">super_incompat</a> table for more
info.</p></td>
</tr>
<tr class="row-odd"><td><p>0x64</p></td>
<td><p>__le32</p></td>
<td><p>s_feature_ro_compat</p></td>
<td><p>Readonly-compatible feature set. If the kernel doesn’t understand one of
these bits, it can still mount read-only. See the <a class="reference internal" href="#super-rocompat">super_rocompat</a> table
for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x68</p></td>
<td><p>__u8</p></td>
<td><p>s_uuid[16]</p></td>
<td><p>128-bit UUID for volume.</p></td>
</tr>
<tr class="row-odd"><td><p>0x78</p></td>
<td><p>char</p></td>
<td><p>s_volume_name[16]</p></td>
<td><p>Volume label.</p></td>
</tr>
<tr class="row-even"><td><p>0x88</p></td>
<td><p>char</p></td>
<td><p>s_last_mounted[64]</p></td>
<td><p>Directory where filesystem was last mounted.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC8</p></td>
<td><p>__le32</p></td>
<td><p>s_algorithm_usage_bitmap</p></td>
<td><p>For compression (Not used in e2fsprogs/Linux)</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>Performance hints.  Directory preallocation should only happen if the
EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</p></td>
</tr>
<tr class="row-odd"><td><p>0xCC</p></td>
<td><p>__u8</p></td>
<td><p>s_prealloc_blocks</p></td>
<td><p>#. of blocks to try to preallocate for … files? (Not used in
e2fsprogs/Linux)</p></td>
</tr>
<tr class="row-even"><td><p>0xCD</p></td>
<td><p>__u8</p></td>
<td><p>s_prealloc_dir_blocks</p></td>
<td><p>#. of blocks to preallocate for directories. (Not used in
e2fsprogs/Linux)</p></td>
</tr>
<tr class="row-odd"><td><p>0xCE</p></td>
<td><p>__le16</p></td>
<td><p>s_reserved_gdt_blocks</p></td>
<td><p>Number of reserved GDT entries for future filesystem expansion.</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>Journalling support is valid only if EXT4_FEATURE_COMPAT_HAS_JOURNAL is
set.</p></td>
</tr>
<tr class="row-odd"><td><p>0xD0</p></td>
<td><p>__u8</p></td>
<td><p>s_journal_uuid[16]</p></td>
<td><p>UUID of journal superblock</p></td>
</tr>
<tr class="row-even"><td><p>0xE0</p></td>
<td><p>__le32</p></td>
<td><p>s_journal_inum</p></td>
<td><p>inode number of journal file.</p></td>
</tr>
<tr class="row-odd"><td><p>0xE4</p></td>
<td><p>__le32</p></td>
<td><p>s_journal_dev</p></td>
<td><p>Device number of journal file, if the external journal feature flag is
set.</p></td>
</tr>
<tr class="row-even"><td><p>0xE8</p></td>
<td><p>__le32</p></td>
<td><p>s_last_orphan</p></td>
<td><p>Start of list of orphaned inodes to delete.</p></td>
</tr>
<tr class="row-odd"><td><p>0xEC</p></td>
<td><p>__le32</p></td>
<td><p>s_hash_seed[4]</p></td>
<td><p>HTREE hash seed.</p></td>
</tr>
<tr class="row-even"><td><p>0xFC</p></td>
<td><p>__u8</p></td>
<td><p>s_def_hash_version</p></td>
<td><p>Default hash algorithm to use for directory hashes. See <a class="reference internal" href="#super-def-hash">super_def_hash</a>
for more info.</p></td>
</tr>
<tr class="row-odd"><td><p>0xFD</p></td>
<td><p>__u8</p></td>
<td><p>s_jnl_backup_type</p></td>
<td><p>If this value is 0 or EXT3_JNL_BACKUP_BLOCKS (1), then the
<code class="docutils literal notranslate"><span class="pre">s_jnl_blocks</span></code> field contains a duplicate copy of the inode’s
<code class="docutils literal notranslate"><span class="pre">i_block[]</span></code> array and <code class="docutils literal notranslate"><span class="pre">i_size</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>0xFE</p></td>
<td><p>__le16</p></td>
<td><p>s_desc_size</p></td>
<td><p>Size of group descriptors, in bytes, if the 64bit incompat feature flag
is set.</p></td>
</tr>
<tr class="row-odd"><td><p>0x100</p></td>
<td><p>__le32</p></td>
<td><p>s_default_mount_opts</p></td>
<td><p>Default mount options. See the <a class="reference internal" href="#super-mountopts">super_mountopts</a> table for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x104</p></td>
<td><p>__le32</p></td>
<td><p>s_first_meta_bg</p></td>
<td><p>First metablock block group, if the meta_bg feature is enabled.</p></td>
</tr>
<tr class="row-odd"><td><p>0x108</p></td>
<td><p>__le32</p></td>
<td><p>s_mkfs_time</p></td>
<td><p>When the filesystem was created, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x10C</p></td>
<td><p>__le32</p></td>
<td><p>s_jnl_blocks[17]</p></td>
<td><p>Backup copy of the journal inode’s <code class="docutils literal notranslate"><span class="pre">i_block[]</span></code> array in the first 15
elements and i_size_high and i_size in the 16th and 17th elements,
respectively.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>64bit support is valid only if EXT4_FEATURE_COMPAT_64BIT is set.</p></td>
</tr>
<tr class="row-even"><td><p>0x150</p></td>
<td><p>__le32</p></td>
<td><p>s_blocks_count_hi</p></td>
<td><p>High 32-bits of the block count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x154</p></td>
<td><p>__le32</p></td>
<td><p>s_r_blocks_count_hi</p></td>
<td><p>High 32-bits of the reserved block count.</p></td>
</tr>
<tr class="row-even"><td><p>0x158</p></td>
<td><p>__le32</p></td>
<td><p>s_free_blocks_count_hi</p></td>
<td><p>High 32-bits of the free block count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x15C</p></td>
<td><p>__le16</p></td>
<td><p>s_min_extra_isize</p></td>
<td><p>All inodes have at least # bytes.</p></td>
</tr>
<tr class="row-even"><td><p>0x15E</p></td>
<td><p>__le16</p></td>
<td><p>s_want_extra_isize</p></td>
<td><p>New inodes should reserve # bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>0x160</p></td>
<td><p>__le32</p></td>
<td><p>s_flags</p></td>
<td><p>Miscellaneous flags. See the <a class="reference internal" href="#super-flags">super_flags</a> table for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x164</p></td>
<td><p>__le16</p></td>
<td><p>s_raid_stride</p></td>
<td><p>RAID stride. This is the number of logical blocks read from or written
to the disk before moving to the next disk. This affects the placement
of filesystem metadata, which will hopefully make RAID storage faster.</p></td>
</tr>
<tr class="row-odd"><td><p>0x166</p></td>
<td><p>__le16</p></td>
<td><p>s_mmp_interval</p></td>
<td><p>#. seconds to wait in multi-mount prevention (MMP) checking. In theory,
MMP is a mechanism to record in the superblock which host and device
have mounted the filesystem, in order to prevent multiple mounts. This
feature does not seem to be implemented…</p></td>
</tr>
<tr class="row-even"><td><p>0x168</p></td>
<td><p>__le64</p></td>
<td><p>s_mmp_block</p></td>
<td><p>Block # for multi-mount protection data.</p></td>
</tr>
<tr class="row-odd"><td><p>0x170</p></td>
<td><p>__le32</p></td>
<td><p>s_raid_stripe_width</p></td>
<td><p>RAID stripe width. This is the number of logical blocks read from or
written to the disk before coming back to the current disk. This is used
by the block allocator to try to reduce the number of read-modify-write
operations in a RAID5/6.</p></td>
</tr>
<tr class="row-even"><td><p>0x174</p></td>
<td><p>__u8</p></td>
<td><p>s_log_groups_per_flex</p></td>
<td><p>Size of a flexible block group is 2 ^ <code class="docutils literal notranslate"><span class="pre">s_log_groups_per_flex</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>0x175</p></td>
<td><p>__u8</p></td>
<td><p>s_checksum_type</p></td>
<td><p>Metadata checksum algorithm type. The only valid value is 1 (crc32c).</p></td>
</tr>
<tr class="row-even"><td><p>0x176</p></td>
<td><p>__le16</p></td>
<td><p>s_reserved_pad</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x178</p></td>
<td><p>__le64</p></td>
<td><p>s_kbytes_written</p></td>
<td><p>Number of KiB written to this filesystem over its lifetime.</p></td>
</tr>
<tr class="row-even"><td><p>0x180</p></td>
<td><p>__le32</p></td>
<td><p>s_snapshot_inum</p></td>
<td><p>inode number of active snapshot. (Not used in e2fsprogs/Linux.)</p></td>
</tr>
<tr class="row-odd"><td><p>0x184</p></td>
<td><p>__le32</p></td>
<td><p>s_snapshot_id</p></td>
<td><p>Sequential ID of active snapshot. (Not used in e2fsprogs/Linux.)</p></td>
</tr>
<tr class="row-even"><td><p>0x188</p></td>
<td><p>__le64</p></td>
<td><p>s_snapshot_r_blocks_count</p></td>
<td><p>Number of blocks reserved for active snapshot’s future use. (Not used in
e2fsprogs/Linux.)</p></td>
</tr>
<tr class="row-odd"><td><p>0x190</p></td>
<td><p>__le32</p></td>
<td><p>s_snapshot_list</p></td>
<td><p>inode number of the head of the on-disk snapshot list. (Not used in
e2fsprogs/Linux.)</p></td>
</tr>
<tr class="row-even"><td><p>0x194</p></td>
<td><p>__le32</p></td>
<td><p>s_error_count</p></td>
<td><p>Number of errors seen.</p></td>
</tr>
<tr class="row-odd"><td><p>0x198</p></td>
<td><p>__le32</p></td>
<td><p>s_first_error_time</p></td>
<td><p>First time an error happened, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x19C</p></td>
<td><p>__le32</p></td>
<td><p>s_first_error_ino</p></td>
<td><p>inode involved in first error.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1A0</p></td>
<td><p>__le64</p></td>
<td><p>s_first_error_block</p></td>
<td><p>Number of block involved of first error.</p></td>
</tr>
<tr class="row-even"><td><p>0x1A8</p></td>
<td><p>__u8</p></td>
<td><p>s_first_error_func[32]</p></td>
<td><p>Name of function where the error happened.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1C8</p></td>
<td><p>__le32</p></td>
<td><p>s_first_error_line</p></td>
<td><p>Line number where error happened.</p></td>
</tr>
<tr class="row-even"><td><p>0x1CC</p></td>
<td><p>__le32</p></td>
<td><p>s_last_error_time</p></td>
<td><p>Time of most recent error, in seconds since the epoch.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1D0</p></td>
<td><p>__le32</p></td>
<td><p>s_last_error_ino</p></td>
<td><p>inode involved in most recent error.</p></td>
</tr>
<tr class="row-even"><td><p>0x1D4</p></td>
<td><p>__le32</p></td>
<td><p>s_last_error_line</p></td>
<td><p>Line number where most recent error happened.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1D8</p></td>
<td><p>__le64</p></td>
<td><p>s_last_error_block</p></td>
<td><p>Number of block involved in most recent error.</p></td>
</tr>
<tr class="row-even"><td><p>0x1E0</p></td>
<td><p>__u8</p></td>
<td><p>s_last_error_func[32]</p></td>
<td><p>Name of function where the most recent error happened.</p></td>
</tr>
<tr class="row-odd"><td><p>0x200</p></td>
<td><p>__u8</p></td>
<td><p>s_mount_opts[64]</p></td>
<td><p>ASCIIZ string of mount options.</p></td>
</tr>
<tr class="row-even"><td><p>0x240</p></td>
<td><p>__le32</p></td>
<td><p>s_usr_quota_inum</p></td>
<td><p>Inode number of user <a class="reference external" href="quota">quota</a> file.</p></td>
</tr>
<tr class="row-odd"><td><p>0x244</p></td>
<td><p>__le32</p></td>
<td><p>s_grp_quota_inum</p></td>
<td><p>Inode number of group <a class="reference external" href="quota">quota</a> file.</p></td>
</tr>
<tr class="row-even"><td><p>0x248</p></td>
<td><p>__le32</p></td>
<td><p>s_overhead_blocks</p></td>
<td><p>Overhead blocks/clusters in fs. (Huh? This field is always zero, which
means that the kernel calculates it dynamically.)</p></td>
</tr>
<tr class="row-odd"><td><p>0x24C</p></td>
<td><p>__le32</p></td>
<td><p>s_backup_bgs[2]</p></td>
<td><p>Block groups containing superblock backups (if sparse_super2)</p></td>
</tr>
<tr class="row-even"><td><p>0x254</p></td>
<td><p>__u8</p></td>
<td><p>s_encrypt_algos[4]</p></td>
<td><p>Encryption algorithms in use. There can be up to four algorithms in use
at any time; valid algorithm codes are given in the <a class="reference internal" href="#super-encrypt">super_encrypt</a> table
below.</p></td>
</tr>
<tr class="row-odd"><td><p>0x258</p></td>
<td><p>__u8</p></td>
<td><p>s_encrypt_pw_salt[16]</p></td>
<td><p>Salt for the string2key algorithm for encryption.</p></td>
</tr>
<tr class="row-even"><td><p>0x268</p></td>
<td><p>__le32</p></td>
<td><p>s_lpf_ino</p></td>
<td><p>Inode number of lost+found</p></td>
</tr>
<tr class="row-odd"><td><p>0x26C</p></td>
<td><p>__le32</p></td>
<td><p>s_prj_quota_inum</p></td>
<td><p>Inode that tracks project quotas.</p></td>
</tr>
<tr class="row-even"><td><p>0x270</p></td>
<td><p>__le32</p></td>
<td><p>s_checksum_seed</p></td>
<td><p>Checksum seed used for metadata_csum calculations. This value is
crc32c(~0, $orig_fs_uuid).</p></td>
</tr>
<tr class="row-odd"><td><p>0x274</p></td>
<td><p>__u8</p></td>
<td><p>s_wtime_hi</p></td>
<td><p>Upper 8 bits of the s_wtime field.</p></td>
</tr>
<tr class="row-even"><td><p>0x275</p></td>
<td><p>__u8</p></td>
<td><p>s_mtime_hi</p></td>
<td><p>Upper 8 bits of the s_mtime field.</p></td>
</tr>
<tr class="row-odd"><td><p>0x276</p></td>
<td><p>__u8</p></td>
<td><p>s_mkfs_time_hi</p></td>
<td><p>Upper 8 bits of the s_mkfs_time field.</p></td>
</tr>
<tr class="row-even"><td><p>0x277</p></td>
<td><p>__u8</p></td>
<td><p>s_lastcheck_hi</p></td>
<td><p>Upper 8 bits of the s_lastcheck field.</p></td>
</tr>
<tr class="row-odd"><td><p>0x278</p></td>
<td><p>__u8</p></td>
<td><p>s_first_error_time_hi</p></td>
<td><p>Upper 8 bits of the s_first_error_time field.</p></td>
</tr>
<tr class="row-even"><td><p>0x279</p></td>
<td><p>__u8</p></td>
<td><p>s_last_error_time_hi</p></td>
<td><p>Upper 8 bits of the s_last_error_time field.</p></td>
</tr>
<tr class="row-odd"><td><p>0x27A</p></td>
<td><p>__u8</p></td>
<td><p>s_pad[2]</p></td>
<td><p>Zero padding.</p></td>
</tr>
<tr class="row-even"><td><p>0x27C</p></td>
<td><p>__le16</p></td>
<td><p>s_encoding</p></td>
<td><p>Filename charset encoding.</p></td>
</tr>
<tr class="row-odd"><td><p>0x27E</p></td>
<td><p>__le16</p></td>
<td><p>s_encoding_flags</p></td>
<td><p>Filename charset encoding flags.</p></td>
</tr>
<tr class="row-even"><td><p>0x280</p></td>
<td><p>__le32</p></td>
<td><p>s_orphan_file_inum</p></td>
<td><p>Orphan file inode number.</p></td>
</tr>
<tr class="row-odd"><td><p>0x284</p></td>
<td><p>__le32</p></td>
<td><p>s_reserved[94]</p></td>
<td><p>Padding to the end of the block.</p></td>
</tr>
<tr class="row-even"><td><p>0x3FC</p></td>
<td><p>__le32</p></td>
<td><p>s_checksum</p></td>
<td><p>Superblock checksum.</p></td>
</tr>
</tbody>
</table>
<p id="super-state">The superblock state is some combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0001</p></td>
<td><p>Cleanly umounted</p></td>
</tr>
<tr class="row-odd"><td><p>0x0002</p></td>
<td><p>Errors detected</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>Orphans being recovered</p></td>
</tr>
</tbody>
</table>
<p id="super-errors">The superblock error policy is one of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Continue</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Remount read-only</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Panic</p></td>
</tr>
</tbody>
</table>
<p id="super-creator">The filesystem creator is one of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Linux</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Hurd</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Masix</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>FreeBSD</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>Lites</p></td>
</tr>
</tbody>
</table>
<p id="super-revision">The superblock revision is one of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Original format</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>v2 format w/ dynamic inode sizes</p></td>
</tr>
</tbody>
</table>
<p>Note that <code class="docutils literal notranslate"><span class="pre">EXT4_DYNAMIC_REV</span></code> refers to a revision 1 or newer filesystem.</p>
<p id="super-compat">The superblock compatible features field is a combination of any of the
following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Directory preallocation (COMPAT_DIR_PREALLOC).</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>“imagic inodes”. Not clear from the code what this does
(COMPAT_IMAGIC_INODES).</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Has a journal (COMPAT_HAS_JOURNAL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>Supports extended attributes (COMPAT_EXT_ATTR).</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>Has reserved GDT blocks for filesystem expansion
(COMPAT_RESIZE_INODE). Requires RO_COMPAT_SPARSE_SUPER.</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>Has directory indices (COMPAT_DIR_INDEX).</p></td>
</tr>
<tr class="row-even"><td><p>0x40</p></td>
<td><p>“Lazy BG”. Not in Linux kernel, seems to have been for uninitialized
block groups? (COMPAT_LAZY_BG)</p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>“Exclude inode”. Not used. (COMPAT_EXCLUDE_INODE).</p></td>
</tr>
<tr class="row-even"><td><p>0x100</p></td>
<td><p>“Exclude bitmap”. Seems to be used to indicate the presence of
snapshot-related exclude bitmaps? Not defined in kernel or used in
e2fsprogs (COMPAT_EXCLUDE_BITMAP).</p></td>
</tr>
<tr class="row-odd"><td><p>0x200</p></td>
<td><p>Sparse Super Block, v2. If this flag is set, the SB field s_backup_bgs
points to the two block groups that contain backup superblocks
(COMPAT_SPARSE_SUPER2).</p></td>
</tr>
<tr class="row-even"><td><p>0x400</p></td>
<td><p>Fast commits supported. Although fast commits blocks are
backward incompatible, fast commit blocks are not always
present in the journal. If fast commit blocks are present in
the journal, JBD2 incompat feature
(JBD2_FEATURE_INCOMPAT_FAST_COMMIT) gets
set (COMPAT_FAST_COMMIT).</p></td>
</tr>
<tr class="row-odd"><td><p>0x1000</p></td>
<td><p>Orphan file allocated. This is the special file for more efficient
tracking of unlinked but still open inodes. When there may be any
entries in the file, we additionally set proper rocompat feature
(RO_COMPAT_ORPHAN_PRESENT).</p></td>
</tr>
</tbody>
</table>
<p id="super-incompat">The superblock incompatible features field is a combination of any of the
following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Compression (INCOMPAT_COMPRESSION).</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>Directory entries record the file type. See ext4_dir_entry_2 below
(INCOMPAT_FILETYPE).</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Filesystem needs recovery (INCOMPAT_RECOVER).</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>Filesystem has a separate journal device (INCOMPAT_JOURNAL_DEV).</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>Meta block groups. See the earlier discussion of this feature
(INCOMPAT_META_BG).</p></td>
</tr>
<tr class="row-odd"><td><p>0x40</p></td>
<td><p>Files in this filesystem use extents (INCOMPAT_EXTENTS).</p></td>
</tr>
<tr class="row-even"><td><p>0x80</p></td>
<td><p>Enable a filesystem size of 2^64 blocks (INCOMPAT_64BIT).</p></td>
</tr>
<tr class="row-odd"><td><p>0x100</p></td>
<td><p>Multiple mount protection (INCOMPAT_MMP).</p></td>
</tr>
<tr class="row-even"><td><p>0x200</p></td>
<td><p>Flexible block groups. See the earlier discussion of this feature
(INCOMPAT_FLEX_BG).</p></td>
</tr>
<tr class="row-odd"><td><p>0x400</p></td>
<td><p>Inodes can be used to store large extended attribute values
(INCOMPAT_EA_INODE).</p></td>
</tr>
<tr class="row-even"><td><p>0x1000</p></td>
<td><p>Data in directory entry (INCOMPAT_DIRDATA). (Not implemented?)</p></td>
</tr>
<tr class="row-odd"><td><p>0x2000</p></td>
<td><p>Metadata checksum seed is stored in the superblock. This feature enables
the administrator to change the UUID of a metadata_csum filesystem
while the filesystem is mounted; without it, the checksum definition
requires all metadata blocks to be rewritten (INCOMPAT_CSUM_SEED).</p></td>
</tr>
<tr class="row-even"><td><p>0x4000</p></td>
<td><p>Large directory &gt;2GB or 3-level htree (INCOMPAT_LARGEDIR). Prior to
this feature, directories could not be larger than 4GiB and could not
have an htree more than 2 levels deep. If this feature is enabled,
directories can be larger than 4GiB and have a maximum htree depth of 3.</p></td>
</tr>
<tr class="row-odd"><td><p>0x8000</p></td>
<td><p>Data in inode (INCOMPAT_INLINE_DATA).</p></td>
</tr>
<tr class="row-even"><td><p>0x10000</p></td>
<td><p>Encrypted inodes are present on the filesystem. (INCOMPAT_ENCRYPT).</p></td>
</tr>
</tbody>
</table>
<p id="super-rocompat">The superblock read-only compatible features field is a combination of any of
the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Sparse superblocks. See the earlier discussion of this feature
(RO_COMPAT_SPARSE_SUPER).</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>This filesystem has been used to store a file greater than 2GiB
(RO_COMPAT_LARGE_FILE).</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Not used in kernel or e2fsprogs (RO_COMPAT_BTREE_DIR).</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>This filesystem has files whose sizes are represented in units of
logical blocks, not 512-byte sectors. This implies a very large file
indeed! (RO_COMPAT_HUGE_FILE)</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>Group descriptors have checksums. In addition to detecting corruption,
this is useful for lazy formatting with uninitialized groups
(RO_COMPAT_GDT_CSUM).</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>Indicates that the old ext3 32,000 subdirectory limit no longer applies
(RO_COMPAT_DIR_NLINK). A directory’s i_links_count will be set to 1
if it is incremented past 64,999.</p></td>
</tr>
<tr class="row-even"><td><p>0x40</p></td>
<td><p>Indicates that large inodes exist on this filesystem
(RO_COMPAT_EXTRA_ISIZE).</p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>This filesystem has a snapshot (RO_COMPAT_HAS_SNAPSHOT).</p></td>
</tr>
<tr class="row-even"><td><p>0x100</p></td>
<td><p><a class="reference external" href="Quota">Quota</a> (RO_COMPAT_QUOTA).</p></td>
</tr>
<tr class="row-odd"><td><p>0x200</p></td>
<td><p>This filesystem supports “bigalloc”, which means that file extents are
tracked in units of clusters (of blocks) instead of blocks
(RO_COMPAT_BIGALLOC).</p></td>
</tr>
<tr class="row-even"><td><p>0x400</p></td>
<td><p>This filesystem supports metadata checksumming.
(RO_COMPAT_METADATA_CSUM; implies RO_COMPAT_GDT_CSUM, though
GDT_CSUM must not be set)</p></td>
</tr>
<tr class="row-odd"><td><p>0x800</p></td>
<td><p>Filesystem supports replicas. This feature is neither in the kernel nor
e2fsprogs. (RO_COMPAT_REPLICA)</p></td>
</tr>
<tr class="row-even"><td><p>0x1000</p></td>
<td><p>Read-only filesystem image; the kernel will not mount this image
read-write and most tools will refuse to write to the image.
(RO_COMPAT_READONLY)</p></td>
</tr>
<tr class="row-odd"><td><p>0x2000</p></td>
<td><p>Filesystem tracks project quotas. (RO_COMPAT_PROJECT)</p></td>
</tr>
<tr class="row-even"><td><p>0x8000</p></td>
<td><p>Verity inodes may be present on the filesystem. (RO_COMPAT_VERITY)</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000</p></td>
<td><p>Indicates orphan file may have valid orphan entries and thus we need
to clean them up when mounting the filesystem
(RO_COMPAT_ORPHAN_PRESENT).</p></td>
</tr>
</tbody>
</table>
<p id="super-def-hash">The <code class="docutils literal notranslate"><span class="pre">s_def_hash_version</span></code> field is one of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>Legacy.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>Half MD4.</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>Tea.</p></td>
</tr>
<tr class="row-odd"><td><p>0x3</p></td>
<td><p>Legacy, unsigned.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Half MD4, unsigned.</p></td>
</tr>
<tr class="row-odd"><td><p>0x5</p></td>
<td><p>Tea, unsigned.</p></td>
</tr>
</tbody>
</table>
<p id="super-mountopts">The <code class="docutils literal notranslate"><span class="pre">s_default_mount_opts</span></code> field is any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0001</p></td>
<td><p>Print debugging info upon (re)mount. (EXT4_DEFM_DEBUG)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0002</p></td>
<td><p>New files take the gid of the containing directory (instead of the fsgid
of the current process). (EXT4_DEFM_BSDGROUPS)</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>Support userspace-provided extended attributes. (EXT4_DEFM_XATTR_USER)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0008</p></td>
<td><p>Support POSIX access control lists (ACLs). (EXT4_DEFM_ACL)</p></td>
</tr>
<tr class="row-even"><td><p>0x0010</p></td>
<td><p>Do not support 32-bit UIDs. (EXT4_DEFM_UID16)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0020</p></td>
<td><p>All data and metadata are commited to the journal.
(EXT4_DEFM_JMODE_DATA)</p></td>
</tr>
<tr class="row-even"><td><p>0x0040</p></td>
<td><p>All data are flushed to the disk before metadata are committed to the
journal. (EXT4_DEFM_JMODE_ORDERED)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0060</p></td>
<td><p>Data ordering is not preserved; data may be written after the metadata
has been written. (EXT4_DEFM_JMODE_WBACK)</p></td>
</tr>
<tr class="row-even"><td><p>0x0100</p></td>
<td><p>Disable write flushes. (EXT4_DEFM_NOBARRIER)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0200</p></td>
<td><p>Track which blocks in a filesystem are metadata and therefore should not
be used as data blocks. This option will be enabled by default on 3.18,
hopefully. (EXT4_DEFM_BLOCK_VALIDITY)</p></td>
</tr>
<tr class="row-even"><td><p>0x0400</p></td>
<td><p>Enable DISCARD support, where the storage device is told about blocks
becoming unused. (EXT4_DEFM_DISCARD)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0800</p></td>
<td><p>Disable delayed allocation. (EXT4_DEFM_NODELALLOC)</p></td>
</tr>
</tbody>
</table>
<p id="super-flags">The <code class="docutils literal notranslate"><span class="pre">s_flags</span></code> field is any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0001</p></td>
<td><p>Signed directory hash in use.</p></td>
</tr>
<tr class="row-odd"><td><p>0x0002</p></td>
<td><p>Unsigned directory hash in use.</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>To test development code.</p></td>
</tr>
</tbody>
</table>
<p id="super-encrypt">The <code class="docutils literal notranslate"><span class="pre">s_encrypt_algos</span></code> list can contain any of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Invalid algorithm (ENCRYPTION_MODE_INVALID).</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>256-bit AES in XTS mode (ENCRYPTION_MODE_AES_256_XTS).</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>256-bit AES in GCM mode (ENCRYPTION_MODE_AES_256_GCM).</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>256-bit AES in CBC mode (ENCRYPTION_MODE_AES_256_CBC).</p></td>
</tr>
</tbody>
</table>
<p>Total size of the superblock is 1024 bytes.</p>
</section>
<section id="block-group-descriptors">
<h2><span class="section-number">3.2. </span>Block Group Descriptors<a class="headerlink" href="#block-group-descriptors" title="Permalink to this headline">¶</a></h2>
<p>Each block group on the filesystem has one of these descriptors
associated with it. As noted in the Layout section above, the group
descriptors (if present) are the second item in the block group. The
standard configuration is for each block group to contain a full copy of
the block group descriptor table unless the sparse_super feature flag
is set.</p>
<p>Notice how the group descriptor records the location of both bitmaps and
the inode table (i.e. they can float). This means that within a block
group, the only data structures with fixed locations are the superblock
and the group descriptor table. The flex_bg mechanism uses this
property to group several block groups into a flex group and lay out all
of the groups’ bitmaps and inode tables into one long run in the first
group of the flex group.</p>
<p>If the meta_bg feature flag is set, then several block groups are
grouped together into a meta group. Note that in the meta_bg case,
however, the first and last two block groups within the larger meta
group contain only group descriptors for the groups inside the meta
group.</p>
<p>flex_bg and meta_bg do not appear to be mutually exclusive features.</p>
<p>In ext2, ext3, and ext4 (when the 64bit feature is not enabled), the
block group descriptor was only 32 bytes long and therefore ends at
bg_checksum. On an ext4 filesystem with the 64bit feature enabled, the
block group descriptor expands to at least the 64 bytes described below;
the size is stored in the superblock.</p>
<p>If gdt_csum is set and metadata_csum is not set, the block group
checksum is the crc16 of the FS UUID, the group number, and the group
descriptor structure. If metadata_csum is set, then the block group
checksum is the lower 16 bits of the checksum of the FS UUID, the group
number, and the group descriptor structure. Both block and inode bitmap
checksums are calculated against the FS UUID, the group number, and the
entire bitmap.</p>
<p>The block group descriptor is laid out in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_group_desc</span></code>.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>bg_block_bitmap_lo</p></td>
<td><p>Lower 32-bits of location of block bitmap.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>bg_inode_bitmap_lo</p></td>
<td><p>Lower 32-bits of location of inode bitmap.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>bg_inode_table_lo</p></td>
<td><p>Lower 32-bits of location of inode table.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__le16</p></td>
<td><p>bg_free_blocks_count_lo</p></td>
<td><p>Lower 16-bits of free block count.</p></td>
</tr>
<tr class="row-even"><td><p>0xE</p></td>
<td><p>__le16</p></td>
<td><p>bg_free_inodes_count_lo</p></td>
<td><p>Lower 16-bits of free inode count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10</p></td>
<td><p>__le16</p></td>
<td><p>bg_used_dirs_count_lo</p></td>
<td><p>Lower 16-bits of directory count.</p></td>
</tr>
<tr class="row-even"><td><p>0x12</p></td>
<td><p>__le16</p></td>
<td><p>bg_flags</p></td>
<td><p>Block group flags. See the <a class="reference internal" href="#bgflags">bgflags</a> table below.</p></td>
</tr>
<tr class="row-odd"><td><p>0x14</p></td>
<td><p>__le32</p></td>
<td><p>bg_exclude_bitmap_lo</p></td>
<td><p>Lower 32-bits of location of snapshot exclusion bitmap.</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>__le16</p></td>
<td><p>bg_block_bitmap_csum_lo</p></td>
<td><p>Lower 16-bits of the block bitmap checksum.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1A</p></td>
<td><p>__le16</p></td>
<td><p>bg_inode_bitmap_csum_lo</p></td>
<td><p>Lower 16-bits of the inode bitmap checksum.</p></td>
</tr>
<tr class="row-even"><td><p>0x1C</p></td>
<td><p>__le16</p></td>
<td><p>bg_itable_unused_lo</p></td>
<td><p>Lower 16-bits of unused inode count. If set, we needn’t scan past the
<code class="docutils literal notranslate"><span class="pre">(sb.s_inodes_per_group</span> <span class="pre">-</span> <span class="pre">gdt.bg_itable_unused)</span></code> th entry in the
inode table for this group.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1E</p></td>
<td><p>__le16</p></td>
<td><p>bg_checksum</p></td>
<td><p>Group descriptor checksum; crc16(sb_uuid+group_num+bg_desc) if the
RO_COMPAT_GDT_CSUM feature is set, or
crc32c(sb_uuid+group_num+bg_desc) &amp; 0xFFFF if the
RO_COMPAT_METADATA_CSUM feature is set.  The bg_checksum
field in bg_desc is skipped when calculating crc16 checksum,
and set to zero if crc32c checksum is used.</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>These fields only exist if the 64bit feature is enabled and s_desc_size
&gt; 32.</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>__le32</p></td>
<td><p>bg_block_bitmap_hi</p></td>
<td><p>Upper 32-bits of location of block bitmap.</p></td>
</tr>
<tr class="row-even"><td><p>0x24</p></td>
<td><p>__le32</p></td>
<td><p>bg_inode_bitmap_hi</p></td>
<td><p>Upper 32-bits of location of inodes bitmap.</p></td>
</tr>
<tr class="row-odd"><td><p>0x28</p></td>
<td><p>__le32</p></td>
<td><p>bg_inode_table_hi</p></td>
<td><p>Upper 32-bits of location of inodes table.</p></td>
</tr>
<tr class="row-even"><td><p>0x2C</p></td>
<td><p>__le16</p></td>
<td><p>bg_free_blocks_count_hi</p></td>
<td><p>Upper 16-bits of free block count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2E</p></td>
<td><p>__le16</p></td>
<td><p>bg_free_inodes_count_hi</p></td>
<td><p>Upper 16-bits of free inode count.</p></td>
</tr>
<tr class="row-even"><td><p>0x30</p></td>
<td><p>__le16</p></td>
<td><p>bg_used_dirs_count_hi</p></td>
<td><p>Upper 16-bits of directory count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x32</p></td>
<td><p>__le16</p></td>
<td><p>bg_itable_unused_hi</p></td>
<td><p>Upper 16-bits of unused inode count.</p></td>
</tr>
<tr class="row-even"><td><p>0x34</p></td>
<td><p>__le32</p></td>
<td><p>bg_exclude_bitmap_hi</p></td>
<td><p>Upper 32-bits of location of snapshot exclusion bitmap.</p></td>
</tr>
<tr class="row-odd"><td><p>0x38</p></td>
<td><p>__le16</p></td>
<td><p>bg_block_bitmap_csum_hi</p></td>
<td><p>Upper 16-bits of the block bitmap checksum.</p></td>
</tr>
<tr class="row-even"><td><p>0x3A</p></td>
<td><p>__le16</p></td>
<td><p>bg_inode_bitmap_csum_hi</p></td>
<td><p>Upper 16-bits of the inode bitmap checksum.</p></td>
</tr>
<tr class="row-odd"><td><p>0x3C</p></td>
<td><p>__u32</p></td>
<td><p>bg_reserved</p></td>
<td><p>Padding to 64 bytes.</p></td>
</tr>
</tbody>
</table>
<p id="bgflags">Block group flags can be any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>inode table and bitmap are not initialized (EXT4_BG_INODE_UNINIT).</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>block bitmap is not initialized (EXT4_BG_BLOCK_UNINIT).</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>inode table is zeroed (EXT4_BG_INODE_ZEROED).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="block-and-inode-bitmaps">
<h2><span class="section-number">3.3. </span>Block and inode Bitmaps<a class="headerlink" href="#block-and-inode-bitmaps" title="Permalink to this headline">¶</a></h2>
<p>The data block bitmap tracks the usage of data blocks within the block
group.</p>
<p>The inode bitmap records which entries in the inode table are in use.</p>
<p>As with most bitmaps, one bit represents the usage status of one data
block or inode table entry. This implies a block group size of 8 *
number_of_bytes_in_a_logical_block.</p>
<p>NOTE: If <code class="docutils literal notranslate"><span class="pre">BLOCK_UNINIT</span></code> is set for a given block group, various parts
of the kernel and e2fsprogs code pretends that the block bitmap contains
zeros (i.e. all blocks in the group are free). However, it is not
necessarily the case that no blocks are in use – if <code class="docutils literal notranslate"><span class="pre">meta_bg</span></code> is set,
the bitmaps and group descriptor live inside the group. Unfortunately,
ext2fs_test_block_bitmap2() will return ‘0’ for those locations,
which produces confusing debugfs output.</p>
</section>
<section id="inode-table">
<h2><span class="section-number">3.4. </span>Inode Table<a class="headerlink" href="#inode-table" title="Permalink to this headline">¶</a></h2>
<p>Inode tables are statically allocated at mkfs time.  Each block group
descriptor points to the start of the table, and the superblock records
the number of inodes per group.  See the section on inodes for more
information.</p>
</section>
<section id="multiple-mount-protection">
<h2><span class="section-number">3.5. </span>Multiple Mount Protection<a class="headerlink" href="#multiple-mount-protection" title="Permalink to this headline">¶</a></h2>
<p>Multiple mount protection (MMP) is a feature that protects the
filesystem against multiple hosts trying to use the filesystem
simultaneously. When a filesystem is opened (for mounting, or fsck,
etc.), the MMP code running on the node (call it node A) checks a
sequence number. If the sequence number is EXT4_MMP_SEQ_CLEAN, the
open continues. If the sequence number is EXT4_MMP_SEQ_FSCK, then
fsck is (hopefully) running, and open fails immediately. Otherwise, the
open code will wait for twice the specified MMP check interval and check
the sequence number again. If the sequence number has changed, then the
filesystem is active on another machine and the open fails. If the MMP
code passes all of those checks, a new MMP sequence number is generated
and written to the MMP block, and the mount proceeds.</p>
<p>While the filesystem is live, the kernel sets up a timer to re-check the
MMP block at the specified MMP check interval. To perform the re-check,
the MMP sequence number is re-read; if it does not match the in-memory
MMP sequence number, then another node (node B) has mounted the
filesystem, and node A remounts the filesystem read-only. If the
sequence numbers match, the sequence number is incremented both in
memory and on disk, and the re-check is complete.</p>
<p>The hostname and device filename are written into the MMP block whenever
an open operation succeeds. The MMP code does not use these values; they
are provided purely for informational purposes.</p>
<p>The checksum is calculated against the FS UUID and the MMP structure.
The MMP structure (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmp_struct</span></code>) is as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 15%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>mmp_magic</p></td>
<td><p>Magic number for MMP, 0x004D4D50 (“MMP”).</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>mmp_seq</p></td>
<td><p>Sequence number, updated periodically.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le64</p></td>
<td><p>mmp_time</p></td>
<td><p>Time that the MMP block was last updated.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10</p></td>
<td><p>char[64]</p></td>
<td><p>mmp_nodename</p></td>
<td><p>Hostname of the node that opened the filesystem.</p></td>
</tr>
<tr class="row-even"><td><p>0x50</p></td>
<td><p>char[32]</p></td>
<td><p>mmp_bdevname</p></td>
<td><p>Block device name of the filesystem.</p></td>
</tr>
<tr class="row-odd"><td><p>0x70</p></td>
<td><p>__le16</p></td>
<td><p>mmp_check_interval</p></td>
<td><p>The MMP re-check interval, in seconds.</p></td>
</tr>
<tr class="row-even"><td><p>0x72</p></td>
<td><p>__le16</p></td>
<td><p>mmp_pad1</p></td>
<td><p>Zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x74</p></td>
<td><p>__le32[226]</p></td>
<td><p>mmp_pad2</p></td>
<td><p>Zero.</p></td>
</tr>
<tr class="row-even"><td><p>0x3FC</p></td>
<td><p>__le32</p></td>
<td><p>mmp_checksum</p></td>
<td><p>Checksum of the MMP block.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="journal-jbd2">
<h2><span class="section-number">3.6. </span>Journal (jbd2)<a class="headerlink" href="#journal-jbd2" title="Permalink to this headline">¶</a></h2>
<p>Introduced in ext3, the ext4 filesystem employs a journal to protect the
filesystem against metadata inconsistencies in the case of a system crash. Up
to 10,240,000 file system blocks (see man mke2fs(8) for more details on journal
size limits) can be reserved inside the filesystem as a place to land
“important” data writes on-disk as quickly as possible. Once the important
data transaction is fully written to the disk and flushed from the disk write
cache, a record of the data being committed is also written to the journal. At
some later point in time, the journal code writes the transactions to their
final locations on disk (this could involve a lot of seeking or a lot of small
read-write-erases) before erasing the commit record. Should the system
crash during the second slow write, the journal can be replayed all the
way to the latest commit record, guaranteeing the atomicity of whatever
gets written through the journal to the disk. The effect of this is to
guarantee that the filesystem does not become stuck midway through a
metadata update.</p>
<p>For performance reasons, ext4 by default only writes filesystem metadata
through the journal. This means that file data blocks are /not/
guaranteed to be in any consistent state after a crash. If this default
guarantee level (<code class="docutils literal notranslate"><span class="pre">data=ordered</span></code>) is not satisfactory, there is a mount
option to control journal behavior. If <code class="docutils literal notranslate"><span class="pre">data=journal</span></code>, all data and
metadata are written to disk through the journal. This is slower but
safest. If <code class="docutils literal notranslate"><span class="pre">data=writeback</span></code>, dirty data blocks are not flushed to the
disk before the metadata are written to disk through the journal.</p>
<p>In case of <code class="docutils literal notranslate"><span class="pre">data=ordered</span></code> mode, Ext4 also supports fast commits which
help reduce commit latency significantly. The default <code class="docutils literal notranslate"><span class="pre">data=ordered</span></code>
mode works by logging metadata blocks to the journal. In fast commit
mode, Ext4 only stores the minimal delta needed to recreate the
affected metadata in fast commit space that is shared with JBD2.
Once the fast commit area fills in or if fast commit is not possible
or if JBD2 commit timer goes off, Ext4 performs a traditional full commit.
A full commit invalidates all the fast commits that happened before
it and thus it makes the fast commit area empty for further fast
commits. This feature needs to be enabled at mkfs time.</p>
<p>The journal inode is typically inode 8. The first 68 bytes of the
journal inode are replicated in the ext4 superblock. The journal itself
is normal (but hidden) file within the filesystem. The file usually
consumes an entire block group, though mke2fs tries to put it in the
middle of the disk.</p>
<p>All fields in jbd2 are written to disk in big-endian order. This is the
opposite of ext4.</p>
<p>NOTE: Both ext4 and ocfs2 use jbd2.</p>
<p>The maximum size of a journal embedded in an ext4 filesystem is 2^32
blocks. jbd2 itself does not seem to care.</p>
<section id="layout">
<h3><span class="section-number">3.6.1. </span>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>Generally speaking, the journal has this format:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 60%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Superblock</p></th>
<th class="head"><p>descriptor_block (data_blocks or revocation_block) [more data or
revocations] commmit_block</p></th>
<th class="head"><p>[more transactions…]</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
<td><p>One transaction</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Notice that a transaction begins with either a descriptor and some data,
or a block revocation list. A finished transaction always ends with a
commit. If there is no commit record (or the checksums don’t match), the
transaction will be discarded during replay.</p>
</section>
<section id="external-journal">
<h3><span class="section-number">3.6.2. </span>External Journal<a class="headerlink" href="#external-journal" title="Permalink to this headline">¶</a></h3>
<p>Optionally, an ext4 filesystem can be created with an external journal
device (as opposed to an internal journal, which uses a reserved inode).
In this case, on the filesystem device, <code class="docutils literal notranslate"><span class="pre">s_journal_inum</span></code> should be
zero and <code class="docutils literal notranslate"><span class="pre">s_journal_uuid</span></code> should be set. On the journal device there
will be an ext4 super block in the usual place, with a matching UUID.
The journal superblock will be in the next full block after the
superblock.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 40%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>1024 bytes of padding</p></th>
<th class="head"><p>ext4 Superblock</p></th>
<th class="head"><p>Journal Superblock</p></th>
<th class="head"><p>descriptor_block (data_blocks or revocation_block) [more data or
revocations] commmit_block</p></th>
<th class="head"><p>[more transactions…]</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>One transaction</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="block-header">
<h3><span class="section-number">3.6.3. </span>Block Header<a class="headerlink" href="#block-header" title="Permalink to this headline">¶</a></h3>
<p>Every block in the journal starts with a common 12-byte header
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_header_s</span></code>:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__be32</p></td>
<td><p>h_magic</p></td>
<td><p>jbd2 magic number, 0xC03B3998.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__be32</p></td>
<td><p>h_blocktype</p></td>
<td><p>Description of what this block contains. See the <a class="reference internal" href="#jbd2-blocktype">jbd2_blocktype</a> table
below.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__be32</p></td>
<td><p>h_sequence</p></td>
<td><p>The transaction ID that goes with this block.</p></td>
</tr>
</tbody>
</table>
<p id="jbd2-blocktype">The journal block type can be any one of:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Descriptor. This block precedes a series of data blocks that were
written through the journal during a transaction.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Block commit record. This block signifies the completion of a
transaction.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Journal superblock, v1.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Journal superblock, v2.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Block revocation records. This speeds up recovery by enabling the
journal to skip writing blocks that were subsequently rewritten.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id1">
<h3><span class="section-number">3.6.4. </span>Super Block<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The super block for the journal is much simpler as compared to ext4’s.
The key data kept within are size of the journal, and where to find the
start of the log of transactions.</p>
<p>The journal superblock is recorded as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_superblock_s</span></code>,
which is 1024 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>Static information describing the journal.</p></td>
</tr>
<tr class="row-odd"><td><p>0x0</p></td>
<td><p>journal_header_t (12 bytes)</p></td>
<td><p>s_header</p></td>
<td><p>Common header identifying this as a superblock.</p></td>
</tr>
<tr class="row-even"><td><p>0xC</p></td>
<td><p>__be32</p></td>
<td><p>s_blocksize</p></td>
<td><p>Journal device block size.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10</p></td>
<td><p>__be32</p></td>
<td><p>s_maxlen</p></td>
<td><p>Total number of blocks in this journal.</p></td>
</tr>
<tr class="row-even"><td><p>0x14</p></td>
<td><p>__be32</p></td>
<td><p>s_first</p></td>
<td><p>First block of log information.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>Dynamic information describing the current state of the log.</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>__be32</p></td>
<td><p>s_sequence</p></td>
<td><p>First commit ID expected in log.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1C</p></td>
<td><p>__be32</p></td>
<td><p>s_start</p></td>
<td><p>Block number of the start of log. Contrary to the comments, this field
being zero does not imply that the journal is clean!</p></td>
</tr>
<tr class="row-even"><td><p>0x20</p></td>
<td><p>__be32</p></td>
<td><p>s_errno</p></td>
<td><p>Error value, as set by <a class="reference internal" href="../journalling.html#c.jbd2_journal_abort" title="jbd2_journal_abort"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_abort()</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>The remaining fields are only valid in a v2 superblock.</p></td>
</tr>
<tr class="row-even"><td><p>0x24</p></td>
<td><p>__be32</p></td>
<td><p>s_feature_compat;</p></td>
<td><p>Compatible feature set. See the table <a class="reference internal" href="#jbd2-compat">jbd2_compat</a> below.</p></td>
</tr>
<tr class="row-odd"><td><p>0x28</p></td>
<td><p>__be32</p></td>
<td><p>s_feature_incompat</p></td>
<td><p>Incompatible feature set. See the table <a class="reference internal" href="#jbd2-incompat">jbd2_incompat</a> below.</p></td>
</tr>
<tr class="row-even"><td><p>0x2C</p></td>
<td><p>__be32</p></td>
<td><p>s_feature_ro_compat</p></td>
<td><p>Read-only compatible feature set. There aren’t any of these currently.</p></td>
</tr>
<tr class="row-odd"><td><p>0x30</p></td>
<td><p>__u8</p></td>
<td><p>s_uuid[16]</p></td>
<td><p>128-bit uuid for journal. This is compared against the copy in the ext4
super block at mount time.</p></td>
</tr>
<tr class="row-even"><td><p>0x40</p></td>
<td><p>__be32</p></td>
<td><p>s_nr_users</p></td>
<td><p>Number of file systems sharing this journal.</p></td>
</tr>
<tr class="row-odd"><td><p>0x44</p></td>
<td><p>__be32</p></td>
<td><p>s_dynsuper</p></td>
<td><p>Location of dynamic super block copy. (Not used?)</p></td>
</tr>
<tr class="row-even"><td><p>0x48</p></td>
<td><p>__be32</p></td>
<td><p>s_max_transaction</p></td>
<td><p>Limit of journal blocks per transaction. (Not used?)</p></td>
</tr>
<tr class="row-odd"><td><p>0x4C</p></td>
<td><p>__be32</p></td>
<td><p>s_max_trans_data</p></td>
<td><p>Limit of data blocks per transaction. (Not used?)</p></td>
</tr>
<tr class="row-even"><td><p>0x50</p></td>
<td><p>__u8</p></td>
<td><p>s_checksum_type</p></td>
<td><p>Checksum algorithm used for the journal.  See <a class="reference internal" href="#jbd2-checksum-type">jbd2_checksum_type</a> for
more info.</p></td>
</tr>
<tr class="row-odd"><td><p>0x51</p></td>
<td><p>__u8[3]</p></td>
<td><p>s_padding2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x54</p></td>
<td><p>__be32</p></td>
<td><p>s_num_fc_blocks</p></td>
<td><p>Number of fast commit blocks in the journal.</p></td>
</tr>
<tr class="row-odd"><td><p>0x58</p></td>
<td><p>__u32</p></td>
<td><p>s_padding[42]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0xFC</p></td>
<td><p>__be32</p></td>
<td><p>s_checksum</p></td>
<td><p>Checksum of the entire superblock, with this field set to zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x100</p></td>
<td><p>__u8</p></td>
<td><p>s_users[16*48]</p></td>
<td><p>ids of all file systems sharing the log. e2fsprogs/Linux don’t allow
shared external journals, but I imagine Lustre (or ocfs2?), which use
the jbd2 code, might.</p></td>
</tr>
</tbody>
</table>
<p id="jbd2-compat">The journal compat features are any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Journal maintains checksums on the data blocks.
(JBD2_FEATURE_COMPAT_CHECKSUM)</p></td>
</tr>
</tbody>
</table>
<p id="jbd2-incompat">The journal incompat features are any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Journal has block revocation records. (JBD2_FEATURE_INCOMPAT_REVOKE)</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>Journal can deal with 64-bit block numbers.
(JBD2_FEATURE_INCOMPAT_64BIT)</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Journal commits asynchronously. (JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>This journal uses v2 of the checksum on-disk format. Each journal
metadata block gets its own checksum, and the block tags in the
descriptor table contain checksums for each of the data blocks in the
journal. (JBD2_FEATURE_INCOMPAT_CSUM_V2)</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>This journal uses v3 of the checksum on-disk format. This is the same as
v2, but the journal block tag size is fixed regardless of the size of
block numbers. (JBD2_FEATURE_INCOMPAT_CSUM_V3)</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>Journal has fast commit blocks. (JBD2_FEATURE_INCOMPAT_FAST_COMMIT)</p></td>
</tr>
</tbody>
</table>
<p id="jbd2-checksum-type">Journal checksum type codes are one of the following.  crc32 or crc32c are the
most likely choices.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>CRC32</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>MD5</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>SHA1</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>CRC32C</p></td>
</tr>
</tbody>
</table>
</section>
<section id="descriptor-block">
<h3><span class="section-number">3.6.5. </span>Descriptor Block<a class="headerlink" href="#descriptor-block" title="Permalink to this headline">¶</a></h3>
<p>The descriptor block contains an array of journal block tags that
describe the final locations of the data blocks that follow in the
journal. Descriptor blocks are open-coded instead of being completely
described by a data structure, but here is the block structure anyway.
Descriptor blocks consume at least 36 bytes, but use a full block:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Descriptor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>journal_header_t</p></td>
<td><p>(open coded)</p></td>
<td><p>Common block header.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>struct journal_block_tag_s</p></td>
<td><p>open coded array[]</p></td>
<td><p>Enough tags either to fill up the block or to describe all the data
blocks that follow this descriptor block.</p></td>
</tr>
</tbody>
</table>
<p>Journal block tags have any of the following formats, depending on which
journal feature and block tag flags are set.</p>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is set, the journal block tag is
defined as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_block_tag3_s</span></code>, which looks like the
following. The size is 16 or 32 bytes.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Descriptor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__be32</p></td>
<td><p>t_blocknr</p></td>
<td><p>Lower 32-bits of the location of where the corresponding data block
should end up on disk.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__be32</p></td>
<td><p>t_flags</p></td>
<td><p>Flags that go with the descriptor. See the table <a class="reference internal" href="#jbd2-tag-flags">jbd2_tag_flags</a> for
more info.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__be32</p></td>
<td><p>t_blocknr_high</p></td>
<td><p>Upper 32-bits of the location of where the corresponding data block
should end up on disk. This is zero if JBD2_FEATURE_INCOMPAT_64BIT is
not enabled.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__be32</p></td>
<td><p>t_checksum</p></td>
<td><p>Checksum of the journal UUID, the sequence number, and the data block.</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>This field appears to be open coded. It always comes at the end of the
tag, after t_checksum. This field is not present if the “same UUID” flag
is set.</p></td>
</tr>
<tr class="row-odd"><td><p>0x8 or 0xC</p></td>
<td><p>char</p></td>
<td><p>uuid[16]</p></td>
<td><p>A UUID to go with this tag. This field appears to be copied from the
<code class="docutils literal notranslate"><span class="pre">j_uuid</span></code> field in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_s</span></code>, but only tune2fs touches that
field.</p></td>
</tr>
</tbody>
</table>
<p id="jbd2-tag-flags">The journal tag flags are any combination of the following:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>On-disk block is escaped. The first four bytes of the data block just
happened to match the jbd2 magic number.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>This block has the same UUID as previous, therefore the UUID field is
omitted.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>The data block was deleted by the transaction. (Not used?)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>This is the last tag in this descriptor block.</p></td>
</tr>
</tbody>
</table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is NOT set, the journal block tag
is defined as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_block_tag_s</span></code>, which looks like the
following. The size is 8, 12, 24, or 28 bytes:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Descriptor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__be32</p></td>
<td><p>t_blocknr</p></td>
<td><p>Lower 32-bits of the location of where the corresponding data block
should end up on disk.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__be16</p></td>
<td><p>t_checksum</p></td>
<td><p>Checksum of the journal UUID, the sequence number, and the data block.
Note that only the lower 16 bits are stored.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>__be16</p></td>
<td><p>t_flags</p></td>
<td><p>Flags that go with the descriptor. See the table <a class="reference internal" href="#jbd2-tag-flags">jbd2_tag_flags</a> for
more info.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>This next field is only present if the super block indicates support for
64-bit block numbers.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__be32</p></td>
<td><p>t_blocknr_high</p></td>
<td><p>Upper 32-bits of the location of where the corresponding data block
should end up on disk.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>This field appears to be open coded. It always comes at the end of the
tag, after t_flags or t_blocknr_high. This field is not present if the
“same UUID” flag is set.</p></td>
</tr>
<tr class="row-even"><td><p>0x8 or 0xC</p></td>
<td><p>char</p></td>
<td><p>uuid[16]</p></td>
<td><p>A UUID to go with this tag. This field appears to be copied from the
<code class="docutils literal notranslate"><span class="pre">j_uuid</span></code> field in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">journal_s</span></code>, but only tune2fs touches that
field.</p></td>
</tr>
</tbody>
</table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or
JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the block is a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jbd2_journal_block_tail</span></code>, which looks like this:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Descriptor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__be32</p></td>
<td><p>t_checksum</p></td>
<td><p>Checksum of the journal UUID + the descriptor block, with this field set
to zero.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="data-block">
<h3><span class="section-number">3.6.6. </span>Data Block<a class="headerlink" href="#data-block" title="Permalink to this headline">¶</a></h3>
<p>In general, the data blocks being written to disk through the journal
are written verbatim into the journal file after the descriptor block.
However, if the first four bytes of the block match the jbd2 magic
number then those four bytes are replaced with zeroes and the “escaped”
flag is set in the descriptor block tag.</p>
</section>
<section id="revocation-block">
<h3><span class="section-number">3.6.7. </span>Revocation Block<a class="headerlink" href="#revocation-block" title="Permalink to this headline">¶</a></h3>
<p>A revocation block is used to prevent replay of a block in an earlier
transaction. This is used to mark blocks that were journalled at one
time but are no longer journalled. Typically this happens if a metadata
block is freed and re-allocated as a file data block; in this case, a
journal replay after the file block was written to disk will cause
corruption.</p>
<p><strong>NOTE</strong>: This mechanism is NOT used to express “this journal block is
superseded by this other journal block”, as the author (djwong)
mistakenly thought. Any block being added to a transaction will cause
the removal of all existing revocation records for that block.</p>
<p>Revocation blocks are described in
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jbd2_journal_revoke_header_s</span></code>, are at least 16 bytes in
length, but use a full block:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>journal_header_t</p></td>
<td><p>r_header</p></td>
<td><p>Common block header.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__be32</p></td>
<td><p>r_count</p></td>
<td><p>Number of bytes used in this block.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>__be32 or __be64</p></td>
<td><p>blocks[0]</p></td>
<td><p>Blocks to revoke.</p></td>
</tr>
</tbody>
</table>
<p>After r_count is a linear array of block numbers that are effectively
revoked by this transaction. The size of each block number is 8 bytes if
the superblock advertises 64-bit block number support, or 4 bytes
otherwise.</p>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or
JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the revocation
block is a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jbd2_journal_revoke_tail</span></code>, which has this format:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__be32</p></td>
<td><p>r_checksum</p></td>
<td><p>Checksum of the journal UUID + revocation block</p></td>
</tr>
</tbody>
</table>
</section>
<section id="commit-block">
<h3><span class="section-number">3.6.8. </span>Commit Block<a class="headerlink" href="#commit-block" title="Permalink to this headline">¶</a></h3>
<p>The commit block is a sentry that indicates that a transaction has been
completely written to the journal. Once this commit block reaches the
journal, the data stored with this transaction can be written to their
final locations on disk.</p>
<p>The commit block is described by <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">commit_header</span></code>, which is 32
bytes long (but uses a full block):</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Descriptor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>journal_header_s</p></td>
<td><p>(open coded)</p></td>
<td><p>Common block header.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>unsigned char</p></td>
<td><p>h_chksum_type</p></td>
<td><p>The type of checksum to use to verify the integrity of the data blocks
in the transaction. See <a class="reference internal" href="#jbd2-checksum-type">jbd2_checksum_type</a> for more info.</p></td>
</tr>
<tr class="row-even"><td><p>0xD</p></td>
<td><p>unsigned char</p></td>
<td><p>h_chksum_size</p></td>
<td><p>The number of bytes used by the checksum. Most likely 4.</p></td>
</tr>
<tr class="row-odd"><td><p>0xE</p></td>
<td><p>unsigned char</p></td>
<td><p>h_padding[2]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>__be32</p></td>
<td><p>h_chksum[JBD2_CHECKSUM_BYTES]</p></td>
<td><p>32 bytes of space to store checksums. If
JBD2_FEATURE_INCOMPAT_CSUM_V2 or JBD2_FEATURE_INCOMPAT_CSUM_V3
are set, the first <code class="docutils literal notranslate"><span class="pre">__be32</span></code> is the checksum of the journal UUID and
the entire commit block, with this field zeroed. If
JBD2_FEATURE_COMPAT_CHECKSUM is set, the first <code class="docutils literal notranslate"><span class="pre">__be32</span></code> is the
crc32 of all the blocks already written to the transaction.</p></td>
</tr>
<tr class="row-odd"><td><p>0x30</p></td>
<td><p>__be64</p></td>
<td><p>h_commit_sec</p></td>
<td><p>The time that the transaction was committed, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x38</p></td>
<td><p>__be32</p></td>
<td><p>h_commit_nsec</p></td>
<td><p>Nanoseconds component of the above timestamp.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="fast-commits">
<h3><span class="section-number">3.6.9. </span>Fast commits<a class="headerlink" href="#fast-commits" title="Permalink to this headline">¶</a></h3>
<p>Fast commit area is organized as a log of tag length values. Each TLV has
a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_tl</span></code> in the beginning which stores the tag and the length
of the entire field. It is followed by variable length tag specific value.
Here is the list of supported tags and their meanings:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tag</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>Value struct</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>EXT4_FC_TAG_HEAD</p></td>
<td><p>Fast commit area header</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_head</span></code></p></td>
<td><p>Stores the TID of the transaction after which these fast commits should
be applied.</p></td>
</tr>
<tr class="row-odd"><td><p>EXT4_FC_TAG_ADD_RANGE</p></td>
<td><p>Add extent to inode</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_add_range</span></code></p></td>
<td><p>Stores the inode number and extent to be added in this inode</p></td>
</tr>
<tr class="row-even"><td><p>EXT4_FC_TAG_DEL_RANGE</p></td>
<td><p>Remove logical offsets to inode</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_del_range</span></code></p></td>
<td><p>Stores the inode number and the logical offset range that needs to be
removed</p></td>
</tr>
<tr class="row-odd"><td><p>EXT4_FC_TAG_CREAT</p></td>
<td><p>Create directory entry for a newly created file</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_dentry_info</span></code></p></td>
<td><p>Stores the parent inode number, inode number and directory entry of the
newly created file</p></td>
</tr>
<tr class="row-even"><td><p>EXT4_FC_TAG_LINK</p></td>
<td><p>Link a directory entry to an inode</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_dentry_info</span></code></p></td>
<td><p>Stores the parent inode number, inode number and directory entry</p></td>
</tr>
<tr class="row-odd"><td><p>EXT4_FC_TAG_UNLINK</p></td>
<td><p>Unlink a directory entry of an inode</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_dentry_info</span></code></p></td>
<td><p>Stores the parent inode number, inode number and directory entry</p></td>
</tr>
<tr class="row-even"><td><p>EXT4_FC_TAG_PAD</p></td>
<td><p>Padding (unused area)</p></td>
<td><p>None</p></td>
<td><p>Unused bytes in the fast commit area.</p></td>
</tr>
<tr class="row-odd"><td><p>EXT4_FC_TAG_TAIL</p></td>
<td><p>Mark the end of a fast commit</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_fc_tail</span></code></p></td>
<td><p>Stores the TID of the commit, CRC of the fast commit of which this tag
represents the end of</p></td>
</tr>
</tbody>
</table>
</section>
<section id="fast-commit-replay-idempotence">
<h3><span class="section-number">3.6.10. </span>Fast Commit Replay Idempotence<a class="headerlink" href="#fast-commit-replay-idempotence" title="Permalink to this headline">¶</a></h3>
<p>Fast commits tags are idempotent in nature provided the recovery code follows
certain rules. The guiding principle that the commit path follows while
committing is that it stores the result of a particular operation instead of
storing the procedure.</p>
<p>Let’s consider this rename operation: ‘mv /a /b’. Let’s assume dirent ‘/a’
was associated with inode 10. During fast commit, instead of storing this
operation as a procedure “rename a to b”, we store the resulting file system
state as a “series” of outcomes:</p>
<ul class="simple">
<li><p>Link dirent b to inode 10</p></li>
<li><p>Unlink dirent a</p></li>
<li><p>Inode 10 with valid refcount</p></li>
</ul>
<p>Now when recovery code runs, it needs “enforce” this state on the file
system. This is what guarantees idempotence of fast commit replay.</p>
<p>Let’s take an example of a procedure that is not idempotent and see how fast
commits make it idempotent. Consider following sequence of operations:</p>
<ol class="arabic simple">
<li><p>rm A</p></li>
<li><p>mv B A</p></li>
<li><p>read A</p></li>
</ol>
<p>If we store this sequence of operations as is then the replay is not idempotent.
Let’s say while in replay, we crash after (2). During the second replay,
file A (which was actually created as a result of “mv B A” operation) would get
deleted. Thus, file named A would be absent when we try to read A. So, this
sequence of operations is not idempotent. However, as mentioned above, instead
of storing the procedure fast commits store the outcome of each procedure. Thus
the fast commit log for above procedure would be as follows:</p>
<p>(Let’s assume dirent A was linked to inode 10 and dirent B was linked to
inode 11 before the replay)</p>
<ol class="arabic simple">
<li><p>Unlink A</p></li>
<li><p>Link A to inode 11</p></li>
<li><p>Unlink B</p></li>
<li><p>Inode 11</p></li>
</ol>
<p>If we crash after (3) we will have file A linked to inode 11. During the second
replay, we will remove file A (inode 11). But we will create it back and make
it point to inode 11. We won’t find B, so we’ll just skip that step. At this
point, the refcount for inode 11 is not reliable, but that gets fixed by the
replay of last inode 11 tag. Thus, by converting a non-idempotent procedure
into a series of idempotent outcomes, fast commits ensured idempotence during
the replay.</p>
</section>
<section id="journal-checkpoint">
<h3><span class="section-number">3.6.11. </span>Journal Checkpoint<a class="headerlink" href="#journal-checkpoint" title="Permalink to this headline">¶</a></h3>
<p>Checkpointing the journal ensures all transactions and their associated buffers
are submitted to the disk. In-progress transactions are waited upon and included
in the checkpoint. Checkpointing is used internally during critical updates to
the filesystem including journal recovery, filesystem resizing, and freeing of
the journal_t structure.</p>
<p>A journal checkpoint can be triggered from userspace via the ioctl
EXT4_IOC_CHECKPOINT. This ioctl takes a single, u64 argument for flags.
Currently, three flags are supported. First, EXT4_IOC_CHECKPOINT_FLAG_DRY_RUN
can be used to verify input to the ioctl. It returns error if there is any
invalid input, otherwise it returns success without performing
any checkpointing. This can be used to check whether the ioctl exists on a
system and to verify there are no issues with arguments or flags. The
other two flags are EXT4_IOC_CHECKPOINT_FLAG_DISCARD and
EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT. These flags cause the journal blocks to be
discarded or zero-filled, respectively, after the journal checkpoint is
complete. EXT4_IOC_CHECKPOINT_FLAG_DISCARD and EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT
cannot both be set. The ioctl may be useful when snapshotting a system or for
complying with content deletion SLOs.</p>
</section>
</section>
<section id="orphan-file">
<h2><span class="section-number">3.7. </span>Orphan file<a class="headerlink" href="#orphan-file" title="Permalink to this headline">¶</a></h2>
<p>In unix there can inodes that are unlinked from directory hierarchy but that
are still alive because they are open. In case of crash the filesystem has to
clean up these inodes as otherwise they (and the blocks referenced from them)
would leak. Similarly if we truncate or extend the file, we need not be able
to perform the operation in a single journalling transaction. In such case we
track the inode as orphan so that in case of crash extra blocks allocated to
the file get truncated.</p>
<p>Traditionally ext4 tracks orphan inodes in a form of single linked list where
superblock contains the inode number of the last orphan inode (s_last_orphan
field) and then each inode contains inode number of the previously orphaned
inode (we overload i_dtime inode field for this). However this filesystem
global single linked list is a scalability bottleneck for workloads that result
in heavy creation of orphan inodes. When orphan file feature
(COMPAT_ORPHAN_FILE) is enabled, the filesystem has a special inode
(referenced from the superblock through s_orphan_file_inum) with several
blocks. Each of these blocks has a structure:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 20%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>Array of
__le32 entries</p></td>
<td><p>Orphan inode
entries</p></td>
<td><p>Each __le32 entry is either
empty (0) or it contains
inode number of an orphan
inode.</p></td>
</tr>
<tr class="row-odd"><td><p>blocksize-8</p></td>
<td><p>__le32</p></td>
<td><p>ob_magic</p></td>
<td><p>Magic value stored in orphan
block tail (0x0b10ca04)</p></td>
</tr>
<tr class="row-even"><td><p>blocksize-4</p></td>
<td><p>__le32</p></td>
<td><p>ob_checksum</p></td>
<td><p>Checksum of the orphan block.</p></td>
</tr>
</tbody>
</table>
<p>When a filesystem with orphan file feature is writeably mounted, we set
RO_COMPAT_ORPHAN_PRESENT feature in the superblock to indicate there may
be valid orphan entries. In case we see this feature when mounting the
filesystem, we read the whole orphan file and process all orphan inodes found
there as usual. When cleanly unmounting the filesystem we remove the
RO_COMPAT_ORPHAN_PRESENT feature to avoid unnecessary scanning of the orphan
file and also make the filesystem fully compatible with older kernels.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Global Structures</a><ul>
<li><a class="reference internal" href="#super-block">3.1. Super Block</a></li>
<li><a class="reference internal" href="#block-group-descriptors">3.2. Block Group Descriptors</a></li>
<li><a class="reference internal" href="#block-and-inode-bitmaps">3.3. Block and inode Bitmaps</a></li>
<li><a class="reference internal" href="#inode-table">3.4. Inode Table</a></li>
<li><a class="reference internal" href="#multiple-mount-protection">3.5. Multiple Mount Protection</a></li>
<li><a class="reference internal" href="#journal-jbd2">3.6. Journal (jbd2)</a><ul>
<li><a class="reference internal" href="#layout">3.6.1. Layout</a></li>
<li><a class="reference internal" href="#external-journal">3.6.2. External Journal</a></li>
<li><a class="reference internal" href="#block-header">3.6.3. Block Header</a></li>
<li><a class="reference internal" href="#id1">3.6.4. Super Block</a></li>
<li><a class="reference internal" href="#descriptor-block">3.6.5. Descriptor Block</a></li>
<li><a class="reference internal" href="#data-block">3.6.6. Data Block</a></li>
<li><a class="reference internal" href="#revocation-block">3.6.7. Revocation Block</a></li>
<li><a class="reference internal" href="#commit-block">3.6.8. Commit Block</a></li>
<li><a class="reference internal" href="#fast-commits">3.6.9. Fast commits</a></li>
<li><a class="reference internal" href="#fast-commit-replay-idempotence">3.6.10. Fast Commit Replay Idempotence</a></li>
<li><a class="reference internal" href="#journal-checkpoint">3.6.11. Journal Checkpoint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orphan-file">3.7. Orphan file</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/ext4/globals.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/ext4/globals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>