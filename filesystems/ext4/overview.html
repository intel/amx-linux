
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2. High Level Design &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3. Global Structures" href="globals.html" />
    <link rel="prev" title="1. About this Book" href="about.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="high-level-design">
<h1><span class="section-number">2. </span>High Level Design<a class="headerlink" href="#high-level-design" title="Permalink to this headline">¶</a></h1>
<p>An ext4 file system is split into a series of block groups. To reduce
performance difficulties due to fragmentation, the block allocator tries
very hard to keep each file’s blocks within the same group, thereby
reducing seek times. The size of a block group is specified in
<code class="docutils literal notranslate"><span class="pre">sb.s_blocks_per_group</span></code> blocks, though it can also calculated as 8 *
<code class="docutils literal notranslate"><span class="pre">block_size_in_bytes</span></code>. With the default block size of 4KiB, each group
will contain 32,768 blocks, for a length of 128MiB. The number of block
groups is the size of the device divided by the size of a block group.</p>
<p>All fields in ext4 are written to disk in little-endian order. HOWEVER,
all fields in jbd2 (the journal) are written to disk in big-endian
order.</p>
<section id="blocks">
<h2><span class="section-number">2.1. </span>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h2>
<p>ext4 allocates storage space in units of “blocks”. A block is a group of
sectors between 1KiB and 64KiB, and the number of sectors must be an
integral power of 2. Blocks are in turn grouped into larger units called
block groups. Block size is specified at mkfs time and typically is
4KiB. You may experience mounting problems if block size is greater than
page size (i.e. 64KiB blocks on a i386 which only has 4KiB memory
pages). By default a filesystem can contain 2^32 blocks; if the ‘64bit’
feature is enabled, then a filesystem can have 2^64 blocks. The location
of structures is stored in terms of the block number the structure lives
in and not the absolute offset on disk.</p>
<p>For 32-bit filesystems, limits are as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>1KiB</p></th>
<th class="head"><p>2KiB</p></th>
<th class="head"><p>4KiB</p></th>
<th class="head"><p>64KiB</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocks</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-even"><td><p>File System Size</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-even"><td><p>Inodes Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-odd"><td><p>Block Group Size</p></td>
<td><p>8MiB</p></td>
<td><p>32MiB</p></td>
<td><p>128MiB</p></td>
<td><p>32GiB</p></td>
</tr>
<tr class="row-even"><td><p>Blocks Per File, Extents</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per File, Block Maps</p></td>
<td><p>16,843,020</p></td>
<td><p>134,480,396</p></td>
<td><p>1,074,791,436</p></td>
<td><p>4,398,314,962,956 (really 2^32 due to field size limitations)</p></td>
</tr>
<tr class="row-even"><td><p>File Size, Extents</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>File Size, Block Maps</p></td>
<td><p>16GiB</p></td>
<td><p>256GiB</p></td>
<td><p>4TiB</p></td>
<td><p>256TiB</p></td>
</tr>
</tbody>
</table>
<p>For 64-bit filesystems, limits are as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>1KiB</p></th>
<th class="head"><p>2KiB</p></th>
<th class="head"><p>4KiB</p></th>
<th class="head"><p>64KiB</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocks</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-even"><td><p>File System Size</p></td>
<td><p>16ZiB</p></td>
<td><p>32ZiB</p></td>
<td><p>64ZiB</p></td>
<td><p>1YiB</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-even"><td><p>Inodes Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-odd"><td><p>Block Group Size</p></td>
<td><p>8MiB</p></td>
<td><p>32MiB</p></td>
<td><p>128MiB</p></td>
<td><p>32GiB</p></td>
</tr>
<tr class="row-even"><td><p>Blocks Per File, Extents</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per File, Block Maps</p></td>
<td><p>16,843,020</p></td>
<td><p>134,480,396</p></td>
<td><p>1,074,791,436</p></td>
<td><p>4,398,314,962,956 (really 2^32 due to field size limitations)</p></td>
</tr>
<tr class="row-even"><td><p>File Size, Extents</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>File Size, Block Maps</p></td>
<td><p>16GiB</p></td>
<td><p>256GiB</p></td>
<td><p>4TiB</p></td>
<td><p>256TiB</p></td>
</tr>
</tbody>
</table>
<p>Note: Files not using extents (i.e. files using block maps) must be
placed within the first 2^32 blocks of a filesystem. Files with extents
must be placed within the first 2^48 blocks of a filesystem. It’s not
clear what happens with larger filesystems.</p>
</section>
<section id="layout">
<h2><span class="section-number">2.2. </span>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h2>
<p>The layout of a standard block group is approximately as follows (each
of these fields is discussed in a separate section below):</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Group 0 Padding</p></th>
<th class="head"><p>ext4 Super Block</p></th>
<th class="head"><p>Group Descriptors</p></th>
<th class="head"><p>Reserved GDT Blocks</p></th>
<th class="head"><p>Data Block Bitmap</p></th>
<th class="head"><p>inode Bitmap</p></th>
<th class="head"><p>inode Table</p></th>
<th class="head"><p>Data Blocks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1024 bytes</p></td>
<td><p>1 block</p></td>
<td><p>many blocks</p></td>
<td><p>many blocks</p></td>
<td><p>1 block</p></td>
<td><p>1 block</p></td>
<td><p>many blocks</p></td>
<td><p>many more blocks</p></td>
</tr>
</tbody>
</table>
<p>For the special case of block group 0, the first 1024 bytes are unused,
to allow for the installation of x86 boot sectors and other oddities.
The superblock will start at offset 1024 bytes, whichever block that
happens to be (usually 0). However, if for some reason the block size =
1024, then block 0 is marked in use and the superblock goes in block 1.
For all other block groups, there is no padding.</p>
<p>The ext4 driver primarily works with the superblock and the group
descriptors that are found in block group 0. Redundant copies of the
superblock and group descriptors are written to some of the block groups
across the disk in case the beginning of the disk gets trashed, though
not all block groups necessarily host a redundant copy (see following
paragraph for more details). If the group does not have a redundant
copy, the block group begins with the data block bitmap. Note also that
when the filesystem is freshly formatted, mkfs will allocate “reserve
GDT block” space after the block group descriptors and before the start
of the block bitmaps to allow for future expansion of the filesystem. By
default, a filesystem is allowed to increase in size by a factor of
1024x over the original filesystem size.</p>
<p>The location of the inode table is given by <code class="docutils literal notranslate"><span class="pre">grp.bg_inode_table_*</span></code>. It
is continuous range of blocks large enough to contain
<code class="docutils literal notranslate"><span class="pre">sb.s_inodes_per_group</span> <span class="pre">*</span> <span class="pre">sb.s_inode_size</span></code> bytes.</p>
<p>As for the ordering of items in a block group, it is generally
established that the super block and the group descriptor table, if
present, will be at the beginning of the block group. The bitmaps and
the inode table can be anywhere, and it is quite possible for the
bitmaps to come after the inode table, or for both to be in different
groups (flex_bg). Leftover space is used for file data blocks, indirect
block maps, extent tree blocks, and extended attributes.</p>
</section>
<section id="flexible-block-groups">
<h2><span class="section-number">2.3. </span>Flexible Block Groups<a class="headerlink" href="#flexible-block-groups" title="Permalink to this headline">¶</a></h2>
<p>Starting in ext4, there is a new feature called flexible block groups
(flex_bg). In a flex_bg, several block groups are tied together as one
logical block group; the bitmap spaces and the inode table space in the
first block group of the flex_bg are expanded to include the bitmaps
and inode tables of all other block groups in the flex_bg. For example,
if the flex_bg size is 4, then group 0 will contain (in order) the
superblock, group descriptors, data block bitmaps for groups 0-3, inode
bitmaps for groups 0-3, inode tables for groups 0-3, and the remaining
space in group 0 is for file data. The effect of this is to group the
block group metadata close together for faster loading, and to enable
large files to be continuous on disk. Backup copies of the superblock
and group descriptors are always at the beginning of block groups, even
if flex_bg is enabled. The number of block groups that make up a
flex_bg is given by 2 ^ <code class="docutils literal notranslate"><span class="pre">sb.s_log_groups_per_flex</span></code>.</p>
</section>
<section id="meta-block-groups">
<h2><span class="section-number">2.4. </span>Meta Block Groups<a class="headerlink" href="#meta-block-groups" title="Permalink to this headline">¶</a></h2>
<p>Without the option META_BG, for safety concerns, all block group
descriptors copies are kept in the first block group. Given the default
128MiB(2^27 bytes) block group size and 64-byte group descriptors, ext4
can have at most 2^27/64 = 2^21 block groups. This limits the entire
filesystem size to 2^21 * 2^27 = 2^48bytes or 256TiB.</p>
<p>The solution to this problem is to use the metablock group feature
(META_BG), which is already in ext3 for all 2.6 releases. With the
META_BG feature, ext4 filesystems are partitioned into many metablock
groups. Each metablock group is a cluster of block groups whose group
descriptor structures can be stored in a single disk block. For ext4
filesystems with 4 KB block size, a single metablock group partition
includes 64 block groups, or 8 GiB of disk space. The metablock group
feature moves the location of the group descriptors from the congested
first block group of the whole filesystem into the first group of each
metablock group itself. The backups are in the second and last group of
each metablock group. This increases the 2^21 maximum block groups limit
to the hard limit 2^32, allowing support for a 512PiB filesystem.</p>
<p>The change in the filesystem format replaces the current scheme where
the superblock is followed by a variable-length set of block group
descriptors. Instead, the superblock and a single block group descriptor
block is placed at the beginning of the first, second, and last block
groups in a meta-block group. A meta-block group is a collection of
block groups which can be described by a single block group descriptor
block. Since the size of the block group descriptor structure is 32
bytes, a meta-block group contains 32 block groups for filesystems with
a 1KB block size, and 128 block groups for filesystems with a 4KB
blocksize. Filesystems can either be created using this new block group
descriptor layout, or existing filesystems can be resized on-line, and
the field s_first_meta_bg in the superblock will indicate the first
block group using this new layout.</p>
<p>Please see an important note about <code class="docutils literal notranslate"><span class="pre">BLOCK_UNINIT</span></code> in the section about
block and inode bitmaps.</p>
</section>
<section id="lazy-block-group-initialization">
<h2><span class="section-number">2.5. </span>Lazy Block Group Initialization<a class="headerlink" href="#lazy-block-group-initialization" title="Permalink to this headline">¶</a></h2>
<p>A new feature for ext4 are three block group descriptor flags that
enable mkfs to skip initializing other parts of the block group
metadata. Specifically, the INODE_UNINIT and BLOCK_UNINIT flags mean
that the inode and block bitmaps for that group can be calculated and
therefore the on-disk bitmap blocks are not initialized. This is
generally the case for an empty block group or a block group containing
only fixed-location block group metadata. The INODE_ZEROED flag means
that the inode table has been initialized; mkfs will unset this flag and
rely on the kernel to initialize the inode tables in the background.</p>
<p>By not writing zeroes to the bitmaps and inode table, mkfs time is
reduced considerably. Note the feature flag is RO_COMPAT_GDT_CSUM,
but the dumpe2fs output prints this as “uninit_bg”. They are the same
thing.</p>
</section>
<section id="special-inodes">
<h2><span class="section-number">2.6. </span>Special inodes<a class="headerlink" href="#special-inodes" title="Permalink to this headline">¶</a></h2>
<p>ext4 reserves some inode for special features, as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>inode Number</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Doesn’t exist; there is no inode 0.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>List of defective blocks.</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Root directory.</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>User quota.</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>Group quota.</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Boot loader.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>Undelete directory.</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>Reserved group descriptors inode. (“resize inode”)</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>Journal inode.</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>The “exclude” inode, for snapshots(?)</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>Replica inode, used for some non-upstream feature?</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>Traditional first non-reserved inode. Usually this is the lost+found directory. See s_first_ino in the superblock.</p></td>
</tr>
</tbody>
</table>
<p>Note that there are also some inodes allocated from non-reserved inode numbers
for other filesystem features which are not referenced from standard directory
hierarchy. These are generally reference from the superblock. They are:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Superblock field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>s_lpf_ino</p></td>
<td><p>Inode number of lost+found directory.</p></td>
</tr>
<tr class="row-odd"><td><p>s_prj_quota_inum</p></td>
<td><p>Inode number of quota file tracking project quotas</p></td>
</tr>
<tr class="row-even"><td><p>s_orphan_file_inum</p></td>
<td><p>Inode number of file tracking orphan inodes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="block-and-inode-allocation-policy">
<h2><span class="section-number">2.7. </span>Block and Inode Allocation Policy<a class="headerlink" href="#block-and-inode-allocation-policy" title="Permalink to this headline">¶</a></h2>
<p>ext4 recognizes (better than ext3, anyway) that data locality is
generally a desirably quality of a filesystem. On a spinning disk,
keeping related blocks near each other reduces the amount of movement
that the head actuator and disk must perform to access a data block,
thus speeding up disk IO. On an SSD there of course are no moving parts,
but locality can increase the size of each transfer request while
reducing the total number of requests. This locality may also have the
effect of concentrating writes on a single erase block, which can speed
up file rewrites significantly. Therefore, it is useful to reduce
fragmentation whenever possible.</p>
<p>The first tool that ext4 uses to combat fragmentation is the multi-block
allocator. When a file is first created, the block allocator
speculatively allocates 8KiB of disk space to the file on the assumption
that the space will get written soon. When the file is closed, the
unused speculative allocations are of course freed, but if the
speculation is correct (typically the case for full writes of small
files) then the file data gets written out in a single multi-block
extent. A second related trick that ext4 uses is delayed allocation.
Under this scheme, when a file needs more blocks to absorb file writes,
the filesystem defers deciding the exact placement on the disk until all
the dirty buffers are being written out to disk. By not committing to a
particular placement until it’s absolutely necessary (the commit timeout
is hit, or sync() is called, or the kernel runs out of memory), the hope
is that the filesystem can make better location decisions.</p>
<p>The third trick that ext4 (and ext3) uses is that it tries to keep a
file’s data blocks in the same block group as its inode. This cuts down
on the seek penalty when the filesystem first has to read a file’s inode
to learn where the file’s data blocks live and then seek over to the
file’s data blocks to begin I/O operations.</p>
<p>The fourth trick is that all the inodes in a directory are placed in the
same block group as the directory, when feasible. The working assumption
here is that all the files in a directory might be related, therefore it
is useful to try to keep them all together.</p>
<p>The fifth trick is that the disk volume is cut up into 128MB block
groups; these mini-containers are used as outlined above to try to
maintain data locality. However, there is a deliberate quirk – when a
directory is created in the root directory, the inode allocator scans
the block groups and puts that directory into the least heavily loaded
block group that it can find. This encourages directories to spread out
over a disk; as the top-level directory/file blobs fill up one block
group, the allocators simply move on to the next block group. Allegedly
this scheme evens out the loading on the block groups, though the author
suspects that the directories which are so unlucky as to land towards
the end of a spinning drive get a raw deal performance-wise.</p>
<p>Of course if all of these mechanisms fail, one can always use e4defrag
to defragment files.</p>
</section>
<section id="checksums">
<h2><span class="section-number">2.8. </span>Checksums<a class="headerlink" href="#checksums" title="Permalink to this headline">¶</a></h2>
<p>Starting in early 2012, metadata checksums were added to all major ext4
and jbd2 data structures. The associated feature flag is metadata_csum.
The desired checksum algorithm is indicated in the superblock, though as
of October 2012 the only supported algorithm is crc32c. Some data
structures did not have space to fit a full 32-bit checksum, so only the
lower 16 bits are stored. Enabling the 64bit feature increases the data
structure size so that full 32-bit checksums can be stored for many data
structures. However, existing 32-bit filesystems cannot be extended to
enable 64bit mode, at least not without the experimental resize2fs
patches to do so.</p>
<p>Existing filesystems can have checksumming added by running
<code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">metadata_csum</span></code> against the underlying device. If tune2fs
encounters directory blocks that lack sufficient empty space to add a
checksum, it will request that you run <code class="docutils literal notranslate"><span class="pre">e2fsck</span> <span class="pre">-D</span></code> to have the
directories rebuilt with checksums. This has the added benefit of
removing slack space from the directory files and rebalancing the htree
indexes. If you _ignore_ this step, your directories will not be
protected by a checksum!</p>
<p>The following table describes the data elements that go into each type
of checksum. The checksum function is whatever the superblock describes
(crc32c as of October 2013) unless noted otherwise.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 10%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metadata</p></th>
<th class="head"><p>Length</p></th>
<th class="head"><p>Ingredients</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Superblock</p></td>
<td><p>__le32</p></td>
<td><p>The entire superblock up to the checksum field. The UUID lives inside
the superblock.</p></td>
</tr>
<tr class="row-odd"><td><p>MMP</p></td>
<td><p>__le32</p></td>
<td><p>UUID + the entire MMP block up to the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>Extended Attributes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + the entire extended attribute block. The checksum field is set to
zero.</p></td>
</tr>
<tr class="row-odd"><td><p>Directory Entries</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the directory block up to the
fake entry enclosing the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>HTREE Nodes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + all valid extents + HTREE tail.
The checksum field is set to zero.</p></td>
</tr>
<tr class="row-odd"><td><p>Extents</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the entire extent block up to
the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>Bitmaps</p></td>
<td><p>__le32 or __le16</p></td>
<td><p>UUID + the entire bitmap. Checksums are stored in the group descriptor,
and truncated if the group descriptor size is 32 bytes (i.e. ^64bit)</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the entire inode. The checksum
field is set to zero. Each inode has its own checksum.</p></td>
</tr>
<tr class="row-even"><td><p>Group Descriptors</p></td>
<td><p>__le16</p></td>
<td><p>If metadata_csum, then UUID + group number + the entire descriptor;
else if gdt_csum, then crc16(UUID + group number + the entire
descriptor). In all cases, only the lower 16 bits are stored.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="bigalloc">
<h2><span class="section-number">2.9. </span>Bigalloc<a class="headerlink" href="#bigalloc" title="Permalink to this headline">¶</a></h2>
<p>At the moment, the default size of a block is 4KiB, which is a commonly
supported page size on most MMU-capable hardware. This is fortunate, as
ext4 code is not prepared to handle the case where the block size
exceeds the page size. However, for a filesystem of mostly huge files,
it is desirable to be able to allocate disk blocks in units of multiple
blocks to reduce both fragmentation and metadata overhead. The
bigalloc feature provides exactly this ability.</p>
<p>The bigalloc feature (EXT4_FEATURE_RO_COMPAT_BIGALLOC) changes ext4 to
use clustered allocation, so that each bit in the ext4 block allocation
bitmap addresses a power of two number of blocks. For example, if the
file system is mainly going to be storing large files in the 4-32
megabyte range, it might make sense to set a cluster size of 1 megabyte.
This means that each bit in the block allocation bitmap now addresses
256 4k blocks. This shrinks the total size of the block allocation
bitmaps for a 2T file system from 64 megabytes to 256 kilobytes. It also
means that a block group addresses 32 gigabytes instead of 128 megabytes,
also shrinking the amount of file system overhead for metadata.</p>
<p>The administrator can set a block cluster size at mkfs time (which is
stored in the s_log_cluster_size field in the superblock); from then
on, the block bitmaps track clusters, not individual blocks. This means
that block groups can be several gigabytes in size (instead of just
128MiB); however, the minimum allocation unit becomes a cluster, not a
block, even for directories. TaoBao had a patchset to extend the “use
units of clusters instead of blocks” to the extent tree, though it is
not clear where those patches went– they eventually morphed into
“extent tree v2” but that code has not landed as of May 2015.</p>
</section>
<section id="inline-data">
<h2><span class="section-number">2.10. </span>Inline Data<a class="headerlink" href="#inline-data" title="Permalink to this headline">¶</a></h2>
<p>The inline data feature was designed to handle the case that a file’s
data is so tiny that it readily fits inside the inode, which
(theoretically) reduces disk block consumption and reduces seeks. If the
file is smaller than 60 bytes, then the data are stored inline in
<code class="docutils literal notranslate"><span class="pre">inode.i_block</span></code>. If the rest of the file would fit inside the extended
attribute space, then it might be found as an extended attribute
“system.data” within the inode body (“ibody EA”). This of course
constrains the amount of extended attributes one can attach to an inode.
If the data size increases beyond i_block + ibody EA, a regular block
is allocated and the contents moved to that block.</p>
<p>Pending a change to compact the extended attribute key used to store
inline data, one ought to be able to store 160 bytes of data in a
256-byte inode (as of June 2015, when i_extra_isize is 28). Prior to
that, the limit was 156 bytes due to inefficient use of inode space.</p>
<p>The inline data feature requires the presence of an extended attribute
for “system.data”, even if the attribute value is zero length.</p>
<section id="inline-directories">
<h3><span class="section-number">2.10.1. </span>Inline Directories<a class="headerlink" href="#inline-directories" title="Permalink to this headline">¶</a></h3>
<p>The first four bytes of i_block are the inode number of the parent
directory. Following that is a 56-byte space for an array of directory
entries; see <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code>. If there is a “system.data”
attribute in the inode body, the EA value is an array of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code> as well. Note that for inline directories, the
i_block and EA space are treated as separate dirent blocks; directory
entries cannot span the two.</p>
<p>Inline directory entries are not checksummed, as the inode checksum
should protect all inline data contents.</p>
</section>
</section>
<section id="large-extended-attribute-values">
<h2><span class="section-number">2.11. </span>Large Extended Attribute Values<a class="headerlink" href="#large-extended-attribute-values" title="Permalink to this headline">¶</a></h2>
<p>To enable ext4 to store extended attribute values that do not fit in the
inode or in the single extended attribute block attached to an inode,
the EA_INODE feature allows us to store the value in the data blocks of
a regular file inode. This “EA inode” is linked only from the extended
attribute name index and must not appear in a directory entry. The
inode’s i_atime field is used to store a checksum of the xattr value;
and i_ctime/i_version store a 64-bit reference count, which enables
sharing of large xattr values between multiple owning inodes. For
backward compatibility with older versions of this feature, the
i_mtime/i_generation <em>may</em> store a back-reference to the inode number
and i_generation of the <strong>one</strong> owning inode (in cases where the EA
inode is not referenced by multiple inodes) to verify that the EA inode
is the correct one being accessed.</p>
</section>
<section id="verity-files">
<h2><span class="section-number">2.12. </span>Verity files<a class="headerlink" href="#verity-files" title="Permalink to this headline">¶</a></h2>
<p>ext4 supports fs-verity, which is a filesystem feature that provides
Merkle tree based hashing for individual readonly files.  Most of
fs-verity is common to all filesystems that support it; see
<a class="reference internal" href="../fsverity.html#fsverity"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a> for the
fs-verity documentation.  However, the on-disk layout of the verity
metadata is filesystem-specific.  On ext4, the verity metadata is
stored after the end of the file data itself, in the following format:</p>
<ul class="simple">
<li><p>Zero-padding to the next 65536-byte boundary.  This padding need not
actually be allocated on-disk, i.e. it may be a hole.</p></li>
<li><p>The Merkle tree, as documented in
<a class="reference internal" href="../fsverity.html#fsverity-merkle-tree"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a>, with the tree levels stored in order from
root to leaf, and the tree blocks within each level stored in their
natural order.</p></li>
<li><p>Zero-padding to the next filesystem block boundary.</p></li>
<li><p>The verity descriptor, as documented in
<a class="reference internal" href="../fsverity.html#fsverity-descriptor"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a>,
with optionally appended signature blob.</p></li>
<li><p>Zero-padding to the next offset that is 4 bytes before a filesystem
block boundary.</p></li>
<li><p>The size of the verity descriptor in bytes, as a 4-byte little
endian integer.</p></li>
</ul>
<p>Verity inodes have EXT4_VERITY_FL set, and they must use extents, i.e.
EXT4_EXTENTS_FL must be set and EXT4_INLINE_DATA_FL must be clear.
They can have EXT4_ENCRYPT_FL set, in which case the verity metadata
is encrypted as well as the data itself.</p>
<p>Verity files cannot have blocks allocated past the end of the verity
metadata.</p>
<p>Verity and DAX are not compatible and attempts to set both of these flags
on a file will fail.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. High Level Design</a><ul>
<li><a class="reference internal" href="#blocks">2.1. Blocks</a></li>
<li><a class="reference internal" href="#layout">2.2. Layout</a></li>
<li><a class="reference internal" href="#flexible-block-groups">2.3. Flexible Block Groups</a></li>
<li><a class="reference internal" href="#meta-block-groups">2.4. Meta Block Groups</a></li>
<li><a class="reference internal" href="#lazy-block-group-initialization">2.5. Lazy Block Group Initialization</a></li>
<li><a class="reference internal" href="#special-inodes">2.6. Special inodes</a></li>
<li><a class="reference internal" href="#block-and-inode-allocation-policy">2.7. Block and Inode Allocation Policy</a></li>
<li><a class="reference internal" href="#checksums">2.8. Checksums</a></li>
<li><a class="reference internal" href="#bigalloc">2.9. Bigalloc</a></li>
<li><a class="reference internal" href="#inline-data">2.10. Inline Data</a><ul>
<li><a class="reference internal" href="#inline-directories">2.10.1. Inline Directories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#large-extended-attribute-values">2.11. Large Extended Attribute Values</a></li>
<li><a class="reference internal" href="#verity-files">2.12. Verity files</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/ext4/overview.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/ext4/overview.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>