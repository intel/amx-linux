
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4. Dynamic Structures &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="WHAT IS Flash-Friendly File System (F2FS)?" href="../f2fs.html" />
    <link rel="prev" title="3. Global Structures" href="globals.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="dynamic-structures">
<h1><span class="section-number">4. </span>Dynamic Structures<a class="headerlink" href="#dynamic-structures" title="Permalink to this headline">¶</a></h1>
<p>Dynamic metadata are created on the fly when files and blocks are
allocated to files.</p>
<section id="index-nodes">
<h2><span class="section-number">4.1. </span>Index Nodes<a class="headerlink" href="#index-nodes" title="Permalink to this headline">¶</a></h2>
<p>In a regular UNIX filesystem, the inode stores all the metadata
pertaining to the file (time stamps, block maps, extended attributes,
etc), not the directory entry. To find the information associated with a
file, one must traverse the directory files to find the directory entry
associated with a file, then load the inode to find the metadata for
that file. ext4 appears to cheat (for performance reasons) a little bit
by storing a copy of the file type (normally stored in the inode) in the
directory entry. (Compare all this to FAT, which stores all the file
information directly in the directory entry, but does not support hard
links and is in general more seek-happy than ext4 due to its simpler
block allocator and extensive use of linked lists.)</p>
<p>The inode table is a linear array of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_inode</span></code>. The table is
sized to have enough blocks to store at least
<code class="docutils literal notranslate"><span class="pre">sb.s_inode_size</span> <span class="pre">*</span> <span class="pre">sb.s_inodes_per_group</span></code> bytes. The number of the
block group containing an inode can be calculated as
<code class="docutils literal notranslate"><span class="pre">(inode_number</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">sb.s_inodes_per_group</span></code>, and the offset into the
group’s table is <code class="docutils literal notranslate"><span class="pre">(inode_number</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">%</span> <span class="pre">sb.s_inodes_per_group</span></code>. There
is no inode 0.</p>
<p>The inode checksum is calculated against the FS UUID, the inode number,
and the inode structure itself.</p>
<p>The inode table entry is laid out in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_inode</span></code>.</p>
<table class="colwidths-given longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le16</p></td>
<td><p>i_mode</p></td>
<td><p>File mode. See the table <a class="reference internal" href="#i-mode">i_mode</a> below.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>__le16</p></td>
<td><p>i_uid</p></td>
<td><p>Lower 16-bits of Owner UID.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>i_size_lo</p></td>
<td><p>Lower 32-bits of size in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>i_atime</p></td>
<td><p>Last access time, in seconds since the epoch. However, if the EA_INODE
inode flag is set, this inode stores an extended attribute value and
this field contains the checksum of the value.</p></td>
</tr>
<tr class="row-even"><td><p>0xC</p></td>
<td><p>__le32</p></td>
<td><p>i_ctime</p></td>
<td><p>Last inode change time, in seconds since the epoch. However, if the
EA_INODE inode flag is set, this inode stores an extended attribute
value and this field contains the lower 32 bits of the attribute value’s
reference count.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10</p></td>
<td><p>__le32</p></td>
<td><p>i_mtime</p></td>
<td><p>Last data modification time, in seconds since the epoch. However, if the
EA_INODE inode flag is set, this inode stores an extended attribute
value and this field contains the number of the inode that owns the
extended attribute.</p></td>
</tr>
<tr class="row-even"><td><p>0x14</p></td>
<td><p>__le32</p></td>
<td><p>i_dtime</p></td>
<td><p>Deletion Time, in seconds since the epoch.</p></td>
</tr>
<tr class="row-odd"><td><p>0x18</p></td>
<td><p>__le16</p></td>
<td><p>i_gid</p></td>
<td><p>Lower 16-bits of GID.</p></td>
</tr>
<tr class="row-even"><td><p>0x1A</p></td>
<td><p>__le16</p></td>
<td><p>i_links_count</p></td>
<td><p>Hard link count. Normally, ext4 does not permit an inode to have more
than 65,000 hard links. This applies to files as well as directories,
which means that there cannot be more than 64,998 subdirectories in a
directory (each subdirectory’s ‘..’ entry counts as a hard link, as does
the ‘.’ entry in the directory itself). With the DIR_NLINK feature
enabled, ext4 supports more than 64,998 subdirectories by setting this
field to 1 to indicate that the number of hard links is not known.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1C</p></td>
<td><p>__le32</p></td>
<td><p>i_blocks_lo</p></td>
<td><p>Lower 32-bits of “block” count. If the huge_file feature flag is not
set on the filesystem, the file consumes <code class="docutils literal notranslate"><span class="pre">i_blocks_lo</span></code> 512-byte blocks
on disk. If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
<code class="docutils literal notranslate"><span class="pre">inode.i_flags</span></code>, then the file consumes <code class="docutils literal notranslate"><span class="pre">i_blocks_lo</span> <span class="pre">+</span> <span class="pre">(i_blocks_hi</span>
<span class="pre">&lt;&lt;</span> <span class="pre">32)</span></code> 512-byte blocks on disk. If huge_file is set and
EXT4_HUGE_FILE_FL IS set in <code class="docutils literal notranslate"><span class="pre">inode.i_flags</span></code>, then this file
consumes (<code class="docutils literal notranslate"><span class="pre">i_blocks_lo</span> <span class="pre">+</span> <span class="pre">i_blocks_hi</span></code> &lt;&lt; 32) filesystem blocks on
disk.</p></td>
</tr>
<tr class="row-even"><td><p>0x20</p></td>
<td><p>__le32</p></td>
<td><p>i_flags</p></td>
<td><p>Inode flags. See the table <a class="reference internal" href="#i-flags">i_flags</a> below.</p></td>
</tr>
<tr class="row-odd"><td><p>0x24</p></td>
<td><p>4 bytes</p></td>
<td><p>i_osd1</p></td>
<td><p>See the table <a class="reference internal" href="#i-osd1">i_osd1</a> for more details.</p></td>
</tr>
<tr class="row-even"><td><p>0x28</p></td>
<td><p>60 bytes</p></td>
<td><p>i_block[EXT4_N_BLOCKS=15]</p></td>
<td><p>Block map or extent tree. See the section “The Contents of inode.i_block”.</p></td>
</tr>
<tr class="row-odd"><td><p>0x64</p></td>
<td><p>__le32</p></td>
<td><p>i_generation</p></td>
<td><p>File version (for NFS).</p></td>
</tr>
<tr class="row-even"><td><p>0x68</p></td>
<td><p>__le32</p></td>
<td><p>i_file_acl_lo</p></td>
<td><p>Lower 32-bits of extended attribute block. ACLs are of course one of
many possible extended attributes; I think the name of this field is a
result of the first use of extended attributes being for ACLs.</p></td>
</tr>
<tr class="row-odd"><td><p>0x6C</p></td>
<td><p>__le32</p></td>
<td><p>i_size_high / i_dir_acl</p></td>
<td><p>Upper 32-bits of file/directory size. In ext2/3 this field was named
i_dir_acl, though it was usually set to zero and never used.</p></td>
</tr>
<tr class="row-even"><td><p>0x70</p></td>
<td><p>__le32</p></td>
<td><p>i_obso_faddr</p></td>
<td><p>(Obsolete) fragment address.</p></td>
</tr>
<tr class="row-odd"><td><p>0x74</p></td>
<td><p>12 bytes</p></td>
<td><p>i_osd2</p></td>
<td><p>See the table <a class="reference internal" href="#i-osd2">i_osd2</a> for more details.</p></td>
</tr>
<tr class="row-even"><td><p>0x80</p></td>
<td><p>__le16</p></td>
<td><p>i_extra_isize</p></td>
<td><p>Size of this inode - 128. Alternately, the size of the extended inode
fields beyond the original ext2 inode, including this field.</p></td>
</tr>
<tr class="row-odd"><td><p>0x82</p></td>
<td><p>__le16</p></td>
<td><p>i_checksum_hi</p></td>
<td><p>Upper 16-bits of the inode checksum.</p></td>
</tr>
<tr class="row-even"><td><p>0x84</p></td>
<td><p>__le32</p></td>
<td><p>i_ctime_extra</p></td>
<td><p>Extra change time bits. This provides sub-second precision. See Inode
Timestamps section.</p></td>
</tr>
<tr class="row-odd"><td><p>0x88</p></td>
<td><p>__le32</p></td>
<td><p>i_mtime_extra</p></td>
<td><p>Extra modification time bits. This provides sub-second precision.</p></td>
</tr>
<tr class="row-even"><td><p>0x8C</p></td>
<td><p>__le32</p></td>
<td><p>i_atime_extra</p></td>
<td><p>Extra access time bits. This provides sub-second precision.</p></td>
</tr>
<tr class="row-odd"><td><p>0x90</p></td>
<td><p>__le32</p></td>
<td><p>i_crtime</p></td>
<td><p>File creation time, in seconds since the epoch.</p></td>
</tr>
<tr class="row-even"><td><p>0x94</p></td>
<td><p>__le32</p></td>
<td><p>i_crtime_extra</p></td>
<td><p>Extra file creation time bits. This provides sub-second precision.</p></td>
</tr>
<tr class="row-odd"><td><p>0x98</p></td>
<td><p>__le32</p></td>
<td><p>i_version_hi</p></td>
<td><p>Upper 32-bits for version number.</p></td>
</tr>
<tr class="row-even"><td><p>0x9C</p></td>
<td><p>__le32</p></td>
<td><p>i_projid</p></td>
<td><p>Project ID.</p></td>
</tr>
</tbody>
</table>
<p id="i-mode">The <code class="docutils literal notranslate"><span class="pre">i_mode</span></code> value is a combination of the following flags:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>S_IXOTH (Others may execute)</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>S_IWOTH (Others may write)</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>S_IROTH (Others may read)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>S_IXGRP (Group members may execute)</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>S_IWGRP (Group members may write)</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>S_IRGRP (Group members may read)</p></td>
</tr>
<tr class="row-even"><td><p>0x40</p></td>
<td><p>S_IXUSR (Owner may execute)</p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>S_IWUSR (Owner may write)</p></td>
</tr>
<tr class="row-even"><td><p>0x100</p></td>
<td><p>S_IRUSR (Owner may read)</p></td>
</tr>
<tr class="row-odd"><td><p>0x200</p></td>
<td><p>S_ISVTX (Sticky bit)</p></td>
</tr>
<tr class="row-even"><td><p>0x400</p></td>
<td><p>S_ISGID (Set GID)</p></td>
</tr>
<tr class="row-odd"><td><p>0x800</p></td>
<td><p>S_ISUID (Set UID)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>These are mutually-exclusive file types:</p></td>
</tr>
<tr class="row-odd"><td><p>0x1000</p></td>
<td><p>S_IFIFO (FIFO)</p></td>
</tr>
<tr class="row-even"><td><p>0x2000</p></td>
<td><p>S_IFCHR (Character device)</p></td>
</tr>
<tr class="row-odd"><td><p>0x4000</p></td>
<td><p>S_IFDIR (Directory)</p></td>
</tr>
<tr class="row-even"><td><p>0x6000</p></td>
<td><p>S_IFBLK (Block device)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8000</p></td>
<td><p>S_IFREG (Regular file)</p></td>
</tr>
<tr class="row-even"><td><p>0xA000</p></td>
<td><p>S_IFLNK (Symbolic link)</p></td>
</tr>
<tr class="row-odd"><td><p>0xC000</p></td>
<td><p>S_IFSOCK (Socket)</p></td>
</tr>
</tbody>
</table>
<p id="i-flags">The <code class="docutils literal notranslate"><span class="pre">i_flags</span></code> field is a combination of these values:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>This file requires secure deletion (EXT4_SECRM_FL). (not implemented)</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>This file should be preserved, should undeletion be desired
(EXT4_UNRM_FL). (not implemented)</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>File is compressed (EXT4_COMPR_FL). (not really implemented)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>All writes to the file must be synchronous (EXT4_SYNC_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>File is immutable (EXT4_IMMUTABLE_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>File can only be appended (EXT4_APPEND_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x40</p></td>
<td><p>The dump(1) utility should not dump this file (EXT4_NODUMP_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>Do not update access time (EXT4_NOATIME_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x100</p></td>
<td><p>Dirty compressed file (EXT4_DIRTY_FL). (not used)</p></td>
</tr>
<tr class="row-odd"><td><p>0x200</p></td>
<td><p>File has one or more compressed clusters (EXT4_COMPRBLK_FL). (not used)</p></td>
</tr>
<tr class="row-even"><td><p>0x400</p></td>
<td><p>Do not compress file (EXT4_NOCOMPR_FL). (not used)</p></td>
</tr>
<tr class="row-odd"><td><p>0x800</p></td>
<td><p>Encrypted inode (EXT4_ENCRYPT_FL). This bit value previously was
EXT4_ECOMPR_FL (compression error), which was never used.</p></td>
</tr>
<tr class="row-even"><td><p>0x1000</p></td>
<td><p>Directory has hashed indexes (EXT4_INDEX_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x2000</p></td>
<td><p>AFS magic directory (EXT4_IMAGIC_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x4000</p></td>
<td><p>File data must always be written through the journal
(EXT4_JOURNAL_DATA_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x8000</p></td>
<td><p>File tail should not be merged (EXT4_NOTAIL_FL). (not used by ext4)</p></td>
</tr>
<tr class="row-even"><td><p>0x10000</p></td>
<td><p>All directory entry data should be written synchronously (see
<code class="docutils literal notranslate"><span class="pre">dirsync</span></code>) (EXT4_DIRSYNC_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x20000</p></td>
<td><p>Top of directory hierarchy (EXT4_TOPDIR_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x40000</p></td>
<td><p>This is a huge file (EXT4_HUGE_FILE_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x80000</p></td>
<td><p>Inode uses extents (EXT4_EXTENTS_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x100000</p></td>
<td><p>Verity protected file (EXT4_VERITY_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x200000</p></td>
<td><p>Inode stores a large extended attribute value in its data blocks
(EXT4_EA_INODE_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x400000</p></td>
<td><p>This file has blocks allocated past EOF (EXT4_EOFBLOCKS_FL).
(deprecated)</p></td>
</tr>
<tr class="row-odd"><td><p>0x01000000</p></td>
<td><p>Inode is a snapshot (<code class="docutils literal notranslate"><span class="pre">EXT4_SNAPFILE_FL</span></code>). (not in mainline)</p></td>
</tr>
<tr class="row-even"><td><p>0x04000000</p></td>
<td><p>Snapshot is being deleted (<code class="docutils literal notranslate"><span class="pre">EXT4_SNAPFILE_DELETED_FL</span></code>). (not in
mainline)</p></td>
</tr>
<tr class="row-odd"><td><p>0x08000000</p></td>
<td><p>Snapshot shrink has completed (<code class="docutils literal notranslate"><span class="pre">EXT4_SNAPFILE_SHRUNK_FL</span></code>). (not in
mainline)</p></td>
</tr>
<tr class="row-even"><td><p>0x10000000</p></td>
<td><p>Inode has inline data (EXT4_INLINE_DATA_FL).</p></td>
</tr>
<tr class="row-odd"><td><p>0x20000000</p></td>
<td><p>Create children with the same project ID (EXT4_PROJINHERIT_FL).</p></td>
</tr>
<tr class="row-even"><td><p>0x80000000</p></td>
<td><p>Reserved for ext4 library (EXT4_RESERVED_FL).</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Aggregate flags:</p></td>
</tr>
<tr class="row-even"><td><p>0x705BDFFF</p></td>
<td><p>User-visible flags.</p></td>
</tr>
<tr class="row-odd"><td><p>0x604BC0FF</p></td>
<td><p>User-modifiable flags. Note that while EXT4_JOURNAL_DATA_FL and
EXT4_EXTENTS_FL can be set with setattr, they are not in the kernel’s
EXT4_FL_USER_MODIFIABLE mask, since it needs to handle the setting of
these flags in a special manner and they are masked out of the set of
flags that are saved directly to i_flags.</p></td>
</tr>
</tbody>
</table>
<p id="i-osd1">The <code class="docutils literal notranslate"><span class="pre">osd1</span></code> field has multiple meanings depending on the creator:</p>
<p>Linux:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>l_i_version</p></td>
<td><p>Inode version. However, if the EA_INODE inode flag is set, this inode
stores an extended attribute value and this field contains the upper 32
bits of the attribute value’s reference count.</p></td>
</tr>
</tbody>
</table>
<p>Hurd:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>h_i_translator</p></td>
<td><p>??</p></td>
</tr>
</tbody>
</table>
<p>Masix:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>m_i_reserved</p></td>
<td><p>??</p></td>
</tr>
</tbody>
</table>
<p id="i-osd2">The <code class="docutils literal notranslate"><span class="pre">osd2</span></code> field has multiple meanings depending on the filesystem creator:</p>
<p>Linux:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le16</p></td>
<td><p>l_i_blocks_high</p></td>
<td><p>Upper 16-bits of the block count. Please see the note attached to
i_blocks_lo.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>__le16</p></td>
<td><p>l_i_file_acl_high</p></td>
<td><p>Upper 16-bits of the extended attribute block (historically, the file
ACL location). See the Extended Attributes section below.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>l_i_uid_high</p></td>
<td><p>Upper 16-bits of the Owner UID.</p></td>
</tr>
<tr class="row-odd"><td><p>0x6</p></td>
<td><p>__le16</p></td>
<td><p>l_i_gid_high</p></td>
<td><p>Upper 16-bits of the GID.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le16</p></td>
<td><p>l_i_checksum_lo</p></td>
<td><p>Lower 16-bits of the inode checksum.</p></td>
</tr>
<tr class="row-odd"><td><p>0xA</p></td>
<td><p>__le16</p></td>
<td><p>l_i_reserved</p></td>
<td><p>Unused.</p></td>
</tr>
</tbody>
</table>
<p>Hurd:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le16</p></td>
<td><p>h_i_reserved1</p></td>
<td><p>??</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>__u16</p></td>
<td><p>h_i_mode_high</p></td>
<td><p>Upper 16-bits of the file mode.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>h_i_uid_high</p></td>
<td><p>Upper 16-bits of the Owner UID.</p></td>
</tr>
<tr class="row-odd"><td><p>0x6</p></td>
<td><p>__le16</p></td>
<td><p>h_i_gid_high</p></td>
<td><p>Upper 16-bits of the GID.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__u32</p></td>
<td><p>h_i_author</p></td>
<td><p>Author code?</p></td>
</tr>
</tbody>
</table>
<p>Masix:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le16</p></td>
<td><p>h_i_reserved1</p></td>
<td><p>??</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>__u16</p></td>
<td><p>m_i_file_acl_high</p></td>
<td><p>Upper 16-bits of the extended attribute block (historically, the file
ACL location).</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>__u32</p></td>
<td><p>m_i_reserved2[2]</p></td>
<td><p>??</p></td>
</tr>
</tbody>
</table>
<section id="inode-size">
<h3><span class="section-number">4.1.1. </span>Inode Size<a class="headerlink" href="#inode-size" title="Permalink to this headline">¶</a></h3>
<p>In ext2 and ext3, the inode structure size was fixed at 128 bytes
(<code class="docutils literal notranslate"><span class="pre">EXT2_GOOD_OLD_INODE_SIZE</span></code>) and each inode had a disk record size of
128 bytes. Starting with ext4, it is possible to allocate a larger
on-disk inode at format time for all inodes in the filesystem to provide
space beyond the end of the original ext2 inode. The on-disk inode
record size is recorded in the superblock as <code class="docutils literal notranslate"><span class="pre">s_inode_size</span></code>. The
number of bytes actually used by struct ext4_inode beyond the original
128-byte ext2 inode is recorded in the <code class="docutils literal notranslate"><span class="pre">i_extra_isize</span></code> field for each
inode, which allows struct ext4_inode to grow for a new kernel without
having to upgrade all of the on-disk inodes. Access to fields beyond
EXT2_GOOD_OLD_INODE_SIZE should be verified to be within
<code class="docutils literal notranslate"><span class="pre">i_extra_isize</span></code>. By default, ext4 inode records are 256 bytes, and (as
of August 2019) the inode structure is 160 bytes
(<code class="docutils literal notranslate"><span class="pre">i_extra_isize</span> <span class="pre">=</span> <span class="pre">32</span></code>). The extra space between the end of the inode
structure and the end of the inode record can be used to store extended
attributes. Each inode record can be as large as the filesystem block
size, though this is not terribly efficient.</p>
</section>
<section id="finding-an-inode">
<h3><span class="section-number">4.1.2. </span>Finding an Inode<a class="headerlink" href="#finding-an-inode" title="Permalink to this headline">¶</a></h3>
<p>Each block group contains <code class="docutils literal notranslate"><span class="pre">sb-&gt;s_inodes_per_group</span></code> inodes. Because
inode 0 is defined not to exist, this formula can be used to find the
block group that an inode lives in:
<code class="docutils literal notranslate"><span class="pre">bg</span> <span class="pre">=</span> <span class="pre">(inode_num</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">sb-&gt;s_inodes_per_group</span></code>. The particular inode
can be found within the block group’s inode table at
<code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">(inode_num</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">%</span> <span class="pre">sb-&gt;s_inodes_per_group</span></code>. To get the byte
address within the inode table, use
<code class="docutils literal notranslate"><span class="pre">offset</span> <span class="pre">=</span> <span class="pre">index</span> <span class="pre">*</span> <span class="pre">sb-&gt;s_inode_size</span></code>.</p>
</section>
<section id="inode-timestamps">
<h3><span class="section-number">4.1.3. </span>Inode Timestamps<a class="headerlink" href="#inode-timestamps" title="Permalink to this headline">¶</a></h3>
<p>Four timestamps are recorded in the lower 128 bytes of the inode
structure – inode change time (ctime), access time (atime), data
modification time (mtime), and deletion time (dtime). The four fields
are 32-bit signed integers that represent seconds since the Unix epoch
(1970-01-01 00:00:00 GMT), which means that the fields will overflow in
January 2038. If the filesystem does not have orphan_file feature, inodes
that are not linked from any directory but are still open (orphan inodes) have
the dtime field overloaded for use with the orphan list. The superblock field
<code class="docutils literal notranslate"><span class="pre">s_last_orphan</span></code> points to the first inode in the orphan list; dtime is then
the number of the next orphaned inode, or zero if there are no more orphans.</p>
<p>If the inode structure size <code class="docutils literal notranslate"><span class="pre">sb-&gt;s_inode_size</span></code> is larger than 128
bytes and the <code class="docutils literal notranslate"><span class="pre">i_inode_extra</span></code> field is large enough to encompass the
respective <code class="docutils literal notranslate"><span class="pre">i_[cma]time_extra</span></code> field, the ctime, atime, and mtime
inode fields are widened to 64 bits. Within this “extra” 32-bit field,
the lower two bits are used to extend the 32-bit seconds field to be 34
bit wide; the upper 30 bits are used to provide nanosecond timestamp
accuracy. Therefore, timestamps should not overflow until May 2446.
dtime was not widened. There is also a fifth timestamp to record inode
creation time (crtime); this field is 64-bits wide and decoded in the
same manner as 64-bit [cma]time. Neither crtime nor dtime are accessible
through the regular stat() interface, though debugfs will report them.</p>
<p>We use the 32-bit signed time value plus (2^32 * (extra epoch bits)).
In other words:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Extra epoch bits</p></th>
<th class="head"><p>MSB of 32-bit time</p></th>
<th class="head"><p>Adjustment for signed 32-bit to 64-bit tv_sec</p></th>
<th class="head"><p>Decoded 64-bit tv_sec</p></th>
<th class="head"><p>valid time range</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-0x80000000</span> <span class="pre">-</span> <span class="pre">-0x00000001</span></code></p></td>
<td><p>1901-12-13 to 1969-12-31</p></td>
</tr>
<tr class="row-odd"><td><p>0 0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x000000000</span> <span class="pre">-</span> <span class="pre">0x07fffffff</span></code></p></td>
<td><p>1970-01-01 to 2038-01-19</p></td>
</tr>
<tr class="row-even"><td><p>0 1</p></td>
<td><p>1</p></td>
<td><p>0x100000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x080000000</span> <span class="pre">-</span> <span class="pre">0x0ffffffff</span></code></p></td>
<td><p>2038-01-19 to 2106-02-07</p></td>
</tr>
<tr class="row-odd"><td><p>0 1</p></td>
<td><p>0</p></td>
<td><p>0x100000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x100000000</span> <span class="pre">-</span> <span class="pre">0x17fffffff</span></code></p></td>
<td><p>2106-02-07 to 2174-02-25</p></td>
</tr>
<tr class="row-even"><td><p>1 0</p></td>
<td><p>1</p></td>
<td><p>0x200000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x180000000</span> <span class="pre">-</span> <span class="pre">0x1ffffffff</span></code></p></td>
<td><p>2174-02-25 to 2242-03-16</p></td>
</tr>
<tr class="row-odd"><td><p>1 0</p></td>
<td><p>0</p></td>
<td><p>0x200000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x200000000</span> <span class="pre">-</span> <span class="pre">0x27fffffff</span></code></p></td>
<td><p>2242-03-16 to 2310-04-04</p></td>
</tr>
<tr class="row-even"><td><p>1 1</p></td>
<td><p>1</p></td>
<td><p>0x300000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x280000000</span> <span class="pre">-</span> <span class="pre">0x2ffffffff</span></code></p></td>
<td><p>2310-04-04 to 2378-04-22</p></td>
</tr>
<tr class="row-odd"><td><p>1 1</p></td>
<td><p>0</p></td>
<td><p>0x300000000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x300000000</span> <span class="pre">-</span> <span class="pre">0x37fffffff</span></code></p></td>
<td><p>2378-04-22 to 2446-05-10</p></td>
</tr>
</tbody>
</table>
<p>This is a somewhat odd encoding since there are effectively seven times
as many positive values as negative values. There have also been
long-standing bugs decoding and encoding dates beyond 2038, which don’t
seem to be fixed as of kernel 3.12 and e2fsprogs 1.42.8. 64-bit kernels
incorrectly use the extra epoch bits 1,1 for dates between 1901 and
1970. At some point the kernel will be fixed and e2fsck will fix this
situation, assuming that it is run before 2310.</p>
</section>
</section>
<section id="the-contents-of-inode-i-block">
<h2><span class="section-number">4.2. </span>The Contents of inode.i_block<a class="headerlink" href="#the-contents-of-inode-i-block" title="Permalink to this headline">¶</a></h2>
<p>Depending on the type of file an inode describes, the 60 bytes of
storage in <code class="docutils literal notranslate"><span class="pre">inode.i_block</span></code> can be used in different ways. In general,
regular files and directories will use it for file block indexing
information, and special files will use it for special purposes.</p>
<section id="symbolic-links">
<h3><span class="section-number">4.2.1. </span>Symbolic Links<a class="headerlink" href="#symbolic-links" title="Permalink to this headline">¶</a></h3>
<p>The target of a symbolic link will be stored in this field if the target
string is less than 60 bytes long. Otherwise, either extents or block
maps will be used to allocate data blocks to store the link target.</p>
</section>
<section id="direct-indirect-block-addressing">
<h3><span class="section-number">4.2.2. </span>Direct/Indirect Block Addressing<a class="headerlink" href="#direct-indirect-block-addressing" title="Permalink to this headline">¶</a></h3>
<p>In ext2/3, file block numbers were mapped to logical block numbers by
means of an (up to) three level 1-1 block map. To find the logical block
that stores a particular file block, the code would navigate through
this increasingly complicated structure. Notice that there is neither a
magic number nor a checksum to provide any level of confidence that the
block isn’t full of garbage.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>i.i_block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to 11</p></td>
<td><p>Direct map to file blocks 0 to 11.</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Indirect block: (file blocks 12 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) + 11, or 12 to 1035 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Direct map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) blocks (1024 if 4KiB blocks)</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>Double-indirect block: (file blocks <code class="docutils literal notranslate"><span class="pre">$block_size</span></code>/4 + 12 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) ^ 2 + (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) + 11, or 1036 to 1049611 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Double Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) indirect blocks (1024 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Direct map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) blocks (1024 if 4KiB blocks)</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Triple-indirect block: (file blocks (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) ^ 2 + (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) + 12 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) ^ 3 + (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) ^ 2 + (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) + 12, or 1049612 to 1074791436 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Triple Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) double indirect blocks (1024 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Double Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) indirect blocks (1024 if 4KiB blocks)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Indirect Block Offset</p></th>
<th class="head"><p>Where It Points</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4)</p></td>
<td><p>Direct map to (<code class="docutils literal notranslate"><span class="pre">$block_size</span></code> / 4) blocks (1024 if 4KiB blocks)</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p>Note that with this block mapping scheme, it is necessary to fill out a
lot of mapping data even for a large contiguous file! This inefficiency
led to the creation of the extent mapping scheme, discussed below.</p>
<p>Notice also that a file using this mapping scheme cannot be placed
higher than 2^32 blocks.</p>
</section>
<section id="extent-tree">
<h3><span class="section-number">4.2.3. </span>Extent Tree<a class="headerlink" href="#extent-tree" title="Permalink to this headline">¶</a></h3>
<p>In ext4, the file to logical block map has been replaced with an extent
tree. Under the old scheme, allocating a contiguous run of 1,000 blocks
requires an indirect block to map all 1,000 entries; with extents, the
mapping is reduced to a single <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent</span></code> with
<code class="docutils literal notranslate"><span class="pre">ee_len</span> <span class="pre">=</span> <span class="pre">1000</span></code>. If flex_bg is enabled, it is possible to allocate
very large files with a single extent, at a considerable reduction in
metadata block use, and some improvement in disk efficiency. The inode
must have the extents flag (0x80000) flag set for this feature to be in
use.</p>
<p>Extents are arranged as a tree. Each node of the tree begins with a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent_header</span></code>. If the node is an interior node
(<code class="docutils literal notranslate"><span class="pre">eh.eh_depth</span></code> &gt; 0), the header is followed by <code class="docutils literal notranslate"><span class="pre">eh.eh_entries</span></code>
instances of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent_idx</span></code>; each of these index entries
points to a block containing more nodes in the extent tree. If the node
is a leaf node (<code class="docutils literal notranslate"><span class="pre">eh.eh_depth</span> <span class="pre">==</span> <span class="pre">0</span></code>), then the header is followed by
<code class="docutils literal notranslate"><span class="pre">eh.eh_entries</span></code> instances of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent</span></code>; these instances
point to the file’s data blocks. The root node of the extent tree is
stored in <code class="docutils literal notranslate"><span class="pre">inode.i_block</span></code>, which allows for the first four extents to
be recorded without the use of extra metadata blocks.</p>
<p>The extent tree header is recorded in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent_header</span></code>,
which is 12 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le16</p></td>
<td><p>eh_magic</p></td>
<td><p>Magic number, 0xF30A.</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>__le16</p></td>
<td><p>eh_entries</p></td>
<td><p>Number of valid entries following the header.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>eh_max</p></td>
<td><p>Maximum number of entries that could follow the header.</p></td>
</tr>
<tr class="row-odd"><td><p>0x6</p></td>
<td><p>__le16</p></td>
<td><p>eh_depth</p></td>
<td><p>Depth of this extent node in the extent tree. 0 = this extent node
points to data blocks; otherwise, this extent node points to other
extent nodes. The extent tree can be at most 5 levels deep: a logical
block number can be at most <code class="docutils literal notranslate"><span class="pre">2^32</span></code>, and the smallest <code class="docutils literal notranslate"><span class="pre">n</span></code> that
satisfies <code class="docutils literal notranslate"><span class="pre">4*(((blocksize</span> <span class="pre">-</span> <span class="pre">12)/12)^n)</span> <span class="pre">&gt;=</span> <span class="pre">2^32</span></code> is 5.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>eh_generation</p></td>
<td><p>Generation of the tree. (Used by Lustre, but not standard ext4).</p></td>
</tr>
</tbody>
</table>
<p>Internal nodes of the extent tree, also known as index nodes, are
recorded as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent_idx</span></code>, and are 12 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>ei_block</p></td>
<td><p>This index node covers file blocks from ‘block’ onward.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>ei_leaf_lo</p></td>
<td><p>Lower 32-bits of the block number of the extent node that is the next
level lower in the tree. The tree node pointed to can be either another
internal node or a leaf node, described below.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le16</p></td>
<td><p>ei_leaf_hi</p></td>
<td><p>Upper 16-bits of the previous field.</p></td>
</tr>
<tr class="row-odd"><td><p>0xA</p></td>
<td><p>__u16</p></td>
<td><p>ei_unused</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Leaf nodes of the extent tree are recorded as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent</span></code>,
and are also 12 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>ee_block</p></td>
<td><p>First file block number that this extent covers.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>ee_len</p></td>
<td><p>Number of blocks covered by extent. If the value of this field is &lt;=
32768, the extent is initialized. If the value of the field is &gt; 32768,
the extent is uninitialized and the actual extent length is <code class="docutils literal notranslate"><span class="pre">ee_len</span></code> -
32768. Therefore, the maximum length of a initialized extent is 32768
blocks, and the maximum length of an uninitialized extent is 32767.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>__le16</p></td>
<td><p>ee_start_hi</p></td>
<td><p>Upper 16-bits of the block number to which this extent points.</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>ee_start_lo</p></td>
<td><p>Lower 32-bits of the block number to which this extent points.</p></td>
</tr>
</tbody>
</table>
<p>Prior to the introduction of metadata checksums, the extent header +
extent entries always left at least 4 bytes of unallocated space at the
end of each extent tree data block (because (2^x % 12) &gt;= 4). Therefore,
the 32-bit checksum is inserted into this space. The 4 extents in the
inode do not need checksumming, since the inode is already checksummed.
The checksum is calculated against the FS UUID, the inode number, the
inode generation, and the entire extent block leading up to (but not
including) the checksum itself.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_extent_tail</span></code> is 4 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>eb_checksum</p></td>
<td><p>Checksum of the extent block, crc32c(uuid+inum+igeneration+extentblock)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="inline-data">
<h3><span class="section-number">4.2.4. </span>Inline Data<a class="headerlink" href="#inline-data" title="Permalink to this headline">¶</a></h3>
<p>If the inline data feature is enabled for the filesystem and the flag is
set for the inode, it is possible that the first 60 bytes of the file
data are stored here.</p>
</section>
</section>
<section id="directory-entries">
<h2><span class="section-number">4.3. </span>Directory Entries<a class="headerlink" href="#directory-entries" title="Permalink to this headline">¶</a></h2>
<p>In an ext4 filesystem, a directory is more or less a flat file that maps
an arbitrary byte string (usually ASCII) to an inode number on the
filesystem. There can be many directory entries across the filesystem
that reference the same inode number–these are known as hard links, and
that is why hard links cannot reference files on other filesystems. As
such, directory entries are found by reading the data block(s)
associated with a directory file for the particular directory entry that
is desired.</p>
<section id="linear-classic-directories">
<h3><span class="section-number">4.3.1. </span>Linear (Classic) Directories<a class="headerlink" href="#linear-classic-directories" title="Permalink to this headline">¶</a></h3>
<p>By default, each directory lists its entries in an “almost-linear”
array. I write “almost” because it’s not a linear array in the memory
sense because directory entries are not split across filesystem blocks.
Therefore, it is more accurate to say that a directory is a series of
data blocks and that each block contains a linear array of directory
entries. The end of each per-block array is signified by reaching the
end of the block; the last entry in the block has a record length that
takes it all the way to the end of the block. The end of the entire
directory is of course signified by reaching the end of the file. Unused
directory entries are signified by inode = 0. By default the filesystem
uses <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry_2</span></code> for directory entries unless the
“filetype” feature flag is not set, in which case it uses
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code>.</p>
<p>The original directory entry format is <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code>, which
is at most 263 bytes long, though on disk you’ll need to reference
<code class="docutils literal notranslate"><span class="pre">dirent.rec_len</span></code> to know for sure.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>inode</p></td>
<td><p>Number of the inode that this directory entry points to.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>rec_len</p></td>
<td><p>Length of this directory entry. Must be a multiple of 4.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>__le16</p></td>
<td><p>name_len</p></td>
<td><p>Length of the file name.</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>char</p></td>
<td><p>name[EXT4_NAME_LEN]</p></td>
<td><p>File name.</p></td>
</tr>
</tbody>
</table>
<p>Since file names cannot be longer than 255 bytes, the new directory
entry format shortens the name_len field and uses the space for a file
type flag, probably to avoid having to load every inode during directory
tree traversal. This format is <code class="docutils literal notranslate"><span class="pre">ext4_dir_entry_2</span></code>, which is at most
263 bytes long, though on disk you’ll need to reference
<code class="docutils literal notranslate"><span class="pre">dirent.rec_len</span></code> to know for sure.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>inode</p></td>
<td><p>Number of the inode that this directory entry points to.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>rec_len</p></td>
<td><p>Length of this directory entry.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>__u8</p></td>
<td><p>name_len</p></td>
<td><p>Length of the file name.</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>__u8</p></td>
<td><p>file_type</p></td>
<td><p>File type code, see <a class="reference internal" href="#ftype">ftype</a> table below.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>char</p></td>
<td><p>name[EXT4_NAME_LEN]</p></td>
<td><p>File name.</p></td>
</tr>
</tbody>
</table>
<p id="ftype">The directory file type is one of the following values:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>Unknown.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>Regular file.</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>Directory.</p></td>
</tr>
<tr class="row-odd"><td><p>0x3</p></td>
<td><p>Character device file.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Block device file.</p></td>
</tr>
<tr class="row-odd"><td><p>0x5</p></td>
<td><p>FIFO.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>Socket.</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>Symbolic link.</p></td>
</tr>
</tbody>
</table>
<p>To support directories that are both encrypted and casefolded directories, we
must also include hash information in the directory entry. We append
<code class="docutils literal notranslate"><span class="pre">ext4_extended_dir_entry_2</span></code> to <code class="docutils literal notranslate"><span class="pre">ext4_dir_entry_2</span></code> except for the entries
for dot and dotdot, which are kept the same. The structure follows immediately
after <code class="docutils literal notranslate"><span class="pre">name</span></code> and is included in the size listed by <code class="docutils literal notranslate"><span class="pre">rec_len</span></code> If a directory
entry uses this extension, it may be up to 271 bytes.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>hash</p></td>
<td><p>The hash of the directory name</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>minor_hash</p></td>
<td><p>The minor hash of the directory name</p></td>
</tr>
</tbody>
</table>
<p>In order to add checksums to these classic directory blocks, a phony
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code> is placed at the end of each leaf block to
hold the checksum. The directory entry is 12 bytes long. The inode
number and name_len fields are set to zero to fool old software into
ignoring an apparently empty directory entry, and the checksum is stored
in the place where the name normally goes. The structure is
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry_tail</span></code>:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>det_reserved_zero1</p></td>
<td><p>Inode number, which must be zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>det_rec_len</p></td>
<td><p>Length of this directory entry, which must be 12.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>__u8</p></td>
<td><p>det_reserved_zero2</p></td>
<td><p>Length of the file name, which must be zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>__u8</p></td>
<td><p>det_reserved_ft</p></td>
<td><p>File type, which must be 0xDE.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>det_checksum</p></td>
<td><p>Directory leaf block checksum.</p></td>
</tr>
</tbody>
</table>
<p>The leaf directory block checksum is calculated against the FS UUID, the
directory’s inode number, the directory’s inode generation number, and
the entire directory entry block up to (but not including) the fake
directory entry.</p>
</section>
<section id="hash-tree-directories">
<h3><span class="section-number">4.3.2. </span>Hash Tree Directories<a class="headerlink" href="#hash-tree-directories" title="Permalink to this headline">¶</a></h3>
<p>A linear array of directory entries isn’t great for performance, so a
new feature was added to ext3 to provide a faster (but peculiar)
balanced tree keyed off a hash of the directory entry name. If the
EXT4_INDEX_FL (0x1000) flag is set in the inode, this directory uses a
hashed btree (htree) to organize and find directory entries. For
backwards read-only compatibility with ext2, this tree is actually
hidden inside the directory file, masquerading as “empty” directory data
blocks! It was stated previously that the end of the linear directory
entry table was signified with an entry pointing to inode 0; this is
(ab)used to fool the old linear-scan algorithm into thinking that the
rest of the directory block is empty so that it moves on.</p>
<p>The root of the tree always lives in the first data block of the
directory. By ext2 custom, the ‘.’ and ‘..’ entries must appear at the
beginning of this first block, so they are put here as two
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry_2</span></code> s and not stored in the tree. The rest of
the root node contains metadata about the tree and finally a hash-&gt;block
map to find nodes that are lower in the htree. If
<code class="docutils literal notranslate"><span class="pre">dx_root.info.indirect_levels</span></code> is non-zero then the htree has two
levels; the data block pointed to by the root node’s map is an interior
node, which is indexed by a minor hash. Interior nodes in this tree
contains a zeroed out <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry_2</span></code> followed by a
minor_hash-&gt;block map to find leafe nodes. Leaf nodes contain a linear
array of all <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry_2</span></code>; all of these entries
(presumably) hash to the same value. If there is an overflow, the
entries simply overflow into the next leaf node, and the
least-significant bit of the hash (in the interior node map) that gets
us to this next leaf node is set.</p>
<p>To traverse the directory as a htree, the code calculates the hash of
the desired file name and uses it to find the corresponding block
number. If the tree is flat, the block is a linear array of directory
entries that can be searched; otherwise, the minor hash of the file name
is computed and used against this second block to find the corresponding
third block number. That third block number will be a linear array of
directory entries.</p>
<p>To traverse the directory as a linear array (such as the old code does),
the code simply reads every data block in the directory. The blocks used
for the htree will appear to have no entries (aside from ‘.’ and ‘..’)
and so only the leaf nodes will appear to have any interesting content.</p>
<p>The root of the htree is in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_root</span></code>, which is the full length
of a data block:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>dot.inode</p></td>
<td><p>inode number of this directory.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>dot.rec_len</p></td>
<td><p>Length of this record, 12.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>u8</p></td>
<td><p>dot.name_len</p></td>
<td><p>Length of the name, 1.</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>u8</p></td>
<td><p>dot.file_type</p></td>
<td><p>File type of this entry, 0x2 (directory) (if the feature flag is set).</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>char</p></td>
<td><p>dot.name[4]</p></td>
<td><p>“.000”</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__le32</p></td>
<td><p>dotdot.inode</p></td>
<td><p>inode number of parent directory.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>__le16</p></td>
<td><p>dotdot.rec_len</p></td>
<td><p>block_size - 12. The record length is long enough to cover all htree
data.</p></td>
</tr>
<tr class="row-odd"><td><p>0x12</p></td>
<td><p>u8</p></td>
<td><p>dotdot.name_len</p></td>
<td><p>Length of the name, 2.</p></td>
</tr>
<tr class="row-even"><td><p>0x13</p></td>
<td><p>u8</p></td>
<td><p>dotdot.file_type</p></td>
<td><p>File type of this entry, 0x2 (directory) (if the feature flag is set).</p></td>
</tr>
<tr class="row-odd"><td><p>0x14</p></td>
<td><p>char</p></td>
<td><p>dotdot_name[4]</p></td>
<td><p>“..00”</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>__le32</p></td>
<td><p>struct dx_root_info.reserved_zero</p></td>
<td><p>Zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1C</p></td>
<td><p>u8</p></td>
<td><p>struct dx_root_info.hash_version</p></td>
<td><p>Hash type, see <a class="reference internal" href="#dirhash">dirhash</a> table below.</p></td>
</tr>
<tr class="row-even"><td><p>0x1D</p></td>
<td><p>u8</p></td>
<td><p>struct dx_root_info.info_length</p></td>
<td><p>Length of the tree information, 0x8.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1E</p></td>
<td><p>u8</p></td>
<td><p>struct dx_root_info.indirect_levels</p></td>
<td><p>Depth of the htree. Cannot be larger than 3 if the INCOMPAT_LARGEDIR
feature is set; cannot be larger than 2 otherwise.</p></td>
</tr>
<tr class="row-even"><td><p>0x1F</p></td>
<td><p>u8</p></td>
<td><p>struct dx_root_info.unused_flags</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>__le16</p></td>
<td><p>limit</p></td>
<td><p>Maximum number of dx_entries that can follow this header, plus 1 for
the header itself.</p></td>
</tr>
<tr class="row-even"><td><p>0x22</p></td>
<td><p>__le16</p></td>
<td><p>count</p></td>
<td><p>Actual number of dx_entries that follow this header, plus 1 for the
header itself.</p></td>
</tr>
<tr class="row-odd"><td><p>0x24</p></td>
<td><p>__le32</p></td>
<td><p>block</p></td>
<td><p>The block number (within the directory file) that goes with hash=0.</p></td>
</tr>
<tr class="row-even"><td><p>0x28</p></td>
<td><p>struct dx_entry</p></td>
<td><p>entries[0]</p></td>
<td><p>As many 8-byte <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_entry</span></code> as fits in the rest of the data block.</p></td>
</tr>
</tbody>
</table>
<p id="dirhash">The directory hash is one of the following values:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>Legacy.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>Half MD4.</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>Tea.</p></td>
</tr>
<tr class="row-odd"><td><p>0x3</p></td>
<td><p>Legacy, unsigned.</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>Half MD4, unsigned.</p></td>
</tr>
<tr class="row-odd"><td><p>0x5</p></td>
<td><p>Tea, unsigned.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>Siphash.</p></td>
</tr>
</tbody>
</table>
<p>Interior nodes of an htree are recorded as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_node</span></code>, which is
also the full length of a data block:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>fake.inode</p></td>
<td><p>Zero, to make it look like this entry is not in use.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le16</p></td>
<td><p>fake.rec_len</p></td>
<td><p>The size of the block, in order to hide all of the dx_node data.</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>u8</p></td>
<td><p>name_len</p></td>
<td><p>Zero. There is no name for this “unused” directory entry.</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>u8</p></td>
<td><p>file_type</p></td>
<td><p>Zero. There is no file type for this “unused” directory entry.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le16</p></td>
<td><p>limit</p></td>
<td><p>Maximum number of dx_entries that can follow this header, plus 1 for
the header itself.</p></td>
</tr>
<tr class="row-odd"><td><p>0xA</p></td>
<td><p>__le16</p></td>
<td><p>count</p></td>
<td><p>Actual number of dx_entries that follow this header, plus 1 for the
header itself.</p></td>
</tr>
<tr class="row-even"><td><p>0xE</p></td>
<td><p>__le32</p></td>
<td><p>block</p></td>
<td><p>The block number (within the directory file) that goes with the lowest
hash value of this block. This value is stored in the parent block.</p></td>
</tr>
<tr class="row-odd"><td><p>0x12</p></td>
<td><p>struct dx_entry</p></td>
<td><p>entries[0]</p></td>
<td><p>As many 8-byte <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_entry</span></code> as fits in the rest of the data block.</p></td>
</tr>
</tbody>
</table>
<p>The hash maps that exist in both <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_root</span></code> and
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_node</span></code> are recorded as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_entry</span></code>, which is 8 bytes
long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>hash</p></td>
<td><p>Hash code.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>block</p></td>
<td><p>Block number (within the directory file, not filesystem blocks) of the
next node in the htree.</p></td>
</tr>
</tbody>
</table>
<p>(If you think this is all quite clever and peculiar, so does the
author.)</p>
<p>If metadata checksums are enabled, the last 8 bytes of the directory
block (precisely the length of one dx_entry) are used to store a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dx_tail</span></code>, which contains the checksum. The <code class="docutils literal notranslate"><span class="pre">limit</span></code> and
<code class="docutils literal notranslate"><span class="pre">count</span></code> entries in the dx_root/dx_node structures are adjusted as
necessary to fit the dx_tail into the block. If there is no space for
the dx_tail, the user is notified to run e2fsck -D to rebuild the
directory index (which will ensure that there’s space for the checksum.
The dx_tail structure is 8 bytes long and looks like this:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>u32</p></td>
<td><p>dt_reserved</p></td>
<td><p>Zero.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>dt_checksum</p></td>
<td><p>Checksum of the htree directory block.</p></td>
</tr>
</tbody>
</table>
<p>The checksum is calculated against the FS UUID, the htree index header
(dx_root or dx_node), all of the htree indices (dx_entry) that are in
use, and the tail block (dx_tail).</p>
</section>
</section>
<section id="extended-attributes">
<h2><span class="section-number">4.4. </span>Extended Attributes<a class="headerlink" href="#extended-attributes" title="Permalink to this headline">¶</a></h2>
<p>Extended attributes (xattrs) are typically stored in a separate data
block on the disk and referenced from inodes via <code class="docutils literal notranslate"><span class="pre">inode.i_file_acl*</span></code>.
The first use of extended attributes seems to have been for storing file
ACLs and other security data (selinux). With the <code class="docutils literal notranslate"><span class="pre">user_xattr</span></code> mount
option it is possible for users to store extended attributes so long as
all attribute names begin with “user”; this restriction seems to have
disappeared as of Linux 3.0.</p>
<p>There are two places where extended attributes can be found. The first
place is between the end of each inode entry and the beginning of the
next inode entry. For example, if inode.i_extra_isize = 28 and
sb.inode_size = 256, then there are 256 - (128 + 28) = 100 bytes
available for in-inode extended attribute storage. The second place
where extended attributes can be found is in the block pointed to by
<code class="docutils literal notranslate"><span class="pre">inode.i_file_acl</span></code>. As of Linux 3.11, it is not possible for this
block to contain a pointer to a second extended attribute block (or even
the remaining blocks of a cluster). In theory it is possible for each
attribute’s value to be stored in a separate data block, though as of
Linux 3.11 the code does not permit this.</p>
<p>Keys are generally assumed to be ASCIIZ strings, whereas values can be
strings or binary data.</p>
<p>Extended attributes, when stored after the inode, have a header
<code class="docutils literal notranslate"><span class="pre">ext4_xattr_ibody_header</span></code> that is 4 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>h_magic</p></td>
<td><p>Magic number for identification, 0xEA020000. This value is set by the
Linux driver, though e2fsprogs doesn’t seem to check it(?)</p></td>
</tr>
</tbody>
</table>
<p>The beginning of an extended attribute block is in
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_xattr_header</span></code>, which is 32 bytes long:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__le32</p></td>
<td><p>h_magic</p></td>
<td><p>Magic number for identification, 0xEA020000.</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>h_refcount</p></td>
<td><p>Reference count.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>h_blocks</p></td>
<td><p>Number of disk blocks used.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__le32</p></td>
<td><p>h_hash</p></td>
<td><p>Hash value of all attributes.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>__le32</p></td>
<td><p>h_checksum</p></td>
<td><p>Checksum of the extended attribute block.</p></td>
</tr>
<tr class="row-odd"><td><p>0x14</p></td>
<td><p>__u32</p></td>
<td><p>h_reserved[3]</p></td>
<td><p>Zero.</p></td>
</tr>
</tbody>
</table>
<p>The checksum is calculated against the FS UUID, the 64-bit block number
of the extended attribute block, and the entire block (header +
entries).</p>
<p>Following the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_xattr_header</span></code> or
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_xattr_ibody_header</span></code> is an array of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_xattr_entry</span></code>; each of these entries is at least 16 bytes
long. When stored in an external block, the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_xattr_entry</span></code>
entries must be stored in sorted order. The sort order is
<code class="docutils literal notranslate"><span class="pre">e_name_index</span></code>, then <code class="docutils literal notranslate"><span class="pre">e_name_len</span></code>, and finally <code class="docutils literal notranslate"><span class="pre">e_name</span></code>.
Attributes stored inside an inode do not need be stored in sorted order.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>__u8</p></td>
<td><p>e_name_len</p></td>
<td><p>Length of name.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>__u8</p></td>
<td><p>e_name_index</p></td>
<td><p>Attribute name index. There is a discussion of this below.</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>__le16</p></td>
<td><p>e_value_offs</p></td>
<td><p>Location of this attribute’s value on the disk block where it is stored.
Multiple attributes can share the same value. For an inode attribute
this value is relative to the start of the first entry; for a block this
value is relative to the start of the block (i.e. the header).</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>__le32</p></td>
<td><p>e_value_inum</p></td>
<td><p>The inode where the value is stored. Zero indicates the value is in the
same block as this entry. This field is only used if the
INCOMPAT_EA_INODE feature is enabled.</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>__le32</p></td>
<td><p>e_value_size</p></td>
<td><p>Length of attribute value.</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>__le32</p></td>
<td><p>e_hash</p></td>
<td><p>Hash value of attribute name and attribute value. The kernel doesn’t
update the hash for in-inode attributes, so for that case this value
must be zero, because e2fsck validates any non-zero hash regardless of
where the xattr lives.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>char</p></td>
<td><p>e_name[e_name_len]</p></td>
<td><p>Attribute name. Does not include trailing NULL.</p></td>
</tr>
</tbody>
</table>
<p>Attribute values can follow the end of the entry table. There appears to
be a requirement that they be aligned to 4-byte boundaries. The values
are stored starting at the end of the block and grow towards the
xattr_header/xattr_entry table. When the two collide, the overflow is
put into a separate disk block. If the disk block fills up, the
filesystem returns -ENOSPC.</p>
<p>The first four fields of the <code class="docutils literal notranslate"><span class="pre">ext4_xattr_entry</span></code> are set to zero to
mark the end of the key list.</p>
<section id="attribute-name-indices">
<h3><span class="section-number">4.4.1. </span>Attribute Name Indices<a class="headerlink" href="#attribute-name-indices" title="Permalink to this headline">¶</a></h3>
<p>Logically speaking, extended attributes are a series of key=value pairs.
The keys are assumed to be NULL-terminated strings. To reduce the amount
of on-disk space that the keys consume, the beginning of the key string
is matched against the attribute name index. If a match is found, the
attribute name index field is set, and matching string is removed from
the key name. Here is a map of name index values to key prefixes:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name Index</p></th>
<th class="head"><p>Key Prefix</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>(no prefix)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>“user.”</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>“system.posix_acl_access”</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>“system.posix_acl_default”</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>“trusted.”</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>“security.”</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>“system.” (inline_data only?)</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>“system.richacl” (SuSE kernels only?)</p></td>
</tr>
</tbody>
</table>
<p>For example, if the attribute key is “user.fubar”, the attribute name
index is set to 1 and the “fubar” name is recorded on disk.</p>
</section>
<section id="posix-acls">
<h3><span class="section-number">4.4.2. </span>POSIX ACLs<a class="headerlink" href="#posix-acls" title="Permalink to this headline">¶</a></h3>
<p>POSIX ACLs are stored in a reduced version of the Linux kernel (and
libacl’s) internal ACL format. The key difference is that the version
number is different (1) and the <code class="docutils literal notranslate"><span class="pre">e_id</span></code> field is only stored for named
user and group ACLs.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. Dynamic Structures</a><ul>
<li><a class="reference internal" href="#index-nodes">4.1. Index Nodes</a><ul>
<li><a class="reference internal" href="#inode-size">4.1.1. Inode Size</a></li>
<li><a class="reference internal" href="#finding-an-inode">4.1.2. Finding an Inode</a></li>
<li><a class="reference internal" href="#inode-timestamps">4.1.3. Inode Timestamps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-contents-of-inode-i-block">4.2. The Contents of inode.i_block</a><ul>
<li><a class="reference internal" href="#symbolic-links">4.2.1. Symbolic Links</a></li>
<li><a class="reference internal" href="#direct-indirect-block-addressing">4.2.2. Direct/Indirect Block Addressing</a></li>
<li><a class="reference internal" href="#extent-tree">4.2.3. Extent Tree</a></li>
<li><a class="reference internal" href="#inline-data">4.2.4. Inline Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#directory-entries">4.3. Directory Entries</a><ul>
<li><a class="reference internal" href="#linear-classic-directories">4.3.1. Linear (Classic) Directories</a></li>
<li><a class="reference internal" href="#hash-tree-directories">4.3.2. Hash Tree Directories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extended-attributes">4.4. Extended Attributes</a><ul>
<li><a class="reference internal" href="#attribute-name-indices">4.4.1. Attribute Name Indices</a></li>
<li><a class="reference internal" href="#posix-acls">4.4.2. POSIX ACLs</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/ext4/dynamic.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/ext4/dynamic.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>