
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Network Filesystem Helper Library &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="v9fs: Plan 9 Resource Sharing for Linux" href="9p.html" />
    <link rel="prev" title="fs-verity: read-only file-based authenticity protection" href="fsverity.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="network-filesystem-helper-library">
<h1>Network Filesystem Helper Library<a class="headerlink" href="#network-filesystem-helper-library" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The network filesystem helper library is a set of functions designed to aid a
network filesystem in implementing VM/VFS operations.  For the moment, that
just includes turning various VM buffered read operations into requests to read
from the server.  The helper library, however, can also interpose other
services, such as local caching or local data encryption.</p>
<p>Note that the library module doesn’t link against local caching directly, so
access must be provided by the netfs.</p>
</section>
<section id="per-inode-context">
<h2>Per-Inode Context<a class="headerlink" href="#per-inode-context" title="Permalink to this headline">¶</a></h2>
<p>The network filesystem helper library needs a place to store a bit of state for
its use on each netfs inode it is helping to manage.  To this end, a context
structure is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_inode {
        struct inode inode;
        const struct netfs_request_ops *ops;
        struct fscache_cookie *cache;
};
</pre></div>
</div>
<p>A network filesystem that wants to use netfs lib must place one of these in its
inode wrapper struct instead of the VFS <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code>.  This can be done in
a way similar to the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_inode {
        struct netfs_inode netfs; /* Netfslib context and vfs inode */
        ...
};
</pre></div>
</div>
<p>This allows netfslib to find its state by using <code class="docutils literal notranslate"><span class="pre">container_of()</span></code> from the
inode pointer, thereby allowing the netfslib helper functions to be pointed to
directly by the VFS/VM operation tables.</p>
<p>The structure contains the following fields:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inode</span></code></p>
<p>The VFS inode structure.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ops</span></code></p>
<p>The set of operations provided by the network filesystem to netfslib.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code></p>
<p>Local caching cookie, or NULL if no caching is enabled.  This field does not
exist if fscache is disabled.</p>
</li>
</ul>
</div></blockquote>
<section id="inode-context-helper-functions">
<h3>Inode Context Helper Functions<a class="headerlink" href="#inode-context-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>To help deal with the per-inode context, a number helper functions are
provided.  Firstly, a function to perform basic initialisation on a context and
set the operations table pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_inode_init(struct netfs_inode *ctx,
                      const struct netfs_request_ops *ops);
</pre></div>
</div>
<p>then a function to cast from the VFS inode structure to the netfs context:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_inode *netfs_node(struct inode *inode);
</pre></div>
</div>
<p>and finally, a function to get the cache cookie pointer from the context
attached to an inode (or NULL if fscache is disabled):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie *netfs_i_cookie(struct netfs_inode *ctx);
</pre></div>
</div>
</section>
</section>
<section id="buffered-read-helpers">
<h2>Buffered Read Helpers<a class="headerlink" href="#buffered-read-helpers" title="Permalink to this headline">¶</a></h2>
<p>The library provides a set of read helpers that handle the -&gt;read_folio(),
-&gt;readahead() and much of the -&gt;write_begin() VM operations and translate them
into a common call framework.</p>
<p>The following services are provided:</p>
<blockquote>
<div><ul class="simple">
<li><p>Handle folios that span multiple pages.</p></li>
<li><p>Insulate the netfs from VM interface changes.</p></li>
<li><p>Allow the netfs to arbitrarily split reads up into pieces, even ones that
don’t match folio sizes or folio alignments and that may cross folios.</p></li>
<li><p>Allow the netfs to expand a readahead request in both directions to meet its
needs.</p></li>
<li><p>Allow the netfs to partially fulfil a read, which will then be resubmitted.</p></li>
<li><p>Handle local caching, allowing cached data and server-read data to be
interleaved for a single request.</p></li>
<li><p>Handle clearing of bufferage that aren’t on the server.</p></li>
<li><p>Handle retrying of reads that failed, switching reads from the cache to the
server as necessary.</p></li>
<li><p>In the future, this is a place that other services can be performed, such as
local encryption of data to be stored remotely or in the cache.</p></li>
</ul>
</div></blockquote>
<p>From the network filesystem, the helpers require a table of operations.  This
includes a mandatory method to issue a read operation along with a number of
optional methods.</p>
<section id="read-helper-functions">
<h3>Read Helper Functions<a class="headerlink" href="#read-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>Three read helpers are provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_readahead(struct readahead_control *ractl);
int netfs_read_folio(struct file *file,
                     struct folio *folio);
int netfs_write_begin(struct netfs_inode *ctx,
                      struct file *file,
                      struct address_space *mapping,
                      loff_t pos,
                      unsigned int len,
                      struct folio **_folio,
                      void **_fsdata);
</pre></div>
</div>
<p>Each corresponds to a VM address space operation.  These operations use the
state in the per-inode context.</p>
<p>For -&gt;readahead() and -&gt;read_folio(), the network filesystem just point directly
at the corresponding read helper; whereas for -&gt;write_begin(), it may be a
little more complicated as the network filesystem might want to flush
conflicting writes or track dirty data and needs to put the acquired folio if
an error occurs after calling the helper.</p>
<p>The helpers manage the read request, calling back into the network filesystem
through the suppplied table of operations.  Waits will be performed as
necessary before returning for helpers that are meant to be synchronous.</p>
<p>If an error occurs, the -&gt;free_request() will be called to clean up the
netfs_io_request struct allocated.  If some parts of the request are in
progress when an error occurs, the request will get partially completed if
sufficient data is read.</p>
<p>Additionally, there is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* void netfs_subreq_terminated(struct netfs_io_subrequest *subreq,
                               ssize_t transferred_or_error,
                               bool was_async);
</pre></div>
</div>
<p>which should be called to complete a read subrequest.  This is given the number
of bytes transferred or a negative error code, plus a flag indicating whether
the operation was asynchronous (ie. whether the follow-on processing can be
done in the current context, given this may involve sleeping).</p>
</section>
<section id="read-helper-structures">
<h3>Read Helper Structures<a class="headerlink" href="#read-helper-structures" title="Permalink to this headline">¶</a></h3>
<p>The read helpers make use of a couple of structures to maintain the state of
the read.  The first is a structure that manages a read request as a whole:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_request {
        struct inode            *inode;
        struct address_space    *mapping;
        struct netfs_cache_resources cache_resources;
        void                    *netfs_priv;
        loff_t                  start;
        size_t                  len;
        loff_t                  i_size;
        const struct netfs_request_ops *netfs_ops;
        unsigned int            debug_id;
        ...
};
</pre></div>
</div>
<p>The above fields are the ones the netfs can use.  They are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inode</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code></p>
<p>The inode and the address space of the file being read from.  The mapping
may or may not point to inode-&gt;i_data.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache_resources</span></code></p>
<p>Resources for the local cache to use, if present.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_priv</span></code></p>
<p>The network filesystem’s private data.  The value for this can be passed in
to the helper functions or set during the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of the read request and the length.  These
may be altered by the -&gt;expand_readahead() op.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">i_size</span></code></p>
<p>The size of the file at the start of the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_ops</span></code></p>
<p>A pointer to the operation table.  The value for this is passed into the
helper functions.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_id</span></code></p>
<p>A number allocated to this operation that can be displayed in trace lines
for reference.</p>
</li>
</ul>
</div></blockquote>
<p>The second structure is used to manage individual slices of the overall read
request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_subrequest {
        struct netfs_io_request *rreq;
        loff_t                  start;
        size_t                  len;
        size_t                  transferred;
        unsigned long           flags;
        unsigned short          debug_index;
        ...
};
</pre></div>
</div>
<p>Each subrequest is expected to access a single source, though the helpers will
handle falling back from one source type to another.  The members are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">rreq</span></code></p>
<p>A pointer to the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of this slice of the read request and the
length.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">transferred</span></code></p>
<p>The amount of data transferred so far of the length of this slice.  The
network filesystem or cache should start the operation this far into the
slice.  If a short read occurs, the helpers will call again, having updated
this to reflect the amount read so far.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>Flags pertaining to the read.  There are two of interest to the filesystem
or cache:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_CLEAR_TAIL</span></code></p>
<p>This can be set to indicate that the remainder of the slice, from
transferred to len, should be cleared.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_SEEK_DATA_READ</span></code></p>
<p>This is a hint to the cache that it might want to try skipping ahead to
the next data (ie. using SEEK_DATA).</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_index</span></code></p>
<p>A number allocated to this slice that can be displayed in trace lines for
reference.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-operations">
<h3>Read Helper Operations<a class="headerlink" href="#read-helper-operations" title="Permalink to this headline">¶</a></h3>
<p>The network filesystem must provide the read helpers with a table of operations
through which it can issue requests and negotiate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_request_ops {
        void (*init_request)(struct netfs_io_request *rreq, struct file *file);
        void (*free_request)(struct netfs_io_request *rreq);
        int (*begin_cache_operation)(struct netfs_io_request *rreq);
        void (*expand_readahead)(struct netfs_io_request *rreq);
        bool (*clamp_length)(struct netfs_io_subrequest *subreq);
        void (*issue_read)(struct netfs_io_subrequest *subreq);
        bool (*is_still_valid)(struct netfs_io_request *rreq);
        int (*check_write_begin)(struct file *file, loff_t pos, unsigned len,
                                 struct folio **foliop, void **_fsdata);
        void (*done)(struct netfs_io_request *rreq);
};
</pre></div>
</div>
<p>The operations are as follows:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">init_request()</span></code></p>
<p>[Optional] This is called to initialise the request structure.  It is given
the file for reference.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">free_request()</span></code></p>
<p>[Optional] This is called as the request is being deallocated so that the
filesystem can clean up any state it has attached there.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">begin_cache_operation()</span></code></p>
<p>[Optional] This is called to ask the network filesystem to call into the
cache (if present) to initialise the caching state for this read.  The netfs
library module cannot access the cache directly, so the cache should call
something like <a class="reference internal" href="caching/netfs-api.html#c.fscache_begin_read_operation" title="fscache_begin_read_operation"><code class="xref c c-func docutils literal notranslate"><span class="pre">fscache_begin_read_operation()</span></code></a> to do this.</p>
<p>The cache gets to store its state in -&gt;cache_resources and must set a table
of operations of its own there (though of a different type).</p>
<p>This should return 0 on success and an error code otherwise.  If an error is
reported, the operation may proceed anyway, just without local caching (only
out of memory and interruption errors cause failure here).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] This is called to allow the filesystem to expand the size of a
readahead read request.  The filesystem gets to expand the request in both
directions, though it’s not permitted to reduce it as the numbers may
represent an allocation already made.  If local caching is enabled, it gets
to expand the request first.</p>
<p>Expansion is communicated by changing -&gt;start and -&gt;len in the request
structure.  Note that if any change is made, -&gt;len must be increased by at
least as much as -&gt;start is reduced.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">clamp_length()</span></code></p>
<p>[Optional] This is called to allow the filesystem to reduce the size of a
subrequest.  The filesystem can use this, for example, to chop up a request
that has to be split across multiple servers or to put multiple reads in
flight.</p>
<p>This should return 0 on success and an error code on error.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">issue_read()</span></code></p>
<p>[Required] The helpers use this to dispatch a subrequest to the server for
reading.  In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what
data should be read from the server.</p>
<p>There is no return value; the <a class="reference internal" href="#c.netfs_subreq_terminated" title="netfs_subreq_terminated"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_subreq_terminated()</span></code></a> function should be
called to indicate whether or not the operation succeeded and how much data
it transferred.  The filesystem also should not deal with setting folios
uptodate, unlocking them or dropping their refs - the helpers need to deal
with this as they have to coordinate with copying to the local cache.</p>
<p>Note that the helpers have the folios locked, but not pinned.  It is
possible to use the ITER_XARRAY iov iterator to refer to the range of the
inode that is being operated upon without the need to allocate large bvec
tables.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_still_valid()</span></code></p>
<p>[Optional] This is called to find out if the data just read from the local
cache is still valid.  It should return true if it is still valid and false
if not.  If it’s not still valid, it will be reread from the server.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_write_begin()</span></code></p>
<p>[Optional] This is called from the <a class="reference internal" href="#c.netfs_write_begin" title="netfs_write_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_write_begin()</span></code></a> helper once it has
allocated/grabbed the folio to be modified to allow the filesystem to flush
conflicting state before allowing it to be modified.</p>
<p>It may unlock and discard the folio it was given and set the caller’s folio
pointer to NULL.  It should return 0 if everything is now fine (<code class="docutils literal notranslate"><span class="pre">*foliop</span></code>
left set) or the op should be retried (<code class="docutils literal notranslate"><span class="pre">*foliop</span></code> cleared) and any other
error code to abort the operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">done</span></code></p>
<p>[Optional] This is called after the folios in the request have all been
unlocked (and marked uptodate if applicable).</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-procedure">
<h3>Read Helper Procedure<a class="headerlink" href="#read-helper-procedure" title="Permalink to this headline">¶</a></h3>
<p>The read helpers work by the following general procedure:</p>
<blockquote>
<div><ul class="simple">
<li><p>Set up the request.</p></li>
<li><p>For readahead, allow the local cache and then the network filesystem to
propose expansions to the read request.  This is then proposed to the VM.
If the VM cannot fully perform the expansion, a partially expanded read will
be performed, though this may not get written to the cache in its entirety.</p></li>
<li><p>Loop around slicing chunks off of the request to form subrequests:</p>
<ul>
<li><p>If a local cache is present, it gets to do the slicing, otherwise the
helpers just try to generate maximal slices.</p></li>
<li><p>The network filesystem gets to clamp the size of each slice if it is to be
the source.  This allows rsize and chunking to be implemented.</p></li>
<li><p>The helpers issue a read from the cache or a read from the server or just
clears the slice as appropriate.</p></li>
<li><p>The next slice begins at the end of the last one.</p></li>
<li><p>As slices finish being read, they terminate.</p></li>
</ul>
</li>
<li><p>When all the subrequests have terminated, the subrequests are assessed and
any that are short or have failed are reissued:</p>
<ul>
<li><p>Failed cache requests are issued against the server instead.</p></li>
<li><p>Failed server requests just fail.</p></li>
<li><p>Short reads against either source will be reissued against that source
provided they have transferred some more data:</p>
<ul>
<li><p>The cache may need to skip holes that it can’t do DIO from.</p></li>
<li><p>If NETFS_SREQ_CLEAR_TAIL was set, a short read will be cleared to the
end of the slice instead of reissuing.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Once the data is read, the folios that have been fully read/cleared:</p>
<ul>
<li><p>Will be marked uptodate.</p></li>
<li><p>If a cache is present, will be marked with PG_fscache.</p></li>
<li><p>Unlocked</p></li>
</ul>
</li>
<li><p>Any folios that need writing to the cache will then have DIO writes issued.</p></li>
<li><p>Synchronous operations will wait for reading to be complete.</p></li>
<li><p>Writes to the cache will proceed asynchronously and the folios will have the
PG_fscache mark removed when that completes.</p></li>
<li><p>The request structures will be cleaned up when everything has completed.</p></li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-cache-api">
<h3>Read Helper Cache API<a class="headerlink" href="#read-helper-cache-api" title="Permalink to this headline">¶</a></h3>
<p>When implementing a local cache to be used by the read helpers, two things are
required: some way for the network filesystem to initialise the caching for a
read request and a table of operations for the helpers to call.</p>
<p>The network filesystem’s -&gt;begin_cache_operation() method is called to set up a
cache and this must call into the cache to do the work.  If using fscache, for
example, the cache would call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_begin_read_operation(struct netfs_io_request *rreq,
                                 struct fscache_cookie *cookie);
</pre></div>
</div>
<p>passing in the request pointer and the cookie corresponding to the file.</p>
<p>The netfs_io_request object contains a place for the cache to hang its
state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_resources {
        const struct netfs_cache_ops    *ops;
        void                            *cache_priv;
        void                            *cache_priv2;
};
</pre></div>
</div>
<p>This contains an operations table pointer and two private pointers.  The
operation table looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_ops {
        void (*end_operation)(struct netfs_cache_resources *cres);

        void (*expand_readahead)(struct netfs_cache_resources *cres,
                                 loff_t *_start, size_t *_len, loff_t i_size);

        enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *subreq,
                                               loff_t i_size);

        int (*read)(struct netfs_cache_resources *cres,
                    loff_t start_pos,
                    struct iov_iter *iter,
                    bool seek_data,
                    netfs_io_terminated_t term_func,
                    void *term_func_priv);

        int (*prepare_write)(struct netfs_cache_resources *cres,
                             loff_t *_start, size_t *_len, loff_t i_size,
                             bool no_space_allocated_yet);

        int (*write)(struct netfs_cache_resources *cres,
                     loff_t start_pos,
                     struct iov_iter *iter,
                     netfs_io_terminated_t term_func,
                     void *term_func_priv);

        int (*query_occupancy)(struct netfs_cache_resources *cres,
                               loff_t start, size_t len, size_t granularity,
                               loff_t *_data_start, size_t *_data_len);
};
</pre></div>
</div>
<p>With a termination handler function pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef void (*netfs_io_terminated_t)(void *priv,
                                      ssize_t transferred_or_error,
                                      bool was_async);
</pre></div>
</div>
<p>The methods defined in the table are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">end_operation()</span></code></p>
<p>[Required] Called to clean up the resources at the end of the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] Called at the beginning of a <a class="reference internal" href="#c.netfs_readahead" title="netfs_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_readahead()</span></code></a> operation to allow
the cache to expand a request in either direction.  This allows the cache to
size the request appropriately for the cache granularity.</p>
<p>The function is passed poiners to the start and length in its parameters,
plus the size of the file for reference, and adjusts the start and length
appropriately.  It should return one of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_FILL_WITH_ZEROES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_DOWNLOAD_FROM_SERVER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_READ_FROM_CACHE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_INVALID_READ</span></code></p></li>
</ul>
<p>to indicate whether the slice should just be cleared or whether it should be
downloaded from the server or read from the cache - or whether slicing
should be given up at the current point.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_read()</span></code></p>
<p>[Required] Called to configure the next slice of a request.  -&gt;start and
-&gt;len in the subrequest indicate where and how big the next slice can be;
the cache gets to reduce the length to match its granularity requirements.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">read()</span></code></p>
<p>[Required] Called to read from the cache.  The start file offset is given
along with an iterator to read to, which gives the length also.  It can be
given a hint requesting that it seek forward from that start position for
data.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_write()</span></code></p>
<p>[Required] Called to prepare a write to the cache to take place.  This
involves checking to see whether the cache has sufficient space to honour
the write.  <code class="docutils literal notranslate"><span class="pre">*_start</span></code> and <code class="docutils literal notranslate"><span class="pre">*_len</span></code> indicate the region to be written; the
region can be shrunk or it can be expanded to a page boundary either way as
necessary to align for direct I/O.  i_size holds the size of the object and
is provided for reference.  no_space_allocated_yet is set to true if the
caller is certain that no data has been written to that region - for example
if it tried to do a read from there already.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">write()</span></code></p>
<p>[Required] Called to write to the cache.  The start file offset is given
along with an iterator to write from, which gives the length also.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">query_occupancy()</span></code></p>
<p>[Required] Called to find out where the next piece of data is within a
particular region of the cache.  The start and length of the region to be
queried are passed in, along with the granularity to which the answer needs
to be aligned.  The function passes back the start and length of the data,
if any, available within that region.  Note that there may be a hole at the
front.</p>
<p>It returns 0 if some data was found, -ENODATA if there was no usable data
within the region or -ENOBUFS if there is no caching on this file.</p>
</li>
</ul>
</div></blockquote>
<p>Note that these methods are passed a pointer to the cache resource structure,
not the read request structure as they could be used in other situations where
there isn’t a read request structure as well, such as writing dirty data to the
cache.</p>
</section>
</section>
<section id="api-function-reference">
<h2>API Function Reference<a class="headerlink" href="#api-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.folio_start_fscache">
void <code class="sig-name descname">folio_start_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_start_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an fscache write on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function before writing a folio to a local cache.  Starting a
second write before the first one finishes is not allowed.</p>
</div>
<dl class="function">
<dt id="c.folio_end_fscache">
void <code class="sig-name descname">folio_end_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>End an fscache write on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function after the folio has been written to the local cache.
This will wake any sleepers waiting on this folio.</p>
</div>
<dl class="function">
<dt id="c.folio_wait_fscache">
void <code class="sig-name descname">folio_wait_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait for
the write to finish.  Another write may start after this one finishes,
unless the caller holds the folio lock.</p>
</div>
<dl class="function">
<dt id="c.folio_wait_fscache_killable">
int <code class="sig-name descname">folio_wait_fscache_killable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait
for the write to finish or for a fatal signal to be received.
Another write may start after this one finishes, unless the caller
holds the folio lock.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0 if successful.</p></li>
<li><p>-EINTR if a fatal signal was encountered.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.netfs_inode">
struct <a class="reference internal" href="#c.netfs_inode" title="netfs_inode">netfs_inode</a> * <code class="sig-name descname">netfs_inode</code><span class="sig-paren">(</span>struct inode<em> *inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the netfs inode context from the inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the netfs lib inode context from the network filesystem’s inode.  The
context struct is expected to directly follow on from the VFS inode struct.</p>
</div>
<dl class="function">
<dt id="c.netfs_inode_init">
void <code class="sig-name descname">netfs_inode_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.netfs_inode" title="netfs_inode">netfs_inode</a><em> *ctx</em>, const struct netfs_request_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_inode_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a netfslib inode context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">netfs_request_ops</span> <span class="pre">*ops</span></code></dt><dd><p>The netfs’s operations list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise the netfs library context struct.  This is expected to follow on
directly from the VFS inode struct.</p>
</div>
<dl class="function">
<dt id="c.netfs_resize_file">
void <code class="sig-name descname">netfs_resize_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.netfs_inode" title="netfs_inode">netfs_inode</a><em> *ctx</em>, loff_t<em> new_i_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_resize_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that a file got resized</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode being resized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_i_size</span></code></dt><dd><p>The new file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the netfs lib that a file got resized so that it can adjust its state.</p>
</div>
<dl class="function">
<dt id="c.netfs_i_cookie">
struct fscache_cookie * <code class="sig-name descname">netfs_i_cookie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.netfs_inode" title="netfs_inode">netfs_inode</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_i_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cache cookie from the inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the caching cookie (if enabled) from the network filesystem’s inode.</p>
</div>
<dl class="function">
<dt id="c.netfs_readahead">
void <code class="sig-name descname">netfs_readahead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.readahead_control" title="readahead_control">readahead_control</a><em> *ractl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to manage a read request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The description of the readahead request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a readahead request by drawing data from the cache if possible, or
the netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O
requests from different sources will get munged together.  If necessary, the
readahead window can be expanded in either direction to a more convenient
alighment for RPC efficiency or to make storage in the cache feasible.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
</div>
<dl class="function">
<dt id="c.netfs_read_folio">
int <code class="sig-name descname">netfs_read_folio</code><span class="sig-paren">(</span>struct file<em> *file</em>, struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> *folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_read_folio" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to manage a read_folio request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>The file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a read_folio request by drawing data from the cache if
possible, or the netfs if not.  Space beyond the EOF is zero-filled.
Multiple I/O requests from different sources will get munged together.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
</div>
<dl class="function">
<dt id="c.netfs_write_begin">
int <code class="sig-name descname">netfs_write_begin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.netfs_inode" title="netfs_inode">netfs_inode</a><em> *ctx</em>, struct file<em> *file</em>, struct <a class="reference internal" href="api-summary.html#c.address_space" title="address_space">address_space</a><em> *mapping</em>, loff_t<em> pos</em>, unsigned int<em> len</em>, struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em> **_folio</em>, void<em> **_fsdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_write_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to prepare for writing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>The file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The mapping to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>File position at which the write will begin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>The length of the write (may extend beyond the end of the folio chosen)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">**_folio</span></code></dt><dd><p>Where to put the resultant folio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**_fsdata</span></code></dt><dd><p>Place for the netfs to store a cookie</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pre-read data for a write-begin request by drawing data from the cache if
possible, or the netfs if not.  Space beyond the EOF is zero-filled.
Multiple I/O requests from different sources will get munged together.  If
necessary, the readahead window can be expanded in either direction to a
more convenient alighment for RPC efficiency or to make storage in the cache
feasible.</p>
<p>The calling netfs must provide a table of operations, only one of which,
issue_op, is mandatory.</p>
<p>The check_write_begin() operation can be provided to check for and flush
conflicting writes once the folio is grabbed and locked.  It is passed a
pointer to the fsdata cookie that gets returned to the VM to be passed to
write_end.  It is permitted to sleep.  It should return 0 if the request
should go ahead or it may return an error.  It may also unlock and put the
folio, provided it sets <code class="docutils literal notranslate"><span class="pre">*foliop</span></code> to NULL, in which case a return of 0
will cause the folio to be re-got and the process to be retried.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
</div>
<dl class="function">
<dt id="c.netfs_subreq_terminated">
void <code class="sig-name descname">netfs_subreq_terminated</code><span class="sig-paren">(</span>struct netfs_io_subrequest<em> *subreq</em>, ssize_t<em> transferred_or_error</em>, bool<em> was_async</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_subreq_terminated" title="Permalink to this definition">¶</a></dt>
<dd><p>Note the termination of an I/O operation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_io_subrequest</span> <span class="pre">*subreq</span></code></dt><dd><p>The I/O request that has terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">transferred_or_error</span></code></dt><dd><p>The amount of data transferred or an error code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">was_async</span></code></dt><dd><p>The termination was asynchronous</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This tells the read helper that a contributory I/O operation has terminated,
one way or another, and that it should integrate the results.</p>
<p>The caller indicates in <strong>transferred_or_error</strong> the outcome of the operation,
supplying a positive value to indicate the number of bytes transferred, 0 to
indicate a failure to transfer anything that should be retried or a negative
error code.  The helper will look after reissuing I/O operations as
appropriate and writing downloaded data to the cache.</p>
<p>If <strong>was_async</strong> is true, the caller might be running in softirq or interrupt
context and we can’t sleep.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Network Filesystem Helper Library</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#per-inode-context">Per-Inode Context</a><ul>
<li><a class="reference internal" href="#inode-context-helper-functions">Inode Context Helper Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffered-read-helpers">Buffered Read Helpers</a><ul>
<li><a class="reference internal" href="#read-helper-functions">Read Helper Functions</a></li>
<li><a class="reference internal" href="#read-helper-structures">Read Helper Structures</a></li>
<li><a class="reference internal" href="#read-helper-operations">Read Helper Operations</a></li>
<li><a class="reference internal" href="#read-helper-procedure">Read Helper Procedure</a></li>
<li><a class="reference internal" href="#read-helper-cache-api">Read Helper Cache API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-function-reference">API Function Reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/netfs_library.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/netfs_library.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>