
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Filesystem Mount API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quota subsystem" href="quota.html" />
    <link rel="prev" title="File Locking Release Notes" href="locks.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="filesystem-mount-api">
<h1>Filesystem Mount API<a class="headerlink" href="#filesystem-mount-api" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The creation of new mounts is now to be done in a multistep process:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Create a filesystem context.</p></li>
<li><p>Parse the parameters and attach them to the context.  Parameters are
expected to be passed individually from userspace, though legacy binary
parameters can also be handled.</p></li>
<li><p>Validate and pre-process the context.</p></li>
<li><p>Get or create a superblock and mountable root.</p></li>
<li><p>Perform the mount.</p></li>
<li><p>Return an error message attached to the context.</p></li>
<li><p>Destroy the context.</p></li>
</ol>
</div></blockquote>
<p>To support this, the file_system_type struct gains two new fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*init_fs_context)(struct fs_context *fc);
const struct fs_parameter_description *parameters;
</pre></div>
</div>
<p>The first is invoked to set up the filesystem-specific parts of a filesystem
context, including the additional space, and the second points to the
parameter description for validation at registration time and querying by a
future system call.</p>
<p>Note that security initialisation is done <em>after</em> the filesystem is called so
that the namespaces may be adjusted first.</p>
</section>
<section id="the-filesystem-context">
<h2>The Filesystem context<a class="headerlink" href="#the-filesystem-context" title="Permalink to this headline">¶</a></h2>
<p>The creation and reconfiguration of a superblock is governed by a filesystem
context.  This is represented by the fs_context structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context {
        const struct fs_context_operations *ops;
        struct file_system_type *fs_type;
        void                    *fs_private;
        struct dentry           *root;
        struct user_namespace   *user_ns;
        struct net              *net_ns;
        const struct cred       *cred;
        char                    *source;
        char                    *subtype;
        void                    *security;
        void                    *s_fs_info;
        unsigned int            sb_flags;
        unsigned int            sb_flags_mask;
        unsigned int            s_iflags;
        unsigned int            lsm_flags;
        enum fs_context_purpose purpose:8;
        ...
};
</pre></div>
</div>
<p>The fs_context fields are as follows:</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const struct fs_context_operations *ops
</pre></div>
</div>
<p>These are operations that can be done on a filesystem context (see
below).  This must be set by the -&gt;init_fs_context() file_system_type
operation.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct file_system_type *fs_type
</pre></div>
</div>
<p>A pointer to the file_system_type of the filesystem that is being
constructed or reconfigured.  This retains a reference on the type owner.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *fs_private
</pre></div>
</div>
<p>A pointer to the file system’s private data.  This is where the filesystem
will need to store any options it parses.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dentry *root
</pre></div>
</div>
<p>A pointer to the root of the mountable tree (and indirectly, the
superblock thereof).  This is filled in by the -&gt;get_tree() op.  If this
is set, an active reference on root-&gt;d_sb must also be held.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct user_namespace *user_ns
struct net *net_ns
</pre></div>
</div>
<p>There are a subset of the namespaces in use by the invoking process.  They
retain references on each namespace.  The subscribed namespaces may be
replaced by the filesystem to reflect other sources, such as the parent
mount superblock on an automount.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const struct cred *cred
</pre></div>
</div>
<p>The mounter’s credentials.  This retains a reference on the credentials.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char *source
</pre></div>
</div>
<p>This specifies the source.  It may be a block device (e.g. /dev/sda1) or
something more exotic, such as the “host:/path” that NFS desires.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char *subtype
</pre></div>
</div>
<p>This is a string to be added to the type displayed in /proc/mounts to
qualify it (used by FUSE).  This is available for the filesystem to set if
desired.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *security
</pre></div>
</div>
<p>A place for the LSMs to hang their security data for the superblock.  The
relevant security operations are described below.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *s_fs_info
</pre></div>
</div>
<p>The proposed s_fs_info for a new superblock, set in the superblock by
<a class="reference internal" href="api-summary.html#c.sget_fc" title="sget_fc"><code class="xref c c-func docutils literal notranslate"><span class="pre">sget_fc()</span></code></a>.  This can be used to distinguish superblocks.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int sb_flags
unsigned int sb_flags_mask
</pre></div>
</div>
<p>Which bits SB_* flags are to be set/cleared in super_block::s_flags.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int s_iflags
</pre></div>
</div>
<p>These will be bitwise-OR’d with s-&gt;s_iflags when a superblock is created.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum fs_context_purpose
</pre></div>
</div>
<p>This indicates the purpose for which the context is intended.  The
available values are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>FS_CONTEXT_FOR_MOUNT,</p></td>
<td><p>New superblock for explicit mount</p></td>
</tr>
<tr class="row-even"><td><p>FS_CONTEXT_FOR_SUBMOUNT</p></td>
<td><p>New automatic submount of extant mount</p></td>
</tr>
<tr class="row-odd"><td><p>FS_CONTEXT_FOR_RECONFIGURE</p></td>
<td><p>Change an existing mount</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>The mount context is created by calling vfs_new_fs_context() or
vfs_dup_fs_context() and is destroyed with put_fs_context().  Note that the
structure is not refcounted.</p>
<p>VFS, security and filesystem mount options are set individually with
vfs_parse_mount_option().  Options provided by the old mount(2) system call as
a page of data can be parsed with generic_parse_monolithic().</p>
<p>When mounting, the filesystem is allowed to take data from any of the pointers
and attach it to the superblock (or whatever), provided it clears the pointer
in the mount context.</p>
<p>The filesystem is also allowed to allocate resources and pin them with the
mount context.  For instance, NFS might pin the appropriate protocol version
module.</p>
</section>
<section id="the-filesystem-context-operations">
<h2>The Filesystem Context Operations<a class="headerlink" href="#the-filesystem-context-operations" title="Permalink to this headline">¶</a></h2>
<p>The filesystem context points to a table of operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context_operations {
        void (*free)(struct fs_context *fc);
        int (*dup)(struct fs_context *fc, struct fs_context *src_fc);
        int (*parse_param)(struct fs_context *fc,
                           struct fs_parameter *param);
        int (*parse_monolithic)(struct fs_context *fc, void *data);
        int (*get_tree)(struct fs_context *fc);
        int (*reconfigure)(struct fs_context *fc);
};
</pre></div>
</div>
<p>These operations are invoked by the various stages of the mount procedure to
manage the filesystem context.  They are as follows:</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*free)(struct fs_context *fc);
</pre></div>
</div>
<p>Called to clean up the filesystem-specific part of the filesystem context
when the context is destroyed.  It should be aware that parts of the
context may have been removed and NULL’d out by -&gt;get_tree().</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*dup)(struct fs_context *fc, struct fs_context *src_fc);
</pre></div>
</div>
<p>Called when a filesystem context has been duplicated to duplicate the
filesystem-private data.  An error may be returned to indicate failure to
do this.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that even if this fails, put_fs_context() will be called
immediately thereafter, so -&gt;dup() <em>must</em> make the
filesystem-private data safe for -&gt;free().</p>
</div>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*parse_param)(struct fs_context *fc,
                   struct fs_parameter *param);
</pre></div>
</div>
<p>Called when a parameter is being added to the filesystem context.  param
points to the key name and maybe a value object.  VFS-specific options
will have been weeded out and fc-&gt;sb_flags updated in the context.
Security options will also have been weeded out and fc-&gt;security updated.</p>
<p>The parameter can be parsed with fs_parse() and fs_lookup_param().  Note
that the source(s) are presented as parameters named “source”.</p>
<p>If successful, 0 should be returned or a negative error code otherwise.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*parse_monolithic)(struct fs_context *fc, void *data);
</pre></div>
</div>
<p>Called when the mount(2) system call is invoked to pass the entire data
page in one go.  If this is expected to be just a list of “key[=val]”
items separated by commas, then this may be set to NULL.</p>
<p>The return value is as for -&gt;parse_param().</p>
<p>If the filesystem (e.g. NFS) needs to examine the data first and then
finds it’s the standard key-val list then it may pass it off to
generic_parse_monolithic().</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*get_tree)(struct fs_context *fc);
</pre></div>
</div>
<p>Called to get or create the mountable root and superblock, using the
information stored in the filesystem context (reconfiguration goes via a
different vector).  It may detach any resources it desires from the
filesystem context and transfer them to the superblock it creates.</p>
<p>On success it should set fc-&gt;root to the mountable root and return 0.  In
the case of an error, it should return a negative error code.</p>
<p>The phase on a userspace-driven context will be set to only allow this to
be called once on any particular context.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*reconfigure)(struct fs_context *fc);
</pre></div>
</div>
<p>Called to effect reconfiguration of a superblock using information stored
in the filesystem context.  It may detach any resources it desires from
the filesystem context and transfer them to the superblock.  The
superblock can be found from fc-&gt;root-&gt;d_sb.</p>
<p>On success it should return 0.  In the case of an error, it should return
a negative error code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>reconfigure is intended as a replacement for remount_fs.</p>
</div>
</li>
</ul>
</div></blockquote>
</section>
<section id="filesystem-context-security">
<h2>Filesystem context Security<a class="headerlink" href="#filesystem-context-security" title="Permalink to this headline">¶</a></h2>
<p>The filesystem context contains a security pointer that the LSMs can use for
building up a security context for the superblock to be mounted.  There are a
number of operations used by the new mount code for this purpose:</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_fs_context_alloc(struct fs_context *fc,
                              struct dentry *reference);
</pre></div>
</div>
<p>Called to initialise fc-&gt;security (which is preset to NULL) and allocate
any resources needed.  It should return 0 on success or a negative error
code on failure.</p>
<p>reference will be non-NULL if the context is being created for superblock
reconfiguration (FS_CONTEXT_FOR_RECONFIGURE) in which case it indicates
the root dentry of the superblock to be reconfigured.  It will also be
non-NULL in the case of a submount (FS_CONTEXT_FOR_SUBMOUNT) in which case
it indicates the automount point.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_fs_context_dup(struct fs_context *fc,
                            struct fs_context *src_fc);
</pre></div>
</div>
<p>Called to initialise fc-&gt;security (which is preset to NULL) and allocate
any resources needed.  The original filesystem context is pointed to by
src_fc and may be used for reference.  It should return 0 on success or a
negative error code on failure.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void security_fs_context_free(struct fs_context *fc);
</pre></div>
</div>
<p>Called to clean up anything attached to fc-&gt;security.  Note that the
contents may have been transferred to a superblock and the pointer cleared
during get_tree.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_fs_context_parse_param(struct fs_context *fc,
                                    struct fs_parameter *param);
</pre></div>
</div>
<p>Called for each mount parameter, including the source.  The arguments are
as for the -&gt;parse_param() method.  It should return 0 to indicate that
the parameter should be passed on to the filesystem, 1 to indicate that
the parameter should be discarded or an error to indicate that the
parameter should be rejected.</p>
<p>The value pointed to by param may be modified (if a string) or stolen
(provided the value pointer is NULL’d out).  If it is stolen, 1 must be
returned to prevent it being passed to the filesystem.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_fs_context_validate(struct fs_context *fc);
</pre></div>
</div>
<p>Called after all the options have been parsed to validate the collection
as a whole and to do any necessary allocation so that
security_sb_get_tree() and security_sb_reconfigure() are less likely to
fail.  It should return 0 or a negative error code.</p>
<p>In the case of reconfiguration, the target superblock will be accessible
via fc-&gt;root.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_sb_get_tree(struct fs_context *fc);
</pre></div>
</div>
<p>Called during the mount procedure to verify that the specified superblock
is allowed to be mounted and to transfer the security data there.  It
should return 0 or a negative error code.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void security_sb_reconfigure(struct fs_context *fc);
</pre></div>
</div>
<p>Called to apply any reconfiguration to an LSM’s context.  It must not
fail.  Error checking and resource allocation must be done in advance by
the parameter parsing and validation hooks.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int security_sb_mountpoint(struct fs_context *fc,
                           struct path *mountpoint,
                           unsigned int mnt_flags);
</pre></div>
</div>
<p>Called during the mount procedure to verify that the root dentry attached
to the context is permitted to be attached to the specified mountpoint.
It should return 0 on success or a negative error code on failure.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="vfs-filesystem-context-api">
<h2>VFS Filesystem context API<a class="headerlink" href="#vfs-filesystem-context-api" title="Permalink to this headline">¶</a></h2>
<p>There are four operations for creating a filesystem context and one for
destroying a context:</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context *fs_context_for_mount(struct file_system_type *fs_type,
                                        unsigned int sb_flags);
</pre></div>
</div>
<p>Allocate a filesystem context for the purpose of setting up a new mount,
whether that be with a new superblock or sharing an existing one.  This
sets the superblock flags, initialises the security and calls
fs_type-&gt;init_fs_context() to initialise the filesystem private data.</p>
<p>fs_type specifies the filesystem type that will manage the context and
sb_flags presets the superblock flags stored therein.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context *fs_context_for_reconfigure(
         struct dentry *dentry,
         unsigned int sb_flags,
         unsigned int sb_flags_mask);
</pre></div>
</div>
<p>Allocate a filesystem context for the purpose of reconfiguring an
existing superblock.  dentry provides a reference to the superblock to be
configured.  sb_flags and sb_flags_mask indicate which superblock flags
need changing and to what.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context *fs_context_for_submount(
         struct file_system_type *fs_type,
         struct dentry *reference);
</pre></div>
</div>
<p>Allocate a filesystem context for the purpose of creating a new mount for
an automount point or other derived superblock.  fs_type specifies the
filesystem type that will manage the context and the reference dentry
supplies the parameters.  Namespaces are propagated from the reference
dentry’s superblock also.</p>
<p>Note that it’s not a requirement that the reference dentry be of the same
filesystem type as fs_type.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_context *vfs_dup_fs_context(struct fs_context *src_fc);
</pre></div>
</div>
<p>Duplicate a filesystem context, copying any options noted and duplicating
or additionally referencing any resources held therein.  This is available
for use where a filesystem has to get a mount within a mount, such as NFS4
does by internally mounting the root of the target server and then doing a
private pathwalk to the target directory.</p>
<p>The purpose in the new context is inherited from the old one.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void put_fs_context(struct fs_context *fc);
</pre></div>
</div>
<p>Destroy a filesystem context, releasing any resources it holds.  This
calls the -&gt;free() operation.  This is intended to be called by anyone who
created a filesystem context.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>filesystem contexts are not refcounted, so this causes unconditional
destruction.</p>
</div>
</li>
</ul>
</div></blockquote>
<p>In all the above operations, apart from the put op, the return is a mount
context pointer or a negative error code.</p>
<p>For the remaining operations, if an error occurs, a negative error code will be
returned.</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int vfs_parse_fs_param(struct fs_context *fc,
                       struct fs_parameter *param);
</pre></div>
</div>
<p>Supply a single mount parameter to the filesystem context.  This includes
the specification of the source/device which is specified as the “source”
parameter (which may be specified multiple times if the filesystem
supports that).</p>
<p>param specifies the parameter key name and the value.  The parameter is
first checked to see if it corresponds to a standard mount flag (in which
case it is used to set an SB_xxx flag and consumed) or a security option
(in which case the LSM consumes it) before it is passed on to the
filesystem.</p>
<p>The parameter value is typed and can be one of:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>fs_value_is_flag</p></td>
<td><p>Parameter not given a value</p></td>
</tr>
<tr class="row-even"><td><p>fs_value_is_string</p></td>
<td><p>Value is a string</p></td>
</tr>
<tr class="row-odd"><td><p>fs_value_is_blob</p></td>
<td><p>Value is a binary blob</p></td>
</tr>
<tr class="row-even"><td><p>fs_value_is_filename</p></td>
<td><p>Value is a filename* + dirfd</p></td>
</tr>
<tr class="row-odd"><td><p>fs_value_is_file</p></td>
<td><p>Value is an open file (file*)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If there is a value, that value is stored in a union in the struct in one
of param-&gt;{string,blob,name,file}.  Note that the function may steal and
clear the pointer, but then becomes responsible for disposing of the
object.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int vfs_parse_fs_string(struct fs_context *fc, const char *key,
                        const char *value, size_t v_size);
</pre></div>
</div>
<p>A wrapper around vfs_parse_fs_param() that copies the value string it is
passed.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int generic_parse_monolithic(struct fs_context *fc, void *data);
</pre></div>
</div>
<p>Parse a sys_mount() data page, assuming the form to be a text list
consisting of key[=val] options separated by commas.  Each item in the
list is passed to vfs_mount_option().  This is the default when the
-&gt;parse_monolithic() method is NULL.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int vfs_get_tree(struct fs_context *fc);
</pre></div>
</div>
<p>Get or create the mountable root and superblock, using the parameters in
the filesystem context to select/configure the superblock.  This invokes
the -&gt;get_tree() method.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vfsmount *vfs_create_mount(struct fs_context *fc);
</pre></div>
</div>
<p>Create a mount given the parameters in the specified filesystem context.
Note that this does not attach the mount to anything.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="superblock-creation-helpers">
<h2>Superblock Creation Helpers<a class="headerlink" href="#superblock-creation-helpers" title="Permalink to this headline">¶</a></h2>
<p>A number of VFS helpers are available for use by filesystems for the creation
or looking up of superblocks.</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct super_block *
sget_fc(struct fs_context *fc,
        int (*test)(struct super_block *sb, struct fs_context *fc),
        int (*set)(struct super_block *sb, struct fs_context *fc));
</pre></div>
</div>
<p>This is the core routine.  If test is non-NULL, it searches for an
existing superblock matching the criteria held in the fs_context, using
the test function to match them.  If no match is found, a new superblock
is created and the set function is called to set it up.</p>
<p>Prior to the set function being called, fc-&gt;s_fs_info will be transferred
to sb-&gt;s_fs_info - and fc-&gt;s_fs_info will be cleared if set returns
success (ie. 0).</p>
</li>
</ul>
</div></blockquote>
<p>The following helpers all wrap <a class="reference internal" href="api-summary.html#c.sget_fc" title="sget_fc"><code class="xref c c-func docutils literal notranslate"><span class="pre">sget_fc()</span></code></a>:</p>
<blockquote>
<div><ol class="arabic">
<li><p>vfs_get_single_super</p>
<p>Only one such superblock may exist in the system.  Any further
attempt to get a new superblock gets this one (and any parameter
differences are ignored).</p>
</li>
<li><p>vfs_get_keyed_super</p>
<p>Multiple superblocks of this type may exist and they’re keyed on
their s_fs_info pointer (for example this may refer to a
namespace).</p>
</li>
<li><p>vfs_get_independent_super</p>
<p>Multiple independent superblocks of this type may exist.  This
function never matches an existing one and always creates a new
one.</p>
</li>
</ol>
</div></blockquote>
</section>
<section id="parameter-description">
<h2>Parameter Description<a class="headerlink" href="#parameter-description" title="Permalink to this headline">¶</a></h2>
<p>Parameters are described using structures defined in linux/fs_parser.h.
There’s a core description struct that links everything together:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_parameter_description {
        const struct fs_parameter_spec *specs;
        const struct fs_parameter_enum *enums;
};
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum {
        Opt_autocell,
        Opt_bar,
        Opt_dyn,
        Opt_foo,
        Opt_source,
};

static const struct fs_parameter_description afs_fs_parameters = {
        .specs          = afs_param_specs,
        .enums          = afs_param_enums,
};
</pre></div>
</div>
<p>The members are as follows:</p>
<blockquote>
<div><ol class="arabic">
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const struct fs_parameter_specification *specs;
</pre></div>
</div>
<p>Table of parameter specifications, terminated with a null entry, where the
entries are of type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_parameter_spec {
        const char              *name;
        u8                      opt;
        enum fs_parameter_type  type:8;
        unsigned short          flags;
};
</pre></div>
</div>
<p>The ‘name’ field is a string to match exactly to the parameter key (no
wildcards, patterns and no case-independence) and ‘opt’ is the value that
will be returned by the fs_parser() function in the case of a successful
match.</p>
<p>The ‘type’ field indicates the desired value type and must be one of:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>TYPE NAME</p></th>
<th class="head"><p>EXPECTED VALUE</p></th>
<th class="head"><p>RESULT IN</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>fs_param_is_flag</p></td>
<td><p>No value</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_bool</p></td>
<td><p>Boolean value</p></td>
<td><p>result-&gt;boolean</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_is_u32</p></td>
<td><p>32-bit unsigned int</p></td>
<td><p>result-&gt;uint_32</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_u32_octal</p></td>
<td><p>32-bit octal int</p></td>
<td><p>result-&gt;uint_32</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_is_u32_hex</p></td>
<td><p>32-bit hex int</p></td>
<td><p>result-&gt;uint_32</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_s32</p></td>
<td><p>32-bit signed int</p></td>
<td><p>result-&gt;int_32</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_is_u64</p></td>
<td><p>64-bit unsigned int</p></td>
<td><p>result-&gt;uint_64</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_enum</p></td>
<td><p>Enum value name</p></td>
<td><p>result-&gt;uint_32</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_is_string</p></td>
<td><p>Arbitrary string</p></td>
<td><p>param-&gt;string</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_blob</p></td>
<td><p>Binary blob</p></td>
<td><p>param-&gt;blob</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_is_blockdev</p></td>
<td><p>Blockdev path</p></td>
<td><ul class="simple">
<li><p>Needs lookup</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>fs_param_is_path</p></td>
<td><p>Path</p></td>
<td><ul class="simple">
<li><p>Needs lookup</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>fs_param_is_fd</p></td>
<td><p>File descriptor</p></td>
<td><p>result-&gt;int_32</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Note that if the value is of fs_param_is_bool type, fs_parse() will try
to match any string value against “0”, “1”, “no”, “yes”, “false”, “true”.</p>
<p>Each parameter can also be qualified with ‘flags’:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>fs_param_v_optional</p></td>
<td><p>The value is optional</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_neg_with_no</p></td>
<td><p>result-&gt;negated set if key is prefixed with “no”</p></td>
</tr>
<tr class="row-odd"><td><p>fs_param_neg_with_empty</p></td>
<td><p>result-&gt;negated set if value is “”</p></td>
</tr>
<tr class="row-even"><td><p>fs_param_deprecated</p></td>
<td><p>The parameter is deprecated.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>These are wrapped with a number of convenience wrappers:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>MACRO</p></th>
<th class="head"><p>SPECIFIES</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>fsparam_flag()</p></td>
<td><p>fs_param_is_flag</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_flag_no()</p></td>
<td><p>fs_param_is_flag, fs_param_neg_with_no</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_bool()</p></td>
<td><p>fs_param_is_bool</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_u32()</p></td>
<td><p>fs_param_is_u32</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_u32oct()</p></td>
<td><p>fs_param_is_u32_octal</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_u32hex()</p></td>
<td><p>fs_param_is_u32_hex</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_s32()</p></td>
<td><p>fs_param_is_s32</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_u64()</p></td>
<td><p>fs_param_is_u64</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_enum()</p></td>
<td><p>fs_param_is_enum</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_string()</p></td>
<td><p>fs_param_is_string</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_blob()</p></td>
<td><p>fs_param_is_blob</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_bdev()</p></td>
<td><p>fs_param_is_blockdev</p></td>
</tr>
<tr class="row-even"><td><p>fsparam_path()</p></td>
<td><p>fs_param_is_path</p></td>
</tr>
<tr class="row-odd"><td><p>fsparam_fd()</p></td>
<td><p>fs_param_is_fd</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>all of which take two arguments, name string and option number - for
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct fs_parameter_spec afs_param_specs[] = {
        fsparam_flag    (&quot;autocell&quot;,    Opt_autocell),
        fsparam_flag    (&quot;dyn&quot;,         Opt_dyn),
        fsparam_string  (&quot;source&quot;,      Opt_source),
        fsparam_flag_no (&quot;foo&quot;,         Opt_foo),
        {}
};
</pre></div>
</div>
<p>An addition macro, __fsparam() is provided that takes an additional pair
of arguments to specify the type and the flags for anything that doesn’t
match one of the above macros.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const struct fs_parameter_enum *enums;
</pre></div>
</div>
<p>Table of enum value names to integer mappings, terminated with a null
entry.  This is of type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fs_parameter_enum {
        u8              opt;
        char            name[14];
        u8              value;
};
</pre></div>
</div>
<p>Where the array is an unsorted list of { parameter ID, name }-keyed
elements that indicate the value to map to, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct fs_parameter_enum afs_param_enums[] = {
        { Opt_bar,   &quot;x&quot;,      1},
        { Opt_bar,   &quot;y&quot;,      23},
        { Opt_bar,   &quot;z&quot;,      42},
};
</pre></div>
</div>
<p>If a parameter of type fs_param_is_enum is encountered, fs_parse() will
try to look the value up in the enum table and the result will be stored
in the parse result.</p>
</li>
</ol>
</div></blockquote>
<p>The parser should be pointed to by the parser pointer in the file_system_type
struct as this will provide validation on registration (if
CONFIG_VALIDATE_FS_PARSER=y) and will allow the description to be queried from
userspace using the fsinfo() syscall.</p>
</section>
<section id="parameter-helper-functions">
<h2>Parameter Helper Functions<a class="headerlink" href="#parameter-helper-functions" title="Permalink to this headline">¶</a></h2>
<p>A number of helper functions are provided to help a filesystem or an LSM
process the parameters it is given.</p>
<blockquote>
<div><ul>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lookup_constant(const struct constant_table tbl[],
                    const char *name, int not_found);
</pre></div>
</div>
<p>Look up a constant by name in a table of name -&gt; integer mappings.  The
table is an array of elements of the following type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct constant_table {
        const char      *name;
        int             value;
};
</pre></div>
</div>
<p>If a match is found, the corresponding value is returned.  If a match
isn’t found, the not_found value is returned instead.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool validate_constant_table(const struct constant_table *tbl,
                             size_t tbl_size,
                             int low, int high, int special);
</pre></div>
</div>
<p>Validate a constant table.  Checks that all the elements are appropriately
ordered, that there are no duplicates and that the values are between low
and high inclusive, though provision is made for one allowable special
value outside of that range.  If no special value is required, special
should just be set to lie inside the low-to-high range.</p>
<p>If all is good, true is returned.  If the table is invalid, errors are
logged to the kernel log buffer and false is returned.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool fs_validate_description(const struct fs_parameter_description *desc);
</pre></div>
</div>
<p>This performs some validation checks on a parameter description.  It
returns true if the description is good and false if it is not.  It will
log errors to the kernel log buffer if validation fails.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fs_parse(struct fs_context *fc,
             const struct fs_parameter_description *desc,
             struct fs_parameter *param,
             struct fs_parse_result *result);
</pre></div>
</div>
<p>This is the main interpreter of parameters.  It uses the parameter
description to look up a parameter by key name and to convert that to an
option number (which it returns).</p>
<p>If successful, and if the parameter type indicates the result is a
boolean, integer or enum type, the value is converted by this function and
the result stored in result-&gt;{boolean,int_32,uint_32,uint_64}.</p>
<p>If a match isn’t initially made, the key is prefixed with “no” and no
value is present then an attempt will be made to look up the key with the
prefix removed.  If this matches a parameter for which the type has flag
fs_param_neg_with_no set, then a match will be made and result-&gt;negated
will be set to true.</p>
<p>If the parameter isn’t matched, -ENOPARAM will be returned; if the
parameter is matched, but the value is erroneous, -EINVAL will be
returned; otherwise the parameter’s option number will be returned.</p>
</li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fs_lookup_param(struct fs_context *fc,
                    struct fs_parameter *value,
                    bool want_bdev,
                    unsigned int flags,
                    struct path *_path);
</pre></div>
</div>
<p>This takes a parameter that carries a string or filename type and attempts
to do a path lookup on it.  If the parameter expects a blockdev, a check
is made that the inode actually represents one.</p>
<p>Returns 0 if successful and <code class="docutils literal notranslate"><span class="pre">*_path</span></code> will be set; returns a negative
error code if not.</p>
</li>
</ul>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Filesystem Mount API</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-filesystem-context">The Filesystem context</a></li>
<li><a class="reference internal" href="#the-filesystem-context-operations">The Filesystem Context Operations</a></li>
<li><a class="reference internal" href="#filesystem-context-security">Filesystem context Security</a></li>
<li><a class="reference internal" href="#vfs-filesystem-context-api">VFS Filesystem context API</a></li>
<li><a class="reference internal" href="#superblock-creation-helpers">Superblock Creation Helpers</a></li>
<li><a class="reference internal" href="#parameter-description">Parameter Description</a></li>
<li><a class="reference internal" href="#parameter-helper-functions">Parameter Helper Functions</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/mount_api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/mount_api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>