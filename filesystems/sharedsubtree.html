
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Shared Subtrees &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Idmappings" href="idmappings.html" />
    <link rel="prev" title="The seq_file Interface" href="seq_file.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="shared-subtrees">
<h1>Shared Subtrees<a class="headerlink" href="#shared-subtrees" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>1) Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Consider the following situation:</p>
<p>A process wants to clone its own namespace, but still wants to access the CD
that got mounted recently.  Shared subtree semantics provide the necessary
mechanism to accomplish the above.</p>
<p>It provides the necessary building blocks for features like per-user-namespace
and versioned filesystem.</p>
</section>
<section id="features">
<h2>2) Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>Shared subtree provides four different flavors of mounts; struct vfsmount to be
precise</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>shared mount</p></li>
<li><p>slave mount</p></li>
<li><p>private mount</p></li>
<li><p>unbindable mount</p></li>
</ol>
</div></blockquote>
<p>2a) A shared mount can be replicated to as many mountpoints and all the
replicas continue to be exactly same.</p>
<blockquote>
<div><p>Here is an example:</p>
<p>Let’s say /mnt has a mount that is shared:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared /mnt
</pre></div>
</div>
<p>Note: mount(8) command now supports the –make-shared flag,
so the sample ‘smount’ program is no longer needed and has been
removed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount --bind /mnt /tmp
</pre></div>
</div>
<p>The above command replicates the mount at /mnt to the mountpoint /tmp
and the contents of both the mounts remain identical.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ls /mnt
a b c

#ls /tmp
a b c
</pre></div>
</div>
<p>Now let’s say we mount a device at /tmp/a:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount /dev/sd0  /tmp/a

#ls /tmp/a
t1 t2 t3

#ls /mnt/a
t1 t2 t3
</pre></div>
</div>
<p>Note that the mount has propagated to the mount at /mnt as well.</p>
<p>And the same is true even when /dev/sd0 is mounted on /mnt/a. The
contents will be visible under /tmp/a too.</p>
</div></blockquote>
<dl>
<dt>2b) A slave mount is like a shared mount except that mount and umount events</dt><dd><p>only propagate towards it.</p>
<p>All slave mounts have a master mount which is a shared.</p>
<p>Here is an example:</p>
<p>Let’s say /mnt has a mount which is shared.
# mount –make-shared /mnt</p>
<p>Let’s bind mount /mnt to /tmp
# mount –bind /mnt /tmp</p>
<p>the new mount at /tmp becomes a shared mount and it is a replica of
the mount at /mnt.</p>
<p>Now let’s make the mount at /tmp; a slave of /mnt
# mount –make-slave /tmp</p>
<p>let’s mount /dev/sd0 on /mnt/a
# mount /dev/sd0 /mnt/a</p>
<p>#ls /mnt/a
t1 t2 t3</p>
<p>#ls /tmp/a
t1 t2 t3</p>
<p>Note the mount event has propagated to the mount at /tmp</p>
<p>However let’s see what happens if we mount something on the mount at /tmp</p>
<p># mount /dev/sd1 /tmp/b</p>
<p>#ls /tmp/b
s1 s2 s3</p>
<p>#ls /mnt/b</p>
<p>Note how the mount event has not propagated to the mount at
/mnt</p>
</dd>
</dl>
<p>2c) A private mount does not forward or receive propagation.</p>
<blockquote>
<div><p>This is the mount we are familiar with. Its the default type.</p>
</div></blockquote>
<p>2d) A unbindable mount is a unbindable private mount</p>
<blockquote>
<div><p>let’s say we have a mount at /mnt and we make it unbindable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   # mount --make-unbindable /mnt

Let&#39;s try to bind mount this mount somewhere else::

   # mount --bind /mnt /tmp
   mount: wrong fs type, bad option, bad superblock on /mnt,
           or too many mounted file systems
</pre></div>
</div>
<p>Binding a unbindable mount is a invalid operation.</p>
</div></blockquote>
<ol class="arabic" start="3">
<li><p>Setting mount states</p>
<blockquote>
<div><p>The mount command (util-linux package) can be used to set mount
states:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared mountpoint
mount --make-slave mountpoint
mount --make-private mountpoint
mount --make-unbindable mountpoint
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</section>
<section id="use-cases">
<h2>4) Use cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="upperalpha">
<li><p>A process wants to clone its own namespace, but still wants to
access the CD that got mounted recently.</p>
<p>Solution:</p>
<blockquote>
<div><p>The system administrator can make the mount at /cdrom shared:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --bind /cdrom /cdrom
mount --make-shared /cdrom
</pre></div>
</div>
<p>Now any process that clones off a new namespace will have a
mount at /cdrom which is a replica of the same mount in the
parent namespace.</p>
<p>So when a CD is inserted and mounted at /cdrom that mount gets
propagated to the other mount at /cdrom in all the other clone
namespaces.</p>
</div></blockquote>
</li>
</ol>
<p>B) A process wants its mounts invisible to any other process, but
still be able to see the other system mounts.</p>
<blockquote>
<div><p>Solution:</p>
<blockquote>
<div><p>To begin with, the administrator can mark the entire mount tree
as shareable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-rshared /
</pre></div>
</div>
<p>A new process can clone off a new namespace. And mark some part
of its namespace as slave:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-rslave /myprivatetree
</pre></div>
</div>
<p>Hence forth any mounts within the /myprivatetree done by the
process will not show up in any other namespace. However mounts
done in the parent namespace under /myprivatetree still shows
up in the process’s namespace.</p>
</div></blockquote>
</div></blockquote>
<p>Apart from the above semantics this feature provides the
building blocks to solve the following problems:</p>
<ol class="upperalpha" start="3">
<li><p>Per-user namespace</p>
<blockquote>
<div><p>The above semantics allows a way to share mounts across
namespaces.  But namespaces are associated with processes. If
namespaces are made first class objects with user API to
associate/disassociate a namespace with userid, then each user
could have his/her own namespace and tailor it to his/her
requirements. This needs to be supported in PAM.</p>
</div></blockquote>
</li>
<li><p>Versioned files</p>
<blockquote>
<div><p>If the entire mount tree is visible at multiple locations, then
an underlying versioning file system can return different
versions of the file depending on the path used to access that
file.</p>
<p>An example is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared /
mount --rbind / /view/v1
mount --rbind / /view/v2
mount --rbind / /view/v3
mount --rbind / /view/v4
</pre></div>
</div>
<p>and if /usr has a versioning filesystem mounted, then that
mount appears at /view/v1/usr, /view/v2/usr, /view/v3/usr and
/view/v4/usr too</p>
<p>A user can request v3 version of the file /usr/fs/namespace.c
by accessing /view/v3/usr/fs/namespace.c . The underlying
versioning filesystem can then decipher that v3 version of the
filesystem is being requested and return the corresponding
inode.</p>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</section>
<section id="detailed-semantics">
<h2>5) Detailed semantics<a class="headerlink" href="#detailed-semantics" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The section below explains the detailed semantics of
bind, rbind, move, mount, umount and clone-namespace operations.</p>
<p>Note: the word ‘vfsmount’ and the noun ‘mount’ have been used
to mean the same thing, throughout this document.</p>
</div></blockquote>
<p>5a) Mount states</p>
<blockquote>
<div><p>A given mount can be in one of the following states</p>
<ol class="arabic simple">
<li><p>shared</p></li>
<li><p>slave</p></li>
<li><p>shared and slave</p></li>
<li><p>private</p></li>
<li><p>unbindable</p></li>
</ol>
<p>A ‘propagation event’ is defined as event generated on a vfsmount
that leads to mount or unmount actions in other vfsmounts.</p>
<p>A ‘peer group’ is defined as a group of vfsmounts that propagate
events to each other.</p>
<ol class="arabic">
<li><p>Shared mounts</p>
<blockquote>
<div><p>A ‘shared mount’ is defined as a vfsmount that belongs to a
‘peer group’.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared /mnt
mount --bind /mnt /tmp
</pre></div>
</div>
<p>The mount at /mnt and that at /tmp are both shared and belong
to the same peer group. Anything mounted or unmounted under
/mnt or /tmp reflect in all the other mounts of its peer
group.</p>
</div></blockquote>
</li>
<li><p>Slave mounts</p>
<blockquote>
<div><p>A ‘slave mount’ is defined as a vfsmount that receives
propagation events and does not forward propagation events.</p>
<p>A slave mount as the name implies has a master mount from which
mount/unmount events are received. Events do not propagate from
the slave mount to the master.  Only a shared mount can be made
a slave by executing the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-slave mount
</pre></div>
</div>
<p>A shared mount that is made as a slave is no more shared unless
modified to become shared.</p>
</div></blockquote>
</li>
<li><p>Shared and Slave</p>
<blockquote>
<div><p>A vfsmount can be both shared as well as slave.  This state
indicates that the mount is a slave of some vfsmount, and
has its own peer group too.  This vfsmount receives propagation
events from its master vfsmount, and also forwards propagation
events to its ‘peer group’ and to its slave vfsmounts.</p>
<p>Strictly speaking, the vfsmount is shared having its own
peer group, and this peer-group is a slave of some other
peer group.</p>
<p>Only a slave vfsmount can be made as ‘shared and slave’ by
either executing the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared mount
</pre></div>
</div>
<p>or by moving the slave vfsmount under a shared vfsmount.</p>
</div></blockquote>
</li>
<li><p>Private mount</p>
<blockquote>
<div><p>A ‘private mount’ is defined as vfsmount that does not
receive or forward any propagation events.</p>
</div></blockquote>
</li>
<li><p>Unbindable mount</p>
<blockquote>
<div><p>A ‘unbindable mount’ is defined as vfsmount that does not
receive or forward any propagation events and cannot
be bind mounted.</p>
</div></blockquote>
</li>
</ol>
<p>State diagram:</p>
<p>The state diagram below explains the state transition of a mount,
in response to various commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-----------------------------------------------------------------------
|             |make-shared |  make-slave  | make-private |make-unbindab|
--------------|------------|--------------|--------------|-------------|
|shared       |shared      |*slave/private|   private    | unbindable  |
|             |            |              |              |             |
|-------------|------------|--------------|--------------|-------------|
|slave        |shared      | **slave      |    private   | unbindable  |
|             |and slave   |              |              |             |
|-------------|------------|--------------|--------------|-------------|
|shared       |shared      | slave        |    private   | unbindable  |
|and slave    |and slave   |              |              |             |
|-------------|------------|--------------|--------------|-------------|
|private      |shared      |  **private   |    private   | unbindable  |
|-------------|------------|--------------|--------------|-------------|
|unbindable   |shared      |**unbindable  |    private   | unbindable  |
------------------------------------------------------------------------

* if the shared mount is the only mount in its peer group, making it
slave, makes it private automatically. Note that there is no master to
which it can be slaved to.

** slaving a non-shared mount has no effect on the mount.
</pre></div>
</div>
<p>Apart from the commands listed below, the ‘move’ operation also changes
the state of a mount depending on type of the destination mount. Its
explained in section 5d.</p>
</div></blockquote>
<p>5b) Bind semantics</p>
<blockquote>
<div><blockquote>
<div><p>Consider the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --bind A/a  B/b
</pre></div>
</div>
<p>where ‘A’ is the source mount, ‘a’ is the dentry in the mount ‘A’, ‘B’
is the destination mount and ‘b’ is the dentry in the destination mount.</p>
<p>The outcome depends on the type of mount of ‘A’ and ‘B’. The table
below contains quick reference:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--------------------------------------------------------------------------
|         BIND MOUNT OPERATION                                           |
|************************************************************************|
|source(A)-&gt;| shared      |       private  |       slave    | unbindable |
| dest(B)  |              |                |                |            |
|   |      |              |                |                |            |
|   v      |              |                |                |            |
|************************************************************************|
|  shared  | shared       |     shared     | shared &amp; slave |  invalid   |
|          |              |                |                |            |
|non-shared| shared       |      private   |      slave     |  invalid   |
**************************************************************************
</pre></div>
</div>
<p>Details:</p>
</div></blockquote>
<ol class="arabic simple">
<li><dl class="simple">
<dt>‘A’ is a shared mount and ‘B’ is a shared mount. A new mount ‘C’</dt><dd><p>which is clone of ‘A’, is created. Its root dentry is ‘a’ . ‘C’ is
mounted on mount ‘B’ at dentry ‘b’. Also new mount ‘C1’, ‘C2’, ‘C3’ …
are created and mounted at the dentry ‘b’ on all mounts where ‘B’
propagates to. A new propagation tree containing ‘C1’,..,’Cn’ is
created. This propagation tree is identical to the propagation tree of
‘B’.  And finally the peer-group of ‘C’ is merged with the peer group
of ‘A’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a private mount and ‘B’ is a shared mount. A new mount ‘C’</dt><dd><p>which is clone of ‘A’, is created. Its root dentry is ‘a’. ‘C’ is
mounted on mount ‘B’ at dentry ‘b’. Also new mount ‘C1’, ‘C2’, ‘C3’ …
are created and mounted at the dentry ‘b’ on all mounts where ‘B’
propagates to. A new propagation tree is set containing all new mounts
‘C’, ‘C1’, .., ‘Cn’ with exactly the same configuration as the
propagation tree for ‘B’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a slave mount of mount ‘Z’ and ‘B’ is a shared mount. A new</dt><dd><p>mount ‘C’ which is clone of ‘A’, is created. Its root dentry is ‘a’ .
‘C’ is mounted on mount ‘B’ at dentry ‘b’. Also new mounts ‘C1’, ‘C2’,
‘C3’ … are created and mounted at the dentry ‘b’ on all mounts where
‘B’ propagates to. A new propagation tree containing the new mounts
‘C’,’C1’,..  ‘Cn’ is created. This propagation tree is identical to the
propagation tree for ‘B’. And finally the mount ‘C’ and its peer group
is made the slave of mount ‘Z’.  In other words, mount ‘C’ is in the
state ‘slave and shared’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a unbindable mount and ‘B’ is a shared mount. This is a</dt><dd><p>invalid operation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a private mount and ‘B’ is a non-shared(private or slave or</dt><dd><p>unbindable) mount. A new mount ‘C’ which is clone of ‘A’, is created.
Its root dentry is ‘a’. ‘C’ is mounted on mount ‘B’ at dentry ‘b’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a shared mount and ‘B’ is a non-shared mount. A new mount ‘C’</dt><dd><p>which is a clone of ‘A’ is created. Its root dentry is ‘a’. ‘C’ is
mounted on mount ‘B’ at dentry ‘b’.  ‘C’ is made a member of the
peer-group of ‘A’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a slave mount of mount ‘Z’ and ‘B’ is a non-shared mount. A</dt><dd><p>new mount ‘C’ which is a clone of ‘A’ is created. Its root dentry is
‘a’.  ‘C’ is mounted on mount ‘B’ at dentry ‘b’. Also ‘C’ is set as a
slave mount of ‘Z’. In other words ‘A’ and ‘C’ are both slave mounts of
‘Z’.  All mount/unmount events on ‘Z’ propagates to ‘A’ and ‘C’. But
mount/unmount on ‘A’ do not propagate anywhere else. Similarly
mount/unmount on ‘C’ do not propagate anywhere else.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a unbindable mount and ‘B’ is a non-shared mount. This is a</dt><dd><p>invalid operation. A unbindable mount cannot be bind mounted.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>5c) Rbind semantics</p>
<blockquote>
<div><p>rbind is same as bind. Bind replicates the specified mount.  Rbind
replicates all the mounts in the tree belonging to the specified mount.
Rbind mount is bind mount applied to all the mounts in the tree.</p>
<p>If the source tree that is rbind has some unbindable mounts,
then the subtree under the unbindable mount is pruned in the new
location.</p>
<p>eg:</p>
<blockquote>
<div><p>let’s say we have the following mount tree:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   A
 /   \
 B   C
/ \ / \
D E F G
</pre></div>
</div>
<p>Let’s say all the mount except the mount C in the tree are
of a type other than unbindable.</p>
<p>If this tree is rbound to say Z</p>
<p>We will have the following tree at the new location:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Z
    |
    A&#39;
   /
  B&#39;                Note how the tree under C is pruned
 / \                in the new location.
D&#39; E&#39;
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>5d) Move semantics</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>Consider the following command</p>
<p>mount –move A  B/b</p>
<p>where ‘A’ is the source mount, ‘B’ is the destination mount and ‘b’ is
the dentry in the destination mount.</p>
<p>The outcome depends on the type of the mount of ‘A’ and ‘B’. The table
below is a quick reference:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>---------------------------------------------------------------------------
|                   MOVE MOUNT OPERATION                                 |
|**************************************************************************
| source(A)-&gt;| shared      |       private  |       slave    | unbindable |
| dest(B)  |               |                |                |            |
|   |      |               |                |                |            |
|   v      |               |                |                |            |
|**************************************************************************
|  shared  | shared        |     shared     |shared and slave|  invalid   |
|          |               |                |                |            |
|non-shared| shared        |      private   |    slave       | unbindable |
***************************************************************************
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>moving a mount residing under a shared mount is invalid.</p>
</div>
</div></blockquote>
<p>Details follow:</p>
</div></blockquote>
<ol class="arabic simple">
<li><dl class="simple">
<dt>‘A’ is a shared mount and ‘B’ is a shared mount.  The mount ‘A’ is</dt><dd><p>mounted on mount ‘B’ at dentry ‘b’.  Also new mounts ‘A1’, ‘A2’…’An’
are created and mounted at dentry ‘b’ on all mounts that receive
propagation from mount ‘B’. A new propagation tree is created in the
exact same configuration as that of ‘B’. This new propagation tree
contains all the new mounts ‘A1’, ‘A2’…  ‘An’.  And this new
propagation tree is appended to the already existing propagation tree
of ‘A’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a private mount and ‘B’ is a shared mount. The mount ‘A’ is</dt><dd><p>mounted on mount ‘B’ at dentry ‘b’. Also new mount ‘A1’, ‘A2’… ‘An’
are created and mounted at dentry ‘b’ on all mounts that receive
propagation from mount ‘B’. The mount ‘A’ becomes a shared mount and a
propagation tree is created which is identical to that of
‘B’. This new propagation tree contains all the new mounts ‘A1’,
‘A2’…  ‘An’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a slave mount of mount ‘Z’ and ‘B’ is a shared mount.  The</dt><dd><p>mount ‘A’ is mounted on mount ‘B’ at dentry ‘b’.  Also new mounts ‘A1’,
‘A2’… ‘An’ are created and mounted at dentry ‘b’ on all mounts that
receive propagation from mount ‘B’. A new propagation tree is created
in the exact same configuration as that of ‘B’. This new propagation
tree contains all the new mounts ‘A1’, ‘A2’…  ‘An’.  And this new
propagation tree is appended to the already existing propagation tree of
‘A’.  Mount ‘A’ continues to be the slave mount of ‘Z’ but it also
becomes ‘shared’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a unbindable mount and ‘B’ is a shared mount. The operation</dt><dd><p>is invalid. Because mounting anything on the shared mount ‘B’ can
create new mounts that get mounted on the mounts that receive
propagation from ‘B’.  And since the mount ‘A’ is unbindable, cloning
it to mount at other mountpoints is not possible.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a private mount and ‘B’ is a non-shared(private or slave or</dt><dd><p>unbindable) mount. The mount ‘A’ is mounted on mount ‘B’ at dentry ‘b’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a shared mount and ‘B’ is a non-shared mount.  The mount ‘A’</dt><dd><p>is mounted on mount ‘B’ at dentry ‘b’.  Mount ‘A’ continues to be a
shared mount.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a slave mount of mount ‘Z’ and ‘B’ is a non-shared mount.</dt><dd><p>The mount ‘A’ is mounted on mount ‘B’ at dentry ‘b’.  Mount ‘A’
continues to be a slave mount of mount ‘Z’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘A’ is a unbindable mount and ‘B’ is a non-shared mount. The mount</dt><dd><p>‘A’ is mounted on mount ‘B’ at dentry ‘b’. Mount ‘A’ continues to be a
unbindable mount.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>5e) Mount semantics</p>
<blockquote>
<div><p>Consider the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount device  B/b
</pre></div>
</div>
<p>‘B’ is the destination mount and ‘b’ is the dentry in the destination
mount.</p>
<p>The above operation is the same as bind operation with the exception
that the source mount is always a private mount.</p>
</div></blockquote>
<p>5f) Unmount semantics</p>
<blockquote>
<div><p>Consider the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>umount A
</pre></div>
</div>
<p>where ‘A’ is a mount mounted on mount ‘B’ at dentry ‘b’.</p>
<p>If mount ‘B’ is shared, then all most-recently-mounted mounts at dentry
‘b’ on mounts that receive propagation from mount ‘B’ and does not have
sub-mounts within them are unmounted.</p>
<p>Example: Let’s say ‘B1’, ‘B2’, ‘B3’ are shared mounts that propagate to
each other.</p>
<p>let’s say ‘A1’, ‘A2’, ‘A3’ are first mounted at dentry ‘b’ on mount
‘B1’, ‘B2’ and ‘B3’ respectively.</p>
<p>let’s say ‘C1’, ‘C2’, ‘C3’ are next mounted at the same dentry ‘b’ on
mount ‘B1’, ‘B2’ and ‘B3’ respectively.</p>
<p>if ‘C1’ is unmounted, all the mounts that are most-recently-mounted on
‘B1’ and on the mounts that ‘B1’ propagates-to are unmounted.</p>
<p>‘B1’ propagates to ‘B2’ and ‘B3’. And the most recently mounted mount
on ‘B2’ at dentry ‘b’ is ‘C2’, and that of mount ‘B3’ is ‘C3’.</p>
<p>So all ‘C1’, ‘C2’ and ‘C3’ should be unmounted.</p>
<p>If any of ‘C2’ or ‘C3’ has some child mounts, then that mount is not
unmounted, but all other mounts are unmounted. However if ‘C1’ is told
to be unmounted and ‘C1’ has some sub-mounts, the umount operation is
failed entirely.</p>
</div></blockquote>
<p>5g) Clone Namespace</p>
<blockquote>
<div><p>A cloned namespace contains all the mounts as that of the parent
namespace.</p>
<p>Let’s say ‘A’ and ‘B’ are the corresponding mounts in the parent and the
child namespace.</p>
<p>If ‘A’ is shared, then ‘B’ is also shared and ‘A’ and ‘B’ propagate to
each other.</p>
<p>If ‘A’ is a slave mount of ‘Z’, then ‘B’ is also the slave mount of
‘Z’.</p>
<p>If ‘A’ is a private mount, then ‘B’ is a private mount too.</p>
<p>If ‘A’ is unbindable mount, then ‘B’ is a unbindable mount too.</p>
</div></blockquote>
<ol class="arabic" start="6">
<li><p>Quiz</p>
<blockquote>
<div><ol class="upperalpha">
<li><p>What is the result of the following command sequence?</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --bind /mnt /mnt
mount --make-shared /mnt
mount --bind /mnt /tmp
mount --move /tmp /mnt/1
</pre></div>
</div>
<p>what should be the contents of /mnt /mnt/1 /mnt/1/1 should be?
Should they all be identical? or should /mnt and /mnt/1 be
identical only?</p>
</div></blockquote>
</li>
<li><p>What is the result of the following command sequence?</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-rshared /
mkdir -p /v/1
mount --rbind / /v/1
</pre></div>
</div>
<p>what should be the content of /v/1/v/1 be?</p>
</div></blockquote>
</li>
<li><p>What is the result of the following command sequence?</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --bind /mnt /mnt
mount --make-shared /mnt
mkdir -p /mnt/1/2/3 /mnt/1/test
mount --bind /mnt/1 /tmp
mount --make-slave /mnt
mount --make-shared /mnt
mount --bind /mnt/1/2 /tmp1
mount --make-slave /mnt
</pre></div>
</div>
<p>At this point we have the first mount at /tmp and
its root dentry is 1. Let’s call this mount ‘A’
And then we have a second mount at /tmp1 with root
dentry 2. Let’s call this mount ‘B’
Next we have a third mount at /mnt with root dentry
mnt. Let’s call this mount ‘C’</p>
<p>‘B’ is the slave of ‘A’ and ‘C’ is a slave of ‘B’
A -&gt; B -&gt; C</p>
<p>at this point if we execute the following command</p>
<p>mount –bind /bin /tmp/test</p>
<p>The mount is attempted on ‘A’</p>
<p>will the mount propagate to ‘B’ and ‘C’ ?</p>
<p>what would be the contents of
/mnt/1/test be?</p>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p>FAQ</p>
<blockquote>
<div><dl class="simple">
<dt>Q1. Why is bind mount needed? How is it different from symbolic links?</dt><dd><p>symbolic links can get stale if the destination mount gets
unmounted or moved. Bind mounts continue to exist even if the
other mount is unmounted or moved.</p>
</dd>
</dl>
<p>Q2. Why can’t the shared subtree be implemented using exportfs?</p>
<blockquote>
<div><p>exportfs is a heavyweight way of accomplishing part of what
shared subtree can do. I cannot imagine a way to implement the
semantics of slave mount using exportfs?</p>
</div></blockquote>
<p>Q3 Why is unbindable mount needed?</p>
<blockquote>
<div><p>Let’s say we want to replicate the mount tree at multiple
locations within the same subtree.</p>
<p>if one rbind mounts a tree within the same subtree ‘n’ times
the number of mounts created is an exponential function of ‘n’.
Having unbindable mount can help prune the unneeded bind
mounts. Here is an example.</p>
<dl>
<dt>step 1:</dt><dd><p>let’s say the root tree has just two directories with
one vfsmount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                root
               /    \
              tmp    usr

And we want to replicate the tree at multiple
mountpoints under /root/tmp
</pre></div>
</div>
</dd>
<dt>step 2:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --make-shared /root

mkdir -p /tmp/m1

mount --rbind /root /tmp/m1
</pre></div>
</div>
<p>the new tree now looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          root
         /    \
       tmp    usr
      /
     m1
    /  \
   tmp  usr
   /
  m1

it has two vfsmounts
</pre></div>
</div>
</dd>
<dt>step 3:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     mkdir -p /tmp/m2
     mount --rbind /root /tmp/m2

 the new tree now looks like this::

               root
              /    \
            tmp     usr
           /    \
         m1       m2
        / \       /  \
      tmp  usr   tmp  usr
      / \          /
     m1  m2      m1
         / \     /  \
       tmp usr  tmp   usr
       /        / \
      m1       m1  m2
     /  \
   tmp   usr
   /  \
  m1   m2

it has 6 vfsmounts
</pre></div>
</div>
</dd>
<dt>step 4:</dt><dd><dl>
<dt>::</dt><dd><p>mkdir -p /tmp/m3
mount –rbind /root /tmp/m3</p>
<p>I won’t draw the tree..but it has 24 vfsmounts</p>
</dd>
</dl>
</dd>
</dl>
<p>at step i the number of vfsmounts is V[i] = i*V[i-1].
This is an exponential function. And this tree has way more
mounts than what we really needed in the first place.</p>
<p>One could use a series of umount at each step to prune
out the unneeded mounts. But there is a better solution.
Unclonable mounts come in handy here.</p>
<dl>
<dt>step 1:</dt><dd><p>let’s say the root tree has just two directories with
one vfsmount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                root
               /    \
              tmp    usr

How do we set up the same tree at multiple locations under
/root/tmp
</pre></div>
</div>
</dd>
<dt>step 2:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount --bind /root/tmp /root/tmp

mount --make-rshared /root
mount --make-unbindable /root/tmp

mkdir -p /tmp/m1

mount --rbind /root /tmp/m1
</pre></div>
</div>
<p>the new tree now looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       root
      /    \
    tmp    usr
   /
  m1
 /  \
tmp  usr
</pre></div>
</div>
</dd>
<dt>step 3:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir -p /tmp/m2
mount --rbind /root /tmp/m2
</pre></div>
</div>
<p>the new tree now looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       root
      /    \
    tmp    usr
   /   \
  m1     m2
 /  \     / \
tmp  usr tmp usr
</pre></div>
</div>
</dd>
<dt>step 4:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir -p /tmp/m3
mount --rbind /root /tmp/m3
</pre></div>
</div>
<p>the new tree now looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>             root
         /           \
        tmp           usr
    /    \    \
  m1     m2     m3
 /  \     / \    /  \
tmp  usr tmp usr tmp usr
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</li>
<li><p>Implementation</p></li>
</ol>
<p>8A) Datastructure</p>
<blockquote>
<div><p>4 new fields are introduced to struct vfsmount:</p>
<ul class="simple">
<li><p>-&gt;mnt_share</p></li>
<li><p>-&gt;mnt_slave_list</p></li>
<li><p>-&gt;mnt_slave</p></li>
<li><p>-&gt;mnt_master</p></li>
</ul>
<dl class="simple">
<dt>-&gt;mnt_share</dt><dd><p>links together all the mount to/from which this vfsmount
send/receives propagation events.</p>
</dd>
<dt>-&gt;mnt_slave_list</dt><dd><p>links all the mounts to which this vfsmount propagates
to.</p>
</dd>
<dt>-&gt;mnt_slave</dt><dd><p>links together all the slaves that its master vfsmount
propagates to.</p>
</dd>
<dt>-&gt;mnt_master</dt><dd><p>points to the master vfsmount from which this vfsmount
receives propagation.</p>
</dd>
<dt>-&gt;mnt_flags</dt><dd><p>takes two more flags to indicate the propagation status of
the vfsmount.  MNT_SHARE indicates that the vfsmount is a shared
vfsmount.  MNT_UNCLONABLE indicates that the vfsmount cannot be
replicated.</p>
</dd>
</dl>
<p>All the shared vfsmounts in a peer group form a cyclic list through
-&gt;mnt_share.</p>
<p>All vfsmounts with the same -&gt;mnt_master form on a cyclic list anchored
in -&gt;mnt_master-&gt;mnt_slave_list and going through -&gt;mnt_slave.</p>
<blockquote>
<div><p>-&gt;mnt_master can point to arbitrary (and possibly different) members
of master peer group.  To find all immediate slaves of a peer group
you need to go through _all_ -&gt;mnt_slave_list of its members.
Conceptually it’s just a single set - distribution among the
individual lists does not affect propagation or the way propagation
tree is modified by operations.</p>
</div></blockquote>
<p>All vfsmounts in a peer group have the same -&gt;mnt_master.  If it is
non-NULL, they form a contiguous (ordered) segment of slave list.</p>
<p>A example propagation tree looks as shown in the figure below.
[ NOTE: Though it looks like a forest, if we consider all the shared
mounts as a conceptual entity called ‘pnode’, it becomes a tree]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    A &lt;--&gt; B &lt;--&gt; C &lt;---&gt; D
   /|\            /|      |\
  / F G          J K      H I
 /
E&lt;--&gt;K
    /|\
   M L N
</pre></div>
</div>
<p>In the above figure  A,B,C and D all are shared and propagate to each
other.   ‘A’ has got 3 slave mounts ‘E’ ‘F’ and ‘G’ ‘C’ has got 2 slave
mounts ‘J’ and ‘K’  and  ‘D’ has got two slave mounts ‘H’ and ‘I’.
‘E’ is also shared with ‘K’ and they propagate to each other.  And
‘K’ has 3 slaves ‘M’, ‘L’ and ‘N’</p>
<p>A’s -&gt;mnt_share links with the -&gt;mnt_share of ‘B’ ‘C’ and ‘D’</p>
<p>A’s -&gt;mnt_slave_list links with -&gt;mnt_slave of ‘E’, ‘K’, ‘F’ and ‘G’</p>
<p>E’s -&gt;mnt_share links with -&gt;mnt_share of K</p>
<p>‘E’, ‘K’, ‘F’, ‘G’ have their -&gt;mnt_master point to struct vfsmount of ‘A’</p>
<p>‘M’, ‘L’, ‘N’ have their -&gt;mnt_master point to struct vfsmount of ‘K’</p>
<p>K’s -&gt;mnt_slave_list links with -&gt;mnt_slave of ‘M’, ‘L’ and ‘N’</p>
<p>C’s -&gt;mnt_slave_list links with -&gt;mnt_slave of ‘J’ and ‘K’</p>
<p>J and K’s -&gt;mnt_master points to struct vfsmount of C</p>
<p>and finally D’s -&gt;mnt_slave_list links with -&gt;mnt_slave of ‘H’ and ‘I’</p>
<p>‘H’ and ‘I’ have their -&gt;mnt_master pointing to struct vfsmount of ‘D’.</p>
<p>NOTE: The propagation tree is orthogonal to the mount tree.</p>
</div></blockquote>
<p>8B Locking:</p>
<blockquote>
<div><p>-&gt;mnt_share, -&gt;mnt_slave, -&gt;mnt_slave_list, -&gt;mnt_master are protected
by namespace_sem (exclusive for modifications, shared for reading).</p>
<p>Normally we have -&gt;mnt_flags modifications serialized by vfsmount_lock.
There are two exceptions: do_add_mount() and clone_mnt().
The former modifies a vfsmount that has not been visible in any shared
data structures yet.
The latter holds namespace_sem and the only references to vfsmount
are in lists that can’t be traversed without namespace_sem.</p>
</div></blockquote>
<p>8C Algorithm:</p>
<blockquote>
<div><p>The crux of the implementation resides in rbind/move operation.</p>
<p>The overall algorithm breaks the operation into 3 phases: (look at
attach_recursive_mnt() and propagate_mnt())</p>
<ol class="arabic simple">
<li><p>prepare phase.</p></li>
<li><p>commit phases.</p></li>
<li><p>abort phases.</p></li>
</ol>
<p>Prepare phase:</p>
<p>for each mount in the source tree:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><dl class="simple">
<dt>Create the necessary number of mount trees to</dt><dd><p>be attached to each of the mounts that receive
propagation from the destination mount.</p>
</dd>
</dl>
</li>
<li><p>Do not attach any of the trees to its destination.
However note down its -&gt;mnt_parent and -&gt;mnt_mountpoint</p></li>
<li><p>Link all the new mounts to form a propagation tree that
is identical to the propagation tree of the destination
mount.</p></li>
</ol>
<p>If this phase is successful, there should be ‘n’ new
propagation trees; where ‘n’ is the number of mounts in the
source tree.  Go to the commit phase</p>
<p>Also there should be ‘m’ new mount trees, where ‘m’ is
the number of mounts to which the destination mount
propagates to.</p>
<p>if any memory allocations fail, go to the abort phase.</p>
</div></blockquote>
<dl class="simple">
<dt>Commit phase</dt><dd><p>attach each of the mount trees to their corresponding
destination mounts.</p>
</dd>
<dt>Abort phase</dt><dd><p>delete all the newly created trees.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>all the propagation related functionality resides in the file pnode.c</p>
</div>
</div></blockquote>
<hr class="docutils" />
<p>version 0.1  (created the initial document, Ram Pai <a class="reference external" href="mailto:linuxram&#37;&#52;&#48;us&#46;ibm&#46;com">linuxram<span>&#64;</span>us<span>&#46;</span>ibm<span>&#46;</span>com</a>)</p>
<p>version 0.2  (Incorporated comments from Al Viro)</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Shared Subtrees</a><ul>
<li><a class="reference internal" href="#overview">1) Overview</a></li>
<li><a class="reference internal" href="#features">2) Features</a></li>
<li><a class="reference internal" href="#use-cases">4) Use cases</a></li>
<li><a class="reference internal" href="#detailed-semantics">5) Detailed semantics</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/sharedsubtree.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/sharedsubtree.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>