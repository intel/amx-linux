
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Idmappings &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Automount Support" href="automount-support.html" />
    <link rel="prev" title="Shared Subtrees" href="sharedsubtree.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="idmappings">
<h1>Idmappings<a class="headerlink" href="#idmappings" title="Permalink to this headline">¶</a></h1>
<p>Most filesystem developers will have encountered idmappings. They are used when
reading from or writing ownership to disk, reporting ownership to userspace, or
for permission checking. This document is aimed at filesystem developers that
want to know how idmappings work.</p>
<section id="formal-notes">
<h2>Formal notes<a class="headerlink" href="#formal-notes" title="Permalink to this headline">¶</a></h2>
<p>An idmapping is essentially a translation of a range of ids into another or the
same range of ids. The notational convention for idmappings that is widely used
in userspace is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u:k:r
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">u</span></code> indicates the first element in the upper idmapset <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>
indicates the first element in the lower idmapset <code class="docutils literal notranslate"><span class="pre">K</span></code>. The <code class="docutils literal notranslate"><span class="pre">r</span></code> parameter
indicates the range of the idmapping, i.e. how many ids are mapped. From now
on, we will always prefix ids with <code class="docutils literal notranslate"><span class="pre">u</span></code> or <code class="docutils literal notranslate"><span class="pre">k</span></code> to make it clear whether
we’re talking about an id in the upper or lower idmapset.</p>
<p>To see what this looks like in practice, let’s take the following idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u22:k10000:r3
</pre></div>
</div>
<p>and write down the mappings it will generate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u22 -&gt; k10000
u23 -&gt; k10001
u24 -&gt; k10002
</pre></div>
</div>
<p>From a mathematical viewpoint <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">K</span></code> are well-ordered sets and an
idmapping is an order isomorphism from <code class="docutils literal notranslate"><span class="pre">U</span></code> into <code class="docutils literal notranslate"><span class="pre">K</span></code>. So <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">K</span></code> are
order isomorphic. In fact, <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">K</span></code> are always well-ordered subsets of
the set of all possible ids useable on a given system.</p>
<p>Looking at this mathematically briefly will help us highlight some properties
that make it easier to understand how we can translate between idmappings. For
example, we know that the inverse idmapping is an order isomorphism as well:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>k10000 -&gt; u22
k10001 -&gt; u23
k10002 -&gt; u24
</pre></div>
</div>
<p>Given that we are dealing with order isomorphisms plus the fact that we’re
dealing with subsets we can embedd idmappings into each other, i.e. we can
sensibly translate between different idmappings. For example, assume we’ve been
given the three idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. u0:k10000:r10000
2. u0:k20000:r10000
3. u0:k30000:r10000
</pre></div>
</div>
<p>and id <code class="docutils literal notranslate"><span class="pre">k11000</span></code> which has been generated by the first idmapping by mapping
<code class="docutils literal notranslate"><span class="pre">u1000</span></code> from the upper idmapset down to <code class="docutils literal notranslate"><span class="pre">k11000</span></code> in the lower idmapset.</p>
<p>Because we’re dealing with order isomorphic subsets it is meaningful to ask
what id <code class="docutils literal notranslate"><span class="pre">k11000</span></code> corresponds to in the second or third idmapping. The
straightfoward algorithm to use is to apply the inverse of the first idmapping,
mapping <code class="docutils literal notranslate"><span class="pre">k11000</span></code> up to <code class="docutils literal notranslate"><span class="pre">u1000</span></code>. Afterwards, we can map <code class="docutils literal notranslate"><span class="pre">u1000</span></code> down using
either the second idmapping mapping or third idmapping mapping. The second
idmapping would map <code class="docutils literal notranslate"><span class="pre">u1000</span></code> down to <code class="docutils literal notranslate"><span class="pre">21000</span></code>. The third idmapping would map
<code class="docutils literal notranslate"><span class="pre">u1000</span></code> down to <code class="docutils literal notranslate"><span class="pre">u31000</span></code>.</p>
<p>If we were given the same task for the following three idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. u0:k10000:r10000
2. u0:k20000:r200
3. u0:k30000:r300
</pre></div>
</div>
<p>we would fail to translate as the sets aren’t order isomorphic over the full
range of the first idmapping anymore (However they are order isomorphic over
the full range of the second idmapping.). Neither the second or third idmapping
contain <code class="docutils literal notranslate"><span class="pre">u1000</span></code> in the upper idmapset <code class="docutils literal notranslate"><span class="pre">U</span></code>. This is equivalent to not having
an id mapped. We can simply say that <code class="docutils literal notranslate"><span class="pre">u1000</span></code> is unmapped in the second and
third idmapping. The kernel will report unmapped ids as the overflowuid
<code class="docutils literal notranslate"><span class="pre">(uid_t)-1</span></code> or overflowgid <code class="docutils literal notranslate"><span class="pre">(gid_t)-1</span></code> to userspace.</p>
<p>The algorithm to calculate what a given id maps to is pretty simple. First, we
need to verify that the range can contain our target id. We will skip this step
for simplicity. After that if we want to know what <code class="docutils literal notranslate"><span class="pre">id</span></code> maps to we can do
simple calculations:</p>
<ul>
<li><p>If we want to map from left to right:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u:k:r
id - u + k = n
</pre></div>
</div>
</li>
<li><p>If we want to map from right to left:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u:k:r
id - k + u = n
</pre></div>
</div>
</li>
</ul>
<p>Instead of “left to right” we can also say “down” and instead of “right to
left” we can also say “up”. Obviously mapping down and up invert each other.</p>
<p>To see whether the simple formulas above work, consider the following two
idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. u0:k20000:r10000
2. u500:k30000:r10000
</pre></div>
</div>
<p>Assume we are given <code class="docutils literal notranslate"><span class="pre">k21000</span></code> in the lower idmapset of the first idmapping. We
want to know what id this was mapped from in the upper idmapset of the first
idmapping. So we’re mapping up in the first idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>id     - k      + u  = n
k21000 - k20000 + u0 = u1000
</pre></div>
</div>
<p>Now assume we are given the id <code class="docutils literal notranslate"><span class="pre">u1100</span></code> in the upper idmapset of the second
idmapping and we want to know what this id maps down to in the lower idmapset
of the second idmapping. This means we’re mapping down in the second
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>id    - u    + k      = n
u1100 - u500 + k30000 = k30600
</pre></div>
</div>
</section>
<section id="general-notes">
<h2>General notes<a class="headerlink" href="#general-notes" title="Permalink to this headline">¶</a></h2>
<p>In the context of the kernel an idmapping can be interpreted as mapping a range
of userspace ids into a range of kernel ids:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>userspace-id:kernel-id:range
</pre></div>
</div>
<p>A userspace id is always an element in the upper idmapset of an idmapping of
type <code class="docutils literal notranslate"><span class="pre">uid_t</span></code> or <code class="docutils literal notranslate"><span class="pre">gid_t</span></code> and a kernel id is always an element in the lower
idmapset of an idmapping of type <code class="docutils literal notranslate"><span class="pre">kuid_t</span></code> or <code class="docutils literal notranslate"><span class="pre">kgid_t</span></code>. From now on
“userspace id” will be used to refer to the well known <code class="docutils literal notranslate"><span class="pre">uid_t</span></code> and <code class="docutils literal notranslate"><span class="pre">gid_t</span></code>
types and “kernel id” will be used to refer to <code class="docutils literal notranslate"><span class="pre">kuid_t</span></code> and <code class="docutils literal notranslate"><span class="pre">kgid_t</span></code>.</p>
<p>The kernel is mostly concerned with kernel ids. They are used when performing
permission checks and are stored in an inode’s <code class="docutils literal notranslate"><span class="pre">i_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid</span></code> field.
A userspace id on the other hand is an id that is reported to userspace by the
kernel, or is passed by userspace to the kernel, or a raw device id that is
written or read from disk.</p>
<p>Note that we are only concerned with idmappings as the kernel stores them not
how userspace would specify them.</p>
<p>For the rest of this document we will prefix all userspace ids with <code class="docutils literal notranslate"><span class="pre">u</span></code> and
all kernel ids with <code class="docutils literal notranslate"><span class="pre">k</span></code>. Ranges of idmappings will be prefixed with <code class="docutils literal notranslate"><span class="pre">r</span></code>. So
an idmapping will be written as <code class="docutils literal notranslate"><span class="pre">u0:k10000:r10000</span></code>.</p>
<p>For example, the id <code class="docutils literal notranslate"><span class="pre">u1000</span></code> is an id in the upper idmapset or “userspace
idmapset” starting with <code class="docutils literal notranslate"><span class="pre">u1000</span></code>. And it is mapped to <code class="docutils literal notranslate"><span class="pre">k11000</span></code> which is a
kernel id in the lower idmapset or “kernel idmapset” starting with <code class="docutils literal notranslate"><span class="pre">k10000</span></code>.</p>
<p>A kernel id is always created by an idmapping. Such idmappings are associated
with user namespaces. Since we mainly care about how idmappings work we’re not
going to be concerned with how idmappings are created nor how they are used
outside of the filesystem context. This is best left to an explanation of user
namespaces.</p>
<p>The initial user namespace is special. It always has an idmapping of the
following form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u0:k0:r4294967295
</pre></div>
</div>
<p>which is an identity idmapping over the full range of ids available on this
system.</p>
<p>Other user namespaces usually have non-identity idmappings such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u0:k10000:r10000
</pre></div>
</div>
<p>When a process creates or wants to change ownership of a file, or when the
ownership of a file is read from disk by a filesystem, the userspace id is
immediately translated into a kernel id according to the idmapping associated
with the relevant user namespace.</p>
<p>For instance, consider a file that is stored on disk by a filesystem as being
owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code>:</p>
<ul class="simple">
<li><p>If a filesystem were to be mounted in the initial user namespaces (as most
filesystems are) then the initial idmapping will be used. As we saw this is
simply the identity idmapping. This would mean id <code class="docutils literal notranslate"><span class="pre">u1000</span></code> read from disk
would be mapped to id <code class="docutils literal notranslate"><span class="pre">k1000</span></code>. So an inode’s <code class="docutils literal notranslate"><span class="pre">i_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid</span></code> field
would contain <code class="docutils literal notranslate"><span class="pre">k1000</span></code>.</p></li>
<li><p>If a filesystem were to be mounted with an idmapping of <code class="docutils literal notranslate"><span class="pre">u0:k10000:r10000</span></code>
then <code class="docutils literal notranslate"><span class="pre">u1000</span></code> read from disk would be mapped to <code class="docutils literal notranslate"><span class="pre">k11000</span></code>. So an inode’s
<code class="docutils literal notranslate"><span class="pre">i_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid</span></code> would contain <code class="docutils literal notranslate"><span class="pre">k11000</span></code>.</p></li>
</ul>
</section>
<section id="translation-algorithms">
<h2>Translation algorithms<a class="headerlink" href="#translation-algorithms" title="Permalink to this headline">¶</a></h2>
<p>We’ve already seen briefly that it is possible to translate between different
idmappings. We’ll now take a closer look how that works.</p>
<section id="crossmapping">
<h3>Crossmapping<a class="headerlink" href="#crossmapping" title="Permalink to this headline">¶</a></h3>
<p>This translation algorithm is used by the kernel in quite a few places. For
example, it is used when reporting back the ownership of a file to userspace
via the <code class="docutils literal notranslate"><span class="pre">stat()</span></code> system call family.</p>
<p>If we’ve been given <code class="docutils literal notranslate"><span class="pre">k11000</span></code> from one idmapping we can map that id up in
another idmapping. In order for this to work both idmappings need to contain
the same kernel id in their kernel idmapsets. For example, consider the
following idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. u0:k10000:r10000
2. u20000:k10000:r10000
</pre></div>
</div>
<p>and we are mapping <code class="docutils literal notranslate"><span class="pre">u1000</span></code> down to <code class="docutils literal notranslate"><span class="pre">k11000</span></code> in the first idmapping . We can
then translate <code class="docutils literal notranslate"><span class="pre">k11000</span></code> into a userspace id in the second idmapping using the
kernel idmapset of the second idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the kernel id up into a userspace id in the second idmapping. */
from_kuid(u20000:k10000:r10000, k11000) = u21000
</pre></div>
</div>
<p>Note, how we can get back to the kernel id in the first idmapping by inverting
the algorithm:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the userspace id down into a kernel id in the second idmapping. */
make_kuid(u20000:k10000:r10000, u21000) = k11000

/* Map the kernel id up into a userspace id in the first idmapping. */
from_kuid(u0:k10000:r10000, k11000) = u1000
</pre></div>
</div>
<p>This algorithm allows us to answer the question what userspace id a given
kernel id corresponds to in a given idmapping. In order to be able to answer
this question both idmappings need to contain the same kernel id in their
respective kernel idmapsets.</p>
<p>For example, when the kernel reads a raw userspace id from disk it maps it down
into a kernel id according to the idmapping associated with the filesystem.
Let’s assume the filesystem was mounted with an idmapping of
<code class="docutils literal notranslate"><span class="pre">u0:k20000:r10000</span></code> and it reads a file owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code> from disk. This
means <code class="docutils literal notranslate"><span class="pre">u1000</span></code> will be mapped to <code class="docutils literal notranslate"><span class="pre">k21000</span></code> which is what will be stored in
the inode’s <code class="docutils literal notranslate"><span class="pre">i_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid</span></code> field.</p>
<p>When someone in userspace calls <code class="docutils literal notranslate"><span class="pre">stat()</span></code> or a related function to get
ownership information about the file the kernel can’t simply map the id back up
according to the filesystem’s idmapping as this would give the wrong owner if
the caller is using an idmapping.</p>
<p>So the kernel will map the id back up in the idmapping of the caller. Let’s
assume the caller has the slighly unconventional idmapping
<code class="docutils literal notranslate"><span class="pre">u3000:k20000:r10000</span></code> then <code class="docutils literal notranslate"><span class="pre">k21000</span></code> would map back up to <code class="docutils literal notranslate"><span class="pre">u4000</span></code>.
Consequently the user would see that this file is owned by <code class="docutils literal notranslate"><span class="pre">u4000</span></code>.</p>
</section>
<section id="remapping">
<h3>Remapping<a class="headerlink" href="#remapping" title="Permalink to this headline">¶</a></h3>
<p>It is possible to translate a kernel id from one idmapping to another one via
the userspace idmapset of the two idmappings. This is equivalent to remapping
a kernel id.</p>
<p>Let’s look at an example. We are given the following two idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. u0:k10000:r10000
2. u0:k20000:r10000
</pre></div>
</div>
<p>and we are given <code class="docutils literal notranslate"><span class="pre">k11000</span></code> in the first idmapping. In order to translate this
kernel id in the first idmapping into a kernel id in the second idmapping we
need to perform two steps:</p>
<ol class="arabic">
<li><p>Map the kernel id up into a userspace id in the first idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the kernel id up into a userspace id in the first idmapping. */
from_kuid(u0:k10000:r10000, k11000) = u1000
</pre></div>
</div>
</li>
<li><p>Map the userspace id down into a kernel id in the second idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the userspace id down into a kernel id in the second idmapping. */
make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
</li>
</ol>
<p>As you can see we used the userspace idmapset in both idmappings to translate
the kernel id in one idmapping to a kernel id in another idmapping.</p>
<p>This allows us to answer the question what kernel id we would need to use to
get the same userspace id in another idmapping. In order to be able to answer
this question both idmappings need to contain the same userspace id in their
respective userspace idmapsets.</p>
<p>Note, how we can easily get back to the kernel id in the first idmapping by
inverting the algorithm:</p>
<ol class="arabic">
<li><p>Map the kernel id up into a userspace id in the second idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the kernel id up into a userspace id in the second idmapping. */
from_kuid(u0:k20000:r10000, k21000) = u1000
</pre></div>
</div>
</li>
<li><p>Map the userspace id down into a kernel id in the first idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the userspace id down into a kernel id in the first idmapping. */
make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
</ol>
<p>Another way to look at this translation is to treat it as inverting one
idmapping and applying another idmapping if both idmappings have the relevant
userspace id mapped. This will come in handy when working with idmapped mounts.</p>
</section>
<section id="invalid-translations">
<h3>Invalid translations<a class="headerlink" href="#invalid-translations" title="Permalink to this headline">¶</a></h3>
<p>It is never valid to use an id in the kernel idmapset of one idmapping as the
id in the userspace idmapset of another or the same idmapping. While the kernel
idmapset always indicates an idmapset in the kernel id space the userspace
idmapset indicates a userspace id. So the following translations are forbidden:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the userspace id down into a kernel id in the first idmapping. */
make_kuid(u0:k10000:r10000, u1000) = k11000

/* INVALID: Map the kernel id down into a kernel id in the second idmapping. */
make_kuid(u10000:k20000:r10000, k110000) = k21000
                                ~~~~~~~
</pre></div>
</div>
<p>and equally wrong:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the kernel id up into a userspace id in the first idmapping. */
from_kuid(u0:k10000:r10000, k11000) = u1000

/* INVALID: Map the userspace id up into a userspace id in the second idmapping. */
from_kuid(u20000:k0:r10000, u1000) = k21000
                            ~~~~~
</pre></div>
</div>
</section>
</section>
<section id="idmappings-when-creating-filesystem-objects">
<h2>Idmappings when creating filesystem objects<a class="headerlink" href="#idmappings-when-creating-filesystem-objects" title="Permalink to this headline">¶</a></h2>
<p>The concepts of mapping an id down or mapping an id up are expressed in the two
kernel functions filesystem developers are rather familiar with and which we’ve
already used in this document:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the userspace id down into a kernel id. */
make_kuid(idmapping, uid)

/* Map the kernel id up into a userspace id. */
from_kuid(idmapping, kuid)
</pre></div>
</div>
<p>We will take an abbreviated look into how idmappings figure into creating
filesystem objects. For simplicity we will only look at what happens when the
VFS has already completed path lookup right before it calls into the filesystem
itself. So we’re concerned with what happens when e.g. <code class="docutils literal notranslate"><span class="pre">vfs_mkdir()</span></code> is
called. We will also assume that the directory we’re creating filesystem
objects in is readable and writable for everyone.</p>
<p>When creating a filesystem object the caller will look at the caller’s
filesystem ids. These are just regular <code class="docutils literal notranslate"><span class="pre">uid_t</span></code> and <code class="docutils literal notranslate"><span class="pre">gid_t</span></code> userspace ids
but they are exclusively used when determining file ownership which is why they
are called “filesystem ids”. They are usually identical to the uid and gid of
the caller but can differ. We will just assume they are always identical to not
get lost in too many details.</p>
<p>When the caller enters the kernel two things happen:</p>
<ol class="arabic simple">
<li><p>Map the caller’s userspace ids down into kernel ids in the caller’s
idmapping.
(To be precise, the kernel will simply look at the kernel ids stashed in the
credentials of the current task but for our education we’ll pretend this
translation happens just in time.)</p></li>
<li><p>Verify that the caller’s kernel ids can be mapped up to userspace ids in the
filesystem’s idmapping.</p></li>
</ol>
<p>The second step is important as regular filesystem will ultimately need to map
the kernel id back up into a userspace id when writing to disk.
So with the second step the kernel guarantees that a valid userspace id can be
written to disk. If it can’t the kernel will refuse the creation request to not
even remotely risk filesystem corruption.</p>
<p>The astute reader will have realized that this is simply a varation of the
crossmapping algorithm we mentioned above in a previous section. First, the
kernel maps the caller’s userspace id down into a kernel id according to the
caller’s idmapping and then maps that kernel id up according to the
filesystem’s idmapping.</p>
<p>Let’s see some examples with caller/filesystem idmapping but without mount
idmappings. This will exhibit some problems we can hit. After that we will
revisit/reconsider these examples, this time using mount idmappings, to see how
they can solve the problems we observed before.</p>
<section id="example-1">
<h3>Example 1<a class="headerlink" href="#example-1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1000
caller idmapping:     u0:k0:r4294967295
filesystem idmapping: u0:k0:r4294967295
</pre></div>
</div>
<p>Both the caller and the filesystem use the identity idmapping:</p>
<ol class="arabic">
<li><p>Map the caller’s userspace ids into kernel ids in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
<li><p>Verify that the caller’s kernel ids can be mapped to userspace ids in the
filesystem’s idmapping.</p>
<p>For this second step the kernel will call the function
<code class="docutils literal notranslate"><span class="pre">fsuidgid_has_mapping()</span></code> which ultimately boils down to calling
<code class="docutils literal notranslate"><span class="pre">from_kuid()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k1000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>In this example both idmappings are the same so there’s nothing exciting going
on. Ultimately the userspace id that lands on disk will be <code class="docutils literal notranslate"><span class="pre">u1000</span></code>.</p>
</section>
<section id="example-2">
<h3>Example 2<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k20000:r10000
</pre></div>
</div>
<ol class="arabic">
<li><p>Map the caller’s userspace ids down into kernel ids in the caller’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Verify that the caller’s kernel ids can be mapped up to userspace ids in the
filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k20000:r10000, k11000) = u-1
</pre></div>
</div>
</li>
</ol>
<p>It’s immediately clear that while the caller’s userspace id could be
successfully mapped down into kernel ids in the caller’s idmapping the kernel
ids could not be mapped up according to the filesystem’s idmapping. So the
kernel will deny this creation request.</p>
<p>Note that while this example is less common, because most filesystem can’t be
mounted with non-initial idmappings this is a general problem as we can see in
the next examples.</p>
</section>
<section id="example-3">
<h3>Example 3<a class="headerlink" href="#example-3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k0:r4294967295
</pre></div>
</div>
<ol class="arabic">
<li><p>Map the caller’s userspace ids down into kernel ids in the caller’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Verify that the caller’s kernel ids can be mapped up to userspace ids in the
filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k11000) = u11000
</pre></div>
</div>
</li>
</ol>
<p>We can see that the translation always succeeds. The userspace id that the
filesystem will ultimately put to disk will always be identical to the value of
the kernel id that was created in the caller’s idmapping. This has mainly two
consequences.</p>
<p>First, that we can’t allow a caller to ultimately write to disk with another
userspace id. We could only do this if we were to mount the whole fileystem
with the caller’s or another idmapping. But that solution is limited to a few
filesystems and not very flexible. But this is a use-case that is pretty
important in containerized workloads.</p>
<p>Second, the caller will usually not be able to create any files or access
directories that have stricter permissions because none of the filesystem’s
kernel ids map up into valid userspace ids in the caller’s idmapping</p>
<ol class="arabic">
<li><p>Map raw userspace ids down to kernel ids in the filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
<li><p>Map kernel ids up to userspace ids in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k1000) = u-1
</pre></div>
</div>
</li>
</ol>
</section>
<section id="example-4">
<h3>Example 4<a class="headerlink" href="#example-4" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>file id:              u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k0:r4294967295
</pre></div>
</div>
<p>In order to report ownership to userspace the kernel uses the crossmapping
algorithm introduced in a previous section:</p>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k1000) = u-1
</pre></div>
</div>
</li>
</ol>
<p>The crossmapping algorithm fails in this case because the kernel id in the
filesystem idmapping cannot be mapped up to a userspace id in the caller’s
idmapping. Thus, the kernel will report the ownership of this file as the
overflowid.</p>
</section>
<section id="example-5">
<h3>Example 5<a class="headerlink" href="#example-5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>file id:              u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k20000:r10000
</pre></div>
</div>
<p>In order to report ownership to userspace the kernel uses the crossmapping
algorithm introduced in a previous section:</p>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k21000) = u-1
</pre></div>
</div>
</li>
</ol>
<p>Again, the crossmapping algorithm fails in this case because the kernel id in
the filesystem idmapping cannot be mapped to a userspace id in the caller’s
idmapping. Thus, the kernel will report the ownership of this file as the
overflowid.</p>
<p>Note how in the last two examples things would be simple if the caller would be
using the initial idmapping. For a filesystem mounted with the initial
idmapping it would be trivial. So we only consider a filesystem with an
idmapping of <code class="docutils literal notranslate"><span class="pre">u0:k20000:r10000</span></code>:</p>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k21000) = u21000
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="idmappings-on-idmapped-mounts">
<h2>Idmappings on idmapped mounts<a class="headerlink" href="#idmappings-on-idmapped-mounts" title="Permalink to this headline">¶</a></h2>
<p>The examples we’ve seen in the previous section where the caller’s idmapping
and the filesystem’s idmapping are incompatible causes various issues for
workloads. For a more complex but common example, consider two containers
started on the host. To completely prevent the two containers from affecting
each other, an administrator may often use different non-overlapping idmappings
for the two containers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>container1 idmapping:  u0:k10000:r10000
container2 idmapping:  u0:k20000:r10000
filesystem idmapping:  u0:k30000:r10000
</pre></div>
</div>
<p>An administrator wanting to provide easy read-write access to the following set
of files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dir id:       u0
dir/file1 id: u1000
dir/file2 id: u2000
</pre></div>
</div>
<p>to both containers currently can’t.</p>
<p>Of course the administrator has the option to recursively change ownership via
<code class="docutils literal notranslate"><span class="pre">chown()</span></code>. For example, they could change ownership so that <code class="docutils literal notranslate"><span class="pre">dir</span></code> and all
files below it can be crossmapped from the filesystem’s into the container’s
idmapping. Let’s assume they change ownership so it is compatible with the
first container’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dir id:       u10000
dir/file1 id: u11000
dir/file2 id: u12000
</pre></div>
</div>
<p>This would still leave <code class="docutils literal notranslate"><span class="pre">dir</span></code> rather useless to the second container. In fact,
<code class="docutils literal notranslate"><span class="pre">dir</span></code> and all files below it would continue to appear owned by the overflowid
for the second container.</p>
<p>Or consider another increasingly popular example. Some service managers such as
systemd implement a concept called “portable home directories”. A user may want
to use their home directories on different machines where they are assigned
different login userspace ids. Most users will have <code class="docutils literal notranslate"><span class="pre">u1000</span></code> as the login id
on their machine at home and all files in their home directory will usually be
owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code>. At uni or at work they may have another login id such as
<code class="docutils literal notranslate"><span class="pre">u1125</span></code>. This makes it rather difficult to interact with their home directory
on their work machine.</p>
<p>In both cases changing ownership recursively has grave implications. The most
obvious one is that ownership is changed globally and permanently. In the home
directory case this change in ownership would even need to happen everytime the
user switches from their home to their work machine. For really large sets of
files this becomes increasingly costly.</p>
<p>If the user is lucky, they are dealing with a filesystem that is mountable
inside user namespaces. But this would also change ownership globally and the
change in ownership is tied to the lifetime of the filesystem mount, i.e. the
superblock. The only way to change ownership is to completely unmount the
filesystem and mount it again in another user namespace. This is usually
impossible because it would mean that all users currently accessing the
filesystem can’t anymore. And it means that <code class="docutils literal notranslate"><span class="pre">dir</span></code> still can’t be shared
between two containers with different idmappings.
But usually the user doesn’t even have this option since most filesystems
aren’t mountable inside containers. And not having them mountable might be
desirable as it doesn’t require the filesystem to deal with malicious
filesystem images.</p>
<p>But the usecases mentioned above and more can be handled by idmapped mounts.
They allow to expose the same set of dentries with different ownership at
different mounts. This is achieved by marking the mounts with a user namespace
through the <code class="docutils literal notranslate"><span class="pre">mount_setattr()</span></code> system call. The idmapping associated with it
is then used to translate from the caller’s idmapping to the filesystem’s
idmapping and vica versa using the remapping algorithm we introduced above.</p>
<p>Idmapped mounts make it possible to change ownership in a temporary and
localized way. The ownership changes are restricted to a specific mount and the
ownership changes are tied to the lifetime of the mount. All other users and
locations where the filesystem is exposed are unaffected.</p>
<p>Filesystems that support idmapped mounts don’t have any real reason to support
being mountable inside user namespaces. A filesystem could be exposed
completely under an idmapped mount to get the same effect. This has the
advantage that filesystems can leave the creation of the superblock to
privileged users in the initial user namespace.</p>
<p>However, it is perfectly possible to combine idmapped mounts with filesystems
mountable inside user namespaces. We will touch on this further below.</p>
<section id="remapping-helpers">
<h3>Remapping helpers<a class="headerlink" href="#remapping-helpers" title="Permalink to this headline">¶</a></h3>
<p>Idmapping functions were added that translate between idmappings. They make use
of the remapping algorithm we’ve introduced earlier. We’re going to look at
two:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">i_uid_into_mnt()</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid_into_mnt()</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">i_*id_into_mnt()</span></code> functions translate filesystem’s kernel ids into
kernel ids in the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the filesystem&#39;s kernel id up into a userspace id in the filesystem&#39;s idmapping. */
from_kuid(filesystem, kid) = uid

/* Map the filesystem&#39;s userspace id down ito a kernel id in the mount&#39;s idmapping. */
make_kuid(mount, uid) = kuid
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapped_fsuid()</span></code> and <code class="docutils literal notranslate"><span class="pre">mapped_fsgid()</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">mapped_fs*id()</span></code> functions translate the caller’s kernel ids into
kernel ids in the filesystem’s idmapping. This translation is achieved by
remapping the caller’s kernel ids using the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Map the caller&#39;s kernel id up into a userspace id in the mount&#39;s idmapping. */
from_kuid(mount, kid) = uid

/* Map the mount&#39;s userspace id down into a kernel id in the filesystem&#39;s idmapping. */
make_kuid(filesystem, uid) = kuid
</pre></div>
</div>
</li>
</ul>
<p>Note that these two functions invert each other. Consider the following
idmappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k20000:r10000
mount idmapping:      u0:k10000:r10000
</pre></div>
</div>
<p>Assume a file owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code> is read from disk. The filesystem maps this id
to <code class="docutils literal notranslate"><span class="pre">k21000</span></code> according to its idmapping. This is what is stored in the
inode’s <code class="docutils literal notranslate"><span class="pre">i_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">i_gid</span></code> fields.</p>
<p>When the caller queries the ownership of this file via <code class="docutils literal notranslate"><span class="pre">stat()</span></code> the kernel
would usually simply use the crossmapping algorithm and map the filesystem’s
kernel id up to a userspace id in the caller’s idmapping.</p>
<p>But when the caller is accessing the file on an idmapped mount the kernel will
first call <code class="docutils literal notranslate"><span class="pre">i_uid_into_mnt()</span></code> thereby translating the filesystem’s kernel id
into a kernel id in the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i_uid_into_mnt(k21000):
  /* Map the filesystem&#39;s kernel id up into a userspace id. */
  from_kuid(u0:k20000:r10000, k21000) = u1000

  /* Map the filesystem&#39;s userspace id down ito a kernel id in the mount&#39;s idmapping. */
  make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
<p>Finally, when the kernel reports the owner to the caller it will turn the
kernel id in the mount’s idmapping into a userspace id in the caller’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k11000) = u1000
</pre></div>
</div>
<p>We can test whether this algorithm really works by verifying what happens when
we create a new file. Let’s say the user is creating a file with <code class="docutils literal notranslate"><span class="pre">u1000</span></code>.</p>
<p>The kernel maps this to <code class="docutils literal notranslate"><span class="pre">k11000</span></code> in the caller’s idmapping. Usually the
kernel would now apply the crossmapping, verifying that <code class="docutils literal notranslate"><span class="pre">k11000</span></code> can be
mapped to a userspace id in the filesystem’s idmapping. Since <code class="docutils literal notranslate"><span class="pre">k11000</span></code> can’t
be mapped up in the filesystem’s idmapping directly this creation request
fails.</p>
<p>But when the caller is accessing the file on an idmapped mount the kernel will
first call <code class="docutils literal notranslate"><span class="pre">mapped_fs*id()</span></code> thereby translating the caller’s kernel id into
a kernel id according to the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mapped_fsuid(k11000):
   /* Map the caller&#39;s kernel id up into a userspace id in the mount&#39;s idmapping. */
   from_kuid(u0:k10000:r10000, k11000) = u1000

   /* Map the mount&#39;s userspace id down into a kernel id in the filesystem&#39;s idmapping. */
   make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
<p>When finally writing to disk the kernel will then map <code class="docutils literal notranslate"><span class="pre">k21000</span></code> up into a
userspace id in the filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k20000:r10000, k21000) = u1000
</pre></div>
</div>
<p>As we can see, we end up with an invertible and therefore information
preserving algorithm. A file created from <code class="docutils literal notranslate"><span class="pre">u1000</span></code> on an idmapped mount will
also be reported as being owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code> and vica versa.</p>
<p>Let’s now briefly reconsider the failing examples from earlier in the context
of idmapped mounts.</p>
</section>
<section id="example-2-reconsidered">
<h3>Example 2 reconsidered<a class="headerlink" href="#example-2-reconsidered" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k20000:r10000
mount idmapping:      u0:k10000:r10000
</pre></div>
</div>
<p>When the caller is using a non-initial idmapping the common case is to attach
the same idmapping to the mount. We now perform three steps:</p>
<ol class="arabic">
<li><p>Map the caller’s userspace ids into kernel ids in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Translate the caller’s kernel id into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mapped_fsuid(k11000):
  /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
  from_kuid(u0:k10000:r10000, k11000) = u1000

  /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
  make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="2">
<li><p>Verify that the caller’s kernel ids can be mapped to userspace ids in the
filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k20000:r10000, k21000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>So the ownership that lands on disk will be <code class="docutils literal notranslate"><span class="pre">u1000</span></code>.</p>
</section>
<section id="example-3-reconsidered">
<h3>Example 3 reconsidered<a class="headerlink" href="#example-3-reconsidered" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k0:r4294967295
mount idmapping:      u0:k10000:r10000
</pre></div>
</div>
<p>The same translation algorithm works with the third example.</p>
<ol class="arabic">
<li><p>Map the caller’s userspace ids into kernel ids in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Translate the caller’s kernel id into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mapped_fsuid(k11000):
   /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
   from_kuid(u0:k10000:r10000, k11000) = u1000

   /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
   make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="2">
<li><p>Verify that the caller’s kernel ids can be mapped to userspace ids in the
filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k21000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>So the ownership that lands on disk will be <code class="docutils literal notranslate"><span class="pre">u1000</span></code>.</p>
</section>
<section id="example-4-reconsidered">
<h3>Example 4 reconsidered<a class="headerlink" href="#example-4-reconsidered" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>file id:              u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k0:r4294967295
mount idmapping:      u0:k10000:r10000
</pre></div>
</div>
<p>In order to report ownership to userspace the kernel now does three steps using
the translation algorithm we introduced earlier:</p>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
<li><p>Translate the kernel id into a kernel id in the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i_uid_into_mnt(k1000):
  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
  from_kuid(u0:k0:r4294967295, k1000) = u1000

  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
  make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k11000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>Earlier, the caller’s kernel id couldn’t be crossmapped in the filesystems’s
idmapping. With the idmapped mount in place it now can be crossmapped into the
filesystem’s idmapping via the mount’s idmapping. The file will now be created
with <code class="docutils literal notranslate"><span class="pre">u1000</span></code> according to the mount’s idmapping.</p>
</section>
<section id="example-5-reconsidered">
<h3>Example 5 reconsidered<a class="headerlink" href="#example-5-reconsidered" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>file id:              u1000
caller idmapping:     u0:k10000:r10000
filesystem idmapping: u0:k20000:r10000
mount idmapping:      u0:k10000:r10000
</pre></div>
</div>
<p>Again, in order to report ownership to userspace the kernel now does three
steps using the translation algorithm we introduced earlier:</p>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k20000:r10000, u1000) = k21000
</pre></div>
</div>
</li>
<li><p>Translate the kernel id into a kernel id in the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i_uid_into_mnt(k21000):
  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
  from_kuid(u0:k20000:r10000, k21000) = u1000

  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
  make_kuid(u0:k10000:r10000, u1000) = k11000
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k10000:r10000, k11000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>Earlier, the file’s kernel id couldn’t be crossmapped in the filesystems’s
idmapping. With the idmapped mount in place it now can be crossmapped into the
filesystem’s idmapping via the mount’s idmapping. The file is now owned by
<code class="docutils literal notranslate"><span class="pre">u1000</span></code> according to the mount’s idmapping.</p>
</section>
<section id="changing-ownership-on-a-home-directory">
<h3>Changing ownership on a home directory<a class="headerlink" href="#changing-ownership-on-a-home-directory" title="Permalink to this headline">¶</a></h3>
<p>We’ve seen above how idmapped mounts can be used to translate between
idmappings when either the caller, the filesystem or both uses a non-initial
idmapping. A wide range of usecases exist when the caller is using
a non-initial idmapping. This mostly happens in the context of containerized
workloads. The consequence is as we have seen that for both, filesystem’s
mounted with the initial idmapping and filesystems mounted with non-initial
idmappings, access to the filesystem isn’t working because the kernel ids can’t
be crossmapped between the caller’s and the filesystem’s idmapping.</p>
<p>As we’ve seen above idmapped mounts provide a solution to this by remapping the
caller’s or filesystem’s idmapping according to the mount’s idmapping.</p>
<p>Aside from containerized workloads, idmapped mounts have the advantage that
they also work when both the caller and the filesystem use the initial
idmapping which means users on the host can change the ownership of directories
and files on a per-mount basis.</p>
<p>Consider our previous example where a user has their home directory on portable
storage. At home they have id <code class="docutils literal notranslate"><span class="pre">u1000</span></code> and all files in their home directory
are owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code> whereas at uni or work they have login id <code class="docutils literal notranslate"><span class="pre">u1125</span></code>.</p>
<p>Taking their home directory with them becomes problematic. They can’t easily
access their files, they might not be able to write to disk without applying
lax permissions or ACLs and even if they can, they will end up with an annoying
mix of files and directories owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code> and <code class="docutils literal notranslate"><span class="pre">u1125</span></code>.</p>
<p>Idmapped mounts allow to solve this problem. A user can create an idmapped
mount for their home directory on their work computer or their computer at home
depending on what ownership they would prefer to end up on the portable storage
itself.</p>
<p>Let’s assume they want all files on disk to belong to <code class="docutils literal notranslate"><span class="pre">u1000</span></code>. When the user
plugs in their portable storage at their work station they can setup a job that
creates an idmapped mount with the minimal idmapping <code class="docutils literal notranslate"><span class="pre">u1000:k1125:r1</span></code>. So now
when they create a file the kernel performs the following steps we already know
from above::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>caller id:            u1125
caller idmapping:     u0:k0:r4294967295
filesystem idmapping: u0:k0:r4294967295
mount idmapping:      u1000:k1125:r1
</pre></div>
</div>
<ol class="arabic">
<li><p>Map the caller’s userspace ids into kernel ids in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1125) = k1125
</pre></div>
</div>
</li>
<li><p>Translate the caller’s kernel id into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mapped_fsuid(k1125):
  /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
  from_kuid(u1000:k1125:r1, k1125) = u1000

  /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
  make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="2">
<li><p>Verify that the caller’s kernel ids can be mapped to userspace ids in the
filesystem’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k1000) = u1000
</pre></div>
</div>
</li>
</ol>
<p>So ultimately the file will be created with <code class="docutils literal notranslate"><span class="pre">u1000</span></code> on disk.</p>
<p>Now let’s briefly look at what ownership the caller with id <code class="docutils literal notranslate"><span class="pre">u1125</span></code> will see
on their work computer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>file id:              u1000
caller idmapping:     u0:k0:r4294967295
filesystem idmapping: u0:k0:r4294967295
mount idmapping:      u1000:k1125:r1
</pre></div>
</div>
<ol class="arabic">
<li><p>Map the userspace id on disk down into a kernel id in the filesystem’s
idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make_kuid(u0:k0:r4294967295, u1000) = k1000
</pre></div>
</div>
</li>
<li><p>Translate the kernel id into a kernel id in the mount’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i_uid_into_mnt(k1000):
  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
  from_kuid(u0:k0:r4294967295, k1000) = u1000

  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
  make_kuid(u1000:k1125:r1, u1000) = k1125
</pre></div>
</div>
</li>
<li><p>Map the kernel id up into a userspace id in the caller’s idmapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from_kuid(u0:k0:r4294967295, k1125) = u1125
</pre></div>
</div>
</li>
</ol>
<p>So ultimately the caller will be reported that the file belongs to <code class="docutils literal notranslate"><span class="pre">u1125</span></code>
which is the caller’s userspace id on their workstation in our example.</p>
<p>The raw userspace id that is put on disk is <code class="docutils literal notranslate"><span class="pre">u1000</span></code> so when the user takes
their home directory back to their home computer where they are assigned
<code class="docutils literal notranslate"><span class="pre">u1000</span></code> using the initial idmapping and mount the filesystem with the initial
idmapping they will see all those files owned by <code class="docutils literal notranslate"><span class="pre">u1000</span></code>.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Idmappings</a><ul>
<li><a class="reference internal" href="#formal-notes">Formal notes</a></li>
<li><a class="reference internal" href="#general-notes">General notes</a></li>
<li><a class="reference internal" href="#translation-algorithms">Translation algorithms</a><ul>
<li><a class="reference internal" href="#crossmapping">Crossmapping</a></li>
<li><a class="reference internal" href="#remapping">Remapping</a></li>
<li><a class="reference internal" href="#invalid-translations">Invalid translations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#idmappings-when-creating-filesystem-objects">Idmappings when creating filesystem objects</a><ul>
<li><a class="reference internal" href="#example-1">Example 1</a></li>
<li><a class="reference internal" href="#example-2">Example 2</a></li>
<li><a class="reference internal" href="#example-3">Example 3</a></li>
<li><a class="reference internal" href="#example-4">Example 4</a></li>
<li><a class="reference internal" href="#example-5">Example 5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#idmappings-on-idmapped-mounts">Idmappings on idmapped mounts</a><ul>
<li><a class="reference internal" href="#remapping-helpers">Remapping helpers</a></li>
<li><a class="reference internal" href="#example-2-reconsidered">Example 2 reconsidered</a></li>
<li><a class="reference internal" href="#example-3-reconsidered">Example 3 reconsidered</a></li>
<li><a class="reference internal" href="#example-4-reconsidered">Example 4 reconsidered</a></li>
<li><a class="reference internal" href="#example-5-reconsidered">Example 5 reconsidered</a></li>
<li><a class="reference internal" href="#changing-ownership-on-a-home-directory">Changing ownership on a home directory</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/idmappings.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/idmappings.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>