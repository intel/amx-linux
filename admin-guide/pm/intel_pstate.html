
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>intel_pstate CPU Performance Scaling Driver &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="amd-pstate CPU Performance Scaling Driver" href="amd-pstate.html" />
    <link rel="prev" title="CPU Performance Scaling" href="cpufreq.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="intel-pstate-cpu-performance-scaling-driver">
<h1><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> CPU Performance Scaling Driver<a class="headerlink" href="#intel-pstate-cpu-performance-scaling-driver" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2017 Intel Corporation</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rafael&#46;j&#46;wysocki&#37;&#52;&#48;intel&#46;com">rafael<span>&#46;</span>j<span>&#46;</span>wysocki<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<section id="general-information">
<h2>General Information<a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is a part of the
<a class="reference internal" href="cpufreq.html"><span class="doc">CPU performance scaling subsystem</span></a> in the Linux kernel
(<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code>).  It is a scaling driver for the Sandy Bridge and later
generations of Intel processors.  Note, however, that some of those processors
may not be supported.  [To understand <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> it is necessary to know
how <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> works in general, so this is the time to read
<a class="reference internal" href="cpufreq.html"><span class="doc">CPU Performance Scaling</span></a> if you have not done that yet.]</p>
<p>For the processors supported by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>, the P-state concept is broader
than just an operating frequency or an operating performance point (see the
LinuxCon Europe 2015 presentation by Kristen Accardi <a class="footnote-reference brackets" href="#id4" id="id1">1</a> for more
information about that).  For this reason, the representation of P-states used
by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> internally follows the hardware specification (for details
refer to Intel Software Developer’s Manual <a class="footnote-reference brackets" href="#id5" id="id2">2</a>).  However, the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core
uses frequencies for identifying operating performance points of CPUs and
frequencies are involved in the user space interface exposed by it, so
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> maps its internal representation of P-states to frequencies too
(fortunately, that mapping is unambiguous).  At the same time, it would not be
practical for <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> to supply the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core with a table of
available frequencies due to the possible size of it, so the driver does not do
that.  Some functionality of the core is limited by that.</p>
<p>Since the hardware P-state selection interface used by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is
available at the logical CPU level, the driver always works with individual
CPUs.  Consequently, if <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is in use, every <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policy
object corresponds to one logical CPU and <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policies are effectively
equivalent to CPUs.  In particular, this means that they become “inactive” every
time the corresponding CPU is taken offline and need to be re-initialized when
it goes back online.</p>
<p><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is not modular, so it cannot be unloaded, which means that the
only way to pass early-configuration-time parameters to it is via the kernel
command line.  However, its configuration can be adjusted via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> to a
great extent.  In some configurations it even is possible to unregister it via
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code> which allows another <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> scaling driver to be loaded and
registered (see <a class="reference internal" href="#status-attr">below</a>).</p>
</section>
<section id="operation-modes">
<h2>Operation Modes<a class="headerlink" href="#operation-modes" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> can operate in two different modes, active or passive.  In the
active mode, it uses its own internal performance scaling governor algorithm or
allows the hardware to do performance scaling by itself, while in the passive
mode it responds to requests made by a generic <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> governor implementing
a certain performance scaling algorithm.  Which of them will be in effect
depends on what kernel command line options are used and on the capabilities of
the processor.</p>
<section id="active-mode">
<h3>Active Mode<a class="headerlink" href="#active-mode" title="Permalink to this headline">¶</a></h3>
<p>This is the default operation mode of <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> for processors with
hardware-managed P-states (HWP) support.  If it works in this mode, the
<code class="docutils literal notranslate"><span class="pre">scaling_driver</span></code> policy attribute in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> for all <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policies
contains the string “intel_pstate”.</p>
<p>In this mode the driver bypasses the scaling governors layer of <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> and
provides its own scaling algorithms for P-state selection.  Those algorithms
can be applied to <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policies in the same way as generic scaling
governors (that is, through the <code class="docutils literal notranslate"><span class="pre">scaling_governor</span></code> policy attribute in
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code>).  [Note that different P-state selection algorithms may be chosen for
different policies, but that is not recommended.]</p>
<p>They are not generic scaling governors, but their names are the same as the
names of some of those governors.  Moreover, confusingly enough, they generally
do not work in the same way as the generic governors they share the names with.
For example, the <code class="docutils literal notranslate"><span class="pre">powersave</span></code> P-state selection algorithm provided by
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is not a counterpart of the generic <code class="docutils literal notranslate"><span class="pre">powersave</span></code> governor
(roughly, it corresponds to the <code class="docutils literal notranslate"><span class="pre">schedutil</span></code> and <code class="docutils literal notranslate"><span class="pre">ondemand</span></code> governors).</p>
<p>There are two P-state selection algorithms provided by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> in the
active mode: <code class="docutils literal notranslate"><span class="pre">powersave</span></code> and <code class="docutils literal notranslate"><span class="pre">performance</span></code>.  The way they both operate
depends on whether or not the hardware-managed P-states (HWP) feature has been
enabled in the processor and possibly on the processor model.</p>
<p>Which of the P-state selection algorithms is used by default depends on the
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option.
Namely, if that option is set, the <code class="docutils literal notranslate"><span class="pre">performance</span></code> algorithm will be used by
default, and the other one will be used by default if it is not set.</p>
<section id="active-mode-with-hwp">
<h4>Active Mode With HWP<a class="headerlink" href="#active-mode-with-hwp" title="Permalink to this headline">¶</a></h4>
<p>If the processor supports the HWP feature, it will be enabled during the
processor initialization and cannot be disabled after that.  It is possible
to avoid enabling it by passing the <code class="docutils literal notranslate"><span class="pre">intel_pstate=no_hwp</span></code> argument to the
kernel in the command line.</p>
<p>If the HWP feature has been enabled, <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> relies on the processor to
select P-states by itself, but still it can give hints to the processor’s
internal P-state selection logic.  What those hints are depends on which P-state
selection algorithm has been applied to the given policy (or to the CPU it
corresponds to).</p>
<p>Even though the P-state selection is carried out by the processor automatically,
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> registers utilization update callbacks with the CPU scheduler
in this mode.  However, they are not used for running a P-state selection
algorithm, but for periodic updates of the current CPU frequency information to
be made available from the <code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code> policy attribute in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>.</p>
<section id="hwp-performance">
<h5>HWP + <code class="docutils literal notranslate"><span class="pre">performance</span></code><a class="headerlink" href="#hwp-performance" title="Permalink to this headline">¶</a></h5>
<p>In this configuration <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> will write 0 to the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob (otherwise), which means that the processor’s
internal P-state selection logic is expected to focus entirely on performance.</p>
<p>This will override the EPP/EPB setting coming from the <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> interface
(see <a class="reference internal" href="#energy-vs-performance-hints">Energy vs Performance Hints</a> below).  Moreover, any attempts to change
the EPP/EPB to a value different from 0 (“performance”) via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> in this
configuration will be rejected.</p>
<p>Also, in this configuration the range of P-states available to the processor’s
internal P-state selection logic is always restricted to the upper boundary
(that is, the maximum P-state that the driver is allowed to use).</p>
</section>
<section id="hwp-powersave">
<h5>HWP + <code class="docutils literal notranslate"><span class="pre">powersave</span></code><a class="headerlink" href="#hwp-powersave" title="Permalink to this headline">¶</a></h5>
<p>In this configuration <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> will set the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob (otherwise) to whatever value it was
previously set to via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> (or whatever default value it was
set to by the platform firmware).  This usually causes the processor’s
internal P-state selection logic to be less performance-focused.</p>
</section>
</section>
<section id="active-mode-without-hwp">
<h4>Active Mode Without HWP<a class="headerlink" href="#active-mode-without-hwp" title="Permalink to this headline">¶</a></h4>
<p>This operation mode is optional for processors that do not support the HWP
feature or when the <code class="docutils literal notranslate"><span class="pre">intel_pstate=no_hwp</span></code> argument is passed to the kernel in
the command line.  The active mode is used in those cases if the
<code class="docutils literal notranslate"><span class="pre">intel_pstate=active</span></code> argument is passed to the kernel in the command line.
In this mode <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> may refuse to work with processors that are not
recognized by it.  [Note that <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> will never refuse to work with
any processor with the HWP feature enabled.]</p>
<p>In this mode <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> registers utilization update callbacks with the
CPU scheduler in order to run a P-state selection algorithm, either
<code class="docutils literal notranslate"><span class="pre">powersave</span></code> or <code class="docutils literal notranslate"><span class="pre">performance</span></code>, depending on the <code class="docutils literal notranslate"><span class="pre">scaling_governor</span></code> policy
setting in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>.  The current CPU frequency information to be made
available from the <code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code> policy attribute in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> is
periodically updated by those utilization update callbacks too.</p>
<section id="performance">
<h5><code class="docutils literal notranslate"><span class="pre">performance</span></code><a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h5>
<p>Without HWP, this P-state selection algorithm is always the same regardless of
the processor model and platform configuration.</p>
<p>It selects the maximum P-state it is allowed to use, subject to limits set via
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code>, every time the driver configuration for the given CPU is updated
(e.g. via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>).</p>
<p>This is the default P-state selection algorithm if the
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option
is set.</p>
</section>
<section id="powersave">
<h5><code class="docutils literal notranslate"><span class="pre">powersave</span></code><a class="headerlink" href="#powersave" title="Permalink to this headline">¶</a></h5>
<p>Without HWP, this P-state selection algorithm is similar to the algorithm
implemented by the generic <code class="docutils literal notranslate"><span class="pre">schedutil</span></code> scaling governor except that the
utilization metric used by it is based on numbers coming from feedback
registers of the CPU.  It generally selects P-states proportional to the
current CPU utilization.</p>
<p>This algorithm is run by the driver’s utilization update callback for the
given CPU when it is invoked by the CPU scheduler, but not more often than
every 10 ms.  Like in the <code class="docutils literal notranslate"><span class="pre">performance</span></code> case, the hardware configuration
is not touched if the new P-state turns out to be the same as the current
one.</p>
<p>This is the default P-state selection algorithm if the
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option
is not set.</p>
</section>
</section>
</section>
<section id="passive-mode">
<h3>Passive Mode<a class="headerlink" href="#passive-mode" title="Permalink to this headline">¶</a></h3>
<p>This is the default operation mode of <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> for processors without
hardware-managed P-states (HWP) support.  It is always used if the
<code class="docutils literal notranslate"><span class="pre">intel_pstate=passive</span></code> argument is passed to the kernel in the command line
regardless of whether or not the given processor supports HWP.  [Note that the
<code class="docutils literal notranslate"><span class="pre">intel_pstate=no_hwp</span></code> setting causes the driver to start in the passive mode
if it is not combined with <code class="docutils literal notranslate"><span class="pre">intel_pstate=active</span></code>.]  Like in the active mode
without HWP support, in this mode <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> may refuse to work with
processors that are not recognized by it if HWP is prevented from being enabled
through the kernel command line.</p>
<p>If the driver works in this mode, the <code class="docutils literal notranslate"><span class="pre">scaling_driver</span></code> policy attribute in
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code> for all <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policies contains the string “intel_cpufreq”.
Then, the driver behaves like a regular <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> scaling driver.  That is,
it is invoked by generic scaling governors when necessary to talk to the
hardware in order to change the P-state of a CPU (in particular, the
<code class="docutils literal notranslate"><span class="pre">schedutil</span></code> governor can invoke it directly from scheduler context).</p>
<p>While in this mode, <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> can be used with all of the (generic)
scaling governors listed by the <code class="docutils literal notranslate"><span class="pre">scaling_available_governors</span></code> policy attribute
in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> (and the P-state selection algorithms described above are not
used).  Then, it is responsible for the configuration of policy objects
corresponding to CPUs and provides the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core (and the scaling
governors attached to the policy objects) with accurate information on the
maximum and minimum operating frequencies supported by the hardware (including
the so-called “turbo” frequency ranges).  In other words, in the passive mode
the entire range of available P-states is exposed by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> to the
<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core.  However, in this mode the driver does not register
utilization update callbacks with the CPU scheduler and the <code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code>
information comes from the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core (and is the last frequency selected
by the current scaling governor for the given policy).</p>
</section>
</section>
<section id="turbo-p-states-support">
<span id="turbo"></span><h2>Turbo P-states Support<a class="headerlink" href="#turbo-p-states-support" title="Permalink to this headline">¶</a></h2>
<p>In the majority of cases, the entire range of P-states available to
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> can be divided into two sub-ranges that correspond to
different types of processor behavior, above and below a boundary that
will be referred to as the “turbo threshold” in what follows.</p>
<p>The P-states above the turbo threshold are referred to as “turbo P-states” and
the whole sub-range of P-states they belong to is referred to as the “turbo
range”.  These names are related to the Turbo Boost technology allowing a
multicore processor to opportunistically increase the P-state of one or more
cores if there is enough power to do that and if that is not going to cause the
thermal envelope of the processor package to be exceeded.</p>
<p>Specifically, if software sets the P-state of a CPU core within the turbo range
(that is, above the turbo threshold), the processor is permitted to take over
performance scaling control for that core and put it into turbo P-states of its
choice going forward.  However, that permission is interpreted differently by
different processor generations.  Namely, the Sandy Bridge generation of
processors will never use any P-states above the last one set by software for
the given core, even if it is within the turbo range, whereas all of the later
processor generations will take it as a license to use any P-states from the
turbo range, even above the one set by software.  In other words, on those
processors setting any P-state from the turbo range will enable the processor
to put the given core into all turbo P-states up to and including the maximum
supported one as it sees fit.</p>
<p>One important property of turbo P-states is that they are not sustainable.  More
precisely, there is no guarantee that any CPUs will be able to stay in any of
those states indefinitely, because the power distribution within the processor
package may change over time  or the thermal envelope it was designed for might
be exceeded if a turbo P-state was used for too long.</p>
<p>In turn, the P-states below the turbo threshold generally are sustainable.  In
fact, if one of them is set by software, the processor is not expected to change
it to a lower one unless in a thermal stress or a power limit violation
situation (a higher P-state may still be used if it is set for another CPU in
the same package at the same time, for example).</p>
<p>Some processors allow multiple cores to be in turbo P-states at the same time,
but the maximum P-state that can be set for them generally depends on the number
of cores running concurrently.  The maximum turbo P-state that can be set for 3
cores at the same time usually is lower than the analogous maximum P-state for
2 cores, which in turn usually is lower than the maximum turbo P-state that can
be set for 1 core.  The one-core maximum turbo P-state is thus the maximum
supported one overall.</p>
<p>The maximum supported turbo P-state, the turbo threshold (the maximum supported
non-turbo P-state) and the minimum supported P-state are specific to the
processor model and can be determined by reading the processor’s model-specific
registers (MSRs).  Moreover, some processors support the Configurable TDP
(Thermal Design Power) feature and, when that feature is enabled, the turbo
threshold effectively becomes a configurable value that can be set by the
platform firmware.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> objects in the ACPI tables, <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> always exposes
the entire range of available P-states, including the whole turbo range, to the
<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core and (in the passive mode) to generic scaling governors.  This
generally causes turbo P-states to be set more often when <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> is
used relative to ACPI-based CPU performance scaling (see <a class="reference internal" href="#acpi-cpufreq">below</a>
for more information).</p>
<p>Moreover, since <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> always knows what the real turbo threshold is
(even if the Configurable TDP feature is enabled in the processor), its
<code class="docutils literal notranslate"><span class="pre">no_turbo</span></code> attribute in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> (described <a class="reference internal" href="#no-turbo-attr">below</a>) should
work as expected in all cases (that is, if set to disable turbo P-states, it
always should prevent <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> from using them).</p>
</section>
<section id="processor-support">
<h2>Processor Support<a class="headerlink" href="#processor-support" title="Permalink to this headline">¶</a></h2>
<p>To handle a given processor <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> requires a number of different
pieces of information on it to be known, including:</p>
<blockquote>
<div><ul class="simple">
<li><p>The minimum supported P-state.</p></li>
<li><p>The maximum supported <a class="reference internal" href="#turbo">non-turbo P-state</a>.</p></li>
<li><p>Whether or not turbo P-states are supported at all.</p></li>
<li><p>The maximum supported <a class="reference internal" href="#turbo">one-core turbo P-state</a> (if turbo P-states
are supported).</p></li>
<li><p>The scaling formula to translate the driver’s internal representation
of P-states into frequencies and the other way around.</p></li>
</ul>
</div></blockquote>
<p>Generally, ways to obtain that information are specific to the processor model
or family.  Although it often is possible to obtain all of it from the processor
itself (using model-specific registers), there are cases in which hardware
manuals need to be consulted to get to it too.</p>
<p>For this reason, there is a list of supported processors in <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> and
the driver initialization will fail if the detected processor is not in that
list, unless it supports the HWP feature.  [The interface to obtain all of the
information listed above is the same for all of the processors supporting the
HWP feature, which is why <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> works with all of them.]</p>
</section>
<section id="user-space-interface-in-sysfs">
<h2>User Space Interface in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code><a class="headerlink" href="#user-space-interface-in-sysfs" title="Permalink to this headline">¶</a></h2>
<section id="global-attributes">
<h3>Global Attributes<a class="headerlink" href="#global-attributes" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> exposes several global attributes (files) in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> to
control its functionality at the system level.  They are located in the
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/intel_pstate/</span></code> directory and affect all CPUs.</p>
<p>Some of them are not present if the <code class="docutils literal notranslate"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code>
argument is passed to the kernel in the command line.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">max_perf_pct</span></code></dt><dd><p>Maximum P-state the driver is allowed to set in percent of the
maximum supported performance level (the highest supported <a class="reference internal" href="#turbo">turbo
P-state</a>).</p>
<p>This attribute will not be exposed if the
<code class="docutils literal notranslate"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> argument is present in the kernel
command line.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_perf_pct</span></code></dt><dd><p>Minimum P-state the driver is allowed to set in percent of the
maximum supported performance level (the highest supported <a class="reference internal" href="#turbo">turbo
P-state</a>).</p>
<p>This attribute will not be exposed if the
<code class="docutils literal notranslate"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> argument is present in the kernel
command line.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_pstates</span></code></dt><dd><p>Number of P-states supported by the processor (between 0 and 255
inclusive) including both turbo and non-turbo P-states (see
<a class="reference internal" href="#turbo-p-states-support">Turbo P-states Support</a>).</p>
<p>This attribute is present only if the value exposed by it is the same
for all of the CPUs in the system.</p>
<p>The value of this attribute is not affected by the <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code>
setting described <a class="reference internal" href="#no-turbo-attr">below</a>.</p>
<p>This attribute is read-only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">turbo_pct</span></code></dt><dd><p>Ratio of the <a class="reference internal" href="#turbo">turbo range</a> size to the size of the entire
range of supported P-states, in percent.</p>
<p>This attribute is present only if the value exposed by it is the same
for all of the CPUs in the system.</p>
<p>This attribute is read-only.</p>
</dd>
</dl>
<dl id="no-turbo-attr">
<dt><code class="docutils literal notranslate"><span class="pre">no_turbo</span></code></dt><dd><p>If set (equal to 1), the driver is not allowed to set any turbo P-states
(see <a class="reference internal" href="#turbo-p-states-support">Turbo P-states Support</a>).  If unset (equal to 0, which is the
default), turbo P-states can be set by the driver.
[Note that <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> does not support the general <code class="docutils literal notranslate"><span class="pre">boost</span></code>
attribute (supported by some other scaling drivers) which is replaced
by this one.]</p>
<p>This attribute does not affect the maximum supported frequency value
supplied to the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core and exposed via the policy interface,
but it affects the maximum possible value of per-policy P-state limits
(see <a class="reference internal" href="#interpretation-of-policy-attributes">Interpretation of Policy Attributes</a> below for details).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwp_dynamic_boost</span></code></dt><dd><p>This attribute is only present if <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> works in the
<a class="reference internal" href="#active-mode-with-hwp">active mode with the HWP feature enabled</a> in
the processor.  If set (equal to 1), it causes the minimum P-state limit
to be increased dynamically for a short time whenever a task previously
waiting on I/O is selected to run on a given logical CPU (the purpose
of this mechanism is to improve performance).</p>
<p>This setting has no effect on logical CPUs whose minimum P-state limit
is directly set to the highest non-turbo P-state or above it.</p>
</dd>
</dl>
<dl id="status-attr">
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Operation mode of the driver: “active”, “passive” or “off”.</p>
<dl class="simple">
<dt>“active”</dt><dd><p>The driver is functional and in the <a class="reference internal" href="#active-mode">active mode</a>.</p>
</dd>
<dt>“passive”</dt><dd><p>The driver is functional and in the <a class="reference internal" href="#passive-mode">passive mode</a>.</p>
</dd>
<dt>“off”</dt><dd><p>The driver is not functional (it is not registered as a scaling
driver with the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core).</p>
</dd>
</dl>
<p>This attribute can be written to in order to change the driver’s
operation mode or to unregister it.  The string written to it must be
one of the possible values of it and, if successful, the write will
cause the driver to switch over to the operation mode represented by
that string - or to be unregistered in the “off” case.  [Actually,
switching over from the active mode to the passive mode or the other
way around causes the driver to be unregistered and registered again
with a different set of callbacks, so all of its settings (the global
as well as the per-policy ones) are then reset to their default
values, possibly depending on the target operation mode.]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">energy_efficiency</span></code></dt><dd><p>This attribute is only present on platforms with CPUs matching the Kaby
Lake or Coffee Lake desktop CPU model. By default, energy-efficiency
optimizations are disabled on these CPU models if HWP is enabled.
Enabling energy-efficiency optimizations may limit maximum operating
frequency with or without the HWP feature.  With HWP enabled, the
optimizations are done only in the turbo frequency range.  Without it,
they are done in the entire available frequency range.  Setting this
attribute to “1” enables the energy-efficiency optimizations and setting
to “0” disables them.</p>
</dd>
</dl>
</section>
<section id="interpretation-of-policy-attributes">
<h3>Interpretation of Policy Attributes<a class="headerlink" href="#interpretation-of-policy-attributes" title="Permalink to this headline">¶</a></h3>
<p>The interpretation of some <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policy attributes described in
<a class="reference internal" href="cpufreq.html"><span class="doc">CPU Performance Scaling</span></a> is special with <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>
as the current scaling driver and it generally depends on the driver’s
<a class="reference internal" href="#operation-modes">operation mode</a>.</p>
<p>First of all, the values of the <code class="docutils literal notranslate"><span class="pre">cpuinfo_max_freq</span></code>, <code class="docutils literal notranslate"><span class="pre">cpuinfo_min_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code> attributes are produced by applying a processor-specific
multiplier to the internal P-state representation used by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>.
Also, the values of the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code>
attributes are capped by the frequency corresponding to the maximum P-state that
the driver is allowed to set.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code> <a class="reference internal" href="#no-turbo-attr">global attribute</a> is set, the driver is
not allowed to use turbo P-states, so the maximum value of <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code>
and <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> is limited to the maximum non-turbo P-state frequency.
Accordingly, setting <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code> causes <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> to go down to that value if they were above it before.
However, the old values of <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> will be
restored after unsetting <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code>, unless these attributes have been written
to after <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code> was set.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">no_turbo</span></code> is not set, the maximum possible value of <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code>
and <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> corresponds to the maximum supported turbo P-state,
which also is the value of <code class="docutils literal notranslate"><span class="pre">cpuinfo_max_freq</span></code> in either case.</p>
<p>Next, the following policy attributes have special meaning if
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> works in the <a class="reference internal" href="#active-mode">active mode</a>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scaling_available_governors</span></code></dt><dd><p>List of P-state selection algorithms provided by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_governor</span></code></dt><dd><p>P-state selection algorithm provided by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> currently in
use with the given policy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code></dt><dd><p>Frequency of the average P-state of the CPU represented by the given
policy for the time interval between the last two invocations of the
driver’s utilization update callback by the CPU scheduler for that CPU.</p>
</dd>
</dl>
<p>One more policy attribute is present if the HWP feature is enabled in the
processor:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base_frequency</span></code></dt><dd><p>Shows the base frequency of the CPU. Any frequency above this will be
in the turbo frequency range.</p>
</dd>
</dl>
<p>The meaning of these attributes in the <a class="reference internal" href="#passive-mode">passive mode</a> is the
same as for other scaling drivers.</p>
<p>Additionally, the value of the <code class="docutils literal notranslate"><span class="pre">scaling_driver</span></code> attribute for <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>
depends on the operation mode of the driver.  Namely, it is either
“intel_pstate” (in the <a class="reference internal" href="#active-mode">active mode</a>) or “intel_cpufreq” (in the
<a class="reference internal" href="#passive-mode">passive mode</a>).</p>
</section>
<section id="coordination-of-p-state-limits">
<h3>Coordination of P-State Limits<a class="headerlink" href="#coordination-of-p-state-limits" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> allows P-state limits to be set in two ways: with the help of
the <code class="docutils literal notranslate"><span class="pre">max_perf_pct</span></code> and <code class="docutils literal notranslate"><span class="pre">min_perf_pct</span></code> <a class="reference internal" href="#global-attributes">global attributes</a> or via the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code>
<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policy attributes.  The coordination between those limits is based
on the following rules, regardless of the current operation mode of the driver:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>All CPUs are affected by the global limits (that is, none of them can be
requested to run faster than the global maximum and none of them can be
requested to run slower than the global minimum).</p></li>
<li><p>Each individual CPU is affected by its own per-policy limits (that is, it
cannot be requested to run faster than its own per-policy maximum and it
cannot be requested to run slower than its own per-policy minimum). The
effective performance depends on whether the platform supports per core
P-states, hyper-threading is enabled and on current performance requests
from other CPUs. When platform doesn’t support per core P-states, the
effective performance can be more than the policy limits set on a CPU, if
other CPUs are requesting higher performance at that moment. Even with per
core P-states support, when hyper-threading is enabled, if the sibling CPU
is requesting higher performance, the other siblings will get higher
performance than their policy limits.</p></li>
<li><p>The global and per-policy limits can be set independently.</p></li>
</ol>
</div></blockquote>
<p>In the <a class="reference internal" href="#active-mode-with-hwp">active mode with the HWP feature enabled</a>, the
resulting effective values are written into hardware registers whenever the
limits change in order to request its internal P-state selection logic to always
set P-states within these limits.  Otherwise, the limits are taken into account
by scaling governors (in the <a class="reference internal" href="#passive-mode">passive mode</a>) and by the driver
every time before setting a new P-state for a CPU.</p>
<p>Additionally, if the <code class="docutils literal notranslate"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> command line argument
is passed to the kernel, <code class="docutils literal notranslate"><span class="pre">max_perf_pct</span></code> and <code class="docutils literal notranslate"><span class="pre">min_perf_pct</span></code> are not exposed
at all and the only way to set the limits is by using the policy attributes.</p>
</section>
<section id="energy-vs-performance-hints">
<h3>Energy vs Performance Hints<a class="headerlink" href="#energy-vs-performance-hints" title="Permalink to this headline">¶</a></h3>
<p>If the hardware-managed P-states (HWP) is enabled in the processor, additional
attributes, intended to allow user space to help <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> to adjust the
processor’s internal P-state selection logic by focusing it on performance or on
energy-efficiency, or somewhere between the two extremes, are present in every
<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policy directory in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>.  They are :</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">energy_performance_preference</span></code></dt><dd><p>Current value of the energy vs performance hint for the given policy
(or the CPU represented by it).</p>
<p>The hint can be changed by writing to this attribute.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">energy_performance_available_preferences</span></code></dt><dd><p>List of strings that can be written to the
<code class="docutils literal notranslate"><span class="pre">energy_performance_preference</span></code> attribute.</p>
<p>They represent different energy vs performance hints and should be
self-explanatory, except that <code class="docutils literal notranslate"><span class="pre">default</span></code> represents whatever hint
value was set by the platform firmware.</p>
</dd>
</dl>
<p>Strings written to the <code class="docutils literal notranslate"><span class="pre">energy_performance_preference</span></code> attribute are
internally translated to integer values written to the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob. It is also possible to write a positive
integer value between 0 to 255, if the EPP feature is present. If the EPP
feature is not present, writing integer value to this attribute is not
supported. In this case, user can use the
“/sys/devices/system/cpu/cpu*/power/energy_perf_bias” interface.</p>
<p>[Note that tasks may by migrated from one CPU to another by the scheduler’s
load-balancing algorithm and if different energy vs performance hints are
set for those CPUs, that may lead to undesirable outcomes.  To avoid such
issues it is better to set the same energy vs performance hint for all CPUs
or to pin every task potentially sensitive to them to a specific CPU.]</p>
</section>
</section>
<section id="intel-pstate-vs-acpi-cpufreq">
<span id="acpi-cpufreq"></span><h2><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> vs <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code><a class="headerlink" href="#intel-pstate-vs-acpi-cpufreq" title="Permalink to this headline">¶</a></h2>
<p>On the majority of systems supported by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>, the ACPI tables
provided by the platform firmware contain <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> objects returning information
that can be used for CPU performance scaling (refer to the ACPI specification
<a class="footnote-reference brackets" href="#id6" id="id3">3</a> for details on the <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> objects and the format of the information
returned by them).</p>
<p>The information returned by the ACPI <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> objects is used by the
<code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> scaling driver.  On systems supported by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>
the <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> driver uses the same hardware CPU performance scaling
interface, but the set of P-states it can use is limited by the <code class="docutils literal notranslate"><span class="pre">_PSS</span></code>
output.</p>
<p>On those systems each <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> object returns a list of P-states supported by
the corresponding CPU which basically is a subset of the P-states range that can
be used by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> on the same system, with one exception: the whole
<a class="reference internal" href="#turbo">turbo range</a> is represented by one item in it (the topmost one).  By
convention, the frequency returned by <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> for that item is greater by 1 MHz
than the frequency of the highest non-turbo P-state listed by it, but the
corresponding P-state representation (following the hardware specification)
returned for it matches the maximum supported turbo P-state (or is the
special value 255 meaning essentially “go as high as you can get”).</p>
<p>The list of P-states returned by <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> is reflected by the table of
available frequencies supplied by <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> to the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core and
scaling governors and the minimum and maximum supported frequencies reported by
it come from that list as well.  In particular, given the special representation
of the turbo range described above, this means that the maximum supported
frequency reported by <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> is higher by 1 MHz than the frequency
of the highest supported non-turbo P-state listed by <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> which, of course,
affects decisions made by the scaling governors, except for <code class="docutils literal notranslate"><span class="pre">powersave</span></code> and
<code class="docutils literal notranslate"><span class="pre">performance</span></code>.</p>
<p>For example, if a given governor attempts to select a frequency proportional to
estimated CPU load and maps the load of 100% to the maximum supported frequency
(possibly multiplied by a constant), then it will tend to choose P-states below
the turbo threshold if <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> is used as the scaling driver, because
in that case the turbo range corresponds to a small fraction of the frequency
band it can use (1 MHz vs 1 GHz or more).  In consequence, it will only go to
the turbo range for the highest loads and the other loads above 50% that might
benefit from running at turbo frequencies will be given non-turbo P-states
instead.</p>
<p>One more issue related to that may appear on systems supporting the
<a class="reference internal" href="#turbo">Configurable TDP feature</a> allowing the platform firmware to set the
turbo threshold.  Namely, if that is not coordinated with the lists of P-states
returned by <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> properly, there may be more than one item corresponding to
a turbo P-state in those lists and there may be a problem with avoiding the
turbo range (if desirable or necessary).  Usually, to avoid using turbo
P-states overall, <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> simply avoids using the topmost state listed
by <code class="docutils literal notranslate"><span class="pre">_PSS</span></code>, but that is not sufficient when there are other turbo P-states in
the list returned by it.</p>
<p>Apart from the above, <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> works like <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> in the
<a class="reference internal" href="#passive-mode">passive mode</a>, except that the number of P-states it can set
is limited to the ones listed by the ACPI <code class="docutils literal notranslate"><span class="pre">_PSS</span></code> objects.</p>
</section>
<section id="kernel-command-line-options-for-intel-pstate">
<h2>Kernel Command Line Options for <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code><a class="headerlink" href="#kernel-command-line-options-for-intel-pstate" title="Permalink to this headline">¶</a></h2>
<p>Several kernel command line options can be used to pass early-configuration-time
parameters to <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> in order to enforce specific behavior of it.  All
of them have to be prepended with the <code class="docutils literal notranslate"><span class="pre">intel_pstate=</span></code> prefix.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Do not register <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> as the scaling driver even if the
processor is supported by it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt><dd><p>Register <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> in the <a class="reference internal" href="#active-mode">active mode</a> to start
with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">passive</span></code></dt><dd><p>Register <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> in the <a class="reference internal" href="#passive-mode">passive mode</a> to
start with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force</span></code></dt><dd><p>Register <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> as the scaling driver instead of
<code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code> even if the latter is preferred on the given system.</p>
<p>This may prevent some platform features (such as thermal controls and
power capping) that rely on the availability of ACPI P-states
information from functioning as expected, so it should be used with
caution.</p>
<p>This option does not work with processors that are not supported by
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> and on platforms where the <code class="docutils literal notranslate"><span class="pre">pcc-cpufreq</span></code> scaling
driver is used instead of <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_hwp</span></code></dt><dd><p>Do not enable the hardware-managed P-states (HWP) feature even if it is
supported by the processor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwp_only</span></code></dt><dd><p>Register <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> as the scaling driver only if the
hardware-managed P-states (HWP) feature is supported by the processor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">support_acpi_ppc</span></code></dt><dd><p>Take ACPI <code class="docutils literal notranslate"><span class="pre">_PPC</span></code> performance limits into account.</p>
<p>If the preferred power management profile in the FADT (Fixed ACPI
Description Table) is set to “Enterprise Server” or “Performance
Server”, the ACPI <code class="docutils literal notranslate"><span class="pre">_PPC</span></code> limits are taken into account by default
and this option has no effect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">per_cpu_perf_limits</span></code></dt><dd><p>Use per-logical-CPU P-State limits (see <a class="reference internal" href="#coordination-of-p-state-limits">Coordination of P-state
Limits</a> for details).</p>
</dd>
</dl>
</section>
<section id="diagnostics-and-tuning">
<h2>Diagnostics and Tuning<a class="headerlink" href="#diagnostics-and-tuning" title="Permalink to this headline">¶</a></h2>
<section id="trace-events">
<h3>Trace Events<a class="headerlink" href="#trace-events" title="Permalink to this headline">¶</a></h3>
<p>There are two static trace events that can be used for <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>
diagnostics.  One of them is the <code class="docutils literal notranslate"><span class="pre">cpu_frequency</span></code> trace event generally used
by <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code>, and the other one is the <code class="docutils literal notranslate"><span class="pre">pstate_sample</span></code> trace event specific
to <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>.  Both of them are triggered by <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> only if
it works in the <a class="reference internal" href="#active-mode">active mode</a>.</p>
<p>The following sequence of shell commands can be used to enable them and see
their output (if the kernel is generally configured to support event tracing):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cd /sys/kernel/debug/tracing/
# echo 1 &gt; events/power/pstate_sample/enable
# echo 1 &gt; events/power/cpu_frequency/enable
# cat trace
gnome-terminal--4510  [001] ..s.  1177.680733: pstate_sample: core_busy=107 scaled=94 from=26 to=26 mperf=1143818 aperf=1230607 tsc=29838618 freq=2474476
cat-5235  [002] ..s.  1177.681723: cpu_frequency: state=2900000 cpu_id=2
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> works in the <a class="reference internal" href="#passive-mode">passive mode</a>, the
<code class="docutils literal notranslate"><span class="pre">cpu_frequency</span></code> trace event will be triggered either by the <code class="docutils literal notranslate"><span class="pre">schedutil</span></code>
scaling governor (for the policies it is attached to), or by the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code>
core (for the policies with other scaling governors).</p>
</section>
<section id="ftrace">
<h3><code class="docutils literal notranslate"><span class="pre">ftrace</span></code><a class="headerlink" href="#ftrace" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ftrace</span></code> interface can be used for low-level diagnostics of
<code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code>.  For example, to check how often the function to set a
P-state is called, the <code class="docutils literal notranslate"><span class="pre">ftrace</span></code> filter can be set to
<code class="xref c c-func docutils literal notranslate"><span class="pre">intel_pstate_set_pstate()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cd /sys/kernel/debug/tracing/
# cat available_filter_functions | grep -i pstate
intel_pstate_set_pstate
intel_pstate_cpu_init
...
# echo intel_pstate_set_pstate &gt; set_ftrace_filter
# echo function &gt; current_tracer
# cat trace | head -15
# tracer: function
#
# entries-in-buffer/entries-written: 80/80   #P:4
#
#                              _-----=&gt; irqs-off
#                             / _----=&gt; need-resched
#                            | / _---=&gt; hardirq/softirq
#                            || / _--=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
            Xorg-3129  [000] ..s.  2537.644844: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
 gnome-terminal--4510  [002] ..s.  2537.649844: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
     gnome-shell-3409  [001] ..s.  2537.650850: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
          &lt;idle&gt;-0     [000] ..s.  2537.654843: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
</pre></div>
</div>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Kristen Accardi, <em>Balancing Power and Performance in the Linux Kernel</em>,
<a class="reference external" href="https://events.static.linuxfound.org/sites/events/files/slides/LinuxConEurope_2015.pdf">https://events.static.linuxfound.org/sites/events/files/slides/LinuxConEurope_2015.pdf</a></p>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><em>Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3: System Programming Guide</em>,
<a class="reference external" href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html">https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html</a></p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><em>Advanced Configuration and Power Interface Specification</em>,
<a class="reference external" href="https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf">https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf</a></p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> CPU Performance Scaling Driver</a><ul>
<li><a class="reference internal" href="#general-information">General Information</a></li>
<li><a class="reference internal" href="#operation-modes">Operation Modes</a><ul>
<li><a class="reference internal" href="#active-mode">Active Mode</a><ul>
<li><a class="reference internal" href="#active-mode-with-hwp">Active Mode With HWP</a><ul>
<li><a class="reference internal" href="#hwp-performance">HWP + <code class="docutils literal notranslate"><span class="pre">performance</span></code></a></li>
<li><a class="reference internal" href="#hwp-powersave">HWP + <code class="docutils literal notranslate"><span class="pre">powersave</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#active-mode-without-hwp">Active Mode Without HWP</a><ul>
<li><a class="reference internal" href="#performance"><code class="docutils literal notranslate"><span class="pre">performance</span></code></a></li>
<li><a class="reference internal" href="#powersave"><code class="docutils literal notranslate"><span class="pre">powersave</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#passive-mode">Passive Mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#turbo-p-states-support">Turbo P-states Support</a></li>
<li><a class="reference internal" href="#processor-support">Processor Support</a></li>
<li><a class="reference internal" href="#user-space-interface-in-sysfs">User Space Interface in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code></a><ul>
<li><a class="reference internal" href="#global-attributes">Global Attributes</a></li>
<li><a class="reference internal" href="#interpretation-of-policy-attributes">Interpretation of Policy Attributes</a></li>
<li><a class="reference internal" href="#coordination-of-p-state-limits">Coordination of P-State Limits</a></li>
<li><a class="reference internal" href="#energy-vs-performance-hints">Energy vs Performance Hints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#intel-pstate-vs-acpi-cpufreq"><code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code> vs <code class="docutils literal notranslate"><span class="pre">acpi-cpufreq</span></code></a></li>
<li><a class="reference internal" href="#kernel-command-line-options-for-intel-pstate">Kernel Command Line Options for <code class="docutils literal notranslate"><span class="pre">intel_pstate</span></code></a></li>
<li><a class="reference internal" href="#diagnostics-and-tuning">Diagnostics and Tuning</a><ul>
<li><a class="reference internal" href="#trace-events">Trace Events</a></li>
<li><a class="reference internal" href="#ftrace"><code class="docutils literal notranslate"><span class="pre">ftrace</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/pm/intel_pstate.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/pm/intel_pstate.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>