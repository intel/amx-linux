
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>CPU Performance Scaling &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="intel_pstate CPU Performance Scaling Driver" href="intel_pstate.html" />
    <link rel="prev" title="intel_idle CPU Idle Time Management Driver" href="intel_idle.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="cpu-performance-scaling">
<h1>CPU Performance Scaling<a class="headerlink" href="#cpu-performance-scaling" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2017 Intel Corporation</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rafael&#46;j&#46;wysocki&#37;&#52;&#48;intel&#46;com">rafael<span>&#46;</span>j<span>&#46;</span>wysocki<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<section id="the-concept-of-cpu-performance-scaling">
<h2>The Concept of CPU Performance Scaling<a class="headerlink" href="#the-concept-of-cpu-performance-scaling" title="Permalink to this headline">¶</a></h2>
<p>The majority of modern processors are capable of operating in a number of
different clock frequency and voltage configurations, often referred to as
Operating Performance Points or P-states (in ACPI terminology).  As a rule,
the higher the clock frequency and the higher the voltage, the more instructions
can be retired by the CPU over a unit of time, but also the higher the clock
frequency and the higher the voltage, the more energy is consumed over a unit of
time (or the more power is drawn) by the CPU in the given P-state.  Therefore
there is a natural tradeoff between the CPU capacity (the number of instructions
that can be executed over a unit of time) and the power drawn by the CPU.</p>
<p>In some situations it is desirable or even necessary to run the program as fast
as possible and then there is no reason to use any P-states different from the
highest one (i.e. the highest-performance frequency/voltage configuration
available).  In some other cases, however, it may not be necessary to execute
instructions so quickly and maintaining the highest available CPU capacity for a
relatively long time without utilizing it entirely may be regarded as wasteful.
It also may not be physically possible to maintain maximum CPU capacity for too
long for thermal or power supply capacity reasons or similar.  To cover those
cases, there are hardware interfaces allowing CPUs to be switched between
different frequency/voltage configurations or (in the ACPI terminology) to be
put into different P-states.</p>
<p>Typically, they are used along with algorithms to estimate the required CPU
capacity, so as to decide which P-states to put the CPUs into.  Of course, since
the utilization of the system generally changes over time, that has to be done
repeatedly on a regular basis.  The activity by which this happens is referred
to as CPU performance scaling or CPU frequency scaling (because it involves
adjusting the CPU clock frequency).</p>
</section>
<section id="cpu-performance-scaling-in-linux">
<h2>CPU Performance Scaling in Linux<a class="headerlink" href="#cpu-performance-scaling-in-linux" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel supports CPU performance scaling by means of the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code>
(CPU Frequency scaling) subsystem that consists of three layers of code: the
core, scaling governors and scaling drivers.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core provides the common code infrastructure and user space
interfaces for all platforms that support CPU performance scaling.  It defines
the basic framework in which the other components operate.</p>
<p>Scaling governors implement algorithms to estimate the required CPU capacity.
As a rule, each governor implements one, possibly parametrized, scaling
algorithm.</p>
<p>Scaling drivers talk to the hardware.  They provide scaling governors with
information on the available P-states (or P-state ranges in some cases) and
access platform-specific hardware interfaces to change CPU P-states as requested
by scaling governors.</p>
<p>In principle, all available scaling governors can be used with every scaling
driver.  That design is based on the observation that the information used by
performance scaling algorithms for P-state selection can be represented in a
platform-independent form in the majority of cases, so it should be possible
to use the same performance scaling algorithm implemented in exactly the same
way regardless of which scaling driver is used.  Consequently, the same set of
scaling governors should be suitable for every supported platform.</p>
<p>However, that observation may not hold for performance scaling algorithms
based on information provided by the hardware itself, for example through
feedback registers, as that information is typically specific to the hardware
interface it comes from and may not be easily represented in an abstract,
platform-independent way.  For this reason, <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> allows scaling drivers
to bypass the governor layer and implement their own performance scaling
algorithms.  That is done by the <a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> scaling driver.</p>
</section>
<section id="cpufreq-policy-objects">
<h2><code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> Policy Objects<a class="headerlink" href="#cpufreq-policy-objects" title="Permalink to this headline">¶</a></h2>
<p>In some cases the hardware interface for P-state control is shared by multiple
CPUs.  That is, for example, the same register (or set of registers) is used to
control the P-state of multiple CPUs at the same time and writing to it affects
all of those CPUs simultaneously.</p>
<p>Sets of CPUs sharing hardware P-state control interfaces are represented by
<code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> as struct cpufreq_policy objects.  For consistency,
struct cpufreq_policy is also used when there is only one CPU in the given
set.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core maintains a pointer to a struct cpufreq_policy object for
every CPU in the system, including CPUs that are currently offline.  If multiple
CPUs share the same hardware P-state control interface, all of the pointers
corresponding to them point to the same struct cpufreq_policy object.</p>
<p><code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> uses struct cpufreq_policy as its basic data type and the design
of its user space interface is based on the policy concept.</p>
</section>
<section id="cpu-initialization">
<h2>CPU Initialization<a class="headerlink" href="#cpu-initialization" title="Permalink to this headline">¶</a></h2>
<p>First of all, a scaling driver has to be registered for <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> to work.
It is only possible to register one scaling driver at a time, so the scaling
driver is expected to be able to handle all CPUs in the system.</p>
<p>The scaling driver may be registered before or after CPU registration.  If
CPUs are registered earlier, the driver core invokes the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core to
take a note of all of the already registered CPUs during the registration of the
scaling driver.  In turn, if any CPUs are registered after the registration of
the scaling driver, the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core will be invoked to take note of them
at their registration time.</p>
<p>In any case, the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core is invoked to take note of any logical CPU it
has not seen so far as soon as it is ready to handle that CPU.  [Note that the
logical CPU may be a physical single-core processor, or a single core in a
multicore processor, or a hardware thread in a physical processor or processor
core.  In what follows “CPU” always means “logical CPU” unless explicitly stated
otherwise and the word “processor” is used to refer to the physical part
possibly including multiple logical CPUs.]</p>
<p>Once invoked, the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core checks if the policy pointer is already set
for the given CPU and if so, it skips the policy object creation.  Otherwise,
a new policy object is created and initialized, which involves the creation of
a new policy directory in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>, and the policy pointer corresponding to
the given CPU is set to the new policy object’s address in memory.</p>
<p>Next, the scaling driver’s <code class="docutils literal notranslate"><span class="pre">-&gt;init()</span></code> callback is invoked with the policy
pointer of the new CPU passed to it as the argument.  That callback is expected
to initialize the performance scaling hardware interface for the given CPU (or,
more precisely, for the set of CPUs sharing the hardware interface it belongs
to, represented by its policy object) and, if the policy object it has been
called for is new, to set parameters of the policy, like the minimum and maximum
frequencies supported by the hardware, the table of available frequencies (if
the set of supported P-states is not a continuous range), and the mask of CPUs
that belong to the same policy (including both online and offline CPUs).  That
mask is then used by the core to populate the policy pointers for all of the
CPUs in it.</p>
<p>The next major initialization step for a new policy object is to attach a
scaling governor to it (to begin with, that is the default scaling governor
determined by the kernel command line or configuration, but it may be changed
later via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>).  First, a pointer to the new policy object is passed to
the governor’s <code class="docutils literal notranslate"><span class="pre">-&gt;init()</span></code> callback which is expected to initialize all of the
data structures necessary to handle the given policy and, possibly, to add
a governor <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> interface to it.  Next, the governor is started by
invoking its <code class="docutils literal notranslate"><span class="pre">-&gt;start()</span></code> callback.</p>
<p>That callback is expected to register per-CPU utilization update callbacks for
all of the online CPUs belonging to the given policy with the CPU scheduler.
The utilization update callbacks will be invoked by the CPU scheduler on
important events, like task enqueue and dequeue, on every iteration of the
scheduler tick or generally whenever the CPU utilization may change (from the
scheduler’s perspective).  They are expected to carry out computations needed
to determine the P-state to use for the given policy going forward and to
invoke the scaling driver to make changes to the hardware in accordance with
the P-state selection.  The scaling driver may be invoked directly from
scheduler context or asynchronously, via a kernel thread or workqueue, depending
on the configuration and capabilities of the scaling driver and the governor.</p>
<p>Similar steps are taken for policy objects that are not new, but were “inactive”
previously, meaning that all of the CPUs belonging to them were offline.  The
only practical difference in that case is that the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core will attempt
to use the scaling governor previously used with the policy that became
“inactive” (and is re-initialized now) instead of the default governor.</p>
<p>In turn, if a previously offline CPU is being brought back online, but some
other CPUs sharing the policy object with it are online already, there is no
need to re-initialize the policy object at all.  In that case, it only is
necessary to restart the scaling governor so that it can take the new online CPU
into account.  That is achieved by invoking the governor’s <code class="docutils literal notranslate"><span class="pre">-&gt;stop</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;start()</span></code> callbacks, in this order, for the entire policy.</p>
<p>As mentioned before, the <a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> scaling driver bypasses the scaling
governor layer of <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> and provides its own P-state selection algorithms.
Consequently, if <a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> is used, scaling governors are not attached to
new policy objects.  Instead, the driver’s <code class="docutils literal notranslate"><span class="pre">-&gt;setpolicy()</span></code> callback is invoked
to register per-CPU utilization update callbacks for each policy.  These
callbacks are invoked by the CPU scheduler in the same way as for scaling
governors, but in the <a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> case they both determine the P-state to
use and change the hardware configuration accordingly in one go from scheduler
context.</p>
<p>The policy objects created during CPU initialization and other data structures
associated with them are torn down when the scaling driver is unregistered
(which happens when the kernel module containing it is unloaded, for example) or
when the last CPU belonging to the given policy in unregistered.</p>
</section>
<section id="policy-interface-in-sysfs">
<h2>Policy Interface in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code><a class="headerlink" href="#policy-interface-in-sysfs" title="Permalink to this headline">¶</a></h2>
<p>During the initialization of the kernel, the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core creates a
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code> directory (kobject) called <code class="docutils literal notranslate"><span class="pre">cpufreq</span></code> under
<code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/</span></code>.</p>
<p>That directory contains a <code class="docutils literal notranslate"><span class="pre">policyX</span></code> subdirectory (where <code class="docutils literal notranslate"><span class="pre">X</span></code> represents an
integer number) for every policy object maintained by the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core.
Each <code class="docutils literal notranslate"><span class="pre">policyX</span></code> directory is pointed to by <code class="docutils literal notranslate"><span class="pre">cpufreq</span></code> symbolic links
under <code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpuY/</span></code> (where <code class="docutils literal notranslate"><span class="pre">Y</span></code> represents an integer
that may be different from the one represented by <code class="docutils literal notranslate"><span class="pre">X</span></code>) for all of the CPUs
associated with (or belonging to) the given policy.  The <code class="docutils literal notranslate"><span class="pre">policyX</span></code> directories
in <code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpufreq</span></code> each contain policy-specific
attributes (files) to control <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> behavior for the corresponding policy
objects (that is, for all of the CPUs associated with them).</p>
<p>Some of those attributes are generic.  They are created by the <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> core
and their behavior generally does not depend on what scaling driver is in use
and what scaling governor is attached to the given policy.  Some scaling drivers
also add driver-specific attributes to the policy directories in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> to
control policy-specific aspects of driver behavior.</p>
<p>The generic attributes under <code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpufreq/policyX/</span></code>
are the following:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">affected_cpus</span></code></dt><dd><p>List of online CPUs belonging to this policy (i.e. sharing the hardware
performance scaling interface represented by the <code class="docutils literal notranslate"><span class="pre">policyX</span></code> policy
object).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bios_limit</span></code></dt><dd><p>If the platform firmware (BIOS) tells the OS to apply an upper limit to
CPU frequencies, that limit will be reported through this attribute (if
present).</p>
<p>The existence of the limit may be a result of some (often unintentional)
BIOS settings, restrictions coming from a service processor or another
BIOS/HW-based mechanisms.</p>
<p>This does not cover ACPI thermal limitations which can be discovered
through a generic thermal driver.</p>
<p>This attribute is not present if the scaling driver in use does not
support it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpuinfo_cur_freq</span></code></dt><dd><p>Current frequency of the CPUs belonging to this policy as obtained from
the hardware (in KHz).</p>
<p>This is expected to be the frequency the hardware actually runs at.
If that frequency cannot be determined, this attribute should not
be present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpuinfo_max_freq</span></code></dt><dd><p>Maximum possible operating frequency the CPUs belonging to this policy
can run at (in kHz).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpuinfo_min_freq</span></code></dt><dd><p>Minimum possible operating frequency the CPUs belonging to this policy
can run at (in kHz).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpuinfo_transition_latency</span></code></dt><dd><p>The time it takes to switch the CPUs belonging to this policy from one
P-state to another, in nanoseconds.</p>
<p>If unknown or if known to be so high that the scaling driver does not
work with the <a class="reference internal" href="#ondemand">ondemand</a> governor, -1 (<code class="xref c c-macro docutils literal notranslate"><span class="pre">CPUFREQ_ETERNAL</span></code>)
will be returned by reads from this attribute.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">related_cpus</span></code></dt><dd><p>List of all (online and offline) CPUs belonging to this policy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_available_governors</span></code></dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> scaling governors present in the kernel that can
be attached to this policy or (if the <a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> scaling driver is
in use) list of scaling algorithms provided by the driver that can be
applied to this policy.</p>
<p>[Note that some governors are modular and it may be necessary to load a
kernel module for the governor held by it to become available and be
listed by this attribute.]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_cur_freq</span></code></dt><dd><p>Current frequency of all of the CPUs belonging to this policy (in kHz).</p>
<p>In the majority of cases, this is the frequency of the last P-state
requested by the scaling driver from the hardware using the scaling
interface provided by it, which may or may not reflect the frequency
the CPU is actually running at (due to hardware design and other
limitations).</p>
<p>Some architectures (e.g. <code class="docutils literal notranslate"><span class="pre">x86</span></code>) may attempt to provide information
more precisely reflecting the current CPU frequency through this
attribute, but that still may not be the exact current CPU frequency as
seen by the hardware at the moment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_driver</span></code></dt><dd><p>The scaling driver currently in use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_governor</span></code></dt><dd><p>The scaling governor currently attached to this policy or (if the
<a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> scaling driver is in use) the scaling algorithm
provided by the driver that is currently applied to this policy.</p>
<p>This attribute is read-write and writing to it will cause a new scaling
governor to be attached to this policy or a new scaling algorithm
provided by the scaling driver to be applied to it (in the
<a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a> case), as indicated by the string written to this
attribute (which must be one of the names listed by the
<code class="docutils literal notranslate"><span class="pre">scaling_available_governors</span></code> attribute described above).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code></dt><dd><p>Maximum frequency the CPUs belonging to this policy are allowed to be
running at (in kHz).</p>
<p>This attribute is read-write and writing a string representing an
integer to it will cause a new limit to be set (it must not be lower
than the value of the <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> attribute).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code></dt><dd><p>Minimum frequency the CPUs belonging to this policy are allowed to be
running at (in kHz).</p>
<p>This attribute is read-write and writing a string representing a
non-negative integer to it will cause a new limit to be set (it must not
be higher than the value of the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> attribute).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_setspeed</span></code></dt><dd><p>This attribute is functional only if the <a class="reference internal" href="#userspace">userspace</a> scaling governor
is attached to the given policy.</p>
<p>It returns the last frequency requested by the governor (in kHz) or can
be written to in order to set a new frequency for the policy.</p>
</dd>
</dl>
</section>
<section id="generic-scaling-governors">
<h2>Generic Scaling Governors<a class="headerlink" href="#generic-scaling-governors" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> provides generic scaling governors that can be used with all
scaling drivers.  As stated before, each of them implements a single, possibly
parametrized, performance scaling algorithm.</p>
<p>Scaling governors are attached to policy objects and different policy objects
can be handled by different scaling governors at the same time (although that
may lead to suboptimal results in some cases).</p>
<p>The scaling governor for a given policy object can be changed at any time with
the help of the <code class="docutils literal notranslate"><span class="pre">scaling_governor</span></code> policy attribute in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>.</p>
<p>Some governors expose <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> attributes to control or fine-tune the scaling
algorithms implemented by them.  Those attributes, referred to as governor
tunables, can be either global (system-wide) or per-policy, depending on the
scaling driver in use.  If the driver requires governor tunables to be
per-policy, they are located in a subdirectory of each policy directory.
Otherwise, they are located in a subdirectory under
<code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpufreq/</span></code>.  In either case the name of the
subdirectory containing the governor tunables is the name of the governor
providing them.</p>
<section id="performance">
<h3><code class="docutils literal notranslate"><span class="pre">performance</span></code><a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>When attached to a policy object, this governor causes the highest frequency,
within the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> policy limit, to be requested for that policy.</p>
<p>The request is made once at that time the governor for the policy is set to
<code class="docutils literal notranslate"><span class="pre">performance</span></code> and whenever the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> or <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code>
policy limits change after that.</p>
</section>
<section id="powersave">
<h3><code class="docutils literal notranslate"><span class="pre">powersave</span></code><a class="headerlink" href="#powersave" title="Permalink to this headline">¶</a></h3>
<p>When attached to a policy object, this governor causes the lowest frequency,
within the <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> policy limit, to be requested for that policy.</p>
<p>The request is made once at that time the governor for the policy is set to
<code class="docutils literal notranslate"><span class="pre">powersave</span></code> and whenever the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> or <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code>
policy limits change after that.</p>
</section>
<section id="userspace">
<h3><code class="docutils literal notranslate"><span class="pre">userspace</span></code><a class="headerlink" href="#userspace" title="Permalink to this headline">¶</a></h3>
<p>This governor does not do anything by itself.  Instead, it allows user space
to set the CPU frequency for the policy it is attached to by writing to the
<code class="docutils literal notranslate"><span class="pre">scaling_setspeed</span></code> attribute of that policy.</p>
</section>
<section id="schedutil">
<h3><code class="docutils literal notranslate"><span class="pre">schedutil</span></code><a class="headerlink" href="#schedutil" title="Permalink to this headline">¶</a></h3>
<p>This governor uses CPU utilization data available from the CPU scheduler.  It
generally is regarded as a part of the CPU scheduler, so it can access the
scheduler’s internal data structures directly.</p>
<p>It runs entirely in scheduler context, although in some cases it may need to
invoke the scaling driver asynchronously when it decides that the CPU frequency
should be changed for a given policy (that depends on whether or not the driver
is capable of changing the CPU frequency from scheduler context).</p>
<p>The actions of this governor for a particular CPU depend on the scheduling class
invoking its utilization update callback for that CPU.  If it is invoked by the
RT or deadline scheduling classes, the governor will increase the frequency to
the allowed maximum (that is, the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> policy limit).  In turn,
if it is invoked by the CFS scheduling class, the governor will use the
Per-Entity Load Tracking (PELT) metric for the root control group of the
given CPU as the CPU utilization estimate (see the <em>Per-entity load tracking</em>
LWN.net article <a class="footnote-reference brackets" href="#id2" id="id1">1</a> for a description of the PELT mechanism).  Then, the new
CPU frequency to apply is computed in accordance with the formula</p>
<blockquote>
<div><p>f = 1.25 * <code class="docutils literal notranslate"><span class="pre">f_0</span></code> * <code class="docutils literal notranslate"><span class="pre">util</span></code> / <code class="docutils literal notranslate"><span class="pre">max</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">util</span></code> is the PELT number, <code class="docutils literal notranslate"><span class="pre">max</span></code> is the theoretical maximum of
<code class="docutils literal notranslate"><span class="pre">util</span></code>, and <code class="docutils literal notranslate"><span class="pre">f_0</span></code> is either the maximum possible CPU frequency for the given
policy (if the PELT number is frequency-invariant), or the current CPU frequency
(otherwise).</p>
<p>This governor also employs a mechanism allowing it to temporarily bump up the
CPU frequency for tasks that have been waiting on I/O most recently, called
“IO-wait boosting”.  That happens when the <code class="xref c c-macro docutils literal notranslate"><span class="pre">SCHED_CPUFREQ_IOWAIT</span></code> flag
is passed by the scheduler to the governor callback which causes the frequency
to go up to the allowed maximum immediately and then draw back to the value
returned by the above formula over time.</p>
<p>This governor exposes only one tunable:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">rate_limit_us</span></code></dt><dd><p>Minimum time (in microseconds) that has to pass between two consecutive
runs of governor computations (default: 1000 times the scaling driver’s
transition latency).</p>
<p>The purpose of this tunable is to reduce the scheduler context overhead
of the governor which might be excessive without it.</p>
</dd>
</dl>
<p>This governor generally is regarded as a replacement for the older <a class="reference internal" href="#ondemand">ondemand</a>
and <a class="reference internal" href="#conservative">conservative</a> governors (described below), as it is simpler and more
tightly integrated with the CPU scheduler, its overhead in terms of CPU context
switches and similar is less significant, and it uses the scheduler’s own CPU
utilization metric, so in principle its decisions should not contradict the
decisions made by the other parts of the scheduler.</p>
</section>
<section id="ondemand">
<h3><code class="docutils literal notranslate"><span class="pre">ondemand</span></code><a class="headerlink" href="#ondemand" title="Permalink to this headline">¶</a></h3>
<p>This governor uses CPU load as a CPU frequency selection metric.</p>
<p>In order to estimate the current CPU load, it measures the time elapsed between
consecutive invocations of its worker routine and computes the fraction of that
time in which the given CPU was not idle.  The ratio of the non-idle (active)
time to the total CPU time is taken as an estimate of the load.</p>
<p>If this governor is attached to a policy shared by multiple CPUs, the load is
estimated for all of them and the greatest result is taken as the load estimate
for the entire policy.</p>
<p>The worker routine of this governor has to run in process context, so it is
invoked asynchronously (via a workqueue) and CPU P-states are updated from
there if necessary.  As a result, the scheduler context overhead from this
governor is minimum, but it causes additional CPU context switches to happen
relatively often and the CPU P-state updates triggered by it can be relatively
irregular.  Also, it affects its own CPU load metric by running code that
reduces the CPU idle time (even though the CPU idle time is only reduced very
slightly by it).</p>
<p>It generally selects CPU frequencies proportional to the estimated load, so that
the value of the <code class="docutils literal notranslate"><span class="pre">cpuinfo_max_freq</span></code> policy attribute corresponds to the load of
1 (or 100%), and the value of the <code class="docutils literal notranslate"><span class="pre">cpuinfo_min_freq</span></code> policy attribute
corresponds to the load of 0, unless when the load exceeds a (configurable)
speedup threshold, in which case it will go straight for the highest frequency
it is allowed to use (the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> policy limit).</p>
<p>This governor exposes the following tunables:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code></dt><dd><p>This is how often the governor’s worker routine should run, in
microseconds.</p>
<p>Typically, it is set to values of the order of 10000 (10 ms).  Its
default value is equal to the value of <code class="docutils literal notranslate"><span class="pre">cpuinfo_transition_latency</span></code>
for each policy this governor is attached to (but since the unit here
is greater by 1000, this means that the time represented by
<code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code> is 1000 times greater than the transition latency by
default).</p>
<p>If this tunable is per-policy, the following shell command sets the time
represented by it to be 750 times as high as the transition latency:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo `$(($(cat cpuinfo_transition_latency) * 750 / 1000)) &gt; ondemand/sampling_rate
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_threshold</span></code></dt><dd><p>If the estimated CPU load is above this value (in percent), the governor
will set the frequency to the maximum value allowed for the policy.
Otherwise, the selected frequency will be proportional to the estimated
CPU load.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore_nice_load</span></code></dt><dd><p>If set to 1 (default 0), it will cause the CPU load estimation code to
treat the CPU time spent on executing tasks with “nice” levels greater
than 0 as CPU idle time.</p>
<p>This may be useful if there are tasks in the system that should not be
taken into account when deciding what frequency to run the CPUs at.
Then, to make that happen it is sufficient to increase the “nice” level
of those tasks above 0 and set this attribute to 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_down_factor</span></code></dt><dd><p>Temporary multiplier, between 1 (default) and 100 inclusive, to apply to
the <code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code> value if the CPU load goes above <code class="docutils literal notranslate"><span class="pre">up_threshold</span></code>.</p>
<p>This causes the next execution of the governor’s worker routine (after
setting the frequency to the allowed maximum) to be delayed, so the
frequency stays at the maximum level for a longer time.</p>
<p>Frequency fluctuations in some bursty workloads may be avoided this way
at the cost of additional energy spent on maintaining the maximum CPU
capacity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">powersave_bias</span></code></dt><dd><p>Reduction factor to apply to the original frequency target of the
governor (including the maximum value used when the <code class="docutils literal notranslate"><span class="pre">up_threshold</span></code>
value is exceeded by the estimated CPU load) or sensitivity threshold
for the AMD frequency sensitivity powersave bias driver
(<code class="file docutils literal notranslate"><span class="pre">drivers/cpufreq/amd_freq_sensitivity.c</span></code>), between 0 and 1000
inclusive.</p>
<p>If the AMD frequency sensitivity powersave bias driver is not loaded,
the effective frequency to apply is given by</p>
<blockquote>
<div><p>f * (1 - <code class="docutils literal notranslate"><span class="pre">powersave_bias</span></code> / 1000)</p>
</div></blockquote>
<p>where f is the governor’s original frequency target.  The default value
of this attribute is 0 in that case.</p>
<p>If the AMD frequency sensitivity powersave bias driver is loaded, the
value of this attribute is 400 by default and it is used in a different
way.</p>
<p>On Family 16h (and later) AMD processors there is a mechanism to get a
measured workload sensitivity, between 0 and 100% inclusive, from the
hardware.  That value can be used to estimate how the performance of the
workload running on a CPU will change in response to frequency changes.</p>
<p>The performance of a workload with the sensitivity of 0 (memory-bound or
IO-bound) is not expected to increase at all as a result of increasing
the CPU frequency, whereas workloads with the sensitivity of 100%
(CPU-bound) are expected to perform much better if the CPU frequency is
increased.</p>
<p>If the workload sensitivity is less than the threshold represented by
the <code class="docutils literal notranslate"><span class="pre">powersave_bias</span></code> value, the sensitivity powersave bias driver
will cause the governor to select a frequency lower than its original
target, so as to avoid over-provisioning workloads that will not benefit
from running at higher CPU frequencies.</p>
</dd>
</dl>
</section>
<section id="conservative">
<h3><code class="docutils literal notranslate"><span class="pre">conservative</span></code><a class="headerlink" href="#conservative" title="Permalink to this headline">¶</a></h3>
<p>This governor uses CPU load as a CPU frequency selection metric.</p>
<p>It estimates the CPU load in the same way as the <a class="reference internal" href="#ondemand">ondemand</a> governor described
above, but the CPU frequency selection algorithm implemented by it is different.</p>
<p>Namely, it avoids changing the frequency significantly over short time intervals
which may not be suitable for systems with limited power supply capacity (e.g.
battery-powered).  To achieve that, it changes the frequency in relatively
small steps, one step at a time, up or down - depending on whether or not a
(configurable) threshold has been exceeded by the estimated CPU load.</p>
<p>This governor exposes the following tunables:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">freq_step</span></code></dt><dd><p>Frequency step in percent of the maximum frequency the governor is
allowed to set (the <code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> policy limit), between 0 and
100 (5 by default).</p>
<p>This is how much the frequency is allowed to change in one go.  Setting
it to 0 will cause the default frequency step (5 percent) to be used
and setting it to 100 effectively causes the governor to periodically
switch the frequency between the <code class="docutils literal notranslate"><span class="pre">scaling_min_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">scaling_max_freq</span></code> policy limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">down_threshold</span></code></dt><dd><p>Threshold value (in percent, 20 by default) used to determine the
frequency change direction.</p>
<p>If the estimated CPU load is greater than this value, the frequency will
go up (by <code class="docutils literal notranslate"><span class="pre">freq_step</span></code>).  If the load is less than this value (and the
<code class="docutils literal notranslate"><span class="pre">sampling_down_factor</span></code> mechanism is not in effect), the frequency will
go down.  Otherwise, the frequency will not be changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_down_factor</span></code></dt><dd><p>Frequency decrease deferral factor, between 1 (default) and 10
inclusive.</p>
<p>It effectively causes the frequency to go down <code class="docutils literal notranslate"><span class="pre">sampling_down_factor</span></code>
times slower than it ramps up.</p>
</dd>
</dl>
</section>
</section>
<section id="frequency-boost-support">
<h2>Frequency Boost Support<a class="headerlink" href="#frequency-boost-support" title="Permalink to this headline">¶</a></h2>
<section id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>Some processors support a mechanism to raise the operating frequency of some
cores in a multicore package temporarily (and above the sustainable frequency
threshold for the whole package) under certain conditions, for example if the
whole chip is not fully utilized and below its intended thermal or power budget.</p>
<p>Different names are used by different vendors to refer to this functionality.
For Intel processors it is referred to as “Turbo Boost”, AMD calls it
“Turbo-Core” or (in technical documentation) “Core Performance Boost” and so on.
As a rule, it also is implemented differently by different vendors.  The simple
term “frequency boost” is used here for brevity to refer to all of those
implementations.</p>
<p>The frequency boost mechanism may be either hardware-based or software-based.
If it is hardware-based (e.g. on x86), the decision to trigger the boosting is
made by the hardware (although in general it requires the hardware to be put
into a special state in which it can control the CPU frequency within certain
limits).  If it is software-based (e.g. on ARM), the scaling driver decides
whether or not to trigger boosting and when to do that.</p>
</section>
<section id="the-boost-file-in-sysfs">
<h3>The <code class="docutils literal notranslate"><span class="pre">boost</span></code> File in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code><a class="headerlink" href="#the-boost-file-in-sysfs" title="Permalink to this headline">¶</a></h3>
<p>This file is located under <code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpufreq/</span></code> and controls
the “boost” setting for the whole system.  It is not present if the underlying
scaling driver does not support the frequency boost mechanism (or supports it,
but provides a driver-specific interface for controlling it, like
<a class="reference internal" href="intel_pstate.html"><span class="doc">intel_pstate</span></a>).</p>
<p>If the value in this file is 1, the frequency boost mechanism is enabled.  This
means that either the hardware can be put into states in which it is able to
trigger boosting (in the hardware-based case), or the software is allowed to
trigger boosting (in the software-based case).  It does not mean that boosting
is actually in use at the moment on any CPUs in the system.  It only means a
permission to use the frequency boost mechanism (which still may never be used
for other reasons).</p>
<p>If the value in this file is 0, the frequency boost mechanism is disabled and
cannot be used at all.</p>
<p>The only values that can be written to this file are 0 and 1.</p>
</section>
<section id="rationale-for-boost-control-knob">
<h3>Rationale for Boost Control Knob<a class="headerlink" href="#rationale-for-boost-control-knob" title="Permalink to this headline">¶</a></h3>
<p>The frequency boost mechanism is generally intended to help to achieve optimum
CPU performance on time scales below software resolution (e.g. below the
scheduler tick interval) and it is demonstrably suitable for many workloads, but
it may lead to problems in certain situations.</p>
<p>For this reason, many systems make it possible to disable the frequency boost
mechanism in the platform firmware (BIOS) setup, but that requires the system to
be restarted for the setting to be adjusted as desired, which may not be
practical at least in some cases.  For example:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Boosting means overclocking the processor, although under controlled
conditions.  Generally, the processor’s energy consumption increases
as a result of increasing its frequency and voltage, even temporarily.
That may not be desirable on systems that switch to power sources of
limited capacity, such as batteries, so the ability to disable the boost
mechanism while the system is running may help there (but that depends on
the workload too).</p></li>
<li><p>In some situations deterministic behavior is more important than
performance or energy consumption (or both) and the ability to disable
boosting while the system is running may be useful then.</p></li>
<li><p>To examine the impact of the frequency boost mechanism itself, it is useful
to be able to run tests with and without boosting, preferably without
restarting the system in the meantime.</p></li>
<li><p>Reproducible results are important when running benchmarks.  Since
the boosting functionality depends on the load of the whole package,
single-thread performance may vary because of it which may lead to
unreproducible results sometimes.  That can be avoided by disabling the
frequency boost mechanism before running benchmarks sensitive to that
issue.</p></li>
</ol>
</div></blockquote>
</section>
<section id="legacy-amd-cpb-knob">
<h3>Legacy AMD <code class="docutils literal notranslate"><span class="pre">cpb</span></code> Knob<a class="headerlink" href="#legacy-amd-cpb-knob" title="Permalink to this headline">¶</a></h3>
<p>The AMD powernow-k8 scaling driver supports a <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> knob very similar to
the global <code class="docutils literal notranslate"><span class="pre">boost</span></code> one.  It is used for disabling/enabling the “Core
Performance Boost” feature of some AMD processors.</p>
<p>If present, that knob is located in every <code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> policy directory in
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code> (<code class="file docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpufreq/policyX/</span></code>) and is called
<code class="docutils literal notranslate"><span class="pre">cpb</span></code>, which indicates a more fine grained control interface.  The actual
implementation, however, works on the system-wide basis and setting that knob
for one policy causes the same value of it to be set for all of the other
policies at the same time.</p>
<p>That knob is still supported on AMD processors that support its underlying
hardware feature, but it may be configured out of the kernel (via the
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_X86_ACPI_CPUFREQ_CPB</span></code> configuration option) and the global
<code class="docutils literal notranslate"><span class="pre">boost</span></code> knob is present regardless.  Thus it is always possible use the
<code class="docutils literal notranslate"><span class="pre">boost</span></code> knob instead of the <code class="docutils literal notranslate"><span class="pre">cpb</span></code> one which is highly recommended, as that
is more consistent with what all of the other systems do (and the <code class="docutils literal notranslate"><span class="pre">cpb</span></code> knob
may not be supported any more in the future).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cpb</span></code> knob is never present for any processors without the underlying
hardware feature (e.g. all Intel ones), even if the
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_X86_ACPI_CPUFREQ_CPB</span></code> configuration option is set.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Jonathan Corbet, <em>Per-entity load tracking</em>,
<a class="reference external" href="https://lwn.net/Articles/531853/">https://lwn.net/Articles/531853/</a></p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CPU Performance Scaling</a><ul>
<li><a class="reference internal" href="#the-concept-of-cpu-performance-scaling">The Concept of CPU Performance Scaling</a></li>
<li><a class="reference internal" href="#cpu-performance-scaling-in-linux">CPU Performance Scaling in Linux</a></li>
<li><a class="reference internal" href="#cpufreq-policy-objects"><code class="docutils literal notranslate"><span class="pre">CPUFreq</span></code> Policy Objects</a></li>
<li><a class="reference internal" href="#cpu-initialization">CPU Initialization</a></li>
<li><a class="reference internal" href="#policy-interface-in-sysfs">Policy Interface in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code></a></li>
<li><a class="reference internal" href="#generic-scaling-governors">Generic Scaling Governors</a><ul>
<li><a class="reference internal" href="#performance"><code class="docutils literal notranslate"><span class="pre">performance</span></code></a></li>
<li><a class="reference internal" href="#powersave"><code class="docutils literal notranslate"><span class="pre">powersave</span></code></a></li>
<li><a class="reference internal" href="#userspace"><code class="docutils literal notranslate"><span class="pre">userspace</span></code></a></li>
<li><a class="reference internal" href="#schedutil"><code class="docutils literal notranslate"><span class="pre">schedutil</span></code></a></li>
<li><a class="reference internal" href="#ondemand"><code class="docutils literal notranslate"><span class="pre">ondemand</span></code></a></li>
<li><a class="reference internal" href="#conservative"><code class="docutils literal notranslate"><span class="pre">conservative</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#frequency-boost-support">Frequency Boost Support</a><ul>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#the-boost-file-in-sysfs">The <code class="docutils literal notranslate"><span class="pre">boost</span></code> File in <code class="docutils literal notranslate"><span class="pre">sysfs</span></code></a></li>
<li><a class="reference internal" href="#rationale-for-boost-control-knob">Rationale for Boost Control Knob</a></li>
<li><a class="reference internal" href="#legacy-amd-cpb-knob">Legacy AMD <code class="docutils literal notranslate"><span class="pre">cpb</span></code> Knob</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/pm/cpufreq.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/pm/cpufreq.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>