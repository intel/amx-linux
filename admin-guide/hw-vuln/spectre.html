
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Spectre Side Channels &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="L1TF - L1 Terminal Fault" href="l1tf.html" />
    <link rel="prev" title="Hardware vulnerabilities" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="spectre-side-channels">
<h1>Spectre Side Channels<a class="headerlink" href="#spectre-side-channels" title="Permalink to this headline">¶</a></h1>
<p>Spectre is a class of side channel attacks that exploit branch prediction
and speculative execution on modern CPUs to read memory, possibly
bypassing access controls. Speculative execution side channel exploits
do not modify memory but attempt to infer privileged data in the memory.</p>
<p>This document covers Spectre variant 1 and Spectre variant 2.</p>
<section id="affected-processors">
<h2>Affected processors<a class="headerlink" href="#affected-processors" title="Permalink to this headline">¶</a></h2>
<p>Speculative execution side channel methods affect a wide range of modern
high performance processors, since most modern high speed processors
use branch prediction and speculative execution.</p>
<p>The following CPUs are vulnerable:</p>
<blockquote>
<div><ul class="simple">
<li><p>Intel Core, Atom, Pentium, and Xeon processors</p></li>
<li><p>AMD Phenom, EPYC, and Zen processors</p></li>
<li><p>IBM POWER and zSeries processors</p></li>
<li><p>Higher end ARM processors</p></li>
<li><p>Apple CPUs</p></li>
<li><p>Higher end MIPS CPUs</p></li>
<li><p>Likely most other high performance CPUs. Contact your CPU vendor for details.</p></li>
</ul>
</div></blockquote>
<p>Whether a processor is affected or not can be read out from the Spectre
vulnerability files in sysfs. See <a class="reference internal" href="#spectre-sys-info"><span class="std std-ref">Spectre system information</span></a>.</p>
</section>
<section id="related-cves">
<h2>Related CVEs<a class="headerlink" href="#related-cves" title="Permalink to this headline">¶</a></h2>
<p>The following CVE entries describe Spectre variants:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 37%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CVE-2017-5753</p></td>
<td><p>Bounds check bypass</p></td>
<td><p>Spectre variant 1</p></td>
</tr>
<tr class="row-even"><td><p>CVE-2017-5715</p></td>
<td><p>Branch target injection</p></td>
<td><p>Spectre variant 2</p></td>
</tr>
<tr class="row-odd"><td><p>CVE-2019-1125</p></td>
<td><p>Spectre v1 swapgs</p></td>
<td><p>Spectre variant 1 (swapgs)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<p>CPUs use speculative operations to improve performance. That may leave
traces of memory accesses or computations in the processor’s caches,
buffers, and branch predictors. Malicious software may be able to
influence the speculative execution paths, and then use the side effects
of the speculative execution in the CPUs’ caches and buffers to infer
privileged data touched during the speculative execution.</p>
<p>Spectre variant 1 attacks take advantage of speculative execution of
conditional branches, while Spectre variant 2 attacks use speculative
execution of indirect branches to leak privileged memory.
See <a class="reference internal" href="#spec-ref1"><span class="std std-ref">[1]</span></a> <a class="reference internal" href="#spec-ref5"><span class="std std-ref">[5]</span></a> <a class="reference internal" href="#spec-ref6"><span class="std std-ref">[6]</span></a>
<a class="reference internal" href="#spec-ref7"><span class="std std-ref">[7]</span></a> <a class="reference internal" href="#spec-ref10"><span class="std std-ref">[10]</span></a> <a class="reference internal" href="#spec-ref11"><span class="std std-ref">[11]</span></a>.</p>
</section>
<section id="spectre-variant-1-bounds-check-bypass">
<h2>Spectre variant 1 (Bounds Check Bypass)<a class="headerlink" href="#spectre-variant-1-bounds-check-bypass" title="Permalink to this headline">¶</a></h2>
<p>The bounds check bypass attack <a class="reference internal" href="#spec-ref2"><span class="std std-ref">[2]</span></a> takes advantage
of speculative execution that bypasses conditional branch instructions
used for memory access bounds check (e.g. checking if the index of an
array results in memory access within a valid range). This results in
memory accesses to invalid memory (with out-of-bound index) that are
done speculatively before validation checks resolve. Such speculative
memory accesses can leave side effects, creating side channels which
leak information to the attacker.</p>
<p>There are some extensions of Spectre variant 1 attacks for reading data
over the network, see <a class="reference internal" href="#spec-ref12"><span class="std std-ref">[12]</span></a>. However such attacks
are difficult, low bandwidth, fragile, and are considered low risk.</p>
<p>Note that, despite “Bounds Check Bypass” name, Spectre variant 1 is not
only about user-controlled array bounds checks.  It can affect any
conditional checks.  The kernel entry code interrupt, exception, and NMI
handlers all have conditional swapgs checks.  Those may be problematic
in the context of Spectre v1, as kernel code can speculatively run with
a user GS.</p>
</section>
<section id="spectre-variant-2-branch-target-injection">
<h2>Spectre variant 2 (Branch Target Injection)<a class="headerlink" href="#spectre-variant-2-branch-target-injection" title="Permalink to this headline">¶</a></h2>
<p>The branch target injection attack takes advantage of speculative
execution of indirect branches <a class="reference internal" href="#spec-ref3"><span class="std std-ref">[3]</span></a>.  The indirect
branch predictors inside the processor used to guess the target of
indirect branches can be influenced by an attacker, causing gadget code
to be speculatively executed, thus exposing sensitive data touched by
the victim. The side effects left in the CPU’s caches during speculative
execution can be measured to infer data values.</p>
<p id="poison-btb">In Spectre variant 2 attacks, the attacker can steer speculative indirect
branches in the victim to gadget code by poisoning the branch target
buffer of a CPU used for predicting indirect branch addresses. Such
poisoning could be done by indirect branching into existing code,
with the address offset of the indirect branch under the attacker’s
control. Since the branch prediction on impacted hardware does not
fully disambiguate branch address and uses the offset for prediction,
this could cause privileged code’s indirect branch to jump to a gadget
code with the same offset.</p>
<p>The most useful gadgets take an attacker-controlled input parameter (such
as a register value) so that the memory read can be controlled. Gadgets
without input parameters might be possible, but the attacker would have
very little control over what memory can be read, reducing the risk of
the attack revealing useful data.</p>
<p>One other variant 2 attack vector is for the attacker to poison the
return stack buffer (RSB) <a class="reference internal" href="#spec-ref13"><span class="std std-ref">[13]</span></a> to cause speculative
subroutine return instruction execution to go to a gadget.  An attacker’s
imbalanced subroutine call instructions might “poison” entries in the
return stack buffer which are later consumed by a victim’s subroutine
return instructions.  This attack can be mitigated by flushing the return
stack buffer on context switch, or virtual machine (VM) exit.</p>
<p>On systems with simultaneous multi-threading (SMT), attacks are possible
from the sibling thread, as level 1 cache and branch target buffer
(BTB) may be shared between hardware threads in a CPU core.  A malicious
program running on the sibling thread may influence its peer’s BTB to
steer its indirect branch speculations to gadget code, and measure the
speculative execution’s side effects left in level 1 cache to infer the
victim’s data.</p>
<p>Yet another variant 2 attack vector is for the attacker to poison the
Branch History Buffer (BHB) to speculatively steer an indirect branch
to a specific Branch Target Buffer (BTB) entry, even if the entry isn’t
associated with the source address of the indirect branch. Specifically,
the BHB might be shared across privilege levels even in the presence of
Enhanced IBRS.</p>
<p>Currently the only known real-world BHB attack vector is via
unprivileged eBPF. Therefore, it’s highly recommended to not enable
unprivileged eBPF, especially when eIBRS is used (without retpolines).
For a full mitigation against BHB attacks, it’s recommended to use
retpolines (or eIBRS combined with retpolines).</p>
</section>
<section id="attack-scenarios">
<h2>Attack scenarios<a class="headerlink" href="#attack-scenarios" title="Permalink to this headline">¶</a></h2>
<p>The following list of attack scenarios have been anticipated, but may
not cover all possible attack vectors.</p>
<section id="a-user-process-attacking-the-kernel">
<h3>1. A user process attacking the kernel<a class="headerlink" href="#a-user-process-attacking-the-kernel" title="Permalink to this headline">¶</a></h3>
<section id="spectre-variant-1">
<h4>Spectre variant 1<a class="headerlink" href="#spectre-variant-1" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The attacker passes a parameter to the kernel via a register or
via a known address in memory during a syscall. Such parameter may
be used later by the kernel as an index to an array or to derive
a pointer for a Spectre variant 1 attack.  The index or pointer
is invalid, but bound checks are bypassed in the code branch taken
for speculative execution. This could cause privileged memory to be
accessed and leaked.</p>
<p>For kernel code that has been identified where data pointers could
potentially be influenced for Spectre attacks, new “nospec” accessor
macros are used to prevent speculative loading of data.</p>
</div></blockquote>
</section>
<section id="spectre-variant-1-swapgs">
<h4>Spectre variant 1 (swapgs)<a class="headerlink" href="#spectre-variant-1-swapgs" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>An attacker can train the branch predictor to speculatively skip the
swapgs path for an interrupt or exception.  If they initialize
the GS register to a user-space value, if the swapgs is speculatively
skipped, subsequent GS-related percpu accesses in the speculation
window will be done with the attacker-controlled GS value.  This
could cause privileged memory to be accessed and leaked.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (coming from user space)
    swapgs
mov %gs:&lt;percpu_offset&gt;, %reg
mov (%reg), %reg1
</pre></div>
</div>
<p>When coming from user space, the CPU can speculatively skip the
swapgs, and then do a speculative percpu load using the user GS
value.  So the user can speculatively force a read of any kernel
value.  If a gadget exists which uses the percpu value as an address
in another load/store, then the contents of the kernel value may
become visible via an L1 side channel attack.</p>
<p>A similar attack exists when coming from kernel space.  The CPU can
speculatively do the swapgs, causing the user GS to get used for the
rest of the speculative window.</p>
</div></blockquote>
</section>
<section id="spectre-variant-2">
<h4>Spectre variant 2<a class="headerlink" href="#spectre-variant-2" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>A spectre variant 2 attacker can <a class="reference internal" href="#poison-btb"><span class="std std-ref">poison</span></a> the branch
target buffer (BTB) before issuing syscall to launch an attack.
After entering the kernel, the kernel could use the poisoned branch
target buffer on indirect jump and jump to gadget code in speculative
execution.</p>
<p>If an attacker tries to control the memory addresses leaked during
speculative execution, he would also need to pass a parameter to the
gadget, either through a register or a known address in memory. After
the gadget has executed, he can measure the side effect.</p>
<p>The kernel can protect itself against consuming poisoned branch
target buffer entries by using return trampolines (also known as
“retpoline”) <a class="reference internal" href="#spec-ref3"><span class="std std-ref">[3]</span></a> <a class="reference internal" href="#spec-ref9"><span class="std std-ref">[9]</span></a> for all
indirect branches. Return trampolines trap speculative execution paths
to prevent jumping to gadget code during speculative execution.
x86 CPUs with Enhanced Indirect Branch Restricted Speculation
(Enhanced IBRS) available in hardware should use the feature to
mitigate Spectre variant 2 instead of retpoline. Enhanced IBRS is
more efficient than retpoline.</p>
<p>There may be gadget code in firmware which could be exploited with
Spectre variant 2 attack by a rogue user process. To mitigate such
attacks on x86, Indirect Branch Restricted Speculation (IBRS) feature
is turned on before the kernel invokes any firmware code.</p>
</div></blockquote>
</section>
</section>
<section id="a-user-process-attacking-another-user-process">
<h3>2. A user process attacking another user process<a class="headerlink" href="#a-user-process-attacking-another-user-process" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A malicious user process can try to attack another user process,
either via a context switch on the same hardware thread, or from the
sibling hyperthread sharing a physical processor core on simultaneous
multi-threading (SMT) system.</p>
<p>Spectre variant 1 attacks generally require passing parameters
between the processes, which needs a data passing relationship, such
as remote procedure calls (RPC).  Those parameters are used in gadget
code to derive invalid data pointers accessing privileged memory in
the attacked process.</p>
<p>Spectre variant 2 attacks can be launched from a rogue process by
<a class="reference internal" href="#poison-btb"><span class="std std-ref">poisoning</span></a> the branch target buffer.  This can
influence the indirect branch targets for a victim process that either
runs later on the same hardware thread, or running concurrently on
a sibling hardware thread sharing the same physical core.</p>
<p>A user process can protect itself against Spectre variant 2 attacks
by using the prctl() syscall to disable indirect branch speculation
for itself.  An administrator can also cordon off an unsafe process
from polluting the branch target buffer by disabling the process’s
indirect branch speculation. This comes with a performance cost
from not using indirect branch speculation and clearing the branch
target buffer.  When SMT is enabled on x86, for a process that has
indirect branch speculation disabled, Single Threaded Indirect Branch
Predictors (STIBP) <a class="reference internal" href="#spec-ref4"><span class="std std-ref">[4]</span></a> are turned on to prevent the
sibling thread from controlling branch target buffer.  In addition,
the Indirect Branch Prediction Barrier (IBPB) is issued to clear the
branch target buffer when context switching to and from such process.</p>
<p>On x86, the return stack buffer is stuffed on context switch.
This prevents the branch target buffer from being used for branch
prediction when the return stack buffer underflows while switching to
a deeper call stack. Any poisoned entries in the return stack buffer
left by the previous process will also be cleared.</p>
<p>User programs should use address space randomization to make attacks
more difficult (Set /proc/sys/kernel/randomize_va_space = 1 or 2).</p>
</div></blockquote>
</section>
<section id="a-virtualized-guest-attacking-the-host">
<h3>3. A virtualized guest attacking the host<a class="headerlink" href="#a-virtualized-guest-attacking-the-host" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The attack mechanism is similar to how user processes attack the
kernel.  The kernel is entered via hyper-calls or other virtualization
exit paths.</p>
<p>For Spectre variant 1 attacks, rogue guests can pass parameters
(e.g. in registers) via hyper-calls to derive invalid pointers to
speculate into privileged memory after entering the kernel.  For places
where such kernel code has been identified, nospec accessor macros
are used to stop speculative memory access.</p>
<p>For Spectre variant 2 attacks, rogue guests can <a class="reference internal" href="#poison-btb"><span class="std std-ref">poison</span></a> the branch target buffer or return stack buffer, causing
the kernel to jump to gadget code in the speculative execution paths.</p>
<p>To mitigate variant 2, the host kernel can use return trampolines
for indirect branches to bypass the poisoned branch target buffer,
and flushing the return stack buffer on VM exit.  This prevents rogue
guests from affecting indirect branching in the host kernel.</p>
<p>To protect host processes from rogue guests, host processes can have
indirect branch speculation disabled via prctl().  The branch target
buffer is cleared before context switching to such processes.</p>
</div></blockquote>
</section>
<section id="a-virtualized-guest-attacking-other-guest">
<h3>4. A virtualized guest attacking other guest<a class="headerlink" href="#a-virtualized-guest-attacking-other-guest" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A rogue guest may attack another guest to get data accessible by the
other guest.</p>
<p>Spectre variant 1 attacks are possible if parameters can be passed
between guests.  This may be done via mechanisms such as shared memory
or message passing.  Such parameters could be used to derive data
pointers to privileged data in guest.  The privileged data could be
accessed by gadget code in the victim’s speculation paths.</p>
<p>Spectre variant 2 attacks can be launched from a rogue guest by
<a class="reference internal" href="#poison-btb"><span class="std std-ref">poisoning</span></a> the branch target buffer or the return
stack buffer. Such poisoned entries could be used to influence
speculation execution paths in the victim guest.</p>
<p>Linux kernel mitigates attacks to other guests running in the same
CPU hardware thread by flushing the return stack buffer on VM exit,
and clearing the branch target buffer before switching to a new guest.</p>
<p>If SMT is used, Spectre variant 2 attacks from an untrusted guest
in the sibling hyperthread can be mitigated by the administrator,
by turning off the unsafe guest’s indirect branch speculation via
prctl().  A guest can also protect itself by turning on microcode
based mitigations (such as IBPB or STIBP on x86) within the guest.</p>
</div></blockquote>
</section>
</section>
<section id="spectre-system-information">
<span id="spectre-sys-info"></span><h2>Spectre system information<a class="headerlink" href="#spectre-system-information" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides a sysfs interface to enumerate the current
mitigation status of the system for Spectre: whether the system is
vulnerable, and which mitigations are active.</p>
<p>The sysfs file showing Spectre variant 1 mitigation status is:</p>
<blockquote>
<div><p>/sys/devices/system/cpu/vulnerabilities/spectre_v1</p>
</div></blockquote>
<p>The possible values in this file are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘Not affected’</p></td>
<td><p>The processor is not vulnerable.</p></td>
</tr>
<tr class="row-even"><td><p>‘Vulnerable: __user pointer sanitization and usercopy barriers only; no swapgs barriers’</p></td>
<td><p>The swapgs protections are disabled; otherwise it has
protection in the kernel on a case by case base with explicit
pointer sanitation and usercopy LFENCE barriers.</p></td>
</tr>
<tr class="row-odd"><td><p>‘Mitigation: usercopy/swapgs barriers and __user pointer sanitization’</p></td>
<td><p>Protection in the kernel on a case by case base with explicit
pointer sanitation, usercopy LFENCE barriers, and swapgs LFENCE
barriers.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>However, the protections are put in place on a case by case basis,
and there is no guarantee that all possible attack vectors for Spectre
variant 1 are covered.</p>
<p>The spectre_v2 kernel file reports if the kernel has been compiled with
retpoline mitigation or if the CPU has hardware mitigation, and if the
CPU has support for additional process-specific mitigation.</p>
<p>This file also reports CPU features enabled by microcode to mitigate
attack between user processes:</p>
<ol class="arabic simple">
<li><p>Indirect Branch Prediction Barrier (IBPB) to add additional
isolation between processes of different users.</p></li>
<li><p>Single Thread Indirect Branch Predictors (STIBP) to add additional
isolation between CPU threads running on the same core.</p></li>
</ol>
<p>These CPU features may impact performance when used and can be enabled
per process on a case-by-case base.</p>
<p>The sysfs file showing Spectre variant 2 mitigation status is:</p>
<blockquote>
<div><p>/sys/devices/system/cpu/vulnerabilities/spectre_v2</p>
</div></blockquote>
<p>The possible values in this file are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Kernel status:</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘Not affected’</p></td>
<td><p>The processor is not vulnerable</p></td>
</tr>
<tr class="row-even"><td><p>‘Mitigation: None’</p></td>
<td><p>Vulnerable, no mitigation</p></td>
</tr>
<tr class="row-odd"><td><p>‘Mitigation: Retpolines’</p></td>
<td><p>Use Retpoline thunks</p></td>
</tr>
<tr class="row-even"><td><p>‘Mitigation: LFENCE’</p></td>
<td><p>Use LFENCE instructions</p></td>
</tr>
<tr class="row-odd"><td><p>‘Mitigation: Enhanced IBRS’</p></td>
<td><p>Hardware-focused mitigation</p></td>
</tr>
<tr class="row-even"><td><p>‘Mitigation: Enhanced IBRS + Retpolines’</p></td>
<td><p>Hardware-focused + Retpolines</p></td>
</tr>
<tr class="row-odd"><td><p>‘Mitigation: Enhanced IBRS + LFENCE’</p></td>
<td><p>Hardware-focused + LFENCE</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Firmware status: Show if Indirect Branch Restricted Speculation (IBRS) is
used to protect against Spectre variant 2 attacks when calling firmware (x86 only).</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘IBRS_FW’</p></td>
<td><p>Protection against user program attacks when calling firmware</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Indirect branch prediction barrier (IBPB) status for protection between
processes of different users. This feature can be controlled through
prctl() per process, or through kernel command line options. This is
an x86 only feature. For more details see below.</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘IBPB: disabled’</p></td>
<td><p>IBPB unused</p></td>
</tr>
<tr class="row-even"><td><p>‘IBPB: always-on’</p></td>
<td><p>Use IBPB on all tasks</p></td>
</tr>
<tr class="row-odd"><td><p>‘IBPB: conditional’</p></td>
<td><p>Use IBPB on SECCOMP or indirect branch restricted tasks</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Single threaded indirect branch prediction (STIBP) status for protection
between different hyper threads. This feature can be controlled through
prctl per process, or through kernel command line options. This is x86
only feature. For more details see below.</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘STIBP: disabled’</p></td>
<td><p>STIBP unused</p></td>
</tr>
<tr class="row-even"><td><p>‘STIBP: forced’</p></td>
<td><p>Use STIBP on all tasks</p></td>
</tr>
<tr class="row-odd"><td><p>‘STIBP: conditional’</p></td>
<td><p>Use STIBP on SECCOMP or indirect branch restricted tasks</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Return stack buffer (RSB) protection status:</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘RSB filling’</p></td>
<td><p>Protection of RSB on context switch enabled</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>EIBRS Post-barrier Return Stack Buffer (PBRSB) protection status:</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘PBRSB-eIBRS: SW sequence’</p></td>
<td><p>CPU is affected and protection of RSB on VMEXIT enabled</p></td>
</tr>
<tr class="row-even"><td><p>‘PBRSB-eIBRS: Vulnerable’</p></td>
<td><p>CPU is vulnerable</p></td>
</tr>
<tr class="row-odd"><td><p>‘PBRSB-eIBRS: Not affected’</p></td>
<td><p>CPU is not affected by PBRSB</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Full mitigation might require a microcode update from the CPU
vendor. When the necessary microcode is not available, the kernel will
report vulnerability.</p>
</section>
<section id="turning-on-mitigation-for-spectre-variant-1-and-spectre-variant-2">
<h2>Turning on mitigation for Spectre variant 1 and Spectre variant 2<a class="headerlink" href="#turning-on-mitigation-for-spectre-variant-1-and-spectre-variant-2" title="Permalink to this headline">¶</a></h2>
<section id="kernel-mitigation">
<h3>1. Kernel mitigation<a class="headerlink" href="#kernel-mitigation" title="Permalink to this headline">¶</a></h3>
<section id="id1">
<h4>Spectre variant 1<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>For the Spectre variant 1, vulnerable kernel code (as determined
by code audit or scanning tools) is annotated on a case by case
basis to use nospec accessor macros for bounds clipping <a class="reference internal" href="#spec-ref2"><span class="std std-ref">[2]</span></a> to avoid any usable disclosure gadgets. However, it may
not cover all attack vectors for Spectre variant 1.</p>
<p>Copy-from-user code has an LFENCE barrier to prevent the <a class="reference internal" href="../../core-api/mm-api.html#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">access_ok()</span></code></a>
check from being mis-speculated.  The barrier is done by the
barrier_nospec() macro.</p>
<p>For the swapgs variant of Spectre variant 1, LFENCE barriers are
added to interrupt, exception and NMI entry where needed.  These
barriers are done by the FENCE_SWAPGS_KERNEL_ENTRY and
FENCE_SWAPGS_USER_ENTRY macros.</p>
</div></blockquote>
</section>
<section id="id2">
<h4>Spectre variant 2<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>For Spectre variant 2 mitigation, the compiler turns indirect calls or
jumps in the kernel into equivalent return trampolines (retpolines)
<a class="reference internal" href="#spec-ref3"><span class="std std-ref">[3]</span></a> <a class="reference internal" href="#spec-ref9"><span class="std std-ref">[9]</span></a> to go to the target
addresses.  Speculative execution paths under retpolines are trapped
in an infinite loop to prevent any speculative execution jumping to
a gadget.</p>
<p>To turn on retpoline mitigation on a vulnerable CPU, the kernel
needs to be compiled with a gcc compiler that supports the
-mindirect-branch=thunk-extern -mindirect-branch-register options.
If the kernel is compiled with a Clang compiler, the compiler needs
to support -mretpoline-external-thunk option.  The kernel config
CONFIG_RETPOLINE needs to be turned on, and the CPU needs to run with
the latest updated microcode.</p>
<p>On Intel Skylake-era systems the mitigation covers most, but not all,
cases. See <a class="reference internal" href="#spec-ref3"><span class="std std-ref">[3]</span></a> for more details.</p>
<p>On CPUs with hardware mitigation for Spectre variant 2 (e.g. Enhanced
IBRS on x86), retpoline is automatically disabled at run time.</p>
<p>The retpoline mitigation is turned on by default on vulnerable
CPUs. It can be forced on or off by the administrator
via the kernel command line and sysfs control files. See
<a class="reference internal" href="#spectre-mitigation-control-command-line"><span class="std std-ref">Mitigation control on the kernel command line</span></a>.</p>
<p>On x86, indirect branch restricted speculation is turned on by default
before invoking any firmware code to prevent Spectre variant 2 exploits
using the firmware.</p>
<p>Using kernel address space randomization (CONFIG_RANDOMIZE_BASE=y
and CONFIG_SLAB_FREELIST_RANDOM=y in the kernel configuration) makes
attacks on the kernel generally more difficult.</p>
</div></blockquote>
</section>
</section>
<section id="user-program-mitigation">
<h3>2. User program mitigation<a class="headerlink" href="#user-program-mitigation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>User programs can mitigate Spectre variant 1 using LFENCE or “bounds
clipping”. For more details see <a class="reference internal" href="#spec-ref2"><span class="std std-ref">[2]</span></a>.</p>
<p>For Spectre variant 2 mitigation, individual user programs
can be compiled with return trampolines for indirect branches.
This protects them from consuming poisoned entries in the branch
target buffer left by malicious software.  Alternatively, the
programs can disable their indirect branch speculation via prctl()
(See <a class="reference internal" href="../../userspace-api/spec_ctrl.html#set-spec-ctrl"><span class="std std-ref">Documentation/userspace-api/spec_ctrl.rst</span></a>).
On x86, this will turn on STIBP to guard against attacks from the
sibling thread when the user program is running, and use IBPB to
flush the branch target buffer when switching to/from the program.</p>
<p>Restricting indirect branch speculation on a user program will
also prevent the program from launching a variant 2 attack
on x86.  Administrators can change that behavior via the kernel
command line and sysfs control files.
See <a class="reference internal" href="#spectre-mitigation-control-command-line"><span class="std std-ref">Mitigation control on the kernel command line</span></a>.</p>
<p>Programs that disable their indirect branch speculation will have
more overhead and run slower.</p>
<p>User programs should use address space randomization
(/proc/sys/kernel/randomize_va_space = 1 or 2) to make attacks more
difficult.</p>
</div></blockquote>
</section>
<section id="vm-mitigation">
<h3>3. VM mitigation<a class="headerlink" href="#vm-mitigation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Within the kernel, Spectre variant 1 attacks from rogue guests are
mitigated on a case by case basis in VM exit paths. Vulnerable code
uses nospec accessor macros for “bounds clipping”, to avoid any
usable disclosure gadgets.  However, this may not cover all variant
1 attack vectors.</p>
<p>For Spectre variant 2 attacks from rogue guests to the kernel, the
Linux kernel uses retpoline or Enhanced IBRS to prevent consumption of
poisoned entries in branch target buffer left by rogue guests.  It also
flushes the return stack buffer on every VM exit to prevent a return
stack buffer underflow so poisoned branch target buffer could be used,
or attacker guests leaving poisoned entries in the return stack buffer.</p>
<p>To mitigate guest-to-guest attacks in the same CPU hardware thread,
the branch target buffer is sanitized by flushing before switching
to a new guest on a CPU.</p>
<p>The above mitigations are turned on by default on vulnerable CPUs.</p>
<p>To mitigate guest-to-guest attacks from sibling thread when SMT is
in use, an untrusted guest running in the sibling thread can have
its indirect branch speculation disabled by administrator via prctl().</p>
<p>The kernel also allows guests to use any microcode based mitigation
they choose to use (such as IBPB or STIBP on x86) to protect themselves.</p>
</div></blockquote>
</section>
</section>
<section id="mitigation-control-on-the-kernel-command-line">
<span id="spectre-mitigation-control-command-line"></span><h2>Mitigation control on the kernel command line<a class="headerlink" href="#mitigation-control-on-the-kernel-command-line" title="Permalink to this headline">¶</a></h2>
<p>Spectre variant 2 mitigation can be disabled or force enabled at the
kernel command line.</p>
<blockquote>
<div><p>nospectre_v1</p>
<blockquote>
<div><p>[X86,PPC] Disable mitigations for Spectre Variant 1
(bounds check bypass). With this option data leaks are
possible in the system.</p>
</div></blockquote>
<p>nospectre_v2</p>
<blockquote>
<div><p>[X86] Disable all mitigations for the Spectre variant 2
(indirect branch prediction) vulnerability. System may
allow data leaks with this option, which is equivalent
to spectre_v2=off.</p>
</div></blockquote>
<p>spectre_v2=</p>
<blockquote>
<div><p>[X86] Control mitigation of Spectre variant 2
(indirect branch speculation) vulnerability.
The default operation protects the kernel from
user space attacks.</p>
<dl class="simple">
<dt>on</dt><dd><p>unconditionally enable, implies
spectre_v2_user=on</p>
</dd>
<dt>off</dt><dd><p>unconditionally disable, implies
spectre_v2_user=off</p>
</dd>
<dt>auto</dt><dd><p>kernel detects whether your CPU model is
vulnerable</p>
</dd>
</dl>
<p>Selecting ‘on’ will, and ‘auto’ may, choose a
mitigation method at run time according to the
CPU, the available microcode, the setting of the
CONFIG_RETPOLINE configuration option, and the
compiler with which the kernel was built.</p>
<p>Selecting ‘on’ will also enable the mitigation
against user space to user space task attacks.</p>
<p>Selecting ‘off’ will disable both the kernel and
the user space protections.</p>
<p>Specific mitigations can also be selected manually:</p>
<p>retpoline               auto pick between generic,lfence
retpoline,generic       Retpolines
retpoline,lfence        LFENCE; indirect branch
retpoline,amd           alias for retpoline,lfence
eibrs                   enhanced IBRS
eibrs,retpoline         enhanced IBRS + Retpolines
eibrs,lfence            enhanced IBRS + LFENCE
ibrs                    use IBRS to protect kernel</p>
<p>Not specifying this option is equivalent to
spectre_v2=auto.</p>
<p>In general the kernel by default selects
reasonable mitigations for the current CPU. To
disable Spectre variant 2 mitigations, boot with
spectre_v2=off. Spectre variant 1 mitigations
cannot be disabled.</p>
</div></blockquote>
</div></blockquote>
<p>For spectre_v2_user see <a class="reference internal" href="../kernel-parameters.html"><span class="doc">The kernel’s command-line parameters</span></a></p>
</section>
<section id="mitigation-selection-guide">
<h2>Mitigation selection guide<a class="headerlink" href="#mitigation-selection-guide" title="Permalink to this headline">¶</a></h2>
<section id="trusted-userspace">
<h3>1. Trusted userspace<a class="headerlink" href="#trusted-userspace" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If all userspace applications are from trusted sources and do not
execute externally supplied untrusted code, then the mitigations can
be disabled.</p>
</div></blockquote>
</section>
<section id="protect-sensitive-programs">
<h3>2. Protect sensitive programs<a class="headerlink" href="#protect-sensitive-programs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For security-sensitive programs that have secrets (e.g. crypto
keys), protection against Spectre variant 2 can be put in place by
disabling indirect branch speculation when the program is running
(See <a class="reference internal" href="../../userspace-api/spec_ctrl.html#set-spec-ctrl"><span class="std std-ref">Documentation/userspace-api/spec_ctrl.rst</span></a>).</p>
</div></blockquote>
</section>
<section id="sandbox-untrusted-programs">
<h3>3. Sandbox untrusted programs<a class="headerlink" href="#sandbox-untrusted-programs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Untrusted programs that could be a source of attacks can be cordoned
off by disabling their indirect branch speculation when they are run
(See <a class="reference internal" href="../../userspace-api/spec_ctrl.html#set-spec-ctrl"><span class="std std-ref">Documentation/userspace-api/spec_ctrl.rst</span></a>).
This prevents untrusted programs from polluting the branch target
buffer.  This behavior can be changed via the kernel command line
and sysfs control files. See
<a class="reference internal" href="#spectre-mitigation-control-command-line"><span class="std std-ref">Mitigation control on the kernel command line</span></a>.</p>
</div></blockquote>
</section>
<section id="high-security-mode">
<h3>3. High security mode<a class="headerlink" href="#high-security-mode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>All Spectre variant 2 mitigations can be forced on
at boot time for all programs (See the “on” option in
<a class="reference internal" href="#spectre-mitigation-control-command-line"><span class="std std-ref">Mitigation control on the kernel command line</span></a>).  This will add
overhead as indirect branch speculations for all programs will be
restricted.</p>
<p>On x86, branch target buffer will be flushed with IBPB when switching
to a new program. STIBP is left on all the time to protect programs
against variant 2 attacks originating from programs running on
sibling threads.</p>
<p>Alternatively, STIBP can be used only when running programs
whose indirect branch speculation is explicitly disabled,
while IBPB is still used all the time when switching to a new
program to clear the branch target buffer (See “ibpb” option in
<a class="reference internal" href="#spectre-mitigation-control-command-line"><span class="std std-ref">Mitigation control on the kernel command line</span></a>).  This “ibpb” option
has less performance cost than the “on” option, which leaves STIBP
on all the time.</p>
</div></blockquote>
</section>
</section>
<section id="references-on-spectre">
<h2>References on Spectre<a class="headerlink" href="#references-on-spectre" title="Permalink to this headline">¶</a></h2>
<p>Intel white papers:</p>
<p id="spec-ref1">[1] <a class="reference external" href="https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf">Intel analysis of speculative execution side channels</a>.</p>
<p id="spec-ref2">[2] <a class="reference external" href="https://software.intel.com/security-software-guidance/software-guidance/bounds-check-bypass">Bounds check bypass</a>.</p>
<p id="spec-ref3">[3] <a class="reference external" href="https://software.intel.com/security-software-guidance/insights/deep-dive-retpoline-branch-target-injection-mitigation">Deep dive: Retpoline: A branch target injection mitigation</a>.</p>
<p id="spec-ref4">[4] <a class="reference external" href="https://software.intel.com/security-software-guidance/insights/deep-dive-single-thread-indirect-branch-predictors">Deep Dive: Single Thread Indirect Branch Predictors</a>.</p>
<p>AMD white papers:</p>
<p id="spec-ref5">[5] <a class="reference external" href="https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf">AMD64 technology indirect branch control extension</a>.</p>
<p id="spec-ref6">[6] <a class="reference external" href="https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf">Software techniques for managing speculation on AMD processors</a>.</p>
<p>ARM white papers:</p>
<p id="spec-ref7">[7] <a class="reference external" href="https://developer.arm.com/support/arm-security-updates/speculative-processor-vulnerability/download-the-whitepaper">Cache speculation side-channels</a>.</p>
<p id="spec-ref8">[8] <a class="reference external" href="https://developer.arm.com/support/arm-security-updates/speculative-processor-vulnerability/latest-updates/cache-speculation-issues-update">Cache speculation issues update</a>.</p>
<p>Google white paper:</p>
<p id="spec-ref9">[9] <a class="reference external" href="https://support.google.com/faqs/answer/7625886">Retpoline: a software construct for preventing branch-target-injection</a>.</p>
<p>MIPS white paper:</p>
<p id="spec-ref10">[10] <a class="reference external" href="https://www.mips.com/blog/mips-response-on-speculative-execution-and-side-channel-vulnerabilities/">MIPS: response on speculative execution and side channel vulnerabilities</a>.</p>
<p>Academic papers:</p>
<p id="spec-ref11">[11] <a class="reference external" href="https://spectreattack.com/spectre.pdf">Spectre Attacks: Exploiting Speculative Execution</a>.</p>
<p id="spec-ref12">[12] <a class="reference external" href="https://arxiv.org/abs/1807.10535">NetSpectre: Read Arbitrary Memory over Network</a>.</p>
<p id="spec-ref13">[13] <a class="reference external" href="https://www.usenix.org/system/files/conference/woot18/woot18-paper-koruyeh.pdf">Spectre Returns! Speculation Attacks using the Return Stack Buffer</a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Spectre Side Channels</a><ul>
<li><a class="reference internal" href="#affected-processors">Affected processors</a></li>
<li><a class="reference internal" href="#related-cves">Related CVEs</a></li>
<li><a class="reference internal" href="#problem">Problem</a></li>
<li><a class="reference internal" href="#spectre-variant-1-bounds-check-bypass">Spectre variant 1 (Bounds Check Bypass)</a></li>
<li><a class="reference internal" href="#spectre-variant-2-branch-target-injection">Spectre variant 2 (Branch Target Injection)</a></li>
<li><a class="reference internal" href="#attack-scenarios">Attack scenarios</a><ul>
<li><a class="reference internal" href="#a-user-process-attacking-the-kernel">1. A user process attacking the kernel</a><ul>
<li><a class="reference internal" href="#spectre-variant-1">Spectre variant 1</a></li>
<li><a class="reference internal" href="#spectre-variant-1-swapgs">Spectre variant 1 (swapgs)</a></li>
<li><a class="reference internal" href="#spectre-variant-2">Spectre variant 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-user-process-attacking-another-user-process">2. A user process attacking another user process</a></li>
<li><a class="reference internal" href="#a-virtualized-guest-attacking-the-host">3. A virtualized guest attacking the host</a></li>
<li><a class="reference internal" href="#a-virtualized-guest-attacking-other-guest">4. A virtualized guest attacking other guest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spectre-system-information">Spectre system information</a></li>
<li><a class="reference internal" href="#turning-on-mitigation-for-spectre-variant-1-and-spectre-variant-2">Turning on mitigation for Spectre variant 1 and Spectre variant 2</a><ul>
<li><a class="reference internal" href="#kernel-mitigation">1. Kernel mitigation</a><ul>
<li><a class="reference internal" href="#id1">Spectre variant 1</a></li>
<li><a class="reference internal" href="#id2">Spectre variant 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#user-program-mitigation">2. User program mitigation</a></li>
<li><a class="reference internal" href="#vm-mitigation">3. VM mitigation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mitigation-control-on-the-kernel-command-line">Mitigation control on the kernel command line</a></li>
<li><a class="reference internal" href="#mitigation-selection-guide">Mitigation selection guide</a><ul>
<li><a class="reference internal" href="#trusted-userspace">1. Trusted userspace</a></li>
<li><a class="reference internal" href="#protect-sensitive-programs">2. Protect sensitive programs</a></li>
<li><a class="reference internal" href="#sandbox-untrusted-programs">3. Sandbox untrusted programs</a></li>
<li><a class="reference internal" href="#high-security-mode">3. High security mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references-on-spectre">References on Spectre</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/hw-vuln/spectre.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/hw-vuln/spectre.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>