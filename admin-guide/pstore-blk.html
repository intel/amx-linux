
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>pstore block oops/panic logger &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Rules on how to access information in sysfs" href="sysfs-rules.html" />
    <link rel="prev" title="Amlogic SoC DDR Bandwidth Performance Monitoring Unit (PMU)" href="perf/meson-ddr-pmu.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pstore-block-oops-panic-logger">
<h1>pstore block oops/panic logger<a class="headerlink" href="#pstore-block-oops-panic-logger" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>pstore block (pstore/blk) is an oops/panic logger that writes its logs to a
block device and non-block device before the system crashes. You can get
these log files by mounting pstore filesystem like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t pstore pstore /sys/fs/pstore
</pre></div>
</div>
</section>
<section id="pstore-block-concepts">
<h2>pstore block concepts<a class="headerlink" href="#pstore-block-concepts" title="Permalink to this headline">¶</a></h2>
<p>pstore/blk provides efficient configuration method for pstore/blk, which
divides all configurations into two parts, configurations for user and
configurations for driver.</p>
<p>Configurations for user determine how pstore/blk works, such as pmsg_size,
kmsg_size and so on. All of them support both Kconfig and module parameters,
but module parameters have priority over Kconfig.</p>
<p>Configurations for driver are all about block device and non-block device,
such as total_size of block device and read/write operations.</p>
</section>
<section id="configurations-for-user">
<h2>Configurations for user<a class="headerlink" href="#configurations-for-user" title="Permalink to this headline">¶</a></h2>
<p>All of these configurations support both Kconfig and module parameters, but
module parameters have priority over Kconfig.</p>
<p>Here is an example for module parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pstore_blk.blkdev=/dev/mmcblk0p7 pstore_blk.kmsg_size=64 best_effort=y
</pre></div>
</div>
<p>The detail of each configurations may be of interest to you.</p>
<section id="blkdev">
<h3>blkdev<a class="headerlink" href="#blkdev" title="Permalink to this headline">¶</a></h3>
<p>The block device to use. Most of the time, it is a partition of block device.
It’s required for pstore/blk. It is also used for MTD device.</p>
<p>When pstore/blk is built as a module, “blkdev” accepts the following variants:</p>
<ol class="arabic simple">
<li><p>/dev/&lt;disk_name&gt; represents the device number of disk</p></li>
<li><p>/dev/&lt;disk_name&gt;&lt;decimal&gt; represents the device number of partition - device
number of disk plus the partition number</p></li>
<li><p>/dev/&lt;disk_name&gt;p&lt;decimal&gt; - same as the above; this form is used when disk
name of partitioned disk ends with a digit.</p></li>
</ol>
<p>When pstore/blk is built into the kernel, “blkdev” accepts the following variants:</p>
<ol class="arabic simple">
<li><p>&lt;hex_major&gt;&lt;hex_minor&gt; device number in hexadecimal representation,
with no leading 0x, for example b302.</p></li>
<li><p>PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF represents the unique id of
a partition if the partition table provides it. The UUID may be either an
EFI/GPT UUID, or refer to an MSDOS partition using the format SSSSSSSS-PP,
where SSSSSSSS is a zero-filled hex representation of the 32-bit
“NT disk signature”, and PP is a zero-filled hex representation of the
1-based partition number.</p></li>
<li><p>PARTUUID=&lt;UUID&gt;/PARTNROFF=&lt;int&gt; to select a partition in relation to a
partition with a known unique id.</p></li>
<li><p>&lt;major&gt;:&lt;minor&gt; major and minor number of the device separated by a colon.</p></li>
</ol>
<p>It accepts the following variants for MTD device:</p>
<ol class="arabic simple">
<li><p>&lt;device name&gt; MTD device name. “pstore” is recommended.</p></li>
<li><p>&lt;device number&gt; MTD device number.</p></li>
</ol>
</section>
<section id="kmsg-size">
<h3>kmsg_size<a class="headerlink" href="#kmsg-size" title="Permalink to this headline">¶</a></h3>
<p>The chunk size in KB for oops/panic front-end. It <strong>MUST</strong> be a multiple of 4.
It’s optional if you do not care oops/panic log.</p>
<p>There are multiple chunks for oops/panic front-end depending on the remaining
space except other pstore front-ends.</p>
<p>pstore/blk will log to oops/panic chunks one by one, and always overwrite the
oldest chunk if there is no more free chunk.</p>
</section>
<section id="pmsg-size">
<h3>pmsg_size<a class="headerlink" href="#pmsg-size" title="Permalink to this headline">¶</a></h3>
<p>The chunk size in KB for pmsg front-end. It <strong>MUST</strong> be a multiple of 4.
It’s optional if you do not care pmsg log.</p>
<p>Unlike oops/panic front-end, there is only one chunk for pmsg front-end.</p>
<p>Pmsg is a user space accessible pstore object. Writes to <em>/dev/pmsg0</em> are
appended to the chunk. On reboot the contents are available in
<em>/sys/fs/pstore/pmsg-pstore-blk-0</em>.</p>
</section>
<section id="console-size">
<h3>console_size<a class="headerlink" href="#console-size" title="Permalink to this headline">¶</a></h3>
<p>The chunk size in KB for console front-end.  It <strong>MUST</strong> be a multiple of 4.
It’s optional if you do not care console log.</p>
<p>Similar to pmsg front-end, there is only one chunk for console front-end.</p>
<p>All log of console will be appended to the chunk. On reboot the contents are
available in <em>/sys/fs/pstore/console-pstore-blk-0</em>.</p>
</section>
<section id="ftrace-size">
<h3>ftrace_size<a class="headerlink" href="#ftrace-size" title="Permalink to this headline">¶</a></h3>
<p>The chunk size in KB for ftrace front-end. It <strong>MUST</strong> be a multiple of 4.
It’s optional if you do not care console log.</p>
<p>Similar to oops front-end, there are multiple chunks for ftrace front-end
depending on the count of cpu processors. Each chunk size is equal to
ftrace_size / processors_count.</p>
<p>All log of ftrace will be appended to the chunk. On reboot the contents are
combined and available in <em>/sys/fs/pstore/ftrace-pstore-blk-0</em>.</p>
<p>Persistent function tracing might be useful for debugging software or hardware
related hangs. Here is an example of usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t pstore pstore /sys/fs/pstore
# mount -t debugfs debugfs /sys/kernel/debug/
# echo 1 &gt; /sys/kernel/debug/pstore/record_ftrace
# reboot -f
[...]
# mount -t pstore pstore /sys/fs/pstore
# tail /sys/fs/pstore/ftrace-pstore-blk-0
CPU:0 ts:5914676 c0063828  c0063b94  call_cpuidle &lt;- cpu_startup_entry+0x1b8/0x1e0
CPU:0 ts:5914678 c039ecdc  c006385c  cpuidle_enter_state &lt;- call_cpuidle+0x44/0x48
CPU:0 ts:5914680 c039e9a0  c039ecf0  cpuidle_enter_freeze &lt;- cpuidle_enter_state+0x304/0x314
CPU:0 ts:5914681 c0063870  c039ea30  sched_idle_set_state &lt;- cpuidle_enter_state+0x44/0x314
CPU:1 ts:5916720 c0160f59  c015ee04  kernfs_unmap_bin_file &lt;- __kernfs_remove+0x140/0x204
CPU:1 ts:5916721 c05ca625  c015ee0c  __mutex_lock_slowpath &lt;- __kernfs_remove+0x148/0x204
CPU:1 ts:5916723 c05c813d  c05ca630  yield_to &lt;- __mutex_lock_slowpath+0x314/0x358
CPU:1 ts:5916724 c05ca2d1  c05ca638  __ww_mutex_lock &lt;- __mutex_lock_slowpath+0x31c/0x358
</pre></div>
</div>
</section>
<section id="max-reason">
<h3>max_reason<a class="headerlink" href="#max-reason" title="Permalink to this headline">¶</a></h3>
<p>Limiting which kinds of kmsg dumps are stored can be controlled via
the <code class="docutils literal notranslate"><span class="pre">max_reason</span></code> value, as defined in include/linux/kmsg_dump.h’s
<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">kmsg_dump_reason</span></code>. For example, to store both Oopses and Panics,
<code class="docutils literal notranslate"><span class="pre">max_reason</span></code> should be set to 2 (KMSG_DUMP_OOPS), to store only Panics
<code class="docutils literal notranslate"><span class="pre">max_reason</span></code> should be set to 1 (KMSG_DUMP_PANIC). Setting this to 0
(KMSG_DUMP_UNDEF), means the reason filtering will be controlled by the
<code class="docutils literal notranslate"><span class="pre">printk.always_kmsg_dump</span></code> boot param: if unset, it’ll be KMSG_DUMP_OOPS,
otherwise KMSG_DUMP_MAX.</p>
</section>
</section>
<section id="configurations-for-driver">
<h2>Configurations for driver<a class="headerlink" href="#configurations-for-driver" title="Permalink to this headline">¶</a></h2>
<p>A device driver uses <code class="docutils literal notranslate"><span class="pre">register_pstore_device</span></code> with
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pstore_device_info</span></code> to register to pstore/blk.</p>
<dl class="function">
<dt id="c.register_pstore_device">
int <code class="sig-name descname">register_pstore_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pstore_device_info" title="pstore_device_info">pstore_device_info</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_pstore_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register non-block device to pstore/blk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pstore_device_info</span> <span class="pre">*dev</span></code></dt><dd><p>non-block device information</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0          - OK</p></li>
<li><p>Others     - something error.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.unregister_pstore_device">
void <code class="sig-name descname">unregister_pstore_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pstore_device_info" title="pstore_device_info">pstore_device_info</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_pstore_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister non-block device from pstore/blk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pstore_device_info</span> <span class="pre">*dev</span></code></dt><dd><p>non-block device information</p>
</dd>
</dl>
</div>
</section>
<section id="compression-and-header">
<h2>Compression and header<a class="headerlink" href="#compression-and-header" title="Permalink to this headline">¶</a></h2>
<p>Block device is large enough for uncompressed oops data. Actually we do not
recommend data compression because pstore/blk will insert some information into
the first line of oops/panic data. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Panic: Total 16 times
</pre></div>
</div>
<p>It means that it’s OOPS|Panic for the 16th time since the first booting.
Sometimes the number of occurrences of oops|panic since the first booting is
important to judge whether the system is stable.</p>
<p>The following line is inserted by pstore filesystem. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Oops#2 Part1
</pre></div>
</div>
<p>It means that it’s OOPS for the 2nd time on the last boot.</p>
</section>
<section id="reading-the-data">
<h2>Reading the data<a class="headerlink" href="#reading-the-data" title="Permalink to this headline">¶</a></h2>
<p>The dump data can be read from the pstore filesystem. The format for these
files is <code class="docutils literal notranslate"><span class="pre">dmesg-pstore-blk-[N]</span></code> for oops/panic front-end,
<code class="docutils literal notranslate"><span class="pre">pmsg-pstore-blk-0</span></code> for pmsg front-end and so on.  The timestamp of the
dump file records the trigger time. To delete a stored record from block
device, simply unlink the respective pstore file.</p>
</section>
<section id="attentions-in-panic-read-write-apis">
<h2>Attentions in panic read/write APIs<a class="headerlink" href="#attentions-in-panic-read-write-apis" title="Permalink to this headline">¶</a></h2>
<p>If on panic, the kernel is not going to run for much longer, the tasks will not
be scheduled and most kernel resources will be out of service. It
looks like a single-threaded program running on a single-core computer.</p>
<p>The following points require special attention for panic read/write APIs:</p>
<ol class="arabic simple">
<li><p>Can <strong>NOT</strong> allocate any memory.
If you need memory, just allocate while the block driver is initializing
rather than waiting until the panic.</p></li>
<li><p>Must be polled, <strong>NOT</strong> interrupt driven.
No task schedule any more. The block driver should delay to ensure the write
succeeds, but NOT sleep.</p></li>
<li><p>Can <strong>NOT</strong> take any lock.
There is no other task, nor any shared resource; you are safe to break all
locks.</p></li>
<li><p>Just use CPU to transfer.
Do not use DMA to transfer unless you are sure that DMA will not keep lock.</p></li>
<li><p>Control registers directly.
Please control registers directly rather than use Linux kernel resources.
Do I/O map while initializing rather than wait until a panic occurs.</p></li>
<li><p>Reset your block device and controller if necessary.
If you are not sure of the state of your block device and controller when
a panic occurs, you are safe to stop and reset them.</p></li>
</ol>
<p>pstore/blk supports psblk_blkdev_info(), which is defined in
<em>linux/pstore_blk.h</em>, to get information of using block device, such as the
device number, sector count and start sector of the whole disk.</p>
</section>
<section id="pstore-block-internals">
<h2>pstore block internals<a class="headerlink" href="#pstore-block-internals" title="Permalink to this headline">¶</a></h2>
<p>For developer reference, here are all the important structures and APIs:</p>
<dl class="type">
<dt id="c.psz_buffer">
struct <code class="sig-name descname">psz_buffer</code><a class="headerlink" href="#c.psz_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>header of zone to flush to storage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct psz_buffer {
#define PSZ_SIG (0x43474244) ;
    uint32_t sig;
    atomic_t datalen;
    atomic_t start;
    uint8_t data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sig</span></code></dt><dd><p>signature to indicate header (PSZ_SIG xor PSZONE-type value)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">datalen</span></code></dt><dd><p>length of data in <strong>data</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>offset into <strong>data</strong> where the beginning of the stored bytes begin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>zone data.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.psz_kmsg_header">
struct <code class="sig-name descname">psz_kmsg_header</code><a class="headerlink" href="#c.psz_kmsg_header" title="Permalink to this definition">¶</a></dt>
<dd><p>kmsg dump-specific header to flush to storage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct psz_kmsg_header {
#define PSTORE_KMSG_HEADER_MAGIC 0x4dfc3ae5 ;
    uint32_t magic;
    struct timespec64 time;
    bool compressed;
    uint32_t counter;
    enum kmsg_dump_reason reason;
    uint8_t data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">magic</span></code></dt><dd><p>magic num for kmsg dump header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>kmsg dump trigger time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compressed</span></code></dt><dd><p>whether conpressed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">counter</span></code></dt><dd><p>kmsg dump counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reason</span></code></dt><dd><p>the kmsg dump reason (e.g. oops, panic, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>pointer to log data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is a sub-header for a kmsg dump, trailing after <a class="reference internal" href="#c.psz_buffer" title="psz_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">psz_buffer</span></code></a>.</p>
<dl class="type">
<dt id="c.pstore_zone">
struct <code class="sig-name descname">pstore_zone</code><a class="headerlink" href="#c.pstore_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>single stored buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pstore_zone {
    loff_t off;
    const char *name;
    enum pstore_type_id type;
    struct psz_buffer *buffer;
    struct psz_buffer *oldbuf;
    size_t buffer_size;
    bool should_recover;
    atomic_t dirty;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">off</span></code></dt><dd><p>zone offset of storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>front-end name for this zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>front-end type for this zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>pointer to data buffer managed by this zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oldbuf</span></code></dt><dd><p>pointer to old data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code></dt><dd><p>bytes in <strong>buffer-&gt;data</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">should_recover</span></code></dt><dd><p>whether this zone should recover from storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty</span></code></dt><dd><p>whether the data in <strong>buffer</strong> dirty</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>zone structure in memory.</p>
<dl class="type">
<dt id="c.psz_context">
struct <code class="sig-name descname">psz_context</code><a class="headerlink" href="#c.psz_context" title="Permalink to this definition">¶</a></dt>
<dd><p>all about running state of pstore/zone</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct psz_context {
    struct pstore_zone **kpszs;
    struct pstore_zone *ppsz;
    struct pstore_zone *cpsz;
    struct pstore_zone **fpszs;
    unsigned int kmsg_max_cnt;
    unsigned int kmsg_read_cnt;
    unsigned int kmsg_write_cnt;
    unsigned int pmsg_read_cnt;
    unsigned int console_read_cnt;
    unsigned int ftrace_max_cnt;
    unsigned int ftrace_read_cnt;
    unsigned int oops_counter;
    unsigned int panic_counter;
    atomic_t recovered;
    atomic_t on_panic;
    struct mutex pstore_zone_info_lock;
    struct pstore_zone_info *pstore_zone_info;
    struct pstore_info pstore;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kpszs</span></code></dt><dd><p>kmsg dump storage zones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ppsz</span></code></dt><dd><p>pmsg storage zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpsz</span></code></dt><dd><p>console storage zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fpszs</span></code></dt><dd><p>ftrace storage zones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kmsg_max_cnt</span></code></dt><dd><p>max count of <strong>kpszs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kmsg_read_cnt</span></code></dt><dd><p>counter of total read kmsg dumps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kmsg_write_cnt</span></code></dt><dd><p>counter of total kmsg dump writes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsg_read_cnt</span></code></dt><dd><p>counter of total read pmsg zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">console_read_cnt</span></code></dt><dd><p>counter of total read console zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ftrace_max_cnt</span></code></dt><dd><p>max count of <strong>fpszs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ftrace_read_cnt</span></code></dt><dd><p>counter of max read ftrace zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oops_counter</span></code></dt><dd><p>counter of oops dumps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">panic_counter</span></code></dt><dd><p>counter of panic dumps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">recovered</span></code></dt><dd><p>whether finished recovering data from storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">on_panic</span></code></dt><dd><p>whether panic is happening</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pstore_zone_info_lock</span></code></dt><dd><p>lock to <strong>pstore_zone_info</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pstore_zone_info</span></code></dt><dd><p>information from backend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pstore</span></code></dt><dd><p>structure for pstore</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.psz_flush_mode">
enum <code class="sig-name descname">psz_flush_mode</code><a class="headerlink" href="#c.psz_flush_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>flush mode for psz_zone_write()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FLUSH_NONE</span></code></dt><dd><p>do not flush to storage but update data on memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLUSH_PART</span></code></dt><dd><p>just flush part of data including meta data to storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLUSH_META</span></code></dt><dd><p>just flush meta data of zone to storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLUSH_ALL</span></code></dt><dd><p>flush all of zone</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.psz_recovery">
int <code class="sig-name descname">psz_recovery</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.psz_context" title="psz_context">psz_context</a><em> *cxt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.psz_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>recover data from storage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">psz_context</span> <span class="pre">*cxt</span></code></dt><dd><p>the context of pstore/zone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>recovery means reading data back from storage after rebooting</p>
<p><strong>Return</strong></p>
<p>0 on success, others on failure.</p>
</div>
<dl class="type">
<dt id="c.pstore_zone_info">
struct <code class="sig-name descname">pstore_zone_info</code><a class="headerlink" href="#c.pstore_zone_info" title="Permalink to this definition">¶</a></dt>
<dd><p>pstore/zone back-end driver structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pstore_zone_info {
    struct module *owner;
    const char *name;
    unsigned long total_size;
    unsigned long kmsg_size;
    int max_reason;
    unsigned long pmsg_size;
    unsigned long console_size;
    unsigned long ftrace_size;
    pstore_zone_read_op read;
    pstore_zone_write_op write;
    pstore_zone_erase_op erase;
    pstore_zone_write_op panic_write;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Module which is responsible for this back-end driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the back-end driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_size</span></code></dt><dd><p>The total size in bytes pstore/zone can use. It must be greater
than 4096 and be multiple of 4096.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kmsg_size</span></code></dt><dd><p>The size of oops/panic zone. Zero means disabled, otherwise,
it must be multiple of SECTOR_SIZE(512 Bytes).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_reason</span></code></dt><dd><p>Maximum kmsg dump reason to store.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsg_size</span></code></dt><dd><p>The size of pmsg zone which is the same as <strong>kmsg_size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">console_size</span></code></dt><dd><p>The size of console zone which is the same as <strong>kmsg_size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ftrace_size</span></code></dt><dd><p>The size of ftrace zone which is the same as <strong>kmsg_size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>The general read operation. Both of the function parameters
<strong>size</strong> and <strong>offset</strong> are relative value to storage.
On success, the number of bytes should be returned, others
mean error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>The same as <strong>read</strong>, but the following error number:
-EBUSY means try to write again later.
-ENOMSG means to try next zone.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erase</span></code></dt><dd><p>The general erase operation for device with special removing
job. Both of the function parameters <strong>size</strong> and <strong>offset</strong> are
relative value to storage.
Return 0 on success and others on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">panic_write</span></code></dt><dd><p>The write operation only used for panic case. It’s optional
if you do not care panic log. The parameters are relative
value to storage.
On success, the number of bytes should be returned, others
excluding -ENOMSG mean error. -ENOMSG means to try next zone.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pstore_device_info">
struct <code class="sig-name descname">pstore_device_info</code><a class="headerlink" href="#c.pstore_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>back-end pstore/blk driver structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pstore_device_info {
    unsigned int flags;
    struct pstore_zone_info zone;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Refer to macro starting with PSTORE_FLAGS defined in
linux/pstore.h. It means what front-ends this device support.
Zero means all backends for compatible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>The <a class="reference internal" href="#c.pstore_zone_info" title="pstore_zone_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pstore_zone_info</span></code></a> details.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pstore_blk_config">
struct <code class="sig-name descname">pstore_blk_config</code><a class="headerlink" href="#c.pstore_blk_config" title="Permalink to this definition">¶</a></dt>
<dd><p>the pstore_blk backend configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pstore_blk_config {
    char device[80];
    enum kmsg_dump_reason max_reason;
    unsigned long kmsg_size;
    unsigned long pmsg_size;
    unsigned long console_size;
    unsigned long ftrace_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt><dd><p>Name of the desired block device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_reason</span></code></dt><dd><p>Maximum kmsg dump reason to store to block device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kmsg_size</span></code></dt><dd><p>Total size of for kmsg dumps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsg_size</span></code></dt><dd><p>Total size of the pmsg storage area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">console_size</span></code></dt><dd><p>Total size of the console storage area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ftrace_size</span></code></dt><dd><p>Total size for ftrace logging data (for all CPUs)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pstore_blk_get_config">
int <code class="sig-name descname">pstore_blk_get_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pstore_blk_config" title="pstore_blk_config">pstore_blk_config</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pstore_blk_get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>get a copy of the pstore_blk backend configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pstore_blk_config</span> <span class="pre">*info</span></code></dt><dd><p>The sturct pstore_blk_config to be filled in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Failure returns negative error code, and success returns 0.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pstore block oops/panic logger</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#pstore-block-concepts">pstore block concepts</a></li>
<li><a class="reference internal" href="#configurations-for-user">Configurations for user</a><ul>
<li><a class="reference internal" href="#blkdev">blkdev</a></li>
<li><a class="reference internal" href="#kmsg-size">kmsg_size</a></li>
<li><a class="reference internal" href="#pmsg-size">pmsg_size</a></li>
<li><a class="reference internal" href="#console-size">console_size</a></li>
<li><a class="reference internal" href="#ftrace-size">ftrace_size</a></li>
<li><a class="reference internal" href="#max-reason">max_reason</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configurations-for-driver">Configurations for driver</a></li>
<li><a class="reference internal" href="#compression-and-header">Compression and header</a></li>
<li><a class="reference internal" href="#reading-the-data">Reading the data</a></li>
<li><a class="reference internal" href="#attentions-in-panic-read-write-apis">Attentions in panic read/write APIs</a></li>
<li><a class="reference internal" href="#pstore-block-internals">pstore block internals</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/admin-guide/pstore-blk.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/admin-guide/pstore-blk.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>