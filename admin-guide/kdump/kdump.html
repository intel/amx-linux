
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Documentation for Kdump - The kexec-based Crash Dumping Solution &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="VMCOREINFO" href="vmcoreinfo.html" />
    <link rel="prev" title="Documentation for Kdump - The kexec-based Crash Dumping Solution" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="documentation-for-kdump-the-kexec-based-crash-dumping-solution">
<h1>Documentation for Kdump - The kexec-based Crash Dumping Solution<a class="headerlink" href="#documentation-for-kdump-the-kexec-based-crash-dumping-solution" title="Permalink to this headline">¶</a></h1>
<p>This document includes overview, setup, installation, and analysis
information.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Kdump uses kexec to quickly boot to a dump-capture kernel whenever a
dump of the system kernel’s memory needs to be taken (for example, when
the system panics). The system kernel’s memory image is preserved across
the reboot and is accessible to the dump-capture kernel.</p>
<p>You can use common commands, such as cp, scp or makedumpfile to copy
the memory image to a dump file on the local disk, or across the network
to a remote system.</p>
<p>Kdump and kexec are currently supported on the x86, x86_64, ppc64, ia64,
s390x, arm and arm64 architectures.</p>
<p>When the system kernel boots, it reserves a small section of memory for
the dump-capture kernel. This ensures that ongoing Direct Memory Access
(DMA) from the system kernel does not corrupt the dump-capture kernel.
The kexec -p command loads the dump-capture kernel into this reserved
memory.</p>
<p>On x86 machines, the first 640 KB of physical memory is needed for boot,
regardless of where the kernel loads. For simpler handling, the whole
low 1M is reserved to avoid any later kernel or device driver writing
data into this area. Like this, the low 1M can be reused as system RAM
by kdump kernel without extra handling.</p>
<p>On PPC64 machines first 32KB of physical memory is needed for booting
regardless of where the kernel is loaded and to support 64K page size
kexec backs up the first 64KB memory.</p>
<p>For s390x, when kdump is triggered, the crashkernel region is exchanged
with the region [0, crashkernel region size] and then the kdump kernel
runs in [0, crashkernel region size]. Therefore no relocatable kernel is
needed for s390x.</p>
<p>All of the necessary information about the system kernel’s core image is
encoded in the ELF format, and stored in a reserved area of memory
before a crash. The physical address of the start of the ELF header is
passed to the dump-capture kernel through the elfcorehdr= boot
parameter. Optionally the size of the ELF header can also be passed
when using the elfcorehdr=[size[KMG]&#64;]offset[KMG] syntax.</p>
<p>With the dump-capture kernel, you can access the memory image through
/proc/vmcore. This exports the dump as an ELF-format file that you can
write out using file copy commands such as cp or scp. You can also use
makedumpfile utility to analyze and write out filtered contents with
options, e.g with ‘-d 31’ it will only write out kernel data. Further,
you can use analysis tools such as the GNU Debugger (GDB) and the Crash
tool to debug the dump file. This method ensures that the dump pages are
correctly ordered.</p>
</section>
<section id="setup-and-installation">
<h2>Setup and Installation<a class="headerlink" href="#setup-and-installation" title="Permalink to this headline">¶</a></h2>
<section id="install-kexec-tools">
<h3>Install kexec-tools<a class="headerlink" href="#install-kexec-tools" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Login as the root user.</p></li>
<li><p>Download the kexec-tools user-space package from the following URL:</p></li>
</ol>
<p><a class="reference external" href="http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz">http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz</a></p>
<p>This is a symlink to the latest version.</p>
<p>The latest kexec-tools git tree is available at:</p>
<ul class="simple">
<li><p>git://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git</p></li>
<li><p><a class="reference external" href="http://www.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git">http://www.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git</a></p></li>
</ul>
<p>There is also a gitweb interface available at
<a class="reference external" href="http://www.kernel.org/git/?p=utils/kernel/kexec/kexec-tools.git">http://www.kernel.org/git/?p=utils/kernel/kexec/kexec-tools.git</a></p>
<p>More information about kexec-tools can be found at
<a class="reference external" href="http://horms.net/projects/kexec/">http://horms.net/projects/kexec/</a></p>
<ol class="arabic" start="3">
<li><p>Unpack the tarball with the tar command, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tar xvpzf kexec-tools.tar.gz
</pre></div>
</div>
</li>
<li><p>Change to the kexec-tools directory, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cd kexec-tools-VERSION
</pre></div>
</div>
</li>
<li><p>Configure the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./configure
</pre></div>
</div>
</li>
<li><p>Compile the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make
</pre></div>
</div>
</li>
<li><p>Install the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make install
</pre></div>
</div>
</li>
</ol>
</section>
<section id="build-the-system-and-dump-capture-kernels">
<h3>Build the system and dump-capture kernels<a class="headerlink" href="#build-the-system-and-dump-capture-kernels" title="Permalink to this headline">¶</a></h3>
<p>There are two possible methods of using Kdump.</p>
<ol class="arabic simple">
<li><p>Build a separate custom dump-capture kernel for capturing the
kernel core dump.</p></li>
<li><p>Or use the system kernel binary itself as dump-capture kernel and there is
no need to build a separate dump-capture kernel. This is possible
only with the architectures which support a relocatable kernel. As
of today, i386, x86_64, ppc64, ia64, arm and arm64 architectures support
relocatable kernel.</p></li>
</ol>
<p>Building a relocatable kernel is advantageous from the point of view that
one does not have to build a second kernel for capturing the dump. But
at the same time one might want to build a custom dump capture kernel
suitable to his needs.</p>
<p>Following are the configuration setting required for system and
dump-capture kernels for enabling kdump support.</p>
</section>
<section id="system-kernel-config-options">
<h3>System kernel config options<a class="headerlink" href="#system-kernel-config-options" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Enable “kexec system call” or “kexec file based system call” in
“Processor type and features.”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KEXEC=y or CONFIG_KEXEC_FILE=y
</pre></div>
</div>
<p>And both of them will select KEXEC_CORE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KEXEC_CORE=y
</pre></div>
</div>
<p>Subsequently, CRASH_CORE is selected by KEXEC_CORE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_CRASH_CORE=y
</pre></div>
</div>
</li>
<li><p>Enable “sysfs file system support” in “Filesystem” -&gt; “Pseudo
filesystems.” This is usually enabled by default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_SYSFS=y
</pre></div>
</div>
<p>Note that “sysfs file system support” might not appear in the “Pseudo
filesystems” menu if “Configure standard kernel features (expert users)”
is not enabled in “General Setup.” In this case, check the .config file
itself to ensure that sysfs is turned on, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>grep &#39;CONFIG_SYSFS&#39; .config
</pre></div>
</div>
</li>
<li><p>Enable “Compile the kernel with debug info” in “Kernel hacking.”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_DEBUG_INFO=Y
</pre></div>
</div>
<p>This causes the kernel to be built with debug symbols. The dump
analysis tools require a vmlinux with debug symbols in order to read
and analyze a dump file.</p>
</li>
</ol>
</section>
<section id="dump-capture-kernel-config-options-arch-independent">
<h3>Dump-capture kernel config options (Arch Independent)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-independent" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Enable “kernel crash dumps” support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_CRASH_DUMP=y
</pre></div>
</div>
</li>
<li><p>Enable “/proc/vmcore support” under “Filesystems” -&gt; “Pseudo filesystems”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_PROC_VMCORE=y
</pre></div>
</div>
<p>(CONFIG_PROC_VMCORE is set by default when CONFIG_CRASH_DUMP is selected.)</p>
</li>
</ol>
</section>
<section id="dump-capture-kernel-config-options-arch-dependent-i386-and-x86-64">
<h3>Dump-capture kernel config options (Arch Dependent, i386 and x86_64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-i386-and-x86-64" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>On i386, enable high memory support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_HIGHMEM64G=y
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_HIGHMEM4G
</pre></div>
</div>
</li>
<li><p>With CONFIG_SMP=y, usually nr_cpus=1 need specified on the kernel
command line when loading the dump-capture kernel because one
CPU is enough for kdump kernel to dump vmcore on most of systems.</p>
<p>However, you can also specify nr_cpus=X to enable multiple processors
in kdump kernel. In this case, “disable_cpu_apicid=” is needed to
tell kdump kernel which cpu is 1st kernel’s BSP. Please refer to
admin-guide/kernel-parameters.txt for more details.</p>
<p>With CONFIG_SMP=n, the above things are not related.</p>
</li>
<li><p>A relocatable kernel is suggested to be built by default. If not yet,
enable “Build a relocatable kernel” support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_RELOCATABLE=y
</pre></div>
</div>
</li>
<li><p>Use a suitable value for “Physical address where the kernel is
loaded” (under “Processor type and features”). This only appears when
“kernel crash dumps” is enabled. A suitable value depends upon
whether kernel is relocatable or not.</p>
<p>If you are using a relocatable kernel use CONFIG_PHYSICAL_START=0x100000
This will compile the kernel for physical address 1MB, but given the fact
kernel is relocatable, it can be run from any physical address hence
kexec boot loader will load it in memory region reserved for dump-capture
kernel.</p>
<p>Otherwise it should be the start of memory region reserved for
second kernel using boot parameter “crashkernel=Y&#64;X”. Here X is
start of memory region reserved for dump-capture kernel.
Generally X is 16MB (0x1000000). So you can set
CONFIG_PHYSICAL_START=0x1000000</p>
</li>
<li><p>Make and install the kernel and its modules. DO NOT add this kernel
to the boot loader configuration files.</p></li>
</ol>
</section>
<section id="dump-capture-kernel-config-options-arch-dependent-ppc64">
<h3>Dump-capture kernel config options (Arch Dependent, ppc64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-ppc64" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Enable “Build a kdump crash kernel” support under “Kernel” options:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_CRASH_DUMP=y
</pre></div>
</div>
</li>
<li><p>Enable “Build a relocatable kernel” support:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_RELOCATABLE=y
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><p>Make and install the kernel and its modules.</p>
</div></blockquote>
</section>
<section id="dump-capture-kernel-config-options-arch-dependent-ia64">
<h3>Dump-capture kernel config options (Arch Dependent, ia64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-ia64" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>No specific options are required to create a dump-capture kernel
for ia64, other than those specified in the arch independent section
above. This means that it is possible to use the system kernel
as a dump-capture kernel if desired.</p>
<p>The crashkernel region can be automatically placed by the system
kernel at runtime. This is done by specifying the base address as 0,
or omitting it all together:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M@0
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M
</pre></div>
</div>
</li>
</ul>
</section>
<section id="dump-capture-kernel-config-options-arch-dependent-arm">
<h3>Dump-capture kernel config options (Arch Dependent, arm)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-arm" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>To use a relocatable kernel,
Enable “AUTO_ZRELADDR” support under “Boot” options:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AUTO_ZRELADDR=y
</pre></div>
</div>
</li>
</ul>
</section>
<section id="dump-capture-kernel-config-options-arch-dependent-arm64">
<h3>Dump-capture kernel config options (Arch Dependent, arm64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-arm64" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Please note that kvm of the dump-capture kernel will not be enabled
on non-VHE systems even if it is configured. This is because the CPU
will not be reset to EL2 on panic.</p></li>
</ul>
</section>
</section>
<section id="crashkernel-syntax">
<h2>crashkernel syntax<a class="headerlink" href="#crashkernel-syntax" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p><a class="reference external" href="mailto:crashkernel=size&#37;&#52;&#48;offset">crashkernel=size<span>&#64;</span>offset</a></p>
<p>Here ‘size’ specifies how much memory to reserve for the dump-capture kernel
and ‘offset’ specifies the beginning of this reserved memory. For example,
“<a class="reference external" href="mailto:crashkernel=64M&#37;&#52;&#48;16M">crashkernel=64M<span>&#64;</span>16M</a>” tells the system kernel to reserve 64 MB of memory
starting at physical address 0x01000000 (16MB) for the dump-capture kernel.</p>
<p>The crashkernel region can be automatically placed by the system
kernel at run time. This is done by specifying the base address as 0,
or omitting it all together:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M@0
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M
</pre></div>
</div>
<p>If the start address is specified, note that the start address of the
kernel will be aligned to a value (which is Arch dependent), so if the
start address is not then any space below the alignment point will be
wasted.</p>
</li>
<li><p>range1:size1[,range2:size2,…][&#64;offset]</p>
<p>While the “crashkernel=size[&#64;offset]” syntax is sufficient for most
configurations, sometimes it’s handy to have the reserved memory dependent
on the value of System RAM – that’s mostly for distributors that pre-setup
the kernel command line to avoid a unbootable system after some memory has
been removed from the machine.</p>
<p>The syntax is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=&lt;range1&gt;:&lt;size1&gt;[,&lt;range2&gt;:&lt;size2&gt;,...][@offset]
range=start-[end]
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=512M-2G:64M,2G-:128M
</pre></div>
</div>
<p>This would mean:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>if the RAM is smaller than 512M, then don’t reserve anything
(this is the “rescue” case)</p></li>
<li><p>if the RAM size is between 512M and 2G (exclusive), then reserve 64M</p></li>
<li><p>if the RAM size is larger than 2G, then reserve 128M</p></li>
</ol>
</div></blockquote>
</li>
<li><p>crashkernel=size,high and crashkernel=size,low</p>
<p>If memory above 4G is preferred, crashkernel=size,high can be used to
fulfill that. With it, physical memory is allowed to be allocated from top,
so could be above 4G if system has more than 4G RAM installed. Otherwise,
memory region will be allocated below 4G if available.</p>
<p>When crashkernel=X,high is passed, kernel could allocate physical memory
region above 4G, low memory under 4G is needed in this case. There are
three ways to get low memory:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Kernel will allocate at least 256M memory below 4G automatically
if crashkernel=Y,low is not specified.</p></li>
<li><p>Let user specify low memory size instead.</p></li>
<li><p>Specified value 0 will disable low memory allocation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=0,low
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</li>
</ol>
<section id="boot-into-system-kernel">
<h3>Boot into System Kernel<a class="headerlink" href="#boot-into-system-kernel" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Update the boot loader (such as grub, yaboot, or lilo) configuration
files as necessary.</p></li>
<li><p>Boot the system kernel with the boot parameter “crashkernel=Y&#64;X”.</p>
<p>On x86 and x86_64, use “crashkernel=Y[&#64;X]”. Most of the time, the
start address ‘X’ is not necessary, kernel will search a suitable
area. Unless an explicit start address is expected.</p>
<p>On ppc64, use “<a class="reference external" href="mailto:crashkernel=128M&#37;&#52;&#48;32M">crashkernel=128M<span>&#64;</span>32M</a>”.</p>
<p>On ia64, <a class="reference external" href="mailto:256M&#37;&#52;&#48;256M">256M<span>&#64;</span>256M</a> is a generous value that typically works.
The region may be automatically placed on ia64, see the
dump-capture kernel config option notes above.
If use sparse memory, the size should be rounded to GRANULE boundaries.</p>
<p>On s390x, typically use “crashkernel=xxM”. The value of xx is dependent
on the memory consumption of the kdump system. In general this is not
dependent on the memory size of the production system.</p>
<p>On arm, the use of “crashkernel=Y&#64;X” is no longer necessary; the
kernel will automatically locate the crash kernel image within the
first 512MB of RAM if X is not given.</p>
<p>On arm64, use “crashkernel=Y[&#64;X]”.  Note that the start address of
the kernel, X if explicitly specified, must be aligned to 2MiB (0x200000).</p>
</li>
</ol>
</section>
</section>
<section id="load-the-dump-capture-kernel">
<h2>Load the Dump-capture Kernel<a class="headerlink" href="#load-the-dump-capture-kernel" title="Permalink to this headline">¶</a></h2>
<p>After booting to the system kernel, dump-capture kernel needs to be
loaded.</p>
<p>Based on the architecture and type of image (relocatable or not), one
can choose to load the uncompressed vmlinux or compressed bzImage/vmlinuz
of dump-capture kernel. Following is the summary.</p>
<p>For i386 and x86_64:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use bzImage/vmlinuz if kernel is relocatable.</p></li>
<li><p>Use vmlinux if kernel is not relocatable.</p></li>
</ul>
</div></blockquote>
<p>For ppc64:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use vmlinux</p></li>
</ul>
</div></blockquote>
<p>For ia64:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use vmlinux or vmlinuz.gz</p></li>
</ul>
</div></blockquote>
<p>For s390x:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use image or bzImage</p></li>
</ul>
</div></blockquote>
<p>For arm:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use zImage</p></li>
</ul>
</div></blockquote>
<p>For arm64:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use vmlinux or Image</p></li>
</ul>
</div></blockquote>
<p>If you are using an uncompressed vmlinux image then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-vmlinux-image&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; --args-linux \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using a compressed bzImage/vmlinuz, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-bzImage&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using a compressed zImage, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec --type zImage -p &lt;dump-capture-kernel-bzImage&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--dtb=&lt;dtb-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using an uncompressed Image, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-Image&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>Please note, that –args-linux does not need to be specified for ia64.
It is planned to make this a no-op on that architecture, but for now
it should be omitted</p>
<p>Following are the arch specific command line options to be used while
loading dump-capture kernel.</p>
<p>For i386, x86_64 and ia64:</p>
<blockquote>
<div><p>“1 irqpoll nr_cpus=1 reset_devices”</p>
</div></blockquote>
<p>For ppc64:</p>
<blockquote>
<div><p>“1 maxcpus=1 noirqdistrib reset_devices”</p>
</div></blockquote>
<p>For s390x:</p>
<blockquote>
<div><p>“1 nr_cpus=1 cgroup_disable=memory”</p>
</div></blockquote>
<p>For arm:</p>
<blockquote>
<div><p>“1 maxcpus=1 reset_devices”</p>
</div></blockquote>
<p>For arm64:</p>
<blockquote>
<div><p>“1 nr_cpus=1 reset_devices”</p>
</div></blockquote>
<p>Notes on loading the dump-capture kernel:</p>
<ul>
<li><p>By default, the ELF headers are stored in ELF64 format to support
systems with more than 4GB memory. On i386, kexec automatically checks if
the physical RAM size exceeds the 4 GB limit and if not, uses ELF32.
So, on non-PAE systems, ELF32 is always used.</p>
<p>The –elf32-core-headers option can be used to force the generation of ELF32
headers. This is necessary because GDB currently cannot open vmcore files
with ELF64 headers on 32-bit systems.</p>
</li>
<li><p>The “irqpoll” boot parameter reduces driver initialization failures
due to shared interrupts in the dump-capture kernel.</p></li>
<li><p>You must specify &lt;root-dev&gt; in the format corresponding to the root
device name in the output of mount command.</p></li>
<li><p>Boot parameter “1” boots the dump-capture kernel into single-user
mode without networking. If you want networking, use “3”.</p></li>
<li><p>We generally don’t have to bring up a SMP kernel just to capture the
dump. Hence generally it is useful either to build a UP dump-capture
kernel or specify maxcpus=1 option while loading dump-capture kernel.
Note, though maxcpus always works, you had better replace it with
nr_cpus to save memory if supported by the current ARCH, such as x86.</p></li>
<li><p>You should enable multi-cpu support in dump-capture kernel if you intend
to use multi-thread programs with it, such as parallel dump feature of
makedumpfile. Otherwise, the multi-thread program may have a great
performance degradation. To enable multi-cpu support, you should bring up an
SMP dump-capture kernel and specify maxcpus/nr_cpus, disable_cpu_apicid=[X]
options while loading it.</p></li>
<li><p>For s390x there are two kdump modes: If a ELF header is specified with
the elfcorehdr= kernel parameter, it is used by the kdump kernel as it
is done on all other architectures. If no elfcorehdr= kernel parameter is
specified, the s390x kdump kernel dynamically creates the header. The
second mode has the advantage that for CPU and memory hotplug, kdump has
not to be reloaded with kexec_load().</p></li>
<li><p>For s390x systems with many attached devices the “cio_ignore” kernel
parameter should be used for the kdump kernel in order to prevent allocation
of kernel memory for devices that are not relevant for kdump. The same
applies to systems that use SCSI/FCP devices. In that case the
“allow_lun_scan” zfcp module parameter should be set to zero before
setting FCP devices online.</p></li>
</ul>
</section>
<section id="kernel-panic">
<h2>Kernel Panic<a class="headerlink" href="#kernel-panic" title="Permalink to this headline">¶</a></h2>
<p>After successfully loading the dump-capture kernel as previously
described, the system will reboot into the dump-capture kernel if a
system crash is triggered.  Trigger points are located in <a class="reference internal" href="../../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a>,
die(), die_nmi() and in the sysrq handler (ALT-SysRq-c).</p>
<p>The following conditions will execute a crash trigger point:</p>
<p>If a hard lockup is detected and “NMI watchdog” is configured, the system
will boot into the dump-capture kernel ( die_nmi() ).</p>
<p>If die() is called, and it happens to be a thread with pid 0 or 1, or die()
is called inside interrupt context or die() is called and panic_on_oops is set,
the system will boot into the dump-capture kernel.</p>
<p>On powerpc systems when a soft-reset is generated, die() is called by all cpus
and the system will boot into the dump-capture kernel.</p>
<p>For testing purposes, you can trigger a crash by using “ALT-SysRq-c”,
“echo c &gt; /proc/sysrq-trigger” or write a module to force the panic.</p>
</section>
<section id="write-out-the-dump-file">
<h2>Write Out the Dump File<a class="headerlink" href="#write-out-the-dump-file" title="Permalink to this headline">¶</a></h2>
<p>After the dump-capture kernel is booted, write out the dump file with
the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cp /proc/vmcore &lt;dump-file&gt;
</pre></div>
</div>
<p>or use scp to write out the dump file between hosts on a network, e.g:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>scp /proc/vmcore remote_username@remote_ip:&lt;dump-file&gt;
</pre></div>
</div>
<p>You can also use makedumpfile utility to write out the dump file
with specified options to filter out unwanted contents, e.g:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>makedumpfile -l --message-level 1 -d 31 /proc/vmcore &lt;dump-file&gt;
</pre></div>
</div>
</section>
<section id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Before analyzing the dump image, you should reboot into a stable kernel.</p>
<p>You can do limited analysis using GDB on the dump file copied out of
/proc/vmcore. Use the debug vmlinux built with -g and run the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gdb vmlinux &lt;dump-file&gt;
</pre></div>
</div>
<p>Stack trace for the task on processor 0, register display, and memory
display work fine.</p>
<p>Note: GDB cannot analyze core files generated in ELF64 format for x86.
On systems with a maximum of 4GB of memory, you can generate
ELF32-format headers using the –elf32-core-headers kernel option on the
dump kernel.</p>
<p>You can also use the Crash utility to analyze dump files in Kdump
format. Crash is available at the following URL:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/crash-utility/crash">https://github.com/crash-utility/crash</a></p>
</div></blockquote>
<dl class="simple">
<dt>Crash document can be found at:</dt><dd><p><a class="reference external" href="https://crash-utility.github.io/">https://crash-utility.github.io/</a></p>
</dd>
</dl>
</section>
<section id="trigger-kdump-on-warn">
<h2>Trigger Kdump on WARN()<a class="headerlink" href="#trigger-kdump-on-warn" title="Permalink to this headline">¶</a></h2>
<p>The kernel parameter, panic_on_warn, calls <a class="reference internal" href="../../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a> in all WARN() paths.  This
will cause a kdump to occur at the <a class="reference internal" href="../../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a> call.  In cases where a user wants
to specify this during runtime, /proc/sys/kernel/panic_on_warn can be set to 1
to achieve the same behaviour.</p>
</section>
<section id="trigger-kdump-on-add-taint">
<h2>Trigger Kdump on add_taint()<a class="headerlink" href="#trigger-kdump-on-add-taint" title="Permalink to this headline">¶</a></h2>
<p>The kernel parameter panic_on_taint facilitates a conditional call to <a class="reference internal" href="../../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a>
from within <a class="reference internal" href="../../driver-api/basics.html#c.add_taint" title="add_taint"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_taint()</span></code></a> whenever the value set in this bitmask matches with the
bit flag being set by <a class="reference internal" href="../../driver-api/basics.html#c.add_taint" title="add_taint"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_taint()</span></code></a>.
This will cause a kdump to occur at the <a class="reference internal" href="../../driver-api/basics.html#c.add_taint" title="add_taint"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_taint()</span></code></a>-&gt;<a class="reference internal" href="../../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a> call.</p>
</section>
<section id="contact">
<h2>Contact<a class="headerlink" href="#contact" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="mailto:kexec&#37;&#52;&#48;lists&#46;infradead&#46;org">kexec<span>&#64;</span>lists<span>&#46;</span>infradead<span>&#46;</span>org</a></p></li>
</ul>
</section>
<section id="gdb-macros">
<h2>GDB macros<a class="headerlink" href="#gdb-macros" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">#
# This file contains a few gdb macros (user defined commands) to extract
# useful information from kernel crashdump (kdump) like stack traces of
# all the processes or a particular process and trapinfo.
#
# These macros can be used by copying this file in .gdbinit (put in home
# directory or current directory) or by invoking gdb command with
# --command=&lt;command-file-name&gt; option
#
# Credits:
# Alexander Nyberg &lt;alexn&#64;telia.com&gt;
# V Srivatsa &lt;vatsa&#64;in.ibm.com&gt;
# Maneesh Soni &lt;maneesh&#64;in.ibm.com&gt;
#

define bttnobp
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $stacksize = sizeof(union thread_union)
        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t
                printf &quot;\npid %d; comm %s:\n&quot;, $next_t.pid, $next_t.comm
                printf &quot;===================\n&quot;
                set var $stackp = $next_t.thread.sp
                set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + $stacksize

                while ($stackp &lt; $stack_top)
                        if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)
                                info symbol *($stackp)
                        end
                        set $stackp += 4
                end
                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        printf &quot;\npid %d; comm %s:\n&quot;, $next_t.pid, $next_t.comm
                        printf &quot;===================\n&quot;
                        set var $stackp = $next_t.thread.sp
                        set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + stacksize

                        while ($stackp &lt; $stack_top)
                                if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)
                                        info symbol *($stackp)
                                end
                                set $stackp += 4
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end
end
document bttnobp
        dump all thread stack traces on a kernel compiled with !CONFIG_FRAME_POINTER
end

define btthreadstack
        set var $pid_task = $arg0

        printf &quot;\npid %d; comm %s:\n&quot;, $pid_task.pid, $pid_task.comm
        printf &quot;task struct: &quot;
        print $pid_task
        printf &quot;===================\n&quot;
        set var $stackp = $pid_task.thread.sp
        set var $stacksize = sizeof(union thread_union)
        set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + $stacksize
        set var $stack_bot = ($stackp &amp; ~($stacksize - 1))

        set $stackp = *((unsigned long *) $stackp)
        while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))
                set var $addr = *(((unsigned long *) $stackp) + 1)
                info symbol $addr
                set $stackp = *((unsigned long *) $stackp)
        end
end
document btthreadstack
         dump a thread stack using the given task structure pointer
end


define btt
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t
                btthreadstack $next_t

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        btthreadstack $next_th
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end
end
document btt
        dump all thread stack traces on a kernel compiled with CONFIG_FRAME_POINTER
end

define btpid
        set var $pid = $arg0
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $pid_task = 0

        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t

                if ($next_t.pid == $pid)
                        set $pid_task = $next_t
                end

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        if ($next_th.pid == $pid)
                                set $pid_task = $next_th
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end

        btthreadstack $pid_task
end
document btpid
        backtrace of pid
end


define trapinfo
        set var $pid = $arg0
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $pid_task = 0

        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t

                if ($next_t.pid == $pid)
                        set $pid_task = $next_t
                end

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        if ($next_th.pid == $pid)
                                set $pid_task = $next_th
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end

        printf &quot;Trapno %ld, cr2 0x%lx, error_code %ld\n&quot;, $pid_task.thread.trap_no, \
                                $pid_task.thread.cr2, $pid_task.thread.error_code

end
document trapinfo
        Run info threads and lookup pid of thread #1
        'trapinfo &lt;pid&gt;' will tell you by which trap &amp; possibly
        address the kernel panicked.
end

define dump_record
        set var $desc = $arg0
        set var $info = $arg1
        if ($argc &gt; 2)
                set var $prev_flags = $arg2
        else
                set var $prev_flags = 0
        end

        set var $prefix = 1
        set var $newline = 1

        set var $begin = $desc-&gt;text_blk_lpos.begin % (1U &lt;&lt; prb-&gt;text_data_ring.size_bits)
        set var $next = $desc-&gt;text_blk_lpos.next % (1U &lt;&lt; prb-&gt;text_data_ring.size_bits)

        # handle data-less record
        if ($begin &amp; 1)
                set var $text_len = 0
                set var $log = &quot;&quot;
        else
                # handle wrapping data block
                if ($begin &gt; $next)
                        set var $begin = 0
                end

                # skip over descriptor id
                set var $begin = $begin + sizeof(long)

                # handle truncated message
                if ($next - $begin &lt; $info-&gt;text_len)
                        set var $text_len = $next - $begin
                else
                        set var $text_len = $info-&gt;text_len
                end

                set var $log = &amp;prb-&gt;text_data_ring.data[$begin]
        end

        # prev &amp; LOG_CONT &amp;&amp; !(info-&gt;flags &amp; LOG_PREIX)
        if (($prev_flags &amp; 8) &amp;&amp; !($info-&gt;flags &amp; 4))
                set var $prefix = 0
        end

        # info-&gt;flags &amp; LOG_CONT
        if ($info-&gt;flags &amp; 8)
                # (prev &amp; LOG_CONT &amp;&amp; !(prev &amp; LOG_NEWLINE))
                if (($prev_flags &amp; 8) &amp;&amp; !($prev_flags &amp; 2))
                        set var $prefix = 0
                end
                # (!(info-&gt;flags &amp; LOG_NEWLINE))
                if (!($info-&gt;flags &amp; 2))
                        set var $newline = 0
                end
        end

        if ($prefix)
                printf &quot;[%5lu.%06lu] &quot;, $info-&gt;ts_nsec / 1000000000, $info-&gt;ts_nsec % 1000000000
        end
        if ($text_len)
                eval &quot;printf \&quot;%%%d.%ds\&quot;, $log&quot;, $text_len, $text_len
        end
        if ($newline)
                printf &quot;\n&quot;
        end

        # handle dictionary data

        set var $dict = &amp;$info-&gt;dev_info.subsystem[0]
        set var $dict_len = sizeof($info-&gt;dev_info.subsystem)
        if ($dict[0] != '\0')
                printf &quot; SUBSYSTEM=&quot;
                set var $idx = 0
                while ($idx &lt; $dict_len)
                        set var $c = $dict[$idx]
                        if ($c == '\0')
                                loop_break
                        else
                                if ($c &lt; ' ' || $c &gt;= 127 || $c == '\\')
                                        printf &quot;\\x%02x&quot;, $c
                                else
                                        printf &quot;%c&quot;, $c
                                end
                        end
                        set var $idx = $idx + 1
                end
                printf &quot;\n&quot;
        end

        set var $dict = &amp;$info-&gt;dev_info.device[0]
        set var $dict_len = sizeof($info-&gt;dev_info.device)
        if ($dict[0] != '\0')
                printf &quot; DEVICE=&quot;
                set var $idx = 0
                while ($idx &lt; $dict_len)
                        set var $c = $dict[$idx]
                        if ($c == '\0')
                                loop_break
                        else
                                if ($c &lt; ' ' || $c &gt;= 127 || $c == '\\')
                                        printf &quot;\\x%02x&quot;, $c
                                else
                                        printf &quot;%c&quot;, $c
                                end
                        end
                        set var $idx = $idx + 1
                end
                printf &quot;\n&quot;
        end
end
document dump_record
        Dump a single record. The first parameter is the descriptor,
        the second parameter is the info, the third parameter is
        optional and specifies the previous record's flags, used for
        properly formatting continued lines.
end

define dmesg
        # definitions from kernel/printk/printk_ringbuffer.h
        set var $desc_committed = 1
        set var $desc_finalized = 2
        set var $desc_sv_bits = sizeof(long) * 8
        set var $desc_flags_shift = $desc_sv_bits - 2
        set var $desc_flags_mask = 3 &lt;&lt; $desc_flags_shift
        set var $id_mask = ~$desc_flags_mask

        set var $desc_count = 1U &lt;&lt; prb-&gt;desc_ring.count_bits
        set var $prev_flags = 0

        set var $id = prb-&gt;desc_ring.tail_id.counter
        set var $end_id = prb-&gt;desc_ring.head_id.counter

        while (1)
                set var $desc = &amp;prb-&gt;desc_ring.descs[$id % $desc_count]
                set var $info = &amp;prb-&gt;desc_ring.infos[$id % $desc_count]

                # skip non-committed record
                set var $state = 3 &amp; ($desc-&gt;state_var.counter &gt;&gt; $desc_flags_shift)
                if ($state == $desc_committed || $state == $desc_finalized)
                        dump_record $desc $info $prev_flags
                        set var $prev_flags = $info-&gt;flags
                end

                set var $id = ($id + 1) &amp; $id_mask
                if ($id == $end_id)
                        loop_break
                end
        end
end
document dmesg
        print the kernel ring buffer
end
</pre>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Documentation for Kdump - The kexec-based Crash Dumping Solution</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#setup-and-installation">Setup and Installation</a><ul>
<li><a class="reference internal" href="#install-kexec-tools">Install kexec-tools</a></li>
<li><a class="reference internal" href="#build-the-system-and-dump-capture-kernels">Build the system and dump-capture kernels</a></li>
<li><a class="reference internal" href="#system-kernel-config-options">System kernel config options</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-independent">Dump-capture kernel config options (Arch Independent)</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-dependent-i386-and-x86-64">Dump-capture kernel config options (Arch Dependent, i386 and x86_64)</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-dependent-ppc64">Dump-capture kernel config options (Arch Dependent, ppc64)</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-dependent-ia64">Dump-capture kernel config options (Arch Dependent, ia64)</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-dependent-arm">Dump-capture kernel config options (Arch Dependent, arm)</a></li>
<li><a class="reference internal" href="#dump-capture-kernel-config-options-arch-dependent-arm64">Dump-capture kernel config options (Arch Dependent, arm64)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#crashkernel-syntax">crashkernel syntax</a><ul>
<li><a class="reference internal" href="#boot-into-system-kernel">Boot into System Kernel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#load-the-dump-capture-kernel">Load the Dump-capture Kernel</a></li>
<li><a class="reference internal" href="#kernel-panic">Kernel Panic</a></li>
<li><a class="reference internal" href="#write-out-the-dump-file">Write Out the Dump File</a></li>
<li><a class="reference internal" href="#analysis">Analysis</a></li>
<li><a class="reference internal" href="#trigger-kdump-on-warn">Trigger Kdump on WARN()</a></li>
<li><a class="reference internal" href="#trigger-kdump-on-add-taint">Trigger Kdump on add_taint()</a></li>
<li><a class="reference internal" href="#contact">Contact</a></li>
<li><a class="reference internal" href="#gdb-macros">GDB macros</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/kdump/kdump.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/kdump/kdump.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>