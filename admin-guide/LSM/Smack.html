
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Smack &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="TOMOYO" href="tomoyo.html" />
    <link rel="prev" title="SELinux" href="SELinux.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="smack">
<h1>Smack<a class="headerlink" href="#smack" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>“Good for you, you’ve decided to clean the elevator!”
- The Elevator, from Dark Star</p>
</div></blockquote>
<p>Smack is the Simplified Mandatory Access Control Kernel.
Smack is a kernel based implementation of mandatory access
control that includes simplicity in its primary design goals.</p>
<p>Smack is not the only Mandatory Access Control scheme
available for Linux. Those new to Mandatory Access Control
are encouraged to compare Smack with the other mechanisms
available to determine which is best suited to the problem
at hand.</p>
<p>Smack consists of three major components:</p>
<blockquote>
<div><ul class="simple">
<li><p>The kernel</p></li>
<li><p>Basic utilities, which are helpful but not required</p></li>
<li><p>Configuration data</p></li>
</ul>
</div></blockquote>
<p>The kernel component of Smack is implemented as a Linux
Security Modules (LSM) module. It requires netlabel and
works best with file systems that support extended attributes,
although xattr support is not strictly required.
It is safe to run a Smack kernel under a “vanilla” distribution.</p>
<p>Smack kernels use the CIPSO IP option. Some network
configurations are intolerant of IP options and can impede
access to systems that use them as Smack does.</p>
<p>Smack is used in the Tizen operating system. Please
go to <a class="reference external" href="http://wiki.tizen.org">http://wiki.tizen.org</a> for information about how
Smack is used in Tizen.</p>
<p>The current git repository for Smack user space is:</p>
<blockquote>
<div><p>git://github.com/smack-team/smack.git</p>
</div></blockquote>
<p>This should make and install on most modern distributions.
There are five commands included in smackutil:</p>
<dl class="simple">
<dt>chsmack:</dt><dd><p>display or set Smack extended attribute values</p>
</dd>
<dt>smackctl:</dt><dd><p>load the Smack access rules</p>
</dd>
<dt>smackaccess:</dt><dd><p>report if a process with one label has access
to an object with another</p>
</dd>
</dl>
<p>These two commands are obsolete with the introduction of
the smackfs/load2 and smackfs/cipso2 interfaces.</p>
<dl class="simple">
<dt>smackload:</dt><dd><p>properly formats data for writing to smackfs/load</p>
</dd>
<dt>smackcipso:</dt><dd><p>properly formats data for writing to smackfs/cipso</p>
</dd>
</dl>
<p>In keeping with the intent of Smack, configuration data is
minimal and not strictly required. The most important
configuration step is mounting the smackfs pseudo filesystem.
If smackutil is installed the startup script will take care
of this, but it can be manually as well.</p>
<p>Add this line to <code class="docutils literal notranslate"><span class="pre">/etc/fstab</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>smackfs /sys/fs/smackfs smackfs defaults 0 0
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">/sys/fs/smackfs</span></code> directory is created by the kernel.</p>
<p>Smack uses extended attributes (xattrs) to store labels on filesystem
objects. The attributes are stored in the extended attribute security
name space. A process must have <code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code> to change any of these
attributes.</p>
<p>The extended attributes that Smack uses are:</p>
<dl class="simple">
<dt>SMACK64</dt><dd><p>Used to make access control decisions. In almost all cases
the label given to a new filesystem object will be the label
of the process that created it.</p>
</dd>
<dt>SMACK64EXEC</dt><dd><p>The Smack label of a process that execs a program file with
this attribute set will run with this attribute’s value.</p>
</dd>
<dt>SMACK64MMAP</dt><dd><p>Don’t allow the file to be mmapped by a process whose Smack
label does not allow all of the access permitted to a process
with the label contained in this attribute. This is a very
specific use case for shared libraries.</p>
</dd>
<dt>SMACK64TRANSMUTE</dt><dd><p>Can only have the value “TRUE”. If this attribute is present
on a directory when an object is created in the directory and
the Smack rule (more below) that permitted the write access
to the directory includes the transmute (“t”) mode the object
gets the label of the directory instead of the label of the
creating process. If the object being created is a directory
the SMACK64TRANSMUTE attribute is set as well.</p>
</dd>
<dt>SMACK64IPIN</dt><dd><p>This attribute is only available on file descriptors for sockets.
Use the Smack label in this attribute for access control
decisions on packets being delivered to this socket.</p>
</dd>
<dt>SMACK64IPOUT</dt><dd><p>This attribute is only available on file descriptors for sockets.
Use the Smack label in this attribute for access control
decisions on packets coming from this socket.</p>
</dd>
</dl>
<p>There are multiple ways to set a Smack label on a file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># attr -S -s SMACK64 -V &quot;value&quot; path
# chsmack -a value path
</pre></div>
</div>
<p>A process can see the Smack label it is running with by
reading <code class="docutils literal notranslate"><span class="pre">/proc/self/attr/current</span></code>. A process with <code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code>
can set the process Smack by writing there.</p>
<p>Most Smack configuration is accomplished by writing to files
in the smackfs filesystem. This pseudo-filesystem is mounted
on <code class="docutils literal notranslate"><span class="pre">/sys/fs/smackfs</span></code>.</p>
<dl>
<dt>access</dt><dd><p>Provided for backward compatibility. The access2 interface
is preferred and should be used instead.
This interface reports whether a subject with the specified
Smack label has a particular access to an object with a
specified Smack label. Write a fixed format access rule to
this file. The next read will indicate whether the access
would be permitted. The text will be either “1” indicating
access, or “0” indicating denial.</p>
</dd>
<dt>access2</dt><dd><p>This interface reports whether a subject with the specified
Smack label has a particular access to an object with a
specified Smack label. Write a long format access rule to
this file. The next read will indicate whether the access
would be permitted. The text will be either “1” indicating
access, or “0” indicating denial.</p>
</dd>
<dt>ambient</dt><dd><p>This contains the Smack label applied to unlabeled network
packets.</p>
</dd>
<dt>change-rule</dt><dd><p>This interface allows modification of existing access control rules.
The format accepted on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%s %s %s %s&quot;
</pre></div>
</div>
<p>where the first string is the subject label, the second the
object label, the third the access to allow and the fourth the
access to deny. The access strings may contain only the characters
“rwxat-”. If a rule for a given subject and object exists it will be
modified by enabling the permissions in the third string and disabling
those in the fourth string. If there is no such rule it will be
created using the access specified in the third and the fourth strings.</p>
</dd>
<dt>cipso</dt><dd><p>Provided for backward compatibility. The cipso2 interface
is preferred and should be used instead.
This interface allows a specific CIPSO header to be assigned
to a Smack label. The format accepted on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%24s%4d%4d&quot;[&quot;%4d&quot;]...
</pre></div>
</div>
<p>The first string is a fixed Smack label. The first number is
the level to use. The second number is the number of categories.
The following numbers are the categories:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;level-3-cats-5-19          3   2   5  19&quot;
</pre></div>
</div>
</dd>
<dt>cipso2</dt><dd><p>This interface allows a specific CIPSO header to be assigned
to a Smack label. The format accepted on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%s%4d%4d&quot;[&quot;%4d&quot;]...
</pre></div>
</div>
<p>The first string is a long Smack label. The first number is
the level to use. The second number is the number of categories.
The following numbers are the categories:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;level-3-cats-5-19   3   2   5  19&quot;
</pre></div>
</div>
</dd>
<dt>direct</dt><dd><p>This contains the CIPSO level used for Smack direct label
representation in network packets.</p>
</dd>
<dt>doi</dt><dd><p>This contains the CIPSO domain of interpretation used in
network packets.</p>
</dd>
<dt>ipv6host</dt><dd><p>This interface allows specific IPv6 internet addresses to be
treated as single label hosts. Packets are sent to single
label hosts only from processes that have Smack write access
to the host label. All packets received from single label hosts
are given the specified label. The format accepted on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%h:%h:%h:%h:%h:%h:%h:%h label&quot; or
&quot;%h:%h:%h:%h:%h:%h:%h:%h/%d label&quot;.
</pre></div>
</div>
<p>The “::” address shortcut is not supported.
If label is “-DELETE” a matched entry will be deleted.</p>
</dd>
<dt>load</dt><dd><p>Provided for backward compatibility. The load2 interface
is preferred and should be used instead.
This interface allows access control rules in addition to
the system defined rules to be specified. The format accepted
on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%24s%24s%5s&quot;
</pre></div>
</div>
<p>where the first string is the subject label, the second the
object label, and the third the requested access. The access
string may contain only the characters “rwxat-”, and specifies
which sort of access is allowed. The “-” is a placeholder for
permissions that are not allowed. The string “r-x–” would
specify read and execute access. Labels are limited to 23
characters in length.</p>
</dd>
<dt>load2</dt><dd><p>This interface allows access control rules in addition to
the system defined rules to be specified. The format accepted
on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%s %s %s&quot;
</pre></div>
</div>
<p>where the first string is the subject label, the second the
object label, and the third the requested access. The access
string may contain only the characters “rwxat-”, and specifies
which sort of access is allowed. The “-” is a placeholder for
permissions that are not allowed. The string “r-x–” would
specify read and execute access.</p>
</dd>
<dt>load-self</dt><dd><p>Provided for backward compatibility. The load-self2 interface
is preferred and should be used instead.
This interface allows process specific access rules to be
defined. These rules are only consulted if access would
otherwise be permitted, and are intended to provide additional
restrictions on the process. The format is the same as for
the load interface.</p>
</dd>
<dt>load-self2</dt><dd><p>This interface allows process specific access rules to be
defined. These rules are only consulted if access would
otherwise be permitted, and are intended to provide additional
restrictions on the process. The format is the same as for
the load2 interface.</p>
</dd>
<dt>logging</dt><dd><p>This contains the Smack logging state.</p>
</dd>
<dt>mapped</dt><dd><p>This contains the CIPSO level used for Smack mapped label
representation in network packets.</p>
</dd>
<dt>netlabel</dt><dd><p>This interface allows specific internet addresses to be
treated as single label hosts. Packets are sent to single
label hosts without CIPSO headers, but only from processes
that have Smack write access to the host label. All packets
received from single label hosts are given the specified
label. The format accepted on write is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;%d.%d.%d.%d label&quot; or &quot;%d.%d.%d.%d/%d label&quot;.
</pre></div>
</div>
<p>If the label specified is “-CIPSO” the address is treated
as a host that supports CIPSO headers.</p>
</dd>
<dt>onlycap</dt><dd><p>This contains labels processes must have for CAP_MAC_ADMIN
and <code class="docutils literal notranslate"><span class="pre">CAP_MAC_OVERRIDE</span></code> to be effective. If this file is empty
these capabilities are effective at for processes with any
label. The values are set by writing the desired labels, separated
by spaces, to the file or cleared by writing “-” to the file.</p>
</dd>
<dt>ptrace</dt><dd><p>This is used to define the current ptrace policy</p>
<dl class="simple">
<dt>0 - default:</dt><dd><p>this is the policy that relies on Smack access rules.
For the <code class="docutils literal notranslate"><span class="pre">PTRACE_READ</span></code> a subject needs to have a read access on
object. For the <code class="docutils literal notranslate"><span class="pre">PTRACE_ATTACH</span></code> a read-write access is required.</p>
</dd>
<dt>1 - exact:</dt><dd><p>this is the policy that limits <code class="docutils literal notranslate"><span class="pre">PTRACE_ATTACH</span></code>. Attach is
only allowed when subject’s and object’s labels are equal.
<code class="docutils literal notranslate"><span class="pre">PTRACE_READ</span></code> is not affected. Can be overridden with <code class="docutils literal notranslate"><span class="pre">CAP_SYS_PTRACE</span></code>.</p>
</dd>
<dt>2 - draconian:</dt><dd><p>this policy behaves like the ‘exact’ above with an
exception that it can’t be overridden with <code class="docutils literal notranslate"><span class="pre">CAP_SYS_PTRACE</span></code>.</p>
</dd>
</dl>
</dd>
<dt>revoke-subject</dt><dd><p>Writing a Smack label here sets the access to ‘-’ for all access
rules with that subject label.</p>
</dd>
<dt>unconfined</dt><dd><p>If the kernel is configured with <code class="docutils literal notranslate"><span class="pre">CONFIG_SECURITY_SMACK_BRINGUP</span></code>
a process with <code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code> can write a label into this interface.
Thereafter, accesses that involve that label will be logged and
the access permitted if it wouldn’t be otherwise. Note that this
is dangerous and can ruin the proper labeling of your system.
It should never be used in production.</p>
</dd>
<dt>relabel-self</dt><dd><p>This interface contains a list of labels to which the process can
transition to, by writing to <code class="docutils literal notranslate"><span class="pre">/proc/self/attr/current</span></code>.
Normally a process can change its own label to any legal value, but only
if it has <code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code>. This interface allows a process without
<code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code> to relabel itself to one of labels from predefined list.
A process without <code class="docutils literal notranslate"><span class="pre">CAP_MAC_ADMIN</span></code> can change its label only once. When it
does, this list will be cleared.
The values are set by writing the desired labels, separated
by spaces, to the file or cleared by writing “-” to the file.</p>
</dd>
</dl>
<p>If you are using the smackload utility
you can add access rules in <code class="docutils literal notranslate"><span class="pre">/etc/smack/accesses</span></code>. They take the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>subjectlabel objectlabel access
</pre></div>
</div>
<p>access is a combination of the letters rwxatb which specify the
kind of access permitted a subject with subjectlabel on an
object with objectlabel. If there is no rule no access is allowed.</p>
<p>Look for additional programs on <a class="reference external" href="http://schaufler-ca.com">http://schaufler-ca.com</a></p>
<section id="the-simplified-mandatory-access-control-kernel-whitepaper">
<h2>The Simplified Mandatory Access Control Kernel (Whitepaper)<a class="headerlink" href="#the-simplified-mandatory-access-control-kernel-whitepaper" title="Permalink to this headline">¶</a></h2>
<p>Casey Schaufler
<a class="reference external" href="mailto:casey&#37;&#52;&#48;schaufler-ca&#46;com">casey<span>&#64;</span>schaufler-ca<span>&#46;</span>com</a></p>
<section id="mandatory-access-control">
<h3>Mandatory Access Control<a class="headerlink" href="#mandatory-access-control" title="Permalink to this headline">¶</a></h3>
<p>Computer systems employ a variety of schemes to constrain how information is
shared among the people and services using the machine. Some of these schemes
allow the program or user to decide what other programs or users are allowed
access to pieces of data. These schemes are called discretionary access
control mechanisms because the access control is specified at the discretion
of the user. Other schemes do not leave the decision regarding what a user or
program can access up to users or programs. These schemes are called mandatory
access control mechanisms because you don’t have a choice regarding the users
or programs that have access to pieces of data.</p>
</section>
<section id="bell-lapadula">
<h3>Bell &amp; LaPadula<a class="headerlink" href="#bell-lapadula" title="Permalink to this headline">¶</a></h3>
<p>From the middle of the 1980’s until the turn of the century Mandatory Access
Control (MAC) was very closely associated with the Bell &amp; LaPadula security
model, a mathematical description of the United States Department of Defense
policy for marking paper documents. MAC in this form enjoyed a following
within the Capital Beltway and Scandinavian supercomputer centers but was
often sited as failing to address general needs.</p>
</section>
<section id="domain-type-enforcement">
<h3>Domain Type Enforcement<a class="headerlink" href="#domain-type-enforcement" title="Permalink to this headline">¶</a></h3>
<p>Around the turn of the century Domain Type Enforcement (DTE) became popular.
This scheme organizes users, programs, and data into domains that are
protected from each other. This scheme has been widely deployed as a component
of popular Linux distributions. The administrative overhead required to
maintain this scheme and the detailed understanding of the whole system
necessary to provide a secure domain mapping leads to the scheme being
disabled or used in limited ways in the majority of cases.</p>
</section>
<section id="id1">
<h3>Smack<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Smack is a Mandatory Access Control mechanism designed to provide useful MAC
while avoiding the pitfalls of its predecessors. The limitations of Bell &amp;
LaPadula are addressed by providing a scheme whereby access can be controlled
according to the requirements of the system and its purpose rather than those
imposed by an arcane government policy. The complexity of Domain Type
Enforcement and avoided by defining access controls in terms of the access
modes already in use.</p>
</section>
<section id="smack-terminology">
<h3>Smack Terminology<a class="headerlink" href="#smack-terminology" title="Permalink to this headline">¶</a></h3>
<p>The jargon used to talk about Smack will be familiar to those who have dealt
with other MAC systems and shouldn’t be too difficult for the uninitiated to
pick up. There are four terms that are used in a specific way and that are
especially important:</p>
<blockquote>
<div><dl class="simple">
<dt>Subject:</dt><dd><p>A subject is an active entity on the computer system.
On Smack a subject is a task, which is in turn the basic unit
of execution.</p>
</dd>
<dt>Object:</dt><dd><p>An object is a passive entity on the computer system.
On Smack files of all types, IPC, and tasks can be objects.</p>
</dd>
<dt>Access:</dt><dd><p>Any attempt by a subject to put information into or get
information from an object is an access.</p>
</dd>
<dt>Label:</dt><dd><p>Data that identifies the Mandatory Access Control
characteristics of a subject or an object.</p>
</dd>
</dl>
</div></blockquote>
<p>These definitions are consistent with the traditional use in the security
community. There are also some terms from Linux that are likely to crop up:</p>
<blockquote>
<div><dl class="simple">
<dt>Capability:</dt><dd><p>A task that possesses a capability has permission to
violate an aspect of the system security policy, as identified by
the specific capability. A task that possesses one or more
capabilities is a privileged task, whereas a task with no
capabilities is an unprivileged task.</p>
</dd>
<dt>Privilege:</dt><dd><p>A task that is allowed to violate the system security
policy is said to have privilege. As of this writing a task can
have privilege either by possessing capabilities or by having an
effective user of root.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="smack-basics">
<h3>Smack Basics<a class="headerlink" href="#smack-basics" title="Permalink to this headline">¶</a></h3>
<p>Smack is an extension to a Linux system. It enforces additional restrictions
on what subjects can access which objects, based on the labels attached to
each of the subject and the object.</p>
<section id="labels">
<h4>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h4>
<p>Smack labels are ASCII character strings. They can be up to 255 characters
long, but keeping them to twenty-three characters is recommended.
Single character labels using special characters, that being anything
other than a letter or digit, are reserved for use by the Smack development
team. Smack labels are unstructured, case sensitive, and the only operation
ever performed on them is comparison for equality. Smack labels cannot
contain unprintable characters, the “/” (slash), the “” (backslash), the “’”
(quote) and ‘”’ (double-quote) characters.
Smack labels cannot begin with a ‘-’. This is reserved for special options.</p>
<p>There are some predefined labels:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>_       Pronounced &quot;floor&quot;, a single underscore character.
^       Pronounced &quot;hat&quot;, a single circumflex character.
*       Pronounced &quot;star&quot;, a single asterisk character.
?       Pronounced &quot;huh&quot;, a single question mark character.
@       Pronounced &quot;web&quot;, a single at sign character.
</pre></div>
</div>
<p>Every task on a Smack system is assigned a label. The Smack label
of a process will usually be assigned by the system initialization
mechanism.</p>
</section>
<section id="access-rules">
<h4>Access Rules<a class="headerlink" href="#access-rules" title="Permalink to this headline">¶</a></h4>
<p>Smack uses the traditional access modes of Linux. These modes are read,
execute, write, and occasionally append. There are a few cases where the
access mode may not be obvious. These include:</p>
<blockquote>
<div><dl class="simple">
<dt>Signals:</dt><dd><p>A signal is a write operation from the subject task to
the object task.</p>
</dd>
<dt>Internet Domain IPC:</dt><dd><p>Transmission of a packet is considered a
write operation from the source task to the destination task.</p>
</dd>
</dl>
</div></blockquote>
<p>Smack restricts access based on the label attached to a subject and the label
attached to the object it is trying to access. The rules enforced are, in
order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Any access requested by a task labeled “*” is denied.</p></li>
<li><p>A read or execute access requested by a task labeled “^”
is permitted.</p></li>
<li><p>A read or execute access requested on an object labeled “_”
is permitted.</p></li>
<li><p>Any access requested on an object labeled “*” is permitted.</p></li>
<li><p>Any access requested by a task on an object with the same
label is permitted.</p></li>
<li><p>Any access requested that is explicitly defined in the loaded
rule set is permitted.</p></li>
<li><p>Any other access is denied.</p></li>
</ol>
</div></blockquote>
</section>
<section id="smack-access-rules">
<h4>Smack Access Rules<a class="headerlink" href="#smack-access-rules" title="Permalink to this headline">¶</a></h4>
<p>With the isolation provided by Smack access separation is simple. There are
many interesting cases where limited access by subjects to objects with
different labels is desired. One example is the familiar spy model of
sensitivity, where a scientist working on a highly classified project would be
able to read documents of lower classifications and anything she writes will
be “born” highly classified. To accommodate such schemes Smack includes a
mechanism for specifying rules allowing access between labels.</p>
</section>
<section id="access-rule-format">
<h4>Access Rule Format<a class="headerlink" href="#access-rule-format" title="Permalink to this headline">¶</a></h4>
<p>The format of an access rule is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>subject-label object-label access
</pre></div>
</div>
<p>Where subject-label is the Smack label of the task, object-label is the Smack
label of the thing being accessed, and access is a string specifying the sort
of access allowed. The access specification is searched for letters that
describe access modes:</p>
<blockquote>
<div><p>a: indicates that append access should be granted.
r: indicates that read access should be granted.
w: indicates that write access should be granted.
x: indicates that execute access should be granted.
t: indicates that the rule requests transmutation.
b: indicates that the rule should be reported for bring-up.</p>
</div></blockquote>
<p>Uppercase values for the specification letters are allowed as well.
Access mode specifications can be in any order. Examples of acceptable rules
are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TopSecret Secret  rx
Secret    Unclass R
Manager   Game    x
User      HR      w
Snap      Crackle rwxatb
New       Old     rRrRr
Closed    Off     -
</pre></div>
</div>
<p>Examples of unacceptable rules are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Top Secret Secret     rx
Ace        Ace        r
Odd        spells     waxbeans
</pre></div>
</div>
<p>Spaces are not allowed in labels. Since a subject always has access to files
with the same label specifying a rule for that case is pointless. Only
valid letters (rwxatbRWXATB) and the dash (‘-’) character are allowed in
access specifications. The dash is a placeholder, so “a-r” is the same
as “ar”. A lone dash is used to specify that no access should be allowed.</p>
</section>
<section id="applying-access-rules">
<h4>Applying Access Rules<a class="headerlink" href="#applying-access-rules" title="Permalink to this headline">¶</a></h4>
<p>The developers of Linux rarely define new sorts of things, usually importing
schemes and concepts from other systems. Most often, the other systems are
variants of Unix. Unix has many endearing properties, but consistency of
access control models is not one of them. Smack strives to treat accesses as
uniformly as is sensible while keeping with the spirit of the underlying
mechanism.</p>
<p>File system objects including files, directories, named pipes, symbolic links,
and devices require access permissions that closely match those used by mode
bit access. To open a file for reading read access is required on the file. To
search a directory requires execute access. Creating a file with write access
requires both read and write access on the containing directory. Deleting a
file requires read and write access to the file and to the containing
directory. It is possible that a user may be able to see that a file exists
but not any of its attributes by the circumstance of having read access to the
containing directory but not to the differently labeled file. This is an
artifact of the file name being data in the directory, not a part of the file.</p>
<p>If a directory is marked as transmuting (SMACK64TRANSMUTE=TRUE) and the
access rule that allows a process to create an object in that directory
includes ‘t’ access the label assigned to the new object will be that
of the directory, not the creating process. This makes it much easier
for two processes with different labels to share data without granting
access to all of their files.</p>
<p>IPC objects, message queues, semaphore sets, and memory segments exist in flat
namespaces and access requests are only required to match the object in
question.</p>
<p>Process objects reflect tasks on the system and the Smack label used to access
them is the same Smack label that the task would use for its own access
attempts. Sending a signal via the kill() system call is a write operation
from the signaler to the recipient. Debugging a process requires both reading
and writing. Creating a new task is an internal operation that results in two
tasks with identical Smack labels and requires no access checks.</p>
<p>Sockets are data structures attached to processes and sending a packet from
one process to another requires that the sender have write access to the
receiver. The receiver is not required to have read access to the sender.</p>
</section>
<section id="setting-access-rules">
<h4>Setting Access Rules<a class="headerlink" href="#setting-access-rules" title="Permalink to this headline">¶</a></h4>
<p>The configuration file /etc/smack/accesses contains the rules to be set at
system startup. The contents are written to the special file
/sys/fs/smackfs/load2. Rules can be added at any time and take effect
immediately. For any pair of subject and object labels there can be only
one rule, with the most recently specified overriding any earlier
specification.</p>
</section>
<section id="task-attribute">
<h4>Task Attribute<a class="headerlink" href="#task-attribute" title="Permalink to this headline">¶</a></h4>
<p>The Smack label of a process can be read from /proc/&lt;pid&gt;/attr/current. A
process can read its own Smack label from /proc/self/attr/current. A
privileged process can change its own Smack label by writing to
/proc/self/attr/current but not the label of another process.</p>
</section>
<section id="file-attribute">
<h4>File Attribute<a class="headerlink" href="#file-attribute" title="Permalink to this headline">¶</a></h4>
<p>The Smack label of a filesystem object is stored as an extended attribute
named SMACK64 on the file. This attribute is in the security namespace. It can
only be changed by a process with privilege.</p>
</section>
<section id="privilege">
<h4>Privilege<a class="headerlink" href="#privilege" title="Permalink to this headline">¶</a></h4>
<p>A process with CAP_MAC_OVERRIDE or CAP_MAC_ADMIN is privileged.
CAP_MAC_OVERRIDE allows the process access to objects it would
be denied otherwise. CAP_MAC_ADMIN allows a process to change
Smack data, including rules and attributes.</p>
</section>
<section id="smack-networking">
<h4>Smack Networking<a class="headerlink" href="#smack-networking" title="Permalink to this headline">¶</a></h4>
<p>As mentioned before, Smack enforces access control on network protocol
transmissions. Every packet sent by a Smack process is tagged with its Smack
label. This is done by adding a CIPSO tag to the header of the IP packet. Each
packet received is expected to have a CIPSO tag that identifies the label and
if it lacks such a tag the network ambient label is assumed. Before the packet
is delivered a check is made to determine that a subject with the label on the
packet has write access to the receiving process and if that is not the case
the packet is dropped.</p>
</section>
<section id="cipso-configuration">
<h4>CIPSO Configuration<a class="headerlink" href="#cipso-configuration" title="Permalink to this headline">¶</a></h4>
<p>It is normally unnecessary to specify the CIPSO configuration. The default
values used by the system handle all internal cases. Smack will compose CIPSO
label values to match the Smack labels being used without administrative
intervention. Unlabeled packets that come into the system will be given the
ambient label.</p>
<p>Smack requires configuration in the case where packets from a system that is
not Smack that speaks CIPSO may be encountered. Usually this will be a Trusted
Solaris system, but there are other, less widely deployed systems out there.
CIPSO provides 3 important values, a Domain Of Interpretation (DOI), a level,
and a category set with each packet. The DOI is intended to identify a group
of systems that use compatible labeling schemes, and the DOI specified on the
Smack system must match that of the remote system or packets will be
discarded. The DOI is 3 by default. The value can be read from
/sys/fs/smackfs/doi and can be changed by writing to /sys/fs/smackfs/doi.</p>
<p>The label and category set are mapped to a Smack label as defined in
/etc/smack/cipso.</p>
<p>A Smack/CIPSO mapping has the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>smack level [category [category]*]
</pre></div>
</div>
<p>Smack does not expect the level or category sets to be related in any
particular way and does not assume or assign accesses based on them. Some
examples of mappings:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TopSecret 7
TS:A,B    7 1 2
SecBDE    5 2 4 6
RAFTERS   7 12 26
</pre></div>
</div>
<p>The “:” and “,” characters are permitted in a Smack label but have no special
meaning.</p>
<p>The mapping of Smack labels to CIPSO values is defined by writing to
/sys/fs/smackfs/cipso2.</p>
<p>In addition to explicit mappings Smack supports direct CIPSO mappings. One
CIPSO level is used to indicate that the category set passed in the packet is
in fact an encoding of the Smack label. The level used is 250 by default. The
value can be read from /sys/fs/smackfs/direct and changed by writing to
/sys/fs/smackfs/direct.</p>
</section>
<section id="socket-attributes">
<h4>Socket Attributes<a class="headerlink" href="#socket-attributes" title="Permalink to this headline">¶</a></h4>
<p>There are two attributes that are associated with sockets. These attributes
can only be set by privileged tasks, but any task can read them for their own
sockets.</p>
<blockquote>
<div><dl class="simple">
<dt>SMACK64IPIN:</dt><dd><p>The Smack label of the task object. A privileged
program that will enforce policy may set this to the star label.</p>
</dd>
<dt>SMACK64IPOUT:</dt><dd><p>The Smack label transmitted with outgoing packets.
A privileged program may set this to match the label of another
task with which it hopes to communicate.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="smack-netlabel-exceptions">
<h4>Smack Netlabel Exceptions<a class="headerlink" href="#smack-netlabel-exceptions" title="Permalink to this headline">¶</a></h4>
<p>You will often find that your labeled application has to talk to the outside,
unlabeled world. To do this there’s a special file /sys/fs/smackfs/netlabel
where you can add some exceptions in the form of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@IP1       LABEL1 or
@IP2/MASK  LABEL2
</pre></div>
</div>
<p>It means that your application will have unlabeled access to &#64;IP1 if it has
write access on LABEL1, and access to the subnet &#64;IP2/MASK if it has write
access on LABEL2.</p>
<p>Entries in the /sys/fs/smackfs/netlabel file are matched by longest mask
first, like in classless IPv4 routing.</p>
<p>A special label ‘&#64;’ and an option ‘-CIPSO’ can be used there:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@      means Internet, any application with any label has access to it
-CIPSO means standard CIPSO networking
</pre></div>
</div>
<p>If you don’t know what CIPSO is and don’t plan to use it, you can just do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 127.0.0.1 -CIPSO &gt; /sys/fs/smackfs/netlabel
echo 0.0.0.0/0 @      &gt; /sys/fs/smackfs/netlabel
</pre></div>
</div>
<p>If you use CIPSO on your 192.168.0.0/16 local network and need also unlabeled
Internet access, you can have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 127.0.0.1      -CIPSO &gt; /sys/fs/smackfs/netlabel
echo 192.168.0.0/16 -CIPSO &gt; /sys/fs/smackfs/netlabel
echo 0.0.0.0/0      @      &gt; /sys/fs/smackfs/netlabel
</pre></div>
</div>
</section>
</section>
<section id="writing-applications-for-smack">
<h3>Writing Applications for Smack<a class="headerlink" href="#writing-applications-for-smack" title="Permalink to this headline">¶</a></h3>
<p>There are three sorts of applications that will run on a Smack system. How an
application interacts with Smack will determine what it will have to do to
work properly under Smack.</p>
</section>
<section id="smack-ignorant-applications">
<h3>Smack Ignorant Applications<a class="headerlink" href="#smack-ignorant-applications" title="Permalink to this headline">¶</a></h3>
<p>By far the majority of applications have no reason whatever to care about the
unique properties of Smack. Since invoking a program has no impact on the
Smack label associated with the process the only concern likely to arise is
whether the process has execute access to the program.</p>
</section>
<section id="smack-relevant-applications">
<h3>Smack Relevant Applications<a class="headerlink" href="#smack-relevant-applications" title="Permalink to this headline">¶</a></h3>
<p>Some programs can be improved by teaching them about Smack, but do not make
any security decisions themselves. The utility ls(1) is one example of such a
program.</p>
</section>
<section id="smack-enforcing-applications">
<h3>Smack Enforcing Applications<a class="headerlink" href="#smack-enforcing-applications" title="Permalink to this headline">¶</a></h3>
<p>These are special programs that not only know about Smack, but participate in
the enforcement of system policy. In most cases these are the programs that
set up user sessions. There are also network services that provide information
to processes running with various labels.</p>
</section>
<section id="file-system-interfaces">
<h3>File System Interfaces<a class="headerlink" href="#file-system-interfaces" title="Permalink to this headline">¶</a></h3>
<p>Smack maintains labels on file system objects using extended attributes. The
Smack label of a file, directory, or other file system object can be obtained
using getxattr(2):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>len = getxattr(&quot;/&quot;, &quot;security.SMACK64&quot;, value, sizeof (value));
</pre></div>
</div>
<p>will put the Smack label of the root directory into value. A privileged
process can set the Smack label of a file system object with setxattr(2):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>len = strlen(&quot;Rubble&quot;);
rc = setxattr(&quot;/foo&quot;, &quot;security.SMACK64&quot;, &quot;Rubble&quot;, len, 0);
</pre></div>
</div>
<p>will set the Smack label of /foo to “Rubble” if the program has appropriate
privilege.</p>
</section>
<section id="socket-interfaces">
<h3>Socket Interfaces<a class="headerlink" href="#socket-interfaces" title="Permalink to this headline">¶</a></h3>
<p>The socket attributes can be read using fgetxattr(2).</p>
<p>A privileged process can set the Smack label of outgoing packets with
fsetxattr(2):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>len = strlen(&quot;Rubble&quot;);
rc = fsetxattr(fd, &quot;security.SMACK64IPOUT&quot;, &quot;Rubble&quot;, len, 0);
</pre></div>
</div>
<p>will set the Smack label “Rubble” on packets going out from the socket if the
program has appropriate privilege:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rc = fsetxattr(fd, &quot;security.SMACK64IPIN, &quot;*&quot;, strlen(&quot;*&quot;), 0);
</pre></div>
</div>
<p>will set the Smack label “*” as the object label against which incoming
packets will be checked if the program has appropriate privilege.</p>
</section>
<section id="administration">
<h3>Administration<a class="headerlink" href="#administration" title="Permalink to this headline">¶</a></h3>
<p>Smack supports some mount options:</p>
<blockquote>
<div><dl class="simple">
<dt>smackfsdef=label:</dt><dd><p>specifies the label to give files that lack
the Smack label extended attribute.</p>
</dd>
<dt>smackfsroot=label:</dt><dd><p>specifies the label to assign the root of the
file system if it lacks the Smack extended attribute.</p>
</dd>
<dt>smackfshat=label:</dt><dd><p>specifies a label that must have read access to
all labels set on the filesystem. Not yet enforced.</p>
</dd>
<dt>smackfsfloor=label:</dt><dd><p>specifies a label to which all labels set on the
filesystem must have read access. Not yet enforced.</p>
</dd>
<dt>smackfstransmute=label:</dt><dd><p>behaves exactly like smackfsroot except that it also
sets the transmute flag on the root of the mount</p>
</dd>
</dl>
</div></blockquote>
<p>These mount options apply to all file system types.</p>
</section>
<section id="smack-auditing">
<h3>Smack auditing<a class="headerlink" href="#smack-auditing" title="Permalink to this headline">¶</a></h3>
<p>If you want Smack auditing of security events, you need to set CONFIG_AUDIT
in your kernel configuration.
By default, all denied events will be audited. You can change this behavior by
writing a single character to the /sys/fs/smackfs/logging file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 : no logging
1 : log denied (default)
2 : log accepted
3 : log denied &amp; accepted
</pre></div>
</div>
<p>Events are logged as ‘key=value’ pairs, for each event you at least will get
the subject, the object, the rights requested, the action, the kernel function
that triggered the event, plus other pairs depending on the type of event
audited.</p>
</section>
<section id="bringup-mode">
<h3>Bringup Mode<a class="headerlink" href="#bringup-mode" title="Permalink to this headline">¶</a></h3>
<p>Bringup mode provides logging features that can make application
configuration and system bringup easier. Configure the kernel with
CONFIG_SECURITY_SMACK_BRINGUP to enable these features. When bringup
mode is enabled accesses that succeed due to rules marked with the “b”
access mode will logged. When a new label is introduced for processes
rules can be added aggressively, marked with the “b”. The logging allows
tracking of which rules actual get used for that label.</p>
<p>Another feature of bringup mode is the “unconfined” option. Writing
a label to /sys/fs/smackfs/unconfined makes subjects with that label
able to access any object, and objects with that label accessible to
all subjects. Any access that is granted because a label is unconfined
is logged. This feature is dangerous, as files and directories may
be created in places they couldn’t if the policy were being enforced.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Smack</a><ul>
<li><a class="reference internal" href="#the-simplified-mandatory-access-control-kernel-whitepaper">The Simplified Mandatory Access Control Kernel (Whitepaper)</a><ul>
<li><a class="reference internal" href="#mandatory-access-control">Mandatory Access Control</a></li>
<li><a class="reference internal" href="#bell-lapadula">Bell &amp; LaPadula</a></li>
<li><a class="reference internal" href="#domain-type-enforcement">Domain Type Enforcement</a></li>
<li><a class="reference internal" href="#id1">Smack</a></li>
<li><a class="reference internal" href="#smack-terminology">Smack Terminology</a></li>
<li><a class="reference internal" href="#smack-basics">Smack Basics</a><ul>
<li><a class="reference internal" href="#labels">Labels</a></li>
<li><a class="reference internal" href="#access-rules">Access Rules</a></li>
<li><a class="reference internal" href="#smack-access-rules">Smack Access Rules</a></li>
<li><a class="reference internal" href="#access-rule-format">Access Rule Format</a></li>
<li><a class="reference internal" href="#applying-access-rules">Applying Access Rules</a></li>
<li><a class="reference internal" href="#setting-access-rules">Setting Access Rules</a></li>
<li><a class="reference internal" href="#task-attribute">Task Attribute</a></li>
<li><a class="reference internal" href="#file-attribute">File Attribute</a></li>
<li><a class="reference internal" href="#privilege">Privilege</a></li>
<li><a class="reference internal" href="#smack-networking">Smack Networking</a></li>
<li><a class="reference internal" href="#cipso-configuration">CIPSO Configuration</a></li>
<li><a class="reference internal" href="#socket-attributes">Socket Attributes</a></li>
<li><a class="reference internal" href="#smack-netlabel-exceptions">Smack Netlabel Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-applications-for-smack">Writing Applications for Smack</a></li>
<li><a class="reference internal" href="#smack-ignorant-applications">Smack Ignorant Applications</a></li>
<li><a class="reference internal" href="#smack-relevant-applications">Smack Relevant Applications</a></li>
<li><a class="reference internal" href="#smack-enforcing-applications">Smack Enforcing Applications</a></li>
<li><a class="reference internal" href="#file-system-interfaces">File System Interfaces</a></li>
<li><a class="reference internal" href="#socket-interfaces">Socket Interfaces</a></li>
<li><a class="reference internal" href="#administration">Administration</a></li>
<li><a class="reference internal" href="#smack-auditing">Smack auditing</a></li>
<li><a class="reference internal" href="#bringup-mode">Bringup Mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/LSM/Smack.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/LSM/Smack.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>