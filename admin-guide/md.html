
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>RAID arrays &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Media subsystem admin and user guide" href="media/index.html" />
    <link rel="prev" title="SafeSetID" href="LSM/SafeSetID.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="raid-arrays">
<h1>RAID arrays<a class="headerlink" href="#raid-arrays" title="Permalink to this headline">¶</a></h1>
<section id="boot-time-assembly-of-raid-arrays">
<h2>Boot time assembly of RAID arrays<a class="headerlink" href="#boot-time-assembly-of-raid-arrays" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Tools that manage md devices can be found at</dt><dd><p><a class="reference external" href="https://www.kernel.org/pub/linux/utils/raid/">https://www.kernel.org/pub/linux/utils/raid/</a></p>
</dd>
</dl>
<p>You can boot with your md device with the following kernel command
lines:</p>
<p>for old raid arrays without persistent superblocks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>md=&lt;md device no.&gt;,&lt;raid level&gt;,&lt;chunk size factor&gt;,&lt;fault level&gt;,dev0,dev1,...,devn
</pre></div>
</div>
<p>for raid arrays with persistent superblocks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>md=&lt;md device no.&gt;,dev0,dev1,...,devn
</pre></div>
</div>
<p>or, to assemble a partitionable array:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>md=d&lt;md device no.&gt;,dev0,dev1,...,devn
</pre></div>
</div>
<section id="md-device-no">
<h3><code class="docutils literal notranslate"><span class="pre">md</span> <span class="pre">device</span> <span class="pre">no.</span></code><a class="headerlink" href="#md-device-no" title="Permalink to this headline">¶</a></h3>
<p>The number of the md device</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 65%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">md</span> <span class="pre">device</span> <span class="pre">no.</span></code></p></th>
<th class="head"><p>device</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>md0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>md1</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>md2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>md3</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>md4</p></td>
</tr>
</tbody>
</table>
</section>
<section id="raid-level">
<h3><code class="docutils literal notranslate"><span class="pre">raid</span> <span class="pre">level</span></code><a class="headerlink" href="#raid-level" title="Permalink to this headline">¶</a></h3>
<p>level of the RAID array</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 54%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">raid</span> <span class="pre">level</span></code></p></th>
<th class="head"><p>level</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-1</p></td>
<td><p>linear mode</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>striped mode</p></td>
</tr>
</tbody>
</table>
<p>other modes are only supported with persistent super blocks</p>
</section>
<section id="chunk-size-factor">
<h3><code class="docutils literal notranslate"><span class="pre">chunk</span> <span class="pre">size</span> <span class="pre">factor</span></code><a class="headerlink" href="#chunk-size-factor" title="Permalink to this headline">¶</a></h3>
<p>(raid-0 and raid-1 only)</p>
<p>Set  the chunk size as 4k &lt;&lt; n.</p>
</section>
<section id="fault-level">
<h3><code class="docutils literal notranslate"><span class="pre">fault</span> <span class="pre">level</span></code><a class="headerlink" href="#fault-level" title="Permalink to this headline">¶</a></h3>
<p>Totally ignored</p>
</section>
<section id="dev0-to-devn">
<h3><code class="docutils literal notranslate"><span class="pre">dev0</span></code> to <code class="docutils literal notranslate"><span class="pre">devn</span></code><a class="headerlink" href="#dev0-to-devn" title="Permalink to this headline">¶</a></h3>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">/dev/hda1</span></code>, <code class="docutils literal notranslate"><span class="pre">/dev/hdc1</span></code>, <code class="docutils literal notranslate"><span class="pre">/dev/sda1</span></code>, <code class="docutils literal notranslate"><span class="pre">/dev/sdb1</span></code></p>
<p>A possible loadlin line (Harald Hoyer &lt;<a class="reference external" href="mailto:HarryH&#37;&#52;&#48;Royal&#46;Net">HarryH<span>&#64;</span>Royal<span>&#46;</span>Net</a>&gt;)  looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>e:\loadlin\loadlin e:\zimage root=/dev/md0 md=0,0,4,0,/dev/hdb2,/dev/hdc3 ro
</pre></div>
</div>
</section>
</section>
<section id="boot-time-autodetection-of-raid-arrays">
<h2>Boot time autodetection of RAID arrays<a class="headerlink" href="#boot-time-autodetection-of-raid-arrays" title="Permalink to this headline">¶</a></h2>
<p>When md is compiled into the kernel (not as module), partitions of
type 0xfd are scanned and automatically assembled into RAID arrays.
This autodetection may be suppressed with the kernel parameter
<code class="docutils literal notranslate"><span class="pre">raid=noautodetect</span></code>.  As of kernel 2.6.9, only drives with a type 0
superblock can be autodetected and run at boot time.</p>
<p>The kernel parameter <code class="docutils literal notranslate"><span class="pre">raid=partitionable</span></code> (or <code class="docutils literal notranslate"><span class="pre">raid=part</span></code>) means
that all auto-detected arrays are assembled as partitionable.</p>
</section>
<section id="boot-time-assembly-of-degraded-dirty-arrays">
<h2>Boot time assembly of degraded/dirty arrays<a class="headerlink" href="#boot-time-assembly-of-degraded-dirty-arrays" title="Permalink to this headline">¶</a></h2>
<p>If a raid5 or raid6 array is both dirty and degraded, it could have
undetectable data corruption.  This is because the fact that it is
<code class="docutils literal notranslate"><span class="pre">dirty</span></code> means that the parity cannot be trusted, and the fact that it
is degraded means that some datablocks are missing and cannot reliably
be reconstructed (due to no parity).</p>
<p>For this reason, md will normally refuse to start such an array.  This
requires the sysadmin to take action to explicitly start the array
despite possible corruption.  This is normally done with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mdadm --assemble --force ....
</pre></div>
</div>
<p>This option is not really available if the array has the root
filesystem on it.  In order to support this booting from such an
array, md supports a module parameter <code class="docutils literal notranslate"><span class="pre">start_dirty_degraded</span></code> which,
when set to 1, bypassed the checks and will allows dirty degraded
arrays to be started.</p>
<p>So, to boot with a root filesystem of a dirty degraded raid 5 or 6, use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>md-mod.start_dirty_degraded=1
</pre></div>
</div>
</section>
<section id="superblock-formats">
<h2>Superblock formats<a class="headerlink" href="#superblock-formats" title="Permalink to this headline">¶</a></h2>
<p>The md driver can support a variety of different superblock formats.
Currently, it supports superblock formats <code class="docutils literal notranslate"><span class="pre">0.90.0</span></code> and the <code class="docutils literal notranslate"><span class="pre">md-1</span></code> format
introduced in the 2.5 development series.</p>
<p>The kernel will autodetect which format superblock is being used.</p>
<p>Superblock format <code class="docutils literal notranslate"><span class="pre">0</span></code> is treated differently to others for legacy
reasons - it is the original superblock format.</p>
</section>
<section id="general-rules-apply-for-all-superblock-formats">
<h2>General Rules - apply for all superblock formats<a class="headerlink" href="#general-rules-apply-for-all-superblock-formats" title="Permalink to this headline">¶</a></h2>
<p>An array is <code class="docutils literal notranslate"><span class="pre">created</span></code> by writing appropriate superblocks to all
devices.</p>
<p>It is <code class="docutils literal notranslate"><span class="pre">assembled</span></code> by associating each of these devices with an
particular md virtual device.  Once it is completely assembled, it can
be accessed.</p>
<p>An array should be created by a user-space tool.  This will write
superblocks to all devices.  It will usually mark the array as
<code class="docutils literal notranslate"><span class="pre">unclean</span></code>, or with some devices missing so that the kernel md driver
can create appropriate redundancy (copying in raid 1, parity
calculation in raid 4/5).</p>
<p>When an array is assembled, it is first initialized with the
SET_ARRAY_INFO ioctl.  This contains, in particular, a major and minor
version number.  The major version number selects which superblock
format is to be used.  The minor number might be used to tune handling
of the format, such as suggesting where on each device to look for the
superblock.</p>
<p>Then each device is added using the ADD_NEW_DISK ioctl.  This
provides, in particular, a major and minor number identifying the
device to add.</p>
<p>The array is started with the RUN_ARRAY ioctl.</p>
<p>Once started, new devices can be added.  They should have an
appropriate superblock written to them, and then be passed in with
ADD_NEW_DISK.</p>
<p>Devices that have failed or are not yet active can be detached from an
array using HOT_REMOVE_DISK.</p>
</section>
<section id="specific-rules-that-apply-to-format-0-super-block-arrays-and-arrays-with-no-superblock-non-persistent">
<h2>Specific Rules that apply to format-0 super block arrays, and arrays with no superblock (non-persistent)<a class="headerlink" href="#specific-rules-that-apply-to-format-0-super-block-arrays-and-arrays-with-no-superblock-non-persistent" title="Permalink to this headline">¶</a></h2>
<p>An array can be <code class="docutils literal notranslate"><span class="pre">created</span></code> by describing the array (level, chunksize
etc) in a SET_ARRAY_INFO ioctl.  This must have <code class="docutils literal notranslate"><span class="pre">major_version==0</span></code> and
<code class="docutils literal notranslate"><span class="pre">raid_disks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
<p>Then uninitialized devices can be added with ADD_NEW_DISK.  The
structure passed to ADD_NEW_DISK must specify the state of the device
and its role in the array.</p>
<p>Once started with RUN_ARRAY, uninitialized spares can be added with
HOT_ADD_DISK.</p>
</section>
<section id="md-devices-in-sysfs">
<h2>MD devices in sysfs<a class="headerlink" href="#md-devices-in-sysfs" title="Permalink to this headline">¶</a></h2>
<p>md devices appear in sysfs (<code class="docutils literal notranslate"><span class="pre">/sys</span></code>) as regular block devices,
e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/block/md0
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">md</span></code> device will contain a subdirectory called <code class="docutils literal notranslate"><span class="pre">md</span></code> which
contains further md-specific information about the device.</p>
<p>All md devices contain:</p>
<blockquote>
<div><dl>
<dt>level</dt><dd><p>a text file indicating the <code class="docutils literal notranslate"><span class="pre">raid</span> <span class="pre">level</span></code>. e.g. raid0, raid1,
raid5, linear, multipath, faulty.
If no raid level has been set yet (array is still being
assembled), the value will reflect whatever has been written
to it, which may be a name like the above, or may be a number
such as <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">5</span></code>, etc.</p>
</dd>
<dt>raid_disks</dt><dd><p>a text file with a simple number indicating the number of devices
in a fully functional array.  If this is not yet known, the file
will be empty.  If an array is being resized this will contain
the new number of devices.
Some raid levels allow this value to be set while the array is
active.  This will reconfigure the array.   Otherwise it can only
be set while assembling an array.
A change to this attribute will not be permitted if it would
reduce the size of the array.  To reduce the number of drives
in an e.g. raid5, the array size must first be reduced by
setting the <code class="docutils literal notranslate"><span class="pre">array_size</span></code> attribute.</p>
</dd>
<dt>chunk_size</dt><dd><p>This is the size in bytes for <code class="docutils literal notranslate"><span class="pre">chunks</span></code> and is only relevant to
raid levels that involve striping (0,4,5,6,10). The address space
of the array is conceptually divided into chunks and consecutive
chunks are striped onto neighbouring devices.
The size should be at least PAGE_SIZE (4k) and should be a power
of 2.  This can only be set while assembling an array</p>
</dd>
<dt>layout</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">layout</span></code> for the array for the particular level.  This is
simply a number that is interpreted differently by different
levels.  It can be written while assembling an array.</p>
</dd>
<dt>array_size</dt><dd><p>This can be used to artificially constrain the available space in
the array to be less than is actually available on the combined
devices.  Writing a number (in Kilobytes) which is less than
the available size will set the size.  Any reconfiguration of the
array (e.g. adding devices) will not cause the size to change.
Writing the word <code class="docutils literal notranslate"><span class="pre">default</span></code> will cause the effective size of the
array to be whatever size is actually available based on
<code class="docutils literal notranslate"><span class="pre">level</span></code>, <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code> and <code class="docutils literal notranslate"><span class="pre">component_size</span></code>.</p>
<p>This can be used to reduce the size of the array before reducing
the number of devices in a raid4/5/6, or to support external
metadata formats which mandate such clipping.</p>
</dd>
<dt>reshape_position</dt><dd><p>This is either <code class="docutils literal notranslate"><span class="pre">none</span></code> or a sector number within the devices of
the array where <code class="docutils literal notranslate"><span class="pre">reshape</span></code> is up to.  If this is set, the three
attributes mentioned above (raid_disks, chunk_size, layout) can
potentially have 2 values, an old and a new value.  If these
values differ, reading the attribute returns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>new (old)
</pre></div>
</div>
<p>and writing will effect the <code class="docutils literal notranslate"><span class="pre">new</span></code> value, leaving the <code class="docutils literal notranslate"><span class="pre">old</span></code>
unchanged.</p>
</dd>
<dt>component_size</dt><dd><p>For arrays with data redundancy (i.e. not raid0, linear, faulty,
multipath), all components must be the same size - or at least
there must a size that they all provide space for.  This is a key
part or the geometry of the array.  It is measured in sectors
and can be read from here.  Writing to this value may resize
the array if the personality supports it (raid1, raid5, raid6),
and if the component drives are large enough.</p>
</dd>
<dt>metadata_version</dt><dd><p>This indicates the format that is being used to record metadata
about the array.  It can be 0.90 (traditional format), 1.0, 1.1,
1.2 (newer format in varying locations) or <code class="docutils literal notranslate"><span class="pre">none</span></code> indicating that
the kernel isn’t managing metadata at all.
Alternately it can be <code class="docutils literal notranslate"><span class="pre">external:</span></code> followed by a string which
is set by user-space.  This indicates that metadata is managed
by a user-space program.  Any device failure or other event that
requires a metadata update will cause array activity to be
suspended until the event is acknowledged.</p>
</dd>
<dt>resync_start</dt><dd><p>The point at which resync should start.  If no resync is needed,
this will be a very large number (or <code class="docutils literal notranslate"><span class="pre">none</span></code> since 2.6.30-rc1).  At
array creation it will default to 0, though starting the array as
<code class="docutils literal notranslate"><span class="pre">clean</span></code> will set it much larger.</p>
</dd>
<dt>new_dev</dt><dd><p>This file can be written but not read.  The value written should
be a block device number as major:minor.  e.g. 8:0
This will cause that device to be attached to the array, if it is
available.  It will then appear at md/dev-XXX (depending on the
name of the device) and further configuration is then possible.</p>
</dd>
<dt>safe_mode_delay</dt><dd><p>When an md array has seen no write requests for a certain period
of time, it will be marked as <code class="docutils literal notranslate"><span class="pre">clean</span></code>.  When another write
request arrives, the array is marked as <code class="docutils literal notranslate"><span class="pre">dirty</span></code> before the write
commences.  This is known as <code class="docutils literal notranslate"><span class="pre">safe_mode</span></code>.
The <code class="docutils literal notranslate"><span class="pre">certain</span> <span class="pre">period</span></code> is controlled by this file which stores the
period as a number of seconds.  The default is 200msec (0.200).
Writing a value of 0 disables safemode.</p>
</dd>
<dt>array_state</dt><dd><p>This file contains a single word which describes the current
state of the array.  In many cases, the state can be set by
writing the word for the desired state, however some states
cannot be explicitly set, and some transitions are not allowed.</p>
<p>Select/poll works on this file.  All changes except between
Active_idle and active (which can be frequent and are not
very interesting) are notified.  active-&gt;active_idle is
reported if the metadata is externally managed.</p>
<dl>
<dt>clear</dt><dd><p>No devices, no size, no level</p>
<p>Writing is equivalent to STOP_ARRAY ioctl</p>
</dd>
<dt>inactive</dt><dd><p>May have some settings, but array is not active
all IO results in error</p>
<p>When written, doesn’t tear down array, but just stops it</p>
</dd>
<dt>suspended (not supported yet)</dt><dd><p>All IO requests will block. The array can be reconfigured.</p>
<p>Writing this, if accepted, will block until array is quiessent</p>
</dd>
<dt>readonly</dt><dd><p>no resync can happen.  no superblocks get written.</p>
<p>Write requests fail</p>
</dd>
<dt>read-auto</dt><dd><p>like readonly, but behaves like <code class="docutils literal notranslate"><span class="pre">clean</span></code> on a write request.</p>
</dd>
<dt>clean</dt><dd><p>no pending writes, but otherwise active.</p>
<p>When written to inactive array, starts without resync</p>
<p>If a write request arrives then
if metadata is known, mark <code class="docutils literal notranslate"><span class="pre">dirty</span></code> and switch to <code class="docutils literal notranslate"><span class="pre">active</span></code>.
if not known, block and switch to write-pending</p>
<p>If written to an active array that has pending writes, then fails.</p>
</dd>
<dt>active</dt><dd><p>fully active: IO and resync can be happening.
When written to inactive array, starts with resync</p>
</dd>
<dt>write-pending</dt><dd><p>clean, but writes are blocked waiting for <code class="docutils literal notranslate"><span class="pre">active</span></code> to be written.</p>
</dd>
<dt>active-idle</dt><dd><p>like active, but no writes have been seen for a while (safe_mode_delay).</p>
</dd>
</dl>
</dd>
<dt>bitmap/location</dt><dd><p>This indicates where the write-intent bitmap for the array is
stored.</p>
<p>It can be one of <code class="docutils literal notranslate"><span class="pre">none</span></code>, <code class="docutils literal notranslate"><span class="pre">file</span></code> or <code class="docutils literal notranslate"><span class="pre">[+-]N</span></code>.
<code class="docutils literal notranslate"><span class="pre">file</span></code> may later be extended to <code class="docutils literal notranslate"><span class="pre">file:/file/name</span></code>
<code class="docutils literal notranslate"><span class="pre">[+-]N</span></code> means that many sectors from the start of the metadata.</p>
<p>This is replicated on all devices.  For arrays with externally
managed metadata, the offset is from the beginning of the
device.</p>
</dd>
<dt>bitmap/chunksize</dt><dd><p>The size, in bytes, of the chunk which will be represented by a
single bit.  For RAID456, it is a portion of an individual
device. For RAID10, it is a portion of the array.  For RAID1, it
is both (they come to the same thing).</p>
</dd>
<dt>bitmap/time_base</dt><dd><p>The time, in seconds, between looking for bits in the bitmap to
be cleared. In the current implementation, a bit will be cleared
between 2 and 3 times <code class="docutils literal notranslate"><span class="pre">time_base</span></code> after all the covered blocks
are known to be in-sync.</p>
</dd>
<dt>bitmap/backlog</dt><dd><p>When write-mostly devices are active in a RAID1, write requests
to those devices proceed in the background - the filesystem (or
other user of the device) does not have to wait for them.
<code class="docutils literal notranslate"><span class="pre">backlog</span></code> sets a limit on the number of concurrent background
writes.  If there are more than this, new writes will by
synchronous.</p>
</dd>
<dt>bitmap/metadata</dt><dd><p>This can be either <code class="docutils literal notranslate"><span class="pre">internal</span></code> or <code class="docutils literal notranslate"><span class="pre">external</span></code>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt><dd><p>is the default and means the metadata for the bitmap
is stored in the first 256 bytes of the allocated space and is
managed by the md module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">external</span></code></dt><dd><p>means that bitmap metadata is managed externally to
the kernel (i.e. by some userspace program)</p>
</dd>
</dl>
</dd>
<dt>bitmap/can_clear</dt><dd><p>This is either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.  If <code class="docutils literal notranslate"><span class="pre">true</span></code>, then bits in the
bitmap will be cleared when the corresponding blocks are thought
to be in-sync.  If <code class="docutils literal notranslate"><span class="pre">false</span></code>, bits will never be cleared.
This is automatically set to <code class="docutils literal notranslate"><span class="pre">false</span></code> if a write happens on a
degraded array, or if the array becomes degraded during a write.
When metadata is managed externally, it should be set to true
once the array becomes non-degraded, and this fact has been
recorded in the metadata.</p>
</dd>
<dt>consistency_policy</dt><dd><p>This indicates how the array maintains consistency in case of unexpected
shutdown. It can be:</p>
<dl class="simple">
<dt>none</dt><dd><p>Array has no redundancy information, e.g. raid0, linear.</p>
</dd>
<dt>resync</dt><dd><p>Full resync is performed and all redundancy is regenerated when the
array is started after unclean shutdown.</p>
</dd>
<dt>bitmap</dt><dd><p>Resync assisted by a write-intent bitmap.</p>
</dd>
<dt>journal</dt><dd><p>For raid4/5/6, journal device is used to log transactions and replay
after unclean shutdown.</p>
</dd>
<dt>ppl</dt><dd><p>For raid5 only, Partial Parity Log is used to close the write hole and
eliminate resync.</p>
</dd>
</dl>
<p>The accepted values when writing to this file are <code class="docutils literal notranslate"><span class="pre">ppl</span></code> and <code class="docutils literal notranslate"><span class="pre">resync</span></code>,
used to enable and disable PPL.</p>
</dd>
<dt>uuid</dt><dd><p>This indicates the UUID of the array in the following format:
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</p>
</dd>
</dl>
</div></blockquote>
<p>As component devices are added to an md array, they appear in the <code class="docutils literal notranslate"><span class="pre">md</span></code>
directory as new directories named:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dev-XXX
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">XXX</span></code> is a name that the kernel knows for the device, e.g. hdb1.
Each directory contains:</p>
<blockquote>
<div><dl>
<dt>block</dt><dd><p>a symlink to the block device in /sys/block, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/block/md0/md/dev-hdb1/block -&gt; ../../../../block/hdb/hdb1
</pre></div>
</div>
</dd>
<dt>super</dt><dd><p>A file containing an image of the superblock read from, or
written to, that device.</p>
</dd>
<dt>state</dt><dd><p>A file recording the current state of the device in the array
which can be a comma separated list of:</p>
<blockquote>
<div><dl>
<dt>faulty</dt><dd><p>device has been kicked from active use due to
a detected fault, or it has unacknowledged bad
blocks</p>
</dd>
<dt>in_sync</dt><dd><p>device is a fully in-sync member of the array</p>
</dd>
<dt>writemostly</dt><dd><p>device will only be subject to read
requests if there are no other options.</p>
<p>This applies only to raid1 arrays.</p>
</dd>
<dt>blocked</dt><dd><p>device has failed, and the failure hasn’t been
acknowledged yet by the metadata handler.</p>
<p>Writes that would write to this device if
it were not faulty are blocked.</p>
</dd>
<dt>spare</dt><dd><p>device is working, but not a full member.</p>
<p>This includes spares that are in the process
of being recovered to</p>
</dd>
<dt>write_error</dt><dd><p>device has ever seen a write error.</p>
</dd>
<dt>want_replacement</dt><dd><p>device is (mostly) working but probably
should be replaced, either due to errors or
due to user request.</p>
</dd>
<dt>replacement</dt><dd><p>device is a replacement for another active
device with same raid_disk.</p>
</dd>
</dl>
</div></blockquote>
<p>This list may grow in future.</p>
<p>This can be written to.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">faulty</span></code>  simulates a failure on the device.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">remove</span></code> removes the device from the array.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">writemostly</span></code> sets the writemostly flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">-writemostly</span></code> clears the writemostly flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">blocked</span></code> sets the <code class="docutils literal notranslate"><span class="pre">blocked</span></code> flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">-blocked</span></code> clears the <code class="docutils literal notranslate"><span class="pre">blocked</span></code> flags and allows writes
to complete and possibly simulates an error.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">in_sync</span></code> sets the in_sync flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">write_error</span></code> sets writeerrorseen flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">-write_error</span></code> clears writeerrorseen flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">want_replacement</span></code> is allowed at any time except to a
replacement device or a spare.  It sets the flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">-want_replacement</span></code> is allowed at any time.  It clears
the flag.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">replacement</span></code> or <code class="docutils literal notranslate"><span class="pre">-replacement</span></code> is only allowed before
starting the array.  It sets or clears the flag.</p>
<p>This file responds to select/poll. Any change to <code class="docutils literal notranslate"><span class="pre">faulty</span></code>
or <code class="docutils literal notranslate"><span class="pre">blocked</span></code> causes an event.</p>
</dd>
<dt>errors</dt><dd><p>An approximate count of read errors that have been detected on
this device but have not caused the device to be evicted from
the array (either because they were corrected or because they
happened while the array was read-only).  When using version-1
metadata, this value persists across restarts of the array.</p>
<p>This value can be written while assembling an array thus
providing an ongoing count for arrays with metadata managed by
userspace.</p>
</dd>
<dt>slot</dt><dd><p>This gives the role that the device has in the array.  It will
either be <code class="docutils literal notranslate"><span class="pre">none</span></code> if the device is not active in the array
(i.e. is a spare or has failed) or an integer less than the
<code class="docutils literal notranslate"><span class="pre">raid_disks</span></code> number for the array indicating which position
it currently fills.  This can only be set while assembling an
array.  A device for which this is set is assumed to be working.</p>
</dd>
<dt>offset</dt><dd><p>This gives the location in the device (in sectors from the
start) where data from the array will be stored.  Any part of
the device before this offset is not touched, unless it is
used for storing metadata (Formats 1.1 and 1.2).</p>
</dd>
<dt>size</dt><dd><p>The amount of the device, after the offset, that can be used
for storage of data.  This will normally be the same as the
component_size.  This can be written while assembling an
array.  If a value less than the current component_size is
written, it will be rejected.</p>
</dd>
<dt>recovery_start</dt><dd><p>When the device is not <code class="docutils literal notranslate"><span class="pre">in_sync</span></code>, this records the number of
sectors from the start of the device which are known to be
correct.  This is normally zero, but during a recovery
operation it will steadily increase, and if the recovery is
interrupted, restoring this value can cause recovery to
avoid repeating the earlier blocks.  With v1.x metadata, this
value is saved and restored automatically.</p>
<p>This can be set whenever the device is not an active member of
the array, either before the array is activated, or before
the <code class="docutils literal notranslate"><span class="pre">slot</span></code> is set.</p>
<p>Setting this to <code class="docutils literal notranslate"><span class="pre">none</span></code> is equivalent to setting <code class="docutils literal notranslate"><span class="pre">in_sync</span></code>.
Setting to any other value also clears the <code class="docutils literal notranslate"><span class="pre">in_sync</span></code> flag.</p>
</dd>
<dt>bad_blocks</dt><dd><p>This gives the list of all known bad blocks in the form of
start address and length (in sectors respectively). If output
is too big to fit in a page, it will be truncated. Writing
<code class="docutils literal notranslate"><span class="pre">sector</span> <span class="pre">length</span></code> to this file adds new acknowledged (i.e.
recorded to disk safely) bad blocks.</p>
</dd>
<dt>unacknowledged_bad_blocks</dt><dd><p>This gives the list of known-but-not-yet-saved-to-disk bad
blocks in the same form of <code class="docutils literal notranslate"><span class="pre">bad_blocks</span></code>. If output is too big
to fit in a page, it will be truncated. Writing to this file
adds bad blocks without acknowledging them. This is largely
for testing.</p>
</dd>
<dt>ppl_sector, ppl_size</dt><dd><p>Location and size (in sectors) of the space used for Partial Parity Log
on this device.</p>
</dd>
</dl>
</div></blockquote>
<p>An active md device will also contain an entry for each active device
in the array.  These are named:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rdNN
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">NN</span></code> is the position in the array, starting from 0.
So for a 3 drive array there will be rd0, rd1, rd2.
These are symbolic links to the appropriate <code class="docutils literal notranslate"><span class="pre">dev-XXX</span></code> entry.
Thus, for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/block/md*/md/rd*/state
</pre></div>
</div>
<p>will show <code class="docutils literal notranslate"><span class="pre">in_sync</span></code> on every line.</p>
<p>Active md devices for levels that support data redundancy (1,4,5,6,10)
also have</p>
<blockquote>
<div><dl>
<dt>sync_action</dt><dd><p>a text file that can be used to monitor and control the rebuild
process.  It contains one word which can be one of:</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>resync</dt><dd><p>redundancy is being recalculated after unclean
shutdown or creation</p>
</dd>
<dt>recover</dt><dd><p>a hot spare is being built to replace a
failed/missing device</p>
</dd>
<dt>idle</dt><dd><p>nothing is happening</p>
</dd>
<dt>check</dt><dd><p>A full check of redundancy was requested and is
happening.  This reads all blocks and checks
them. A repair may also happen for some raid
levels.</p>
</dd>
<dt>repair</dt><dd><p>A full check and repair is happening.  This is
similar to <code class="docutils literal notranslate"><span class="pre">resync</span></code>, but was requested by the
user, and the write-intent bitmap is NOT used to
optimise the process.</p>
</dd>
</dl>
</div></blockquote>
<p>This file is writable, and each of the strings that could be
read are meaningful for writing.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">idle</span></code> will stop an active resync/recovery etc.  There is no
guarantee that another resync/recovery may not be automatically
started again, though some event will be needed to trigger
this.</p>
<p><code class="docutils literal notranslate"><span class="pre">resync</span></code> or <code class="docutils literal notranslate"><span class="pre">recovery</span></code> can be used to restart the
corresponding operation if it was stopped with <code class="docutils literal notranslate"><span class="pre">idle</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">check</span></code> and <code class="docutils literal notranslate"><span class="pre">repair</span></code> will start the appropriate process
providing the current state is <code class="docutils literal notranslate"><span class="pre">idle</span></code>.</p>
</div></blockquote>
<p>This file responds to select/poll.  Any important change in the value
triggers a poll event.  Sometimes the value will briefly be
<code class="docutils literal notranslate"><span class="pre">recover</span></code> if a recovery seems to be needed, but cannot be
achieved. In that case, the transition to <code class="docutils literal notranslate"><span class="pre">recover</span></code> isn’t
notified, but the transition away is.</p>
</div></blockquote>
</dd>
<dt>degraded</dt><dd><p>This contains a count of the number of devices by which the
arrays is degraded.  So an optimal array will show <code class="docutils literal notranslate"><span class="pre">0</span></code>.  A
single failed/missing drive will show <code class="docutils literal notranslate"><span class="pre">1</span></code>, etc.</p>
<p>This file responds to select/poll, any increase or decrease
in the count of missing devices will trigger an event.</p>
</dd>
<dt>mismatch_count</dt><dd><p>When performing <code class="docutils literal notranslate"><span class="pre">check</span></code> and <code class="docutils literal notranslate"><span class="pre">repair</span></code>, and possibly when
performing <code class="docutils literal notranslate"><span class="pre">resync</span></code>, md will count the number of errors that are
found.  The count in <code class="docutils literal notranslate"><span class="pre">mismatch_cnt</span></code> is the number of sectors
that were re-written, or (for <code class="docutils literal notranslate"><span class="pre">check</span></code>) would have been
re-written.  As most raid levels work in units of pages rather
than sectors, this may be larger than the number of actual errors
by a factor of the number of sectors in a page.</p>
</dd>
<dt>bitmap_set_bits</dt><dd><p>If the array has a write-intent bitmap, then writing to this
attribute can set bits in the bitmap, indicating that a resync
would need to check the corresponding blocks. Either individual
numbers or start-end pairs can be written.  Multiple numbers
can be separated by a space.</p>
<p>Note that the numbers are <code class="docutils literal notranslate"><span class="pre">bit</span></code> numbers, not <code class="docutils literal notranslate"><span class="pre">block</span></code> numbers.
They should be scaled by the bitmap_chunksize.</p>
</dd>
<dt>sync_speed_min, sync_speed_max</dt><dd><p>This are similar to <code class="docutils literal notranslate"><span class="pre">/proc/sys/dev/raid/speed_limit_{min,max}</span></code>
however they only apply to the particular array.</p>
<p>If no value has been written to these, or if the word <code class="docutils literal notranslate"><span class="pre">system</span></code>
is written, then the system-wide value is used.  If a value,
in kibibytes-per-second is written, then it is used.</p>
<p>When the files are read, they show the currently active value
followed by <code class="docutils literal notranslate"><span class="pre">(local)</span></code> or <code class="docutils literal notranslate"><span class="pre">(system)</span></code> depending on whether it is
a locally set or system-wide value.</p>
</dd>
<dt>sync_completed</dt><dd><p>This shows the number of sectors that have been completed of
whatever the current sync_action is, followed by the number of
sectors in total that could need to be processed.  The two
numbers are separated by a <code class="docutils literal notranslate"><span class="pre">/</span></code>  thus effectively showing one
value, a fraction of the process that is complete.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">select</span></code> on this attribute will return when resync completes,
when it reaches the current sync_max (below) and possibly at
other times.</p>
</dd>
<dt>sync_speed</dt><dd><p>This shows the current actual speed, in K/sec, of the current
sync_action.  It is averaged over the last 30 seconds.</p>
</dd>
<dt>suspend_lo, suspend_hi</dt><dd><p>The two values, given as numbers of sectors, indicate a range
within the array where IO will be blocked.  This is currently
only supported for raid4/5/6.</p>
</dd>
<dt>sync_min, sync_max</dt><dd><p>The two values, given as numbers of sectors, indicate a range
within the array where <code class="docutils literal notranslate"><span class="pre">check</span></code>/<code class="docutils literal notranslate"><span class="pre">repair</span></code> will operate. Must be
a multiple of chunk_size. When it reaches <code class="docutils literal notranslate"><span class="pre">sync_max</span></code> it will
pause, rather than complete.
You can use <code class="docutils literal notranslate"><span class="pre">select</span></code> or <code class="docutils literal notranslate"><span class="pre">poll</span></code> on <code class="docutils literal notranslate"><span class="pre">sync_completed</span></code> to wait for
that number to reach sync_max.  Then you can either increase
<code class="docutils literal notranslate"><span class="pre">sync_max</span></code>, or can write <code class="docutils literal notranslate"><span class="pre">idle</span></code> to <code class="docutils literal notranslate"><span class="pre">sync_action</span></code>.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">max</span></code> for <code class="docutils literal notranslate"><span class="pre">sync_max</span></code> effectively disables the limit.
When a resync is active, the value can only ever be increased,
never decreased.
The value of <code class="docutils literal notranslate"><span class="pre">0</span></code> is the minimum for <code class="docutils literal notranslate"><span class="pre">sync_min</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>Each active md device may also have attributes specific to the
personality module that manages it.
These are specific to the implementation of the module and could
change substantially if the implementation changes.</p>
<p>These currently include:</p>
<blockquote>
<div><dl class="simple">
<dt>stripe_cache_size  (currently raid5 only)</dt><dd><p>number of entries in the stripe cache.  This is writable, but
there are upper and lower limits (32768, 17).  Default is 256.</p>
</dd>
<dt>strip_cache_active (currently raid5 only)</dt><dd><p>number of active entries in the stripe cache</p>
</dd>
<dt>preread_bypass_threshold (currently raid5 only)</dt><dd><p>number of times a stripe requiring preread will be bypassed by
a stripe that does not require preread.  For fairness defaults
to 1.  Setting this to 0 disables bypass accounting and
requires preread stripes to wait until all full-width stripe-
writes are complete.  Valid values are 0 to stripe_cache_size.</p>
</dd>
<dt>journal_mode (currently raid5 only)</dt><dd><p>The cache mode for raid5. raid5 could include an extra disk for
caching. The mode can be “write-throuth” and “write-back”. The
default is “write-through”.</p>
</dd>
<dt>ppl_write_hint</dt><dd><p>NVMe stream ID to be set for each PPL write request.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">RAID arrays</a><ul>
<li><a class="reference internal" href="#boot-time-assembly-of-raid-arrays">Boot time assembly of RAID arrays</a><ul>
<li><a class="reference internal" href="#md-device-no"><code class="docutils literal notranslate"><span class="pre">md</span> <span class="pre">device</span> <span class="pre">no.</span></code></a></li>
<li><a class="reference internal" href="#raid-level"><code class="docutils literal notranslate"><span class="pre">raid</span> <span class="pre">level</span></code></a></li>
<li><a class="reference internal" href="#chunk-size-factor"><code class="docutils literal notranslate"><span class="pre">chunk</span> <span class="pre">size</span> <span class="pre">factor</span></code></a></li>
<li><a class="reference internal" href="#fault-level"><code class="docutils literal notranslate"><span class="pre">fault</span> <span class="pre">level</span></code></a></li>
<li><a class="reference internal" href="#dev0-to-devn"><code class="docutils literal notranslate"><span class="pre">dev0</span></code> to <code class="docutils literal notranslate"><span class="pre">devn</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#boot-time-autodetection-of-raid-arrays">Boot time autodetection of RAID arrays</a></li>
<li><a class="reference internal" href="#boot-time-assembly-of-degraded-dirty-arrays">Boot time assembly of degraded/dirty arrays</a></li>
<li><a class="reference internal" href="#superblock-formats">Superblock formats</a></li>
<li><a class="reference internal" href="#general-rules-apply-for-all-superblock-formats">General Rules - apply for all superblock formats</a></li>
<li><a class="reference internal" href="#specific-rules-that-apply-to-format-0-super-block-arrays-and-arrays-with-no-superblock-non-persistent">Specific Rules that apply to format-0 super block arrays, and arrays with no superblock (non-persistent)</a></li>
<li><a class="reference internal" href="#md-devices-in-sysfs">MD devices in sysfs</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/admin-guide/md.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/admin-guide/md.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>