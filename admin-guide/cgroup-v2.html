
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Control Group v2 &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CIFS" href="cifs/index.html" />
    <link rel="prev" title="RDMA Controller" href="cgroup-v1/rdma.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="control-group-v2">
<span id="cgroup-v2"></span><h1>Control Group v2<a class="headerlink" href="#control-group-v2" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date</dt>
<dd class="field-odd"><p>October, 2015</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Tejun Heo &lt;<a class="reference external" href="mailto:tj&#37;&#52;&#48;kernel&#46;org">tj<span>&#64;</span>kernel<span>&#46;</span>org</a>&gt;</p>
</dd>
</dl>
<p>This is the authoritative documentation on the design, interface and
conventions of cgroup v2.  It describes all userland-visible aspects
of cgroup including core and specific controller behaviors.  All
future changes must be reflected in this document.  Documentation for
v1 is available under <a class="reference internal" href="cgroup-v1/index.html#cgroup-v1"><span class="std std-ref">Documentation/admin-guide/cgroup-v1/index.rst</span></a>.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<section id="terminology">
<h3>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h3>
<p>“cgroup” stands for “control group” and is never capitalized.  The
singular form is used to designate the whole feature and also as a
qualifier as in “cgroup controllers”.  When explicitly referring to
multiple individual control groups, the plural form “cgroups” is used.</p>
</section>
<section id="what-is-cgroup">
<h3>What is cgroup?<a class="headerlink" href="#what-is-cgroup" title="Permalink to this headline">¶</a></h3>
<p>cgroup is a mechanism to organize processes hierarchically and
distribute system resources along the hierarchy in a controlled and
configurable manner.</p>
<p>cgroup is largely composed of two parts - the core and controllers.
cgroup core is primarily responsible for hierarchically organizing
processes.  A cgroup controller is usually responsible for
distributing a specific type of system resource along the hierarchy
although there are utility controllers which serve purposes other than
resource distribution.</p>
<p>cgroups form a tree structure and every process in the system belongs
to one and only one cgroup.  All threads of a process belong to the
same cgroup.  On creation, all processes are put in the cgroup that
the parent process belongs to at the time.  A process can be migrated
to another cgroup.  Migration of a process doesn’t affect already
existing descendant processes.</p>
<p>Following certain structural constraints, controllers may be enabled or
disabled selectively on a cgroup.  All controller behaviors are
hierarchical - if a controller is enabled on a cgroup, it affects all
processes which belong to the cgroups consisting the inclusive
sub-hierarchy of the cgroup.  When a controller is enabled on a nested
cgroup, it always restricts the resource distribution further.  The
restrictions set closer to the root in the hierarchy can not be
overridden from further away.</p>
</section>
</section>
<section id="basic-operations">
<h2>Basic Operations<a class="headerlink" href="#basic-operations" title="Permalink to this headline">¶</a></h2>
<section id="mounting">
<h3>Mounting<a class="headerlink" href="#mounting" title="Permalink to this headline">¶</a></h3>
<p>Unlike v1, cgroup v2 has only single hierarchy.  The cgroup v2
hierarchy can be mounted with the following mount command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t cgroup2 none $MOUNT_POINT
</pre></div>
</div>
<p>cgroup2 filesystem has the magic number 0x63677270 (“cgrp”).  All
controllers which support v2 and are not bound to a v1 hierarchy are
automatically bound to the v2 hierarchy and show up at the root.
Controllers which are not in active use in the v2 hierarchy can be
bound to other hierarchies.  This allows mixing v2 hierarchy with the
legacy v1 multiple hierarchies in a fully backward compatible way.</p>
<p>A controller can be moved across hierarchies only after the controller
is no longer referenced in its current hierarchy.  Because per-cgroup
controller states are destroyed asynchronously and controllers may
have lingering references, a controller may not show up immediately on
the v2 hierarchy after the final umount of the previous hierarchy.
Similarly, a controller should be fully disabled to be moved out of
the unified hierarchy and it may take some time for the disabled
controller to become available for other hierarchies; furthermore, due
to inter-controller dependencies, other controllers may need to be
disabled too.</p>
<p>While useful for development and manual configurations, moving
controllers dynamically between the v2 and other hierarchies is
strongly discouraged for production use.  It is recommended to decide
the hierarchies and controller associations before starting using the
controllers after system boot.</p>
<p>During transition to v2, system management software might still
automount the v1 cgroup filesystem and so hijack all controllers
during boot, before manual intervention is possible. To make testing
and experimenting easier, the kernel parameter cgroup_no_v1= allows
disabling controllers in v1 and make them always available in v2.</p>
<p>cgroup v2 currently supports the following mount options.</p>
<blockquote>
<div><dl class="simple">
<dt>nsdelegate</dt><dd><p>Consider cgroup namespaces as delegation boundaries.  This
option is system wide and can only be set on mount or modified
through remount from the init namespace.  The mount option is
ignored on non-init namespace mounts.  Please refer to the
Delegation section for details.</p>
</dd>
<dt>favordynmods</dt><dd><p>Reduce the latencies of dynamic cgroup modifications such as
task migrations and controller on/offs at the cost of making
hot path operations such as forks and exits more expensive.
The static usage pattern of creating a cgroup, enabling
controllers, and then seeding it with CLONE_INTO_CGROUP is
not affected by this option.</p>
</dd>
<dt>memory_localevents</dt><dd><p>Only populate memory.events with data for the current cgroup,
and not any subtrees. This is legacy behaviour, the default
behaviour without this option is to include subtree counts.
This option is system wide and can only be set on mount or
modified through remount from the init namespace. The mount
option is ignored on non-init namespace mounts.</p>
</dd>
<dt>memory_recursiveprot</dt><dd><p>Recursively apply memory.min and memory.low protection to
entire subtrees, without requiring explicit downward
propagation into leaf cgroups.  This allows protecting entire
subtrees from one another, while retaining free competition
within those subtrees.  This should have been the default
behavior but is a mount-option to avoid regressing setups
relying on the original semantics (e.g. specifying bogusly
high ‘bypass’ protection values at higher tree levels).</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="organizing-processes-and-threads">
<h3>Organizing Processes and Threads<a class="headerlink" href="#organizing-processes-and-threads" title="Permalink to this headline">¶</a></h3>
<section id="processes">
<h4>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h4>
<p>Initially, only the root cgroup exists to which all processes belong.
A child cgroup can be created by creating a sub-directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir $CGROUP_NAME
</pre></div>
</div>
<p>A given cgroup may have multiple child cgroups forming a tree
structure.  Each cgroup has a read-writable interface file
“cgroup.procs”.  When read, it lists the PIDs of all processes which
belong to the cgroup one-per-line.  The PIDs are not ordered and the
same PID may show up more than once if the process got moved to
another cgroup and then back or the PID got recycled while reading.</p>
<p>A process can be migrated into a cgroup by writing its PID to the
target cgroup’s “cgroup.procs” file.  Only one process can be migrated
on a single write(2) call.  If a process is composed of multiple
threads, writing the PID of any thread migrates all threads of the
process.</p>
<p>When a process forks a child process, the new process is born into the
cgroup that the forking process belongs to at the time of the
operation.  After exit, a process stays associated with the cgroup
that it belonged to at the time of exit until it’s reaped; however, a
zombie process does not appear in “cgroup.procs” and thus can’t be
moved to another cgroup.</p>
<p>A cgroup which doesn’t have any children or live processes can be
destroyed by removing the directory.  Note that a cgroup which doesn’t
have any children and is associated only with zombie processes is
considered empty and can be removed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># rmdir $CGROUP_NAME
</pre></div>
</div>
<p>“/proc/$PID/cgroup” lists a process’s cgroup membership.  If legacy
cgroup is in use in the system, this file may contain multiple lines,
one for each hierarchy.  The entry for cgroup v2 is always in the
format “0::$PATH”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/842/cgroup
...
0::/test-cgroup/test-cgroup-nested
</pre></div>
</div>
<p>If the process becomes a zombie and the cgroup it was associated with
is removed subsequently, ” (deleted)” is appended to the path:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/842/cgroup
...
0::/test-cgroup/test-cgroup-nested (deleted)
</pre></div>
</div>
</section>
<section id="threads">
<h4>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h4>
<p>cgroup v2 supports thread granularity for a subset of controllers to
support use cases requiring hierarchical resource distribution across
the threads of a group of processes.  By default, all threads of a
process belong to the same cgroup, which also serves as the resource
domain to host resource consumptions which are not specific to a
process or thread.  The thread mode allows threads to be spread across
a subtree while still maintaining the common resource domain for them.</p>
<p>Controllers which support thread mode are called threaded controllers.
The ones which don’t are called domain controllers.</p>
<p>Marking a cgroup threaded makes it join the resource domain of its
parent as a threaded cgroup.  The parent may be another threaded
cgroup whose resource domain is further up in the hierarchy.  The root
of a threaded subtree, that is, the nearest ancestor which is not
threaded, is called threaded domain or thread root interchangeably and
serves as the resource domain for the entire subtree.</p>
<p>Inside a threaded subtree, threads of a process can be put in
different cgroups and are not subject to the no internal process
constraint - threaded controllers can be enabled on non-leaf cgroups
whether they have threads in them or not.</p>
<p>As the threaded domain cgroup hosts all the domain resource
consumptions of the subtree, it is considered to have internal
resource consumptions whether there are processes in it or not and
can’t have populated child cgroups which aren’t threaded.  Because the
root cgroup is not subject to no internal process constraint, it can
serve both as a threaded domain and a parent to domain cgroups.</p>
<p>The current operation mode or type of the cgroup is shown in the
“cgroup.type” file which indicates whether the cgroup is a normal
domain, a domain which is serving as the domain of a threaded subtree,
or a threaded cgroup.</p>
<p>On creation, a cgroup is always a domain cgroup and can be made
threaded by writing “threaded” to the “cgroup.type” file.  The
operation is single direction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo threaded &gt; cgroup.type
</pre></div>
</div>
<p>Once threaded, the cgroup can’t be made a domain again.  To enable the
thread mode, the following conditions must be met.</p>
<ul class="simple">
<li><p>As the cgroup will join the parent’s resource domain.  The parent
must either be a valid (threaded) domain or a threaded cgroup.</p></li>
<li><p>When the parent is an unthreaded domain, it must not have any domain
controllers enabled or populated domain children.  The root is
exempt from this requirement.</p></li>
</ul>
<p>Topology-wise, a cgroup can be in an invalid state.  Please consider
the following topology:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A (threaded domain) - B (threaded) - C (domain, just created)
</pre></div>
</div>
<p>C is created as a domain but isn’t connected to a parent which can
host child domains.  C can’t be used until it is turned into a
threaded cgroup.  “cgroup.type” file will report “domain (invalid)” in
these cases.  Operations which fail due to invalid topology use
EOPNOTSUPP as the errno.</p>
<p>A domain cgroup is turned into a threaded domain when one of its child
cgroup becomes threaded or threaded controllers are enabled in the
“cgroup.subtree_control” file while there are processes in the cgroup.
A threaded domain reverts to a normal domain when the conditions
clear.</p>
<p>When read, “cgroup.threads” contains the list of the thread IDs of all
threads in the cgroup.  Except that the operations are per-thread
instead of per-process, “cgroup.threads” has the same format and
behaves the same way as “cgroup.procs”.  While “cgroup.threads” can be
written to in any cgroup, as it can only move threads inside the same
threaded domain, its operations are confined inside each threaded
subtree.</p>
<p>The threaded domain cgroup serves as the resource domain for the whole
subtree, and, while the threads can be scattered across the subtree,
all the processes are considered to be in the threaded domain cgroup.
“cgroup.procs” in a threaded domain cgroup contains the PIDs of all
processes in the subtree and is not readable in the subtree proper.
However, “cgroup.procs” can be written to from anywhere in the subtree
to migrate all threads of the matching process to the cgroup.</p>
<p>Only threaded controllers can be enabled in a threaded subtree.  When
a threaded controller is enabled inside a threaded subtree, it only
accounts for and controls resource consumptions associated with the
threads in the cgroup and its descendants.  All consumptions which
aren’t tied to a specific thread belong to the threaded domain cgroup.</p>
<p>Because a threaded subtree is exempt from no internal process
constraint, a threaded controller must be able to handle competition
between threads in a non-leaf cgroup and its child cgroups.  Each
threaded controller defines how such competitions are handled.</p>
</section>
</section>
<section id="un-populated-notification">
<h3>[Un]populated Notification<a class="headerlink" href="#un-populated-notification" title="Permalink to this headline">¶</a></h3>
<p>Each non-root cgroup has a “cgroup.events” file which contains
“populated” field indicating whether the cgroup’s sub-hierarchy has
live processes in it.  Its value is 0 if there is no live process in
the cgroup and its descendants; otherwise, 1.  poll and [id]notify
events are triggered when the value changes.  This can be used, for
example, to start a clean-up operation after all processes of a given
sub-hierarchy have exited.  The populated state updates and
notifications are recursive.  Consider the following sub-hierarchy
where the numbers in the parentheses represent the numbers of processes
in each cgroup:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A(4) - B(0) - C(1)
            \ D(0)
</pre></div>
</div>
<p>A, B and C’s “populated” fields would be 1 while D’s 0.  After the one
process in C exits, B and C’s “populated” fields would flip to “0” and
file modified events will be generated on the “cgroup.events” files of
both cgroups.</p>
</section>
<section id="controlling-controllers">
<h3>Controlling Controllers<a class="headerlink" href="#controlling-controllers" title="Permalink to this headline">¶</a></h3>
<section id="enabling-and-disabling">
<h4>Enabling and Disabling<a class="headerlink" href="#enabling-and-disabling" title="Permalink to this headline">¶</a></h4>
<p>Each cgroup has a “cgroup.controllers” file which lists all
controllers available for the cgroup to enable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat cgroup.controllers
cpu io memory
</pre></div>
</div>
<p>No controller is enabled by default.  Controllers can be enabled and
disabled by writing to the “cgroup.subtree_control” file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;+cpu +memory -io&quot; &gt; cgroup.subtree_control
</pre></div>
</div>
<p>Only controllers which are listed in “cgroup.controllers” can be
enabled.  When multiple operations are specified as above, either they
all succeed or fail.  If multiple operations on the same controller
are specified, the last one is effective.</p>
<p>Enabling a controller in a cgroup indicates that the distribution of
the target resource across its immediate children will be controlled.
Consider the following sub-hierarchy.  The enabled controllers are
listed in parentheses:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A(cpu,memory) - B(memory) - C()
                          \ D()
</pre></div>
</div>
<p>As A has “cpu” and “memory” enabled, A will control the distribution
of CPU cycles and memory to its children, in this case, B.  As B has
“memory” enabled but not “CPU”, C and D will compete freely on CPU
cycles but their division of memory available to B will be controlled.</p>
<p>As a controller regulates the distribution of the target resource to
the cgroup’s children, enabling it creates the controller’s interface
files in the child cgroups.  In the above example, enabling “cpu” on B
would create the “cpu.” prefixed controller interface files in C and
D.  Likewise, disabling “memory” from B would remove the “memory.”
prefixed controller interface files from C and D.  This means that the
controller interface files - anything which doesn’t start with
“cgroup.” are owned by the parent rather than the cgroup itself.</p>
</section>
<section id="top-down-constraint">
<h4>Top-down Constraint<a class="headerlink" href="#top-down-constraint" title="Permalink to this headline">¶</a></h4>
<p>Resources are distributed top-down and a cgroup can further distribute
a resource only if the resource has been distributed to it from the
parent.  This means that all non-root “cgroup.subtree_control” files
can only contain controllers which are enabled in the parent’s
“cgroup.subtree_control” file.  A controller can be enabled only if
the parent has the controller enabled and a controller can’t be
disabled if one or more children have it enabled.</p>
</section>
<section id="no-internal-process-constraint">
<h4>No Internal Process Constraint<a class="headerlink" href="#no-internal-process-constraint" title="Permalink to this headline">¶</a></h4>
<p>Non-root cgroups can distribute domain resources to their children
only when they don’t have any processes of their own.  In other words,
only domain cgroups which don’t contain any processes can have domain
controllers enabled in their “cgroup.subtree_control” files.</p>
<p>This guarantees that, when a domain controller is looking at the part
of the hierarchy which has it enabled, processes are always only on
the leaves.  This rules out situations where child cgroups compete
against internal processes of the parent.</p>
<p>The root cgroup is exempt from this restriction.  Root contains
processes and anonymous resource consumption which can’t be associated
with any other cgroups and requires special treatment from most
controllers.  How resource consumption in the root cgroup is governed
is up to each controller (for more information on this topic please
refer to the Non-normative information section in the Controllers
chapter).</p>
<p>Note that the restriction doesn’t get in the way if there is no
enabled controller in the cgroup’s “cgroup.subtree_control”.  This is
important as otherwise it wouldn’t be possible to create children of a
populated cgroup.  To control resource distribution of a cgroup, the
cgroup must create children and transfer all its processes to the
children before enabling controllers in its “cgroup.subtree_control”
file.</p>
</section>
</section>
<section id="delegation">
<h3>Delegation<a class="headerlink" href="#delegation" title="Permalink to this headline">¶</a></h3>
<section id="model-of-delegation">
<h4>Model of Delegation<a class="headerlink" href="#model-of-delegation" title="Permalink to this headline">¶</a></h4>
<p>A cgroup can be delegated in two ways.  First, to a less privileged
user by granting write access of the directory and its “cgroup.procs”,
“cgroup.threads” and “cgroup.subtree_control” files to the user.
Second, if the “nsdelegate” mount option is set, automatically to a
cgroup namespace on namespace creation.</p>
<p>Because the resource control interface files in a given directory
control the distribution of the parent’s resources, the delegatee
shouldn’t be allowed to write to them.  For the first method, this is
achieved by not granting access to these files.  For the second, the
kernel rejects writes to all files other than “cgroup.procs” and
“cgroup.subtree_control” on a namespace root from inside the
namespace.</p>
<p>The end results are equivalent for both delegation types.  Once
delegated, the user can build sub-hierarchy under the directory,
organize processes inside it as it sees fit and further distribute the
resources it received from the parent.  The limits and other settings
of all resource controllers are hierarchical and regardless of what
happens in the delegated sub-hierarchy, nothing can escape the
resource restrictions imposed by the parent.</p>
<p>Currently, cgroup doesn’t impose any restrictions on the number of
cgroups in or nesting depth of a delegated sub-hierarchy; however,
this may be limited explicitly in the future.</p>
</section>
<section id="delegation-containment">
<h4>Delegation Containment<a class="headerlink" href="#delegation-containment" title="Permalink to this headline">¶</a></h4>
<p>A delegated sub-hierarchy is contained in the sense that processes
can’t be moved into or out of the sub-hierarchy by the delegatee.</p>
<p>For delegations to a less privileged user, this is achieved by
requiring the following conditions for a process with a non-root euid
to migrate a target process into a cgroup by writing its PID to the
“cgroup.procs” file.</p>
<ul class="simple">
<li><p>The writer must have write access to the “cgroup.procs” file.</p></li>
<li><p>The writer must have write access to the “cgroup.procs” file of the
common ancestor of the source and destination cgroups.</p></li>
</ul>
<p>The above two constraints ensure that while a delegatee may migrate
processes around freely in the delegated sub-hierarchy it can’t pull
in from or push out to outside the sub-hierarchy.</p>
<p>For an example, let’s assume cgroups C0 and C1 have been delegated to
user U0 who created C00, C01 under C0 and C10 under C1 as follows and
all processes under C0 and C1 belong to U0:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>~~~~~~~~~~~~~ - C0 - C00
~ cgroup    ~      \ C01
~ hierarchy ~
~~~~~~~~~~~~~ - C1 - C10
</pre></div>
</div>
<p>Let’s also say U0 wants to write the PID of a process which is
currently in C10 into “C00/cgroup.procs”.  U0 has write access to the
file; however, the common ancestor of the source cgroup C10 and the
destination cgroup C00 is above the points of delegation and U0 would
not have write access to its “cgroup.procs” files and thus the write
will be denied with -EACCES.</p>
<p>For delegations to namespaces, containment is achieved by requiring
that both the source and destination cgroups are reachable from the
namespace of the process which is attempting the migration.  If either
is not reachable, the migration is rejected with -ENOENT.</p>
</section>
</section>
<section id="guidelines">
<h3>Guidelines<a class="headerlink" href="#guidelines" title="Permalink to this headline">¶</a></h3>
<section id="organize-once-and-control">
<h4>Organize Once and Control<a class="headerlink" href="#organize-once-and-control" title="Permalink to this headline">¶</a></h4>
<p>Migrating a process across cgroups is a relatively expensive operation
and stateful resources such as memory are not moved together with the
process.  This is an explicit design decision as there often exist
inherent trade-offs between migration and various hot paths in terms
of synchronization cost.</p>
<p>As such, migrating processes across cgroups frequently as a means to
apply different resource restrictions is discouraged.  A workload
should be assigned to a cgroup according to the system’s logical and
resource structure once on start-up.  Dynamic adjustments to resource
distribution can be made by changing controller configuration through
the interface files.</p>
</section>
<section id="avoid-name-collisions">
<h4>Avoid Name Collisions<a class="headerlink" href="#avoid-name-collisions" title="Permalink to this headline">¶</a></h4>
<p>Interface files for a cgroup and its children cgroups occupy the same
directory and it is possible to create children cgroups which collide
with interface files.</p>
<p>All cgroup core interface files are prefixed with “cgroup.” and each
controller’s interface files are prefixed with the controller name and
a dot.  A controller’s name is composed of lower case alphabets and
‘_’s but never begins with an ‘_’ so it can be used as the prefix
character for collision avoidance.  Also, interface file names won’t
start or end with terms which are often used in categorizing workloads
such as job, service, slice, unit or workload.</p>
<p>cgroup doesn’t do anything to prevent name collisions and it’s the
user’s responsibility to avoid them.</p>
</section>
</section>
</section>
<section id="resource-distribution-models">
<h2>Resource Distribution Models<a class="headerlink" href="#resource-distribution-models" title="Permalink to this headline">¶</a></h2>
<p>cgroup controllers implement several resource distribution schemes
depending on the resource type and expected use cases.  This section
describes major schemes in use along with their expected behaviors.</p>
<section id="weights">
<h3>Weights<a class="headerlink" href="#weights" title="Permalink to this headline">¶</a></h3>
<p>A parent’s resource is distributed by adding up the weights of all
active children and giving each the fraction matching the ratio of its
weight against the sum.  As only children which can make use of the
resource at the moment participate in the distribution, this is
work-conserving.  Due to the dynamic nature, this model is usually
used for stateless resources.</p>
<p>All weights are in the range [1, 10000] with the default at 100.  This
allows symmetric multiplicative biases in both directions at fine
enough granularity while staying in the intuitive range.</p>
<p>As long as the weight is in range, all configuration combinations are
valid and there is no reason to reject configuration changes or
process migrations.</p>
<p>“cpu.weight” proportionally distributes CPU cycles to active children
and is an example of this type.</p>
</section>
<section id="limits">
<span id="cgroupv2-limits-distributor"></span><h3>Limits<a class="headerlink" href="#limits" title="Permalink to this headline">¶</a></h3>
<p>A child can only consume upto the configured amount of the resource.
Limits can be over-committed - the sum of the limits of children can
exceed the amount of resource available to the parent.</p>
<p>Limits are in the range [0, max] and defaults to “max”, which is noop.</p>
<p>As limits can be over-committed, all configuration combinations are
valid and there is no reason to reject configuration changes or
process migrations.</p>
<p>“io.max” limits the maximum BPS and/or IOPS that a cgroup can consume
on an IO device and is an example of this type.</p>
</section>
<section id="protections">
<span id="cgroupv2-protections-distributor"></span><h3>Protections<a class="headerlink" href="#protections" title="Permalink to this headline">¶</a></h3>
<p>A cgroup is protected upto the configured amount of the resource
as long as the usages of all its ancestors are under their
protected levels.  Protections can be hard guarantees or best effort
soft boundaries.  Protections can also be over-committed in which case
only upto the amount available to the parent is protected among
children.</p>
<p>Protections are in the range [0, max] and defaults to 0, which is
noop.</p>
<p>As protections can be over-committed, all configuration combinations
are valid and there is no reason to reject configuration changes or
process migrations.</p>
<p>“memory.low” implements best-effort memory protection and is an
example of this type.</p>
</section>
<section id="allocations">
<h3>Allocations<a class="headerlink" href="#allocations" title="Permalink to this headline">¶</a></h3>
<p>A cgroup is exclusively allocated a certain amount of a finite
resource.  Allocations can’t be over-committed - the sum of the
allocations of children can not exceed the amount of resource
available to the parent.</p>
<p>Allocations are in the range [0, max] and defaults to 0, which is no
resource.</p>
<p>As allocations can’t be over-committed, some configuration
combinations are invalid and should be rejected.  Also, if the
resource is mandatory for execution of processes, process migrations
may be rejected.</p>
<p>“cpu.rt.max” hard-allocates realtime slices and is an example of this
type.</p>
</section>
</section>
<section id="interface-files">
<h2>Interface Files<a class="headerlink" href="#interface-files" title="Permalink to this headline">¶</a></h2>
<section id="format">
<h3>Format<a class="headerlink" href="#format" title="Permalink to this headline">¶</a></h3>
<p>All interface files should be in one of the following formats whenever
possible:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>New-line separated values
(when only one value can be written at once)

      VAL0\n
      VAL1\n
      ...

Space separated values
(when read-only or multiple values can be written at once)

      VAL0 VAL1 ...\n

Flat keyed

      KEY0 VAL0\n
      KEY1 VAL1\n
      ...

Nested keyed

      KEY0 SUB_KEY0=VAL00 SUB_KEY1=VAL01...
      KEY1 SUB_KEY0=VAL10 SUB_KEY1=VAL11...
      ...
</pre></div>
</div>
<p>For a writable file, the format for writing should generally match
reading; however, controllers may allow omitting later fields or
implement restricted shortcuts for most common use cases.</p>
<p>For both flat and nested keyed files, only the values for a single key
can be written at a time.  For nested keyed files, the sub key pairs
may be specified in any order and not all pairs have to be specified.</p>
</section>
<section id="conventions">
<h3>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Settings for a single feature should be contained in a single file.</p></li>
<li><p>The root cgroup should be exempt from resource control and thus
shouldn’t have resource control interface files.</p></li>
<li><p>The default time unit is microseconds.  If a different unit is ever
used, an explicit unit suffix must be present.</p></li>
<li><p>A parts-per quantity should use a percentage decimal with at least
two digit fractional part - e.g. 13.40.</p></li>
<li><p>If a controller implements weight based resource distribution, its
interface file should be named “weight” and have the range [1,
10000] with 100 as the default.  The values are chosen to allow
enough and symmetric bias in both directions while keeping it
intuitive (the default is 100%).</p></li>
<li><p>If a controller implements an absolute resource guarantee and/or
limit, the interface files should be named “min” and “max”
respectively.  If a controller implements best effort resource
guarantee and/or limit, the interface files should be named “low”
and “high” respectively.</p>
<p>In the above four control files, the special token “max” should be
used to represent upward infinity for both reading and writing.</p>
</li>
<li><p>If a setting has a configurable default value and keyed specific
overrides, the default entry should be keyed with “default” and
appear as the first entry in the file.</p>
<p>The default value can be updated by writing either “default $VAL” or
“$VAL”.</p>
<p>When writing to update a specific override, “default” can be used as
the value to indicate removal of the override.  Override entries
with “default” as the value must not appear when read.</p>
<p>For example, a setting which is keyed by major:minor device numbers
with integer values may look like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat cgroup-example-interface-file
default 150
8:0 300
</pre></div>
</div>
<p>The default value can be updated by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo 125 &gt; cgroup-example-interface-file
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;default 125&quot; &gt; cgroup-example-interface-file
</pre></div>
</div>
<p>An override can be set by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;8:16 170&quot; &gt; cgroup-example-interface-file
</pre></div>
</div>
<p>and cleared by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;8:0 default&quot; &gt; cgroup-example-interface-file
# cat cgroup-example-interface-file
default 125
8:16 170
</pre></div>
</div>
</li>
<li><p>For events which are not very high frequency, an interface file
“events” should be created which lists event key value pairs.
Whenever a notifiable event happens, file modified event should be
generated on the file.</p></li>
</ul>
</section>
<section id="core-interface-files">
<h3>Core Interface Files<a class="headerlink" href="#core-interface-files" title="Permalink to this headline">¶</a></h3>
<p>All cgroup core files are prefixed with “cgroup.”</p>
<blockquote>
<div><dl>
<dt>cgroup.type</dt><dd><p>A read-write single value file which exists on non-root
cgroups.</p>
<p>When read, it indicates the current type of the cgroup, which
can be one of the following values.</p>
<ul class="simple">
<li><p>“domain” : A normal valid domain cgroup.</p></li>
<li><p>“domain threaded” : A threaded domain cgroup which is
serving as the root of a threaded subtree.</p></li>
<li><p>“domain invalid” : A cgroup which is in an invalid state.
It can’t be populated or have controllers enabled.  It may
be allowed to become a threaded cgroup.</p></li>
<li><p>“threaded” : A threaded cgroup which is a member of a
threaded subtree.</p></li>
</ul>
<p>A cgroup can be turned into a threaded cgroup by writing
“threaded” to this file.</p>
</dd>
<dt>cgroup.procs</dt><dd><p>A read-write new-line separated values file which exists on
all cgroups.</p>
<p>When read, it lists the PIDs of all processes which belong to
the cgroup one-per-line.  The PIDs are not ordered and the
same PID may show up more than once if the process got moved
to another cgroup and then back or the PID got recycled while
reading.</p>
<p>A PID can be written to migrate the process associated with
the PID to the cgroup.  The writer should match all of the
following conditions.</p>
<ul class="simple">
<li><p>It must have write access to the “cgroup.procs” file.</p></li>
<li><p>It must have write access to the “cgroup.procs” file of the
common ancestor of the source and destination cgroups.</p></li>
</ul>
<p>When delegating a sub-hierarchy, write access to this file
should be granted along with the containing directory.</p>
<p>In a threaded cgroup, reading this file fails with EOPNOTSUPP
as all the processes belong to the thread root.  Writing is
supported and moves every thread of the process to the cgroup.</p>
</dd>
<dt>cgroup.threads</dt><dd><p>A read-write new-line separated values file which exists on
all cgroups.</p>
<p>When read, it lists the TIDs of all threads which belong to
the cgroup one-per-line.  The TIDs are not ordered and the
same TID may show up more than once if the thread got moved to
another cgroup and then back or the TID got recycled while
reading.</p>
<p>A TID can be written to migrate the thread associated with the
TID to the cgroup.  The writer should match all of the
following conditions.</p>
<ul class="simple">
<li><p>It must have write access to the “cgroup.threads” file.</p></li>
<li><p>The cgroup that the thread is currently in must be in the
same resource domain as the destination cgroup.</p></li>
<li><p>It must have write access to the “cgroup.procs” file of the
common ancestor of the source and destination cgroups.</p></li>
</ul>
<p>When delegating a sub-hierarchy, write access to this file
should be granted along with the containing directory.</p>
</dd>
<dt>cgroup.controllers</dt><dd><p>A read-only space separated values file which exists on all
cgroups.</p>
<p>It shows space separated list of all controllers available to
the cgroup.  The controllers are not ordered.</p>
</dd>
<dt>cgroup.subtree_control</dt><dd><p>A read-write space separated values file which exists on all
cgroups.  Starts out empty.</p>
<p>When read, it shows space separated list of the controllers
which are enabled to control resource distribution from the
cgroup to its children.</p>
<p>Space separated list of controllers prefixed with ‘+’ or ‘-’
can be written to enable or disable controllers.  A controller
name prefixed with ‘+’ enables the controller and ‘-’
disables.  If a controller appears more than once on the list,
the last one is effective.  When multiple enable and disable
operations are specified, either all succeed or all fail.</p>
</dd>
<dt>cgroup.events</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups.
The following entries are defined.  Unless specified
otherwise, a value change in this file generates a file
modified event.</p>
<blockquote>
<div><dl class="simple">
<dt>populated</dt><dd><p>1 if the cgroup or its descendants contains any live
processes; otherwise, 0.</p>
</dd>
<dt>frozen</dt><dd><p>1 if the cgroup is frozen; otherwise, 0.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>cgroup.max.descendants</dt><dd><p>A read-write single value files.  The default is “max”.</p>
<p>Maximum allowed number of descent cgroups.
If the actual number of descendants is equal or larger,
an attempt to create a new cgroup in the hierarchy will fail.</p>
</dd>
<dt>cgroup.max.depth</dt><dd><p>A read-write single value files.  The default is “max”.</p>
<p>Maximum allowed descent depth below the current cgroup.
If the actual descent depth is equal or larger,
an attempt to create a new child cgroup will fail.</p>
</dd>
<dt>cgroup.stat</dt><dd><p>A read-only flat-keyed file with the following entries:</p>
<blockquote>
<div><dl>
<dt>nr_descendants</dt><dd><p>Total number of visible descendant cgroups.</p>
</dd>
<dt>nr_dying_descendants</dt><dd><p>Total number of dying descendant cgroups. A cgroup becomes
dying after being deleted by a user. The cgroup will remain
in dying state for some time undefined time (which can depend
on system load) before being completely destroyed.</p>
<p>A process can’t enter a dying cgroup under any circumstances,
a dying cgroup can’t revive.</p>
<p>A dying cgroup can consume system resources not exceeding
limits, which were active at the moment of cgroup deletion.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>cgroup.freeze</dt><dd><p>A read-write single value file which exists on non-root cgroups.
Allowed values are “0” and “1”. The default is “0”.</p>
<p>Writing “1” to the file causes freezing of the cgroup and all
descendant cgroups. This means that all belonging processes will
be stopped and will not run until the cgroup will be explicitly
unfrozen. Freezing of the cgroup may take some time; when this action
is completed, the “frozen” value in the cgroup.events control file
will be updated to “1” and the corresponding notification will be
issued.</p>
<p>A cgroup can be frozen either by its own settings, or by settings
of any ancestor cgroups. If any of ancestor cgroups is frozen, the
cgroup will remain frozen.</p>
<p>Processes in the frozen cgroup can be killed by a fatal signal.
They also can enter and leave a frozen cgroup: either by an explicit
move by a user, or if freezing of the cgroup races with fork().
If a process is moved to a frozen cgroup, it stops. If a process is
moved out of a frozen cgroup, it becomes running.</p>
<p>Frozen status of a cgroup doesn’t affect any cgroup tree operations:
it’s possible to delete a frozen (and empty) cgroup, as well as
create new sub-cgroups.</p>
</dd>
<dt>cgroup.kill</dt><dd><p>A write-only single value file which exists in non-root cgroups.
The only allowed value is “1”.</p>
<p>Writing “1” to the file causes the cgroup and all descendant cgroups to
be killed. This means that all processes located in the affected cgroup
tree will be killed via SIGKILL.</p>
<p>Killing a cgroup tree will deal with concurrent forks appropriately and
is protected against migrations.</p>
<p>In a threaded cgroup, writing this file fails with EOPNOTSUPP as
killing cgroups is a process directed operation, i.e. it affects
the whole thread-group.</p>
</dd>
<dt>cgroup.pressure</dt><dd><p>A read-write single value file that allowed values are “0” and “1”.
The default is “1”.</p>
<p>Writing “0” to the file will disable the cgroup PSI accounting.
Writing “1” to the file will re-enable the cgroup PSI accounting.</p>
<p>This control attribute is not hierarchical, so disable or enable PSI
accounting in a cgroup does not affect PSI accounting in descendants
and doesn’t need pass enablement via ancestors from root.</p>
<p>The reason this control attribute exists is that PSI accounts stalls for
each cgroup separately and aggregates it at each level of the hierarchy.
This may cause non-negligible overhead for some workloads when under
deep level of the hierarchy, in which case this control attribute can
be used to disable PSI accounting in the non-leaf cgroups.</p>
</dd>
<dt>irq.pressure</dt><dd><p>A read-write nested-keyed file.</p>
<p>Shows pressure stall information for IRQ/SOFTIRQ. See
<a class="reference internal" href="../accounting/psi.html#psi"><span class="std std-ref">Documentation/accounting/psi.rst</span></a> for details.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="controllers">
<h2>Controllers<a class="headerlink" href="#controllers" title="Permalink to this headline">¶</a></h2>
<section id="cpu">
<span id="cgroup-v2-cpu"></span><h3>CPU<a class="headerlink" href="#cpu" title="Permalink to this headline">¶</a></h3>
<p>The “cpu” controllers regulates distribution of CPU cycles.  This
controller implements weight and absolute bandwidth limit models for
normal scheduling policy and absolute bandwidth allocation model for
realtime scheduling policy.</p>
<p>In all the above models, cycles distribution is defined only on a temporal
base and it does not account for the frequency at which tasks are executed.
The (optional) utilization clamping support allows to hint the schedutil
cpufreq governor about the minimum desired frequency which should always be
provided by a CPU, as well as the maximum desired frequency, which should not
be exceeded by a CPU.</p>
<p>WARNING: cgroup2 doesn’t yet support control of realtime processes and
the cpu controller can only be enabled when all RT processes are in
the root cgroup.  Be aware that system management software may already
have placed RT processes into nonroot cgroups during the system boot
process, and these processes may need to be moved to the root cgroup
before the cpu controller can be enabled.</p>
<section id="cpu-interface-files">
<h4>CPU Interface Files<a class="headerlink" href="#cpu-interface-files" title="Permalink to this headline">¶</a></h4>
<p>All time durations are in microseconds.</p>
<blockquote>
<div><dl>
<dt>cpu.stat</dt><dd><p>A read-only flat-keyed file.
This file exists whether the controller is enabled or not.</p>
<p>It always reports the following three stats:</p>
<ul class="simple">
<li><p>usage_usec</p></li>
<li><p>user_usec</p></li>
<li><p>system_usec</p></li>
</ul>
<p>and the following three when the controller is enabled:</p>
<ul class="simple">
<li><p>nr_periods</p></li>
<li><p>nr_throttled</p></li>
<li><p>throttled_usec</p></li>
<li><p>nr_bursts</p></li>
<li><p>burst_usec</p></li>
</ul>
</dd>
<dt>cpu.weight</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “100”.</p>
<p>The weight in the range [1, 10000].</p>
</dd>
<dt>cpu.weight.nice</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “0”.</p>
<p>The nice value is in the range [-20, 19].</p>
<p>This interface file is an alternative interface for
“cpu.weight” and allows reading and setting weight using the
same values used by nice(2).  Because the range is smaller and
granularity is coarser for the nice values, the read value is
the closest approximation of the current weight.</p>
</dd>
<dt>cpu.max</dt><dd><p>A read-write two value file which exists on non-root cgroups.
The default is “max 100000”.</p>
<p>The maximum bandwidth limit.  It’s in the following format:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$MAX $PERIOD
</pre></div>
</div>
<p>which indicates that the group may consume upto $MAX in each
$PERIOD duration.  “max” for $MAX indicates no limit.  If only
one number is written, $MAX is updated.</p>
</dd>
<dt>cpu.max.burst</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “0”.</p>
<p>The burst in the range [0, $MAX].</p>
</dd>
<dt>cpu.pressure</dt><dd><p>A read-write nested-keyed file.</p>
<p>Shows pressure stall information for CPU. See
<a class="reference internal" href="../accounting/psi.html#psi"><span class="std std-ref">Documentation/accounting/psi.rst</span></a> for details.</p>
</dd>
<dt>cpu.uclamp.min</dt><dd><p>A read-write single value file which exists on non-root cgroups.
The default is “0”, i.e. no utilization boosting.</p>
<p>The requested minimum utilization (protection) as a percentage
rational number, e.g. 12.34 for 12.34%.</p>
<p>This interface allows reading and setting minimum utilization clamp
values similar to the sched_setattr(2). This minimum utilization
value is used to clamp the task specific minimum utilization clamp.</p>
<p>The requested minimum utilization (protection) is always capped by
the current value for the maximum utilization (limit), i.e.
<cite>cpu.uclamp.max</cite>.</p>
</dd>
<dt>cpu.uclamp.max</dt><dd><p>A read-write single value file which exists on non-root cgroups.
The default is “max”. i.e. no utilization capping</p>
<p>The requested maximum utilization (limit) as a percentage rational
number, e.g. 98.76 for 98.76%.</p>
<p>This interface allows reading and setting maximum utilization clamp
values similar to the sched_setattr(2). This maximum utilization
value is used to clamp the task specific maximum utilization clamp.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="memory">
<h3>Memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h3>
<p>The “memory” controller regulates distribution of memory.  Memory is
stateful and implements both limit and protection models.  Due to the
intertwining between memory usage and reclaim pressure and the
stateful nature of memory, the distribution model is relatively
complex.</p>
<p>While not completely water-tight, all major memory usages by a given
cgroup are tracked so that the total memory consumption can be
accounted and controlled to a reasonable extent.  Currently, the
following types of memory usages are tracked.</p>
<ul class="simple">
<li><p>Userland memory - page cache and anonymous memory.</p></li>
<li><p>Kernel data structures such as dentries and inodes.</p></li>
<li><p>TCP socket buffers.</p></li>
</ul>
<p>The above list may expand in the future for better coverage.</p>
<section id="memory-interface-files">
<h4>Memory Interface Files<a class="headerlink" href="#memory-interface-files" title="Permalink to this headline">¶</a></h4>
<p>All memory amounts are in bytes.  If a value which is not aligned to
PAGE_SIZE is written, the value may be rounded up to the closest
PAGE_SIZE multiple when read back.</p>
<blockquote>
<div><dl>
<dt>memory.current</dt><dd><p>A read-only single value file which exists on non-root
cgroups.</p>
<p>The total amount of memory currently being used by the cgroup
and its descendants.</p>
</dd>
<dt>memory.min</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “0”.</p>
<p>Hard memory protection.  If the memory usage of a cgroup
is within its effective min boundary, the cgroup’s memory
won’t be reclaimed under any conditions. If there is no
unprotected reclaimable memory available, OOM killer
is invoked. Above the effective min boundary (or
effective low boundary if it is higher), pages are reclaimed
proportionally to the overage, reducing reclaim pressure for
smaller overages.</p>
<p>Effective min boundary is limited by memory.min values of
all ancestor cgroups. If there is memory.min overcommitment
(child cgroup or cgroups are requiring more protected memory
than parent will allow), then each child cgroup will get
the part of parent’s protection proportional to its
actual memory usage below memory.min.</p>
<p>Putting more memory than generally available under this
protection is discouraged and may lead to constant OOMs.</p>
<p>If a memory cgroup is not populated with processes,
its memory.min is ignored.</p>
</dd>
<dt>memory.low</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “0”.</p>
<p>Best-effort memory protection.  If the memory usage of a
cgroup is within its effective low boundary, the cgroup’s
memory won’t be reclaimed unless there is no reclaimable
memory available in unprotected cgroups.
Above the effective low boundary (or
effective min boundary if it is higher), pages are reclaimed
proportionally to the overage, reducing reclaim pressure for
smaller overages.</p>
<p>Effective low boundary is limited by memory.low values of
all ancestor cgroups. If there is memory.low overcommitment
(child cgroup or cgroups are requiring more protected memory
than parent will allow), then each child cgroup will get
the part of parent’s protection proportional to its
actual memory usage below memory.low.</p>
<p>Putting more memory than generally available under this
protection is discouraged.</p>
</dd>
<dt>memory.high</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Memory usage throttle limit.  This is the main mechanism to
control memory usage of a cgroup.  If a cgroup’s usage goes
over the high boundary, the processes of the cgroup are
throttled and put under heavy reclaim pressure.</p>
<p>Going over the high limit never invokes the OOM killer and
under extreme conditions the limit may be breached.</p>
</dd>
<dt>memory.max</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Memory usage hard limit.  This is the final protection
mechanism.  If a cgroup’s memory usage reaches this limit and
can’t be reduced, the OOM killer is invoked in the cgroup.
Under certain circumstances, the usage may go over the limit
temporarily.</p>
<p>In default configuration regular 0-order allocations always
succeed unless OOM killer chooses current task as a victim.</p>
<p>Some kinds of allocations don’t invoke the OOM killer.
Caller could retry them differently, return into userspace
as -ENOMEM or silently ignore in cases like disk readahead.</p>
<p>This is the ultimate protection mechanism.  As long as the
high limit is used and monitored properly, this limit’s
utility is limited to providing the final safety net.</p>
</dd>
<dt>memory.reclaim</dt><dd><p>A write-only nested-keyed file which exists for all cgroups.</p>
<p>This is a simple interface to trigger memory reclaim in the
target cgroup.</p>
<p>This file accepts a string which contains the number of bytes to
reclaim.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1G&quot; &gt; memory.reclaim
</pre></div>
</div>
<p>Please note that the kernel can over or under reclaim from
the target cgroup. If less bytes are reclaimed than the
specified amount, -EAGAIN is returned.</p>
<p>Please note that the proactive reclaim (triggered by this
interface) is not meant to indicate memory pressure on the
memory cgroup. Therefore socket memory balancing triggered by
the memory reclaim normally is not exercised in this case.
This means that the networking layer will not adapt based on
reclaim induced by memory.reclaim.</p>
<p>This file also allows the user to specify the nodes to reclaim from,
via the ‘nodes=’ key, for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1G nodes=0,1&quot; &gt; memory.reclaim
</pre></div>
</div>
<p>The above instructs the kernel to reclaim memory from nodes 0,1.</p>
</dd>
<dt>memory.peak</dt><dd><p>A read-only single value file which exists on non-root
cgroups.</p>
<p>The max memory usage recorded for the cgroup and its
descendants since the creation of the cgroup.</p>
</dd>
<dt>memory.oom.group</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default value is “0”.</p>
<p>Determines whether the cgroup should be treated as
an indivisible workload by the OOM killer. If set,
all tasks belonging to the cgroup or to its descendants
(if the memory cgroup is not a leaf cgroup) are killed
together or not at all. This can be used to avoid
partial kills to guarantee workload integrity.</p>
<p>Tasks with the OOM protection (oom_score_adj set to -1000)
are treated as an exception and are never killed.</p>
<p>If the OOM killer is invoked in a cgroup, it’s not going
to kill any tasks outside of this cgroup, regardless
memory.oom.group values of ancestor cgroups.</p>
</dd>
<dt>memory.events</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups.
The following entries are defined.  Unless specified
otherwise, a value change in this file generates a file
modified event.</p>
<p>Note that all fields in this file are hierarchical and the
file modified event can be generated due to an event down the
hierarchy. For the local events at the cgroup level see
memory.events.local.</p>
<blockquote>
<div><dl>
<dt>low</dt><dd><p>The number of times the cgroup is reclaimed due to
high memory pressure even though its usage is under
the low boundary.  This usually indicates that the low
boundary is over-committed.</p>
</dd>
<dt>high</dt><dd><p>The number of times processes of the cgroup are
throttled and routed to perform direct memory reclaim
because the high memory boundary was exceeded.  For a
cgroup whose memory usage is capped by the high limit
rather than global memory pressure, this event’s
occurrences are expected.</p>
</dd>
<dt>max</dt><dd><p>The number of times the cgroup’s memory usage was
about to go over the max boundary.  If direct reclaim
fails to bring it down, the cgroup goes to OOM state.</p>
</dd>
<dt>oom</dt><dd><p>The number of time the cgroup’s memory usage was
reached the limit and allocation was about to fail.</p>
<p>This event is not raised if the OOM killer is not
considered as an option, e.g. for failed high-order
allocations or if caller asked to not retry attempts.</p>
</dd>
<dt>oom_kill</dt><dd><p>The number of processes belonging to this cgroup
killed by any kind of OOM killer.</p>
</dd>
<dt>oom_group_kill</dt><dd><p>The number of times a group OOM has occurred.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>memory.events.local</dt><dd><p>Similar to memory.events but the fields in the file are local
to the cgroup i.e. not hierarchical. The file modified event
generated on this file reflects only the local events.</p>
</dd>
<dt>memory.stat</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups.</p>
<p>This breaks down the cgroup’s memory footprint into different
types of memory, type-specific details, and other information
on the state and past events of the memory management system.</p>
<p>All memory amounts are in bytes.</p>
<p>The entries are ordered to be human readable, and new entries
can show up in the middle. Don’t rely on items remaining in a
fixed position; use the keys to look up specific values!</p>
<p>If the entry has no per-node counter (or not show in the
memory.numa_stat). We use ‘npn’ (non-per-node) as the tag
to indicate that it will not show in the memory.numa_stat.</p>
<blockquote>
<div><dl>
<dt>anon</dt><dd><p>Amount of memory used in anonymous mappings such as
brk(), sbrk(), and mmap(MAP_ANONYMOUS)</p>
</dd>
<dt>file</dt><dd><p>Amount of memory used to cache filesystem data,
including tmpfs and shared memory.</p>
</dd>
<dt>kernel (npn)</dt><dd><p>Amount of total kernel memory, including
(kernel_stack, pagetables, percpu, vmalloc, slab) in
addition to other kernel memory use cases.</p>
</dd>
<dt>kernel_stack</dt><dd><p>Amount of memory allocated to kernel stacks.</p>
</dd>
<dt>pagetables</dt><dd><p>Amount of memory allocated for page tables.</p>
</dd>
<dt>sec_pagetables</dt><dd><p>Amount of memory allocated for secondary page tables,
this currently includes KVM mmu allocations on x86
and arm64.</p>
</dd>
<dt>percpu (npn)</dt><dd><p>Amount of memory used for storing per-cpu kernel
data structures.</p>
</dd>
<dt>sock (npn)</dt><dd><p>Amount of memory used in network transmission buffers</p>
</dd>
<dt>vmalloc (npn)</dt><dd><p>Amount of memory used for vmap backed memory.</p>
</dd>
<dt>shmem</dt><dd><p>Amount of cached filesystem data that is swap-backed,
such as tmpfs, shm segments, shared anonymous mmap()s</p>
</dd>
<dt>zswap</dt><dd><p>Amount of memory consumed by the zswap compression backend.</p>
</dd>
<dt>zswapped</dt><dd><p>Amount of application memory swapped out to zswap.</p>
</dd>
<dt>file_mapped</dt><dd><p>Amount of cached filesystem data mapped with mmap()</p>
</dd>
<dt>file_dirty</dt><dd><p>Amount of cached filesystem data that was modified but
not yet written back to disk</p>
</dd>
<dt>file_writeback</dt><dd><p>Amount of cached filesystem data that was modified and
is currently being written back to disk</p>
</dd>
<dt>swapcached</dt><dd><p>Amount of swap cached in memory. The swapcache is accounted
against both memory and swap usage.</p>
</dd>
<dt>anon_thp</dt><dd><p>Amount of memory used in anonymous mappings backed by
transparent hugepages</p>
</dd>
<dt>file_thp</dt><dd><p>Amount of cached filesystem data backed by transparent
hugepages</p>
</dd>
<dt>shmem_thp</dt><dd><p>Amount of shm, tmpfs, shared anonymous mmap()s backed by
transparent hugepages</p>
</dd>
<dt>inactive_anon, active_anon, inactive_file, active_file, unevictable</dt><dd><p>Amount of memory, swap-backed and filesystem-backed,
on the internal memory management lists used by the
page reclaim algorithm.</p>
<p>As these represent internal list state (eg. shmem pages are on anon
memory management lists), inactive_foo + active_foo may not be equal to
the value for the foo counter, since the foo counter is type-based, not
list-based.</p>
</dd>
<dt>slab_reclaimable</dt><dd><p>Part of “slab” that might be reclaimed, such as
dentries and inodes.</p>
</dd>
<dt>slab_unreclaimable</dt><dd><p>Part of “slab” that cannot be reclaimed on memory
pressure.</p>
</dd>
<dt>slab (npn)</dt><dd><p>Amount of memory used for storing in-kernel data
structures.</p>
</dd>
<dt>workingset_refault_anon</dt><dd><p>Number of refaults of previously evicted anonymous pages.</p>
</dd>
<dt>workingset_refault_file</dt><dd><p>Number of refaults of previously evicted file pages.</p>
</dd>
<dt>workingset_activate_anon</dt><dd><p>Number of refaulted anonymous pages that were immediately
activated.</p>
</dd>
<dt>workingset_activate_file</dt><dd><p>Number of refaulted file pages that were immediately activated.</p>
</dd>
<dt>workingset_restore_anon</dt><dd><p>Number of restored anonymous pages which have been detected as
an active workingset before they got reclaimed.</p>
</dd>
<dt>workingset_restore_file</dt><dd><p>Number of restored file pages which have been detected as an
active workingset before they got reclaimed.</p>
</dd>
<dt>workingset_nodereclaim</dt><dd><p>Number of times a shadow node has been reclaimed</p>
</dd>
<dt>pgscan (npn)</dt><dd><p>Amount of scanned pages (in an inactive LRU list)</p>
</dd>
<dt>pgsteal (npn)</dt><dd><p>Amount of reclaimed pages</p>
</dd>
<dt>pgscan_kswapd (npn)</dt><dd><p>Amount of scanned pages by kswapd (in an inactive LRU list)</p>
</dd>
<dt>pgscan_direct (npn)</dt><dd><p>Amount of scanned pages directly  (in an inactive LRU list)</p>
</dd>
<dt>pgscan_khugepaged (npn)</dt><dd><p>Amount of scanned pages by khugepaged  (in an inactive LRU list)</p>
</dd>
<dt>pgsteal_kswapd (npn)</dt><dd><p>Amount of reclaimed pages by kswapd</p>
</dd>
<dt>pgsteal_direct (npn)</dt><dd><p>Amount of reclaimed pages directly</p>
</dd>
<dt>pgsteal_khugepaged (npn)</dt><dd><p>Amount of reclaimed pages by khugepaged</p>
</dd>
<dt>pgfault (npn)</dt><dd><p>Total number of page faults incurred</p>
</dd>
<dt>pgmajfault (npn)</dt><dd><p>Number of major page faults incurred</p>
</dd>
<dt>pgrefill (npn)</dt><dd><p>Amount of scanned pages (in an active LRU list)</p>
</dd>
<dt>pgactivate (npn)</dt><dd><p>Amount of pages moved to the active LRU list</p>
</dd>
<dt>pgdeactivate (npn)</dt><dd><p>Amount of pages moved to the inactive LRU list</p>
</dd>
<dt>pglazyfree (npn)</dt><dd><p>Amount of pages postponed to be freed under memory pressure</p>
</dd>
<dt>pglazyfreed (npn)</dt><dd><p>Amount of reclaimed lazyfree pages</p>
</dd>
<dt>thp_fault_alloc (npn)</dt><dd><p>Number of transparent hugepages which were allocated to satisfy
a page fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE
is not set.</p>
</dd>
<dt>thp_collapse_alloc (npn)</dt><dd><p>Number of transparent hugepages which were allocated to allow
collapsing an existing range of pages. This counter is not
present when CONFIG_TRANSPARENT_HUGEPAGE is not set.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>memory.numa_stat</dt><dd><p>A read-only nested-keyed file which exists on non-root cgroups.</p>
<p>This breaks down the cgroup’s memory footprint into different
types of memory, type-specific details, and other information
per node on the state of the memory management system.</p>
<p>This is useful for providing visibility into the NUMA locality
information within an memcg since the pages are allowed to be
allocated from any physical node. One of the use case is evaluating
application performance by combining this information with the
application’s CPU allocation.</p>
<p>All memory amounts are in bytes.</p>
<p>The output format of memory.numa_stat is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>type N0=&lt;bytes in node 0&gt; N1=&lt;bytes in node 1&gt; ...
</pre></div>
</div>
<p>The entries are ordered to be human readable, and new entries
can show up in the middle. Don’t rely on items remaining in a
fixed position; use the keys to look up specific values!</p>
<p>The entries can refer to the memory.stat.</p>
</dd>
<dt>memory.swap.current</dt><dd><p>A read-only single value file which exists on non-root
cgroups.</p>
<p>The total amount of swap currently being used by the cgroup
and its descendants.</p>
</dd>
<dt>memory.swap.high</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Swap usage throttle limit.  If a cgroup’s swap usage exceeds
this limit, all its further allocations will be throttled to
allow userspace to implement custom out-of-memory procedures.</p>
<p>This limit marks a point of no return for the cgroup. It is NOT
designed to manage the amount of swapping a workload does
during regular operation. Compare to memory.swap.max, which
prohibits swapping past a set amount, but lets the cgroup
continue unimpeded as long as other memory can be reclaimed.</p>
<p>Healthy workloads are not expected to reach this limit.</p>
</dd>
<dt>memory.swap.max</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Swap usage hard limit.  If a cgroup’s swap usage reaches this
limit, anonymous memory of the cgroup will not be swapped out.</p>
</dd>
<dt>memory.swap.events</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups.
The following entries are defined.  Unless specified
otherwise, a value change in this file generates a file
modified event.</p>
<blockquote>
<div><dl class="simple">
<dt>high</dt><dd><p>The number of times the cgroup’s swap usage was over
the high threshold.</p>
</dd>
<dt>max</dt><dd><p>The number of times the cgroup’s swap usage was about
to go over the max boundary and swap allocation
failed.</p>
</dd>
<dt>fail</dt><dd><p>The number of times swap allocation failed either
because of running out of swap system-wide or max
limit.</p>
</dd>
</dl>
</div></blockquote>
<p>When reduced under the current usage, the existing swap
entries are reclaimed gradually and the swap usage may stay
higher than the limit for an extended period of time.  This
reduces the impact on the workload and memory management.</p>
</dd>
<dt>memory.zswap.current</dt><dd><p>A read-only single value file which exists on non-root
cgroups.</p>
<p>The total amount of memory consumed by the zswap compression
backend.</p>
</dd>
<dt>memory.zswap.max</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Zswap usage hard limit. If a cgroup’s zswap pool reaches this
limit, it will refuse to take any more stores before existing
entries fault back in or are written out to disk.</p>
</dd>
<dt>memory.pressure</dt><dd><p>A read-only nested-keyed file.</p>
<p>Shows pressure stall information for memory. See
<a class="reference internal" href="../accounting/psi.html#psi"><span class="std std-ref">Documentation/accounting/psi.rst</span></a> for details.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="usage-guidelines">
<h4>Usage Guidelines<a class="headerlink" href="#usage-guidelines" title="Permalink to this headline">¶</a></h4>
<p>“memory.high” is the main mechanism to control memory usage.
Over-committing on high limit (sum of high limits &gt; available memory)
and letting global memory pressure to distribute memory according to
usage is a viable strategy.</p>
<p>Because breach of the high limit doesn’t trigger the OOM killer but
throttles the offending cgroup, a management agent has ample
opportunities to monitor and take appropriate actions such as granting
more memory or terminating the workload.</p>
<p>Determining whether a cgroup has enough memory is not trivial as
memory usage doesn’t indicate whether the workload can benefit from
more memory.  For example, a workload which writes data received from
network to a file can use all available memory but can also operate as
performant with a small amount of memory.  A measure of memory
pressure - how much the workload is being impacted due to lack of
memory - is necessary to determine whether a workload needs more
memory; unfortunately, memory pressure monitoring mechanism isn’t
implemented yet.</p>
</section>
<section id="memory-ownership">
<h4>Memory Ownership<a class="headerlink" href="#memory-ownership" title="Permalink to this headline">¶</a></h4>
<p>A memory area is charged to the cgroup which instantiated it and stays
charged to the cgroup until the area is released.  Migrating a process
to a different cgroup doesn’t move the memory usages that it
instantiated while in the previous cgroup to the new cgroup.</p>
<p>A memory area may be used by processes belonging to different cgroups.
To which cgroup the area will be charged is in-deterministic; however,
over time, the memory area is likely to end up in a cgroup which has
enough memory allowance to avoid high reclaim pressure.</p>
<p>If a cgroup sweeps a considerable amount of memory which is expected
to be accessed repeatedly by other cgroups, it may make sense to use
POSIX_FADV_DONTNEED to relinquish the ownership of memory areas
belonging to the affected files to ensure correct memory ownership.</p>
</section>
</section>
<section id="io">
<h3>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h3>
<p>The “io” controller regulates the distribution of IO resources.  This
controller implements both weight based and absolute bandwidth or IOPS
limit distribution; however, weight based distribution is available
only if cfq-iosched is in use and neither scheme is available for
blk-mq devices.</p>
<section id="io-interface-files">
<h4>IO Interface Files<a class="headerlink" href="#io-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>io.stat</dt><dd><p>A read-only nested-keyed file.</p>
<p>Lines are keyed by $MAJ:$MIN device numbers and not ordered.
The following nested keys are defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>rbytes</p></td>
<td><p>Bytes read</p></td>
</tr>
<tr class="row-even"><td><p>wbytes</p></td>
<td><p>Bytes written</p></td>
</tr>
<tr class="row-odd"><td><p>rios</p></td>
<td><p>Number of read IOs</p></td>
</tr>
<tr class="row-even"><td><p>wios</p></td>
<td><p>Number of write IOs</p></td>
</tr>
<tr class="row-odd"><td><p>dbytes</p></td>
<td><p>Bytes discarded</p></td>
</tr>
<tr class="row-even"><td><p>dios</p></td>
<td><p>Number of discard IOs</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>An example read output follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>8:16 rbytes=1459200 wbytes=314773504 rios=192 wios=353 dbytes=0 dios=0
8:0 rbytes=90430464 wbytes=299008000 rios=8950 wios=1252 dbytes=50331648 dios=3021
</pre></div>
</div>
</dd>
<dt>io.cost.qos</dt><dd><p>A read-write nested-keyed file which exists only on the root
cgroup.</p>
<p>This file configures the Quality of Service of the IO cost
model based controller (CONFIG_BLK_CGROUP_IOCOST) which
currently implements “io.weight” proportional control.  Lines
are keyed by $MAJ:$MIN device numbers and not ordered.  The
line for a given device is populated on the first write for
the device on “io.cost.qos” or “io.cost.model”.  The following
nested keys are defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>enable</p></td>
<td><p>Weight-based control enable</p></td>
</tr>
<tr class="row-even"><td><p>ctrl</p></td>
<td><p>“auto” or “user”</p></td>
</tr>
<tr class="row-odd"><td><p>rpct</p></td>
<td><p>Read latency percentile    [0, 100]</p></td>
</tr>
<tr class="row-even"><td><p>rlat</p></td>
<td><p>Read latency threshold</p></td>
</tr>
<tr class="row-odd"><td><p>wpct</p></td>
<td><p>Write latency percentile   [0, 100]</p></td>
</tr>
<tr class="row-even"><td><p>wlat</p></td>
<td><p>Write latency threshold</p></td>
</tr>
<tr class="row-odd"><td><p>min</p></td>
<td><p>Minimum scaling percentage [1, 10000]</p></td>
</tr>
<tr class="row-even"><td><p>max</p></td>
<td><p>Maximum scaling percentage [1, 10000]</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The controller is disabled by default and can be enabled by
setting “enable” to 1.  “rpct” and “wpct” parameters default
to zero and the controller uses internal device saturation
state to adjust the overall IO rate between “min” and “max”.</p>
<p>When a better control quality is needed, latency QoS
parameters can be configured.  For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>8:16 enable=1 ctrl=auto rpct=95.00 rlat=75000 wpct=95.00 wlat=150000 min=50.00 max=150.0
</pre></div>
</div>
<p>shows that on sdb, the controller is enabled, will consider
the device saturated if the 95th percentile of read completion
latencies is above 75ms or write 150ms, and adjust the overall
IO issue rate between 50% and 150% accordingly.</p>
<p>The lower the saturation point, the better the latency QoS at
the cost of aggregate bandwidth.  The narrower the allowed
adjustment range between “min” and “max”, the more conformant
to the cost model the IO behavior.  Note that the IO issue
base rate may be far off from 100% and setting “min” and “max”
blindly can lead to a significant loss of device capacity or
control quality.  “min” and “max” are useful for regulating
devices which show wide temporary behavior changes - e.g. a
ssd which accepts writes at the line speed for a while and
then completely stalls for multiple seconds.</p>
<p>When “ctrl” is “auto”, the parameters are controlled by the
kernel and may change automatically.  Setting “ctrl” to “user”
or setting any of the percentile and latency parameters puts
it into “user” mode and disables the automatic changes.  The
automatic mode can be restored by setting “ctrl” to “auto”.</p>
</dd>
<dt>io.cost.model</dt><dd><p>A read-write nested-keyed file which exists only on the root
cgroup.</p>
<p>This file configures the cost model of the IO cost model based
controller (CONFIG_BLK_CGROUP_IOCOST) which currently
implements “io.weight” proportional control.  Lines are keyed
by $MAJ:$MIN device numbers and not ordered.  The line for a
given device is populated on the first write for the device on
“io.cost.qos” or “io.cost.model”.  The following nested keys
are defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ctrl</p></td>
<td><p>“auto” or “user”</p></td>
</tr>
<tr class="row-even"><td><p>model</p></td>
<td><p>The cost model in use - “linear”</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When “ctrl” is “auto”, the kernel may change all parameters
dynamically.  When “ctrl” is set to “user” or any other
parameters are written to, “ctrl” become “user” and the
automatic changes are disabled.</p>
<p>When “model” is “linear”, the following model parameters are
defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>[r|w]bps</p></td>
<td><p>The maximum sequential IO throughput</p></td>
</tr>
<tr class="row-even"><td><p>[r|w]seqiops</p></td>
<td><p>The maximum 4k sequential IOs per second</p></td>
</tr>
<tr class="row-odd"><td><p>[r|w]randiops</p></td>
<td><p>The maximum 4k random IOs per second</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>From the above, the builtin linear model determines the base
costs of a sequential and random IO and the cost coefficient
for the IO size.  While simple, this model can cover most
common device classes acceptably.</p>
<p>The IO cost model isn’t expected to be accurate in absolute
sense and is scaled to the device behavior dynamically.</p>
<p>If needed, tools/cgroup/iocost_coef_gen.py can be used to
generate device-specific coefficients.</p>
</dd>
<dt>io.weight</dt><dd><p>A read-write flat-keyed file which exists on non-root cgroups.
The default is “default 100”.</p>
<p>The first line is the default weight applied to devices
without specific override.  The rest are overrides keyed by
$MAJ:$MIN device numbers and not ordered.  The weights are in
the range [1, 10000] and specifies the relative amount IO time
the cgroup can use in relation to its siblings.</p>
<p>The default weight can be updated by writing either “default
$WEIGHT” or simply “$WEIGHT”.  Overrides can be set by writing
“$MAJ:$MIN $WEIGHT” and unset by writing “$MAJ:$MIN default”.</p>
<p>An example read output follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default 100
8:16 200
8:0 50
</pre></div>
</div>
</dd>
<dt>io.max</dt><dd><p>A read-write nested-keyed file which exists on non-root
cgroups.</p>
<p>BPS and IOPS based IO limit.  Lines are keyed by $MAJ:$MIN
device numbers and not ordered.  The following nested keys are
defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>rbps</p></td>
<td><p>Max read bytes per second</p></td>
</tr>
<tr class="row-even"><td><p>wbps</p></td>
<td><p>Max write bytes per second</p></td>
</tr>
<tr class="row-odd"><td><p>riops</p></td>
<td><p>Max read IO operations per second</p></td>
</tr>
<tr class="row-even"><td><p>wiops</p></td>
<td><p>Max write IO operations per second</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When writing, any number of nested key-value pairs can be
specified in any order.  “max” can be specified as the value
to remove a specific limit.  If the same key is specified
multiple times, the outcome is undefined.</p>
<p>BPS and IOPS are measured in each IO direction and IOs are
delayed if limit is reached.  Temporary bursts are allowed.</p>
<p>Setting read limit at 2M BPS and write at 120 IOPS for 8:16:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;8:16 rbps=2097152 wiops=120&quot; &gt; io.max
</pre></div>
</div>
<p>Reading returns the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>8:16 rbps=2097152 wbps=max riops=max wiops=120
</pre></div>
</div>
<p>Write IOPS limit can be removed by writing the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;8:16 wiops=max&quot; &gt; io.max
</pre></div>
</div>
<p>Reading now returns the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>8:16 rbps=2097152 wbps=max riops=max wiops=max
</pre></div>
</div>
</dd>
<dt>io.pressure</dt><dd><p>A read-only nested-keyed file.</p>
<p>Shows pressure stall information for IO. See
<a class="reference internal" href="../accounting/psi.html#psi"><span class="std std-ref">Documentation/accounting/psi.rst</span></a> for details.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="writeback">
<h4>Writeback<a class="headerlink" href="#writeback" title="Permalink to this headline">¶</a></h4>
<p>Page cache is dirtied through buffered writes and shared mmaps and
written asynchronously to the backing filesystem by the writeback
mechanism.  Writeback sits between the memory and IO domains and
regulates the proportion of dirty memory by balancing dirtying and
write IOs.</p>
<p>The io controller, in conjunction with the memory controller,
implements control of page cache writeback IOs.  The memory controller
defines the memory domain that dirty memory ratio is calculated and
maintained for and the io controller defines the io domain which
writes out dirty pages for the memory domain.  Both system-wide and
per-cgroup dirty memory states are examined and the more restrictive
of the two is enforced.</p>
<p>cgroup writeback requires explicit support from the underlying
filesystem.  Currently, cgroup writeback is implemented on ext2, ext4,
btrfs, f2fs, and xfs.  On other filesystems, all writeback IOs are
attributed to the root cgroup.</p>
<p>There are inherent differences in memory and writeback management
which affects how cgroup ownership is tracked.  Memory is tracked per
page while writeback per inode.  For the purpose of writeback, an
inode is assigned to a cgroup and all IO requests to write dirty pages
from the inode are attributed to that cgroup.</p>
<p>As cgroup ownership for memory is tracked per page, there can be pages
which are associated with different cgroups than the one the inode is
associated with.  These are called foreign pages.  The writeback
constantly keeps track of foreign pages and, if a particular foreign
cgroup becomes the majority over a certain period of time, switches
the ownership of the inode to that cgroup.</p>
<p>While this model is enough for most use cases where a given inode is
mostly dirtied by a single cgroup even when the main writing cgroup
changes over time, use cases where multiple cgroups write to a single
inode simultaneously are not supported well.  In such circumstances, a
significant portion of IOs are likely to be attributed incorrectly.
As memory controller assigns page ownership on the first use and
doesn’t update it until the page is released, even if writeback
strictly follows page ownership, multiple cgroups dirtying overlapping
areas wouldn’t work as expected.  It’s recommended to avoid such usage
patterns.</p>
<p>The sysctl knobs which affect writeback behavior are applied to cgroup
writeback as follows.</p>
<blockquote>
<div><dl class="simple">
<dt>vm.dirty_background_ratio, vm.dirty_ratio</dt><dd><p>These ratios apply the same to cgroup writeback with the
amount of available memory capped by limits imposed by the
memory controller and system-wide clean memory.</p>
</dd>
<dt>vm.dirty_background_bytes, vm.dirty_bytes</dt><dd><p>For cgroup writeback, this is calculated into ratio against
total available memory and applied the same way as
vm.dirty[_background]_ratio.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="io-latency">
<h4>IO Latency<a class="headerlink" href="#io-latency" title="Permalink to this headline">¶</a></h4>
<p>This is a cgroup v2 controller for IO workload protection.  You provide a group
with a latency target, and if the average latency exceeds that target the
controller will throttle any peers that have a lower latency target than the
protected workload.</p>
<p>The limits are only applied at the peer level in the hierarchy.  This means that
in the diagram below, only groups A, B, and C will influence each other, and
groups D and F will influence each other.  Group G will influence nobody:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          [root]
  /          |            \
  A          B            C
 /  \        |
D    F       G
</pre></div>
</div>
<p>So the ideal way to configure this is to set io.latency in groups A, B, and C.
Generally you do not want to set a value lower than the latency your device
supports.  Experiment to find the value that works best for your workload.
Start at higher than the expected latency for your device and watch the
avg_lat value in io.stat for your workload group to get an idea of the
latency you see during normal operation.  Use the avg_lat value as a basis for
your real setting, setting at 10-15% higher than the value in io.stat.</p>
</section>
<section id="how-io-latency-throttling-works">
<h4>How IO Latency Throttling Works<a class="headerlink" href="#how-io-latency-throttling-works" title="Permalink to this headline">¶</a></h4>
<p>io.latency is work conserving; so as long as everybody is meeting their latency
target the controller doesn’t do anything.  Once a group starts missing its
target it begins throttling any peer group that has a higher target than itself.
This throttling takes 2 forms:</p>
<ul class="simple">
<li><p>Queue depth throttling.  This is the number of outstanding IO’s a group is
allowed to have.  We will clamp down relatively quickly, starting at no limit
and going all the way down to 1 IO at a time.</p></li>
<li><p>Artificial delay induction.  There are certain types of IO that cannot be
throttled without possibly adversely affecting higher priority groups.  This
includes swapping and metadata IO.  These types of IO are allowed to occur
normally, however they are “charged” to the originating group.  If the
originating group is being throttled you will see the use_delay and delay
fields in io.stat increase.  The delay value is how many microseconds that are
being added to any process that runs in this group.  Because this number can
grow quite large if there is a lot of swapping or metadata IO occurring we
limit the individual delay events to 1 second at a time.</p></li>
</ul>
<p>Once the victimized group starts meeting its latency target again it will start
unthrottling any peer groups that were throttled previously.  If the victimized
group simply stops doing IO the global counter will unthrottle appropriately.</p>
</section>
<section id="io-latency-interface-files">
<h4>IO Latency Interface Files<a class="headerlink" href="#io-latency-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>io.latency</dt><dd><p>This takes a similar format as the other controllers.</p>
<blockquote>
<div><p>“MAJOR:MINOR target=&lt;target time in microseconds&gt;”</p>
</div></blockquote>
</dd>
<dt>io.stat</dt><dd><p>If the controller is enabled you will see extra stats in io.stat in
addition to the normal ones.</p>
<blockquote>
<div><dl class="simple">
<dt>depth</dt><dd><p>This is the current queue depth for the group.</p>
</dd>
<dt>avg_lat</dt><dd><p>This is an exponential moving average with a decay rate of 1/exp
bound by the sampling interval.  The decay rate interval can be
calculated by multiplying the win value in io.stat by the
corresponding number of samples based on the win value.</p>
</dd>
<dt>win</dt><dd><p>The sampling window size in milliseconds.  This is the minimum
duration of time between evaluation events.  Windows only elapse
with IO activity.  Idle periods extend the most recent window.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="io-priority">
<h4>IO Priority<a class="headerlink" href="#io-priority" title="Permalink to this headline">¶</a></h4>
<p>A single attribute controls the behavior of the I/O priority cgroup policy,
namely the blkio.prio.class attribute. The following values are accepted for
that attribute:</p>
<blockquote>
<div><dl class="simple">
<dt>no-change</dt><dd><p>Do not modify the I/O priority class.</p>
</dd>
<dt>none-to-rt</dt><dd><p>For requests that do not have an I/O priority class (NONE),
change the I/O priority class into RT. Do not modify
the I/O priority class of other requests.</p>
</dd>
<dt>restrict-to-be</dt><dd><p>For requests that do not have an I/O priority class or that have I/O
priority class RT, change it into BE. Do not modify the I/O priority
class of requests that have priority class IDLE.</p>
</dd>
<dt>idle</dt><dd><p>Change the I/O priority class of all requests into IDLE, the lowest
I/O priority class.</p>
</dd>
</dl>
</div></blockquote>
<p>The following numerical values are associated with the I/O priority policies:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 81%" />
<col style="width: 19%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>no-change</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>none-to-rt</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>rt-to-be</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>all-to-idle</p></td>
<td><p>3</p></td>
</tr>
</tbody>
</table>
<p>The numerical value that corresponds to each I/O priority class is as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 91%" />
<col style="width: 9%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>IOPRIO_CLASS_NONE</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>IOPRIO_CLASS_RT (real-time)</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>IOPRIO_CLASS_BE (best effort)</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>IOPRIO_CLASS_IDLE</p></td>
<td><p>3</p></td>
</tr>
</tbody>
</table>
<p>The algorithm to set the I/O priority class for a request is as follows:</p>
<ul class="simple">
<li><p>Translate the I/O priority class policy into a number.</p></li>
<li><p>Change the request I/O priority class into the maximum of the I/O priority
class policy number and the numerical I/O priority class.</p></li>
</ul>
</section>
</section>
<section id="pid">
<h3>PID<a class="headerlink" href="#pid" title="Permalink to this headline">¶</a></h3>
<p>The process number controller is used to allow a cgroup to stop any
new tasks from being fork()’d or clone()’d after a specified limit is
reached.</p>
<p>The number of tasks in a cgroup can be exhausted in ways which other
controllers cannot prevent, thus warranting its own controller.  For
example, a fork bomb is likely to exhaust the number of tasks before
hitting memory restrictions.</p>
<p>Note that PIDs used in this controller refer to TIDs, process IDs as
used by the kernel.</p>
<section id="pid-interface-files">
<h4>PID Interface Files<a class="headerlink" href="#pid-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>pids.max</dt><dd><p>A read-write single value file which exists on non-root
cgroups.  The default is “max”.</p>
<p>Hard limit of number of processes.</p>
</dd>
<dt>pids.current</dt><dd><p>A read-only single value file which exists on all cgroups.</p>
<p>The number of processes currently in the cgroup and its
descendants.</p>
</dd>
</dl>
</div></blockquote>
<p>Organisational operations are not blocked by cgroup policies, so it is
possible to have pids.current &gt; pids.max.  This can be done by either
setting the limit to be smaller than pids.current, or attaching enough
processes to the cgroup such that pids.current is larger than
pids.max.  However, it is not possible to violate a cgroup PID policy
through fork() or clone(). These will return -EAGAIN if the creation
of a new process would cause a cgroup policy to be violated.</p>
</section>
</section>
<section id="cpuset">
<h3>Cpuset<a class="headerlink" href="#cpuset" title="Permalink to this headline">¶</a></h3>
<p>The “cpuset” controller provides a mechanism for constraining
the CPU and memory node placement of tasks to only the resources
specified in the cpuset interface files in a task’s current cgroup.
This is especially valuable on large NUMA systems where placing jobs
on properly sized subsets of the systems with careful processor and
memory placement to reduce cross-node memory access and contention
can improve overall system performance.</p>
<p>The “cpuset” controller is hierarchical.  That means the controller
cannot use CPUs or memory nodes not allowed in its parent.</p>
<section id="cpuset-interface-files">
<h4>Cpuset Interface Files<a class="headerlink" href="#cpuset-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>cpuset.cpus</dt><dd><p>A read-write multiple values file which exists on non-root
cpuset-enabled cgroups.</p>
<p>It lists the requested CPUs to be used by tasks within this
cgroup.  The actual list of CPUs to be granted, however, is
subjected to constraints imposed by its parent and can differ
from the requested CPUs.</p>
<p>The CPU numbers are comma-separated numbers or ranges.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat cpuset.cpus
0-4,6,8-10
</pre></div>
</div>
<p>An empty value indicates that the cgroup is using the same
setting as the nearest cgroup ancestor with a non-empty
“cpuset.cpus” or all the available CPUs if none is found.</p>
<p>The value of “cpuset.cpus” stays constant until the next update
and won’t be affected by any CPU hotplug events.</p>
</dd>
<dt>cpuset.cpus.effective</dt><dd><p>A read-only multiple values file which exists on all
cpuset-enabled cgroups.</p>
<p>It lists the onlined CPUs that are actually granted to this
cgroup by its parent.  These CPUs are allowed to be used by
tasks within the current cgroup.</p>
<p>If “cpuset.cpus” is empty, the “cpuset.cpus.effective” file shows
all the CPUs from the parent cgroup that can be available to
be used by this cgroup.  Otherwise, it should be a subset of
“cpuset.cpus” unless none of the CPUs listed in “cpuset.cpus”
can be granted.  In this case, it will be treated just like an
empty “cpuset.cpus”.</p>
<p>Its value will be affected by CPU hotplug events.</p>
</dd>
<dt>cpuset.mems</dt><dd><p>A read-write multiple values file which exists on non-root
cpuset-enabled cgroups.</p>
<p>It lists the requested memory nodes to be used by tasks within
this cgroup.  The actual list of memory nodes granted, however,
is subjected to constraints imposed by its parent and can differ
from the requested memory nodes.</p>
<p>The memory node numbers are comma-separated numbers or ranges.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat cpuset.mems
0-1,3
</pre></div>
</div>
<p>An empty value indicates that the cgroup is using the same
setting as the nearest cgroup ancestor with a non-empty
“cpuset.mems” or all the available memory nodes if none
is found.</p>
<p>The value of “cpuset.mems” stays constant until the next update
and won’t be affected by any memory nodes hotplug events.</p>
<p>Setting a non-empty value to “cpuset.mems” causes memory of
tasks within the cgroup to be migrated to the designated nodes if
they are currently using memory outside of the designated nodes.</p>
<p>There is a cost for this memory migration.  The migration
may not be complete and some memory pages may be left behind.
So it is recommended that “cpuset.mems” should be set properly
before spawning new tasks into the cpuset.  Even if there is
a need to change “cpuset.mems” with active tasks, it shouldn’t
be done frequently.</p>
</dd>
<dt>cpuset.mems.effective</dt><dd><p>A read-only multiple values file which exists on all
cpuset-enabled cgroups.</p>
<p>It lists the onlined memory nodes that are actually granted to
this cgroup by its parent. These memory nodes are allowed to
be used by tasks within the current cgroup.</p>
<p>If “cpuset.mems” is empty, it shows all the memory nodes from the
parent cgroup that will be available to be used by this cgroup.
Otherwise, it should be a subset of “cpuset.mems” unless none of
the memory nodes listed in “cpuset.mems” can be granted.  In this
case, it will be treated just like an empty “cpuset.mems”.</p>
<p>Its value will be affected by memory nodes hotplug events.</p>
</dd>
<dt>cpuset.cpus.partition</dt><dd><p>A read-write single value file which exists on non-root
cpuset-enabled cgroups.  This flag is owned by the parent cgroup
and is not delegatable.</p>
<p>It accepts only the following input values when written to.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>“member”</p></td>
<td><p>Non-root member of a partition</p></td>
</tr>
<tr class="row-even"><td><p>“root”</p></td>
<td><p>Partition root</p></td>
</tr>
<tr class="row-odd"><td><p>“isolated”</p></td>
<td><p>Partition root without load balancing</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The root cgroup is always a partition root and its state
cannot be changed.  All other non-root cgroups start out as
“member”.</p>
<p>When set to “root”, the current cgroup is the root of a new
partition or scheduling domain that comprises itself and all
its descendants except those that are separate partition roots
themselves and their descendants.</p>
<p>When set to “isolated”, the CPUs in that partition root will
be in an isolated state without any load balancing from the
scheduler.  Tasks placed in such a partition with multiple
CPUs should be carefully distributed and bound to each of the
individual CPUs for optimal performance.</p>
<p>The value shown in “cpuset.cpus.effective” of a partition root
is the CPUs that the partition root can dedicate to a potential
new child partition root. The new child subtracts available
CPUs from its parent “cpuset.cpus.effective”.</p>
<p>A partition root (“root” or “isolated”) can be in one of the
two possible states - valid or invalid.  An invalid partition
root is in a degraded state where some state information may
be retained, but behaves more like a “member”.</p>
<p>All possible state transitions among “member”, “root” and
“isolated” are allowed.</p>
<p>On read, the “cpuset.cpus.partition” file can show the following
values.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>“member”</p></td>
<td><p>Non-root member of a partition</p></td>
</tr>
<tr class="row-even"><td><p>“root”</p></td>
<td><p>Partition root</p></td>
</tr>
<tr class="row-odd"><td><p>“isolated”</p></td>
<td><p>Partition root without load balancing</p></td>
</tr>
<tr class="row-even"><td><p>“root invalid (&lt;reason&gt;)”</p></td>
<td><p>Invalid partition root</p></td>
</tr>
<tr class="row-odd"><td><p>“isolated invalid (&lt;reason&gt;)”</p></td>
<td><p>Invalid isolated partition root</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In the case of an invalid partition root, a descriptive string on
why the partition is invalid is included within parentheses.</p>
<p>For a partition root to become valid, the following conditions
must be met.</p>
<ol class="arabic simple">
<li><p>The “cpuset.cpus” is exclusive with its siblings , i.e. they
are not shared by any of its siblings (exclusivity rule).</p></li>
<li><p>The parent cgroup is a valid partition root.</p></li>
<li><p>The “cpuset.cpus” is not empty and must contain at least
one of the CPUs from parent’s “cpuset.cpus”, i.e. they overlap.</p></li>
<li><p>The “cpuset.cpus.effective” cannot be empty unless there is
no task associated with this partition.</p></li>
</ol>
<p>External events like hotplug or changes to “cpuset.cpus” can
cause a valid partition root to become invalid and vice versa.
Note that a task cannot be moved to a cgroup with empty
“cpuset.cpus.effective”.</p>
<p>For a valid partition root with the sibling cpu exclusivity
rule enabled, changes made to “cpuset.cpus” that violate the
exclusivity rule will invalidate the partition as well as its
sibiling partitions with conflicting cpuset.cpus values. So
care must be taking in changing “cpuset.cpus”.</p>
<p>A valid non-root parent partition may distribute out all its CPUs
to its child partitions when there is no task associated with it.</p>
<p>Care must be taken to change a valid partition root to
“member” as all its child partitions, if present, will become
invalid causing disruption to tasks running in those child
partitions. These inactivated partitions could be recovered if
their parent is switched back to a partition root with a proper
set of “cpuset.cpus”.</p>
<p>Poll and inotify events are triggered whenever the state of
“cpuset.cpus.partition” changes.  That includes changes caused
by write to “cpuset.cpus.partition”, cpu hotplug or other
changes that modify the validity status of the partition.
This will allow user space agents to monitor unexpected changes
to “cpuset.cpus.partition” without the need to do continuous
polling.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="device-controller">
<h3>Device controller<a class="headerlink" href="#device-controller" title="Permalink to this headline">¶</a></h3>
<p>Device controller manages access to device files. It includes both
creation of new device files (using mknod), and access to the
existing device files.</p>
<p>Cgroup v2 device controller has no interface files and is implemented
on top of cgroup BPF. To control access to device files, a user may
create bpf programs of type BPF_PROG_TYPE_CGROUP_DEVICE and attach
them to cgroups with BPF_CGROUP_DEVICE flag. On an attempt to access a
device file, corresponding BPF programs will be executed, and depending
on the return value the attempt will succeed or fail with -EPERM.</p>
<p>A BPF_PROG_TYPE_CGROUP_DEVICE program takes a pointer to the
bpf_cgroup_dev_ctx structure, which describes the device access attempt:
access type (mknod/read/write) and device (type, major and minor numbers).
If the program returns 0, the attempt fails with -EPERM, otherwise it
succeeds.</p>
<p>An example of BPF_PROG_TYPE_CGROUP_DEVICE program may be found in
tools/testing/selftests/bpf/progs/dev_cgroup.c in the kernel source tree.</p>
</section>
<section id="rdma">
<h3>RDMA<a class="headerlink" href="#rdma" title="Permalink to this headline">¶</a></h3>
<p>The “rdma” controller regulates the distribution and accounting of
RDMA resources.</p>
<section id="rdma-interface-files">
<h4>RDMA Interface Files<a class="headerlink" href="#rdma-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>rdma.max</dt><dd><p>A readwrite nested-keyed file that exists for all the cgroups
except root that describes current configured resource limit
for a RDMA/IB device.</p>
<p>Lines are keyed by device name and are not ordered.
Each line contains space separated resource name and its configured
limit that can be distributed.</p>
<p>The following nested keys are defined.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>hca_handle</p></td>
<td><p>Maximum number of HCA Handles</p></td>
</tr>
<tr class="row-even"><td><p>hca_object</p></td>
<td><p>Maximum number of HCA Objects</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>An example for mlx4 and ocrdma device follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mlx4_0 hca_handle=2 hca_object=2000
ocrdma1 hca_handle=3 hca_object=max
</pre></div>
</div>
</dd>
<dt>rdma.current</dt><dd><p>A read-only file that describes current resource usage.
It exists for all the cgroup except root.</p>
<p>An example for mlx4 and ocrdma device follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mlx4_0 hca_handle=1 hca_object=20
ocrdma1 hca_handle=1 hca_object=23
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="hugetlb">
<h3>HugeTLB<a class="headerlink" href="#hugetlb" title="Permalink to this headline">¶</a></h3>
<p>The HugeTLB controller allows to limit the HugeTLB usage per control group and
enforces the controller limit during page fault.</p>
<section id="hugetlb-interface-files">
<h4>HugeTLB Interface Files<a class="headerlink" href="#hugetlb-interface-files" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>hugetlb.&lt;hugepagesize&gt;.current</dt><dd><p>Show current usage for “hugepagesize” hugetlb.  It exists for all
the cgroup except root.</p>
</dd>
<dt>hugetlb.&lt;hugepagesize&gt;.max</dt><dd><p>Set/show the hard limit of “hugepagesize” hugetlb usage.
The default value is “max”.  It exists for all the cgroup except root.</p>
</dd>
<dt>hugetlb.&lt;hugepagesize&gt;.events</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups.</p>
<blockquote>
<div><dl class="simple">
<dt>max</dt><dd><p>The number of allocation failure due to HugeTLB limit</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>hugetlb.&lt;hugepagesize&gt;.events.local</dt><dd><p>Similar to hugetlb.&lt;hugepagesize&gt;.events but the fields in the file
are local to the cgroup i.e. not hierarchical. The file modified event
generated on this file reflects only the local events.</p>
</dd>
<dt>hugetlb.&lt;hugepagesize&gt;.numa_stat</dt><dd><p>Similar to memory.numa_stat, it shows the numa information of the
hugetlb pages of &lt;hugepagesize&gt; in this cgroup.  Only active in
use hugetlb pages are included.  The per-node values are in bytes.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="misc">
<h3>Misc<a class="headerlink" href="#misc" title="Permalink to this headline">¶</a></h3>
<p>The Miscellaneous cgroup provides the resource limiting and tracking
mechanism for the scalar resources which cannot be abstracted like the other
cgroup resources. Controller is enabled by the CONFIG_CGROUP_MISC config
option.</p>
<p>A resource can be added to the controller via enum misc_res_type{} in the
include/linux/misc_cgroup.h file and the corresponding name via misc_res_name[]
in the kernel/cgroup/misc.c file. Provider of the resource must set its
capacity prior to using the resource by calling misc_cg_set_capacity().</p>
<p>Once a capacity is set then the resource usage can be updated using charge and
uncharge APIs. All of the APIs to interact with misc controller are in
include/linux/misc_cgroup.h.</p>
<section id="misc-interface-files">
<h4>Misc Interface Files<a class="headerlink" href="#misc-interface-files" title="Permalink to this headline">¶</a></h4>
<p>Miscellaneous controller provides 3 interface files. If two misc resources (res_a and res_b) are registered then:</p>
<blockquote>
<div><dl>
<dt>misc.capacity</dt><dd><p>A read-only flat-keyed file shown only in the root cgroup.  It shows
miscellaneous scalar resources available on the platform along with
their quantities:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat misc.capacity
res_a 50
res_b 10
</pre></div>
</div>
</dd>
<dt>misc.current</dt><dd><p>A read-only flat-keyed file shown in the non-root cgroups.  It shows
the current usage of the resources in the cgroup and its children.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat misc.current
res_a 3
res_b 0
</pre></div>
</div>
</dd>
<dt>misc.max</dt><dd><p>A read-write flat-keyed file shown in the non root cgroups. Allowed
maximum usage of the resources in the cgroup and its children.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat misc.max
res_a max
res_b 4
</pre></div>
</div>
<p>Limit can be set by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo res_a 1 &gt; misc.max
</pre></div>
</div>
<p>Limit can be set to max by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo res_a max &gt; misc.max
</pre></div>
</div>
<p>Limits can be set higher than the capacity value in the misc.capacity
file.</p>
</dd>
<dt>misc.events</dt><dd><p>A read-only flat-keyed file which exists on non-root cgroups. The
following entries are defined. Unless specified otherwise, a value
change in this file generates a file modified event. All fields in
this file are hierarchical.</p>
<blockquote>
<div><dl class="simple">
<dt>max</dt><dd><p>The number of times the cgroup’s resource usage was
about to go over the max boundary.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="migration-and-ownership">
<h4>Migration and Ownership<a class="headerlink" href="#migration-and-ownership" title="Permalink to this headline">¶</a></h4>
<p>A miscellaneous scalar resource is charged to the cgroup in which it is used
first, and stays charged to that cgroup until that resource is freed. Migrating
a process to a different cgroup does not move the charge to the destination
cgroup where the process has moved.</p>
</section>
</section>
<section id="others">
<h3>Others<a class="headerlink" href="#others" title="Permalink to this headline">¶</a></h3>
<section id="perf-event">
<h4>perf_event<a class="headerlink" href="#perf-event" title="Permalink to this headline">¶</a></h4>
<p>perf_event controller, if not mounted on a legacy hierarchy, is
automatically enabled on the v2 hierarchy so that perf events can
always be filtered by cgroup v2 path.  The controller can still be
moved to a legacy hierarchy after v2 hierarchy is populated.</p>
</section>
</section>
<section id="non-normative-information">
<h3>Non-normative information<a class="headerlink" href="#non-normative-information" title="Permalink to this headline">¶</a></h3>
<p>This section contains information that isn’t considered to be a part of
the stable kernel API and so is subject to change.</p>
<section id="cpu-controller-root-cgroup-process-behaviour">
<h4>CPU controller root cgroup process behaviour<a class="headerlink" href="#cpu-controller-root-cgroup-process-behaviour" title="Permalink to this headline">¶</a></h4>
<p>When distributing CPU cycles in the root cgroup each thread in this
cgroup is treated as if it was hosted in a separate child cgroup of the
root cgroup. This child cgroup weight is dependent on its thread nice
level.</p>
<p>For details of this mapping see sched_prio_to_weight array in
kernel/sched/core.c file (values from this array should be scaled
appropriately so the neutral - nice 0 - value is 100 instead of 1024).</p>
</section>
<section id="io-controller-root-cgroup-process-behaviour">
<h4>IO controller root cgroup process behaviour<a class="headerlink" href="#io-controller-root-cgroup-process-behaviour" title="Permalink to this headline">¶</a></h4>
<p>Root cgroup processes are hosted in an implicit leaf child node.
When distributing IO resources this implicit child node is taken into
account as if it was a normal child cgroup of the root cgroup with a
weight value of 200.</p>
</section>
</section>
</section>
<section id="namespace">
<h2>Namespace<a class="headerlink" href="#namespace" title="Permalink to this headline">¶</a></h2>
<section id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h3>
<p>cgroup namespace provides a mechanism to virtualize the view of the
“/proc/$PID/cgroup” file and cgroup mounts.  The CLONE_NEWCGROUP clone
flag can be used with clone(2) and unshare(2) to create a new cgroup
namespace.  The process running inside the cgroup namespace will have
its “/proc/$PID/cgroup” output restricted to cgroupns root.  The
cgroupns root is the cgroup of the process at the time of creation of
the cgroup namespace.</p>
<p>Without cgroup namespace, the “/proc/$PID/cgroup” file shows the
complete path of the cgroup of a process.  In a container setup where
a set of cgroups and namespaces are intended to isolate processes the
“/proc/$PID/cgroup” file may leak potential system level information
to the isolated processes.  For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/self/cgroup
0::/batchjobs/container_id1
</pre></div>
</div>
<p>The path ‘/batchjobs/container_id1’ can be considered as system-data
and undesirable to expose to the isolated processes.  cgroup namespace
can be used to restrict visibility of this path.  For example, before
creating a cgroup namespace, one would see:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls -l /proc/self/ns/cgroup
lrwxrwxrwx 1 root root 0 2014-07-15 10:37 /proc/self/ns/cgroup -&gt; cgroup:[4026531835]
# cat /proc/self/cgroup
0::/batchjobs/container_id1
</pre></div>
</div>
<p>After unsharing a new namespace, the view changes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls -l /proc/self/ns/cgroup
lrwxrwxrwx 1 root root 0 2014-07-15 10:35 /proc/self/ns/cgroup -&gt; cgroup:[4026532183]
# cat /proc/self/cgroup
0::/
</pre></div>
</div>
<p>When some thread from a multi-threaded process unshares its cgroup
namespace, the new cgroupns gets applied to the entire process (all
the threads).  This is natural for the v2 hierarchy; however, for the
legacy hierarchies, this may be unexpected.</p>
<p>A cgroup namespace is alive as long as there are processes inside or
mounts pinning it.  When the last usage goes away, the cgroup
namespace is destroyed.  The cgroupns root and the actual cgroups
remain.</p>
</section>
<section id="the-root-and-views">
<h3>The Root and Views<a class="headerlink" href="#the-root-and-views" title="Permalink to this headline">¶</a></h3>
<p>The ‘cgroupns root’ for a cgroup namespace is the cgroup in which the
process calling unshare(2) is running.  For example, if a process in
/batchjobs/container_id1 cgroup calls unshare, cgroup
/batchjobs/container_id1 becomes the cgroupns root.  For the
init_cgroup_ns, this is the real root (‘/’) cgroup.</p>
<p>The cgroupns root cgroup does not change even if the namespace creator
process later moves to a different cgroup:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ~/unshare -c # unshare cgroupns in some cgroup
# cat /proc/self/cgroup
0::/
# mkdir sub_cgrp_1
# echo 0 &gt; sub_cgrp_1/cgroup.procs
# cat /proc/self/cgroup
0::/sub_cgrp_1
</pre></div>
</div>
<p>Each process gets its namespace-specific view of “/proc/$PID/cgroup”</p>
<p>Processes running inside the cgroup namespace will be able to see
cgroup paths (in /proc/self/cgroup) only inside their root cgroup.
From within an unshared cgroupns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sleep 100000 &amp;
[1] 7353
# echo 7353 &gt; sub_cgrp_1/cgroup.procs
# cat /proc/7353/cgroup
0::/sub_cgrp_1
</pre></div>
</div>
<p>From the initial cgroup namespace, the real cgroup path will be
visible:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /proc/7353/cgroup
0::/batchjobs/container_id1/sub_cgrp_1
</pre></div>
</div>
<p>From a sibling cgroup namespace (that is, a namespace rooted at a
different cgroup), the cgroup path relative to its own cgroup
namespace root will be shown.  For instance, if PID 7353’s cgroup
namespace root is at ‘/batchjobs/container_id2’, then it will see:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/7353/cgroup
0::/../container_id2/sub_cgrp_1
</pre></div>
</div>
<p>Note that the relative path always starts with ‘/’ to indicate that
its relative to the cgroup namespace root of the caller.</p>
</section>
<section id="migration-and-setns-2">
<h3>Migration and setns(2)<a class="headerlink" href="#migration-and-setns-2" title="Permalink to this headline">¶</a></h3>
<p>Processes inside a cgroup namespace can move into and out of the
namespace root if they have proper access to external cgroups.  For
example, from inside a namespace with cgroupns root at
/batchjobs/container_id1, and assuming that the global hierarchy is
still accessible inside cgroupns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/7353/cgroup
0::/sub_cgrp_1
# echo 7353 &gt; batchjobs/container_id2/cgroup.procs
# cat /proc/7353/cgroup
0::/../container_id2
</pre></div>
</div>
<p>Note that this kind of setup is not encouraged.  A task inside cgroup
namespace should only be exposed to its own cgroupns hierarchy.</p>
<p>setns(2) to another cgroup namespace is allowed when:</p>
<ol class="loweralpha simple">
<li><p>the process has CAP_SYS_ADMIN against its current user namespace</p></li>
<li><p>the process has CAP_SYS_ADMIN against the target cgroup
namespace’s userns</p></li>
</ol>
<p>No implicit cgroup changes happen with attaching to another cgroup
namespace.  It is expected that the someone moves the attaching
process under the target cgroup namespace root.</p>
</section>
<section id="interaction-with-other-namespaces">
<h3>Interaction with Other Namespaces<a class="headerlink" href="#interaction-with-other-namespaces" title="Permalink to this headline">¶</a></h3>
<p>Namespace specific cgroup hierarchy can be mounted by a process
running inside a non-init cgroup namespace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t cgroup2 none $MOUNT_POINT
</pre></div>
</div>
<p>This will mount the unified cgroup hierarchy with cgroupns root as the
filesystem root.  The process needs CAP_SYS_ADMIN against its user and
mount namespaces.</p>
<p>The virtualization of /proc/self/cgroup file combined with restricting
the view of cgroup hierarchy by namespace-private cgroupfs mount
provides a properly isolated cgroup view inside the container.</p>
</section>
</section>
<section id="information-on-kernel-programming">
<h2>Information on Kernel Programming<a class="headerlink" href="#information-on-kernel-programming" title="Permalink to this headline">¶</a></h2>
<p>This section contains kernel programming information in the areas
where interacting with cgroup is necessary.  cgroup core and
controllers are not covered.</p>
<section id="filesystem-support-for-writeback">
<h3>Filesystem Support for Writeback<a class="headerlink" href="#filesystem-support-for-writeback" title="Permalink to this headline">¶</a></h3>
<p>A filesystem can support cgroup writeback by updating
address_space_operations-&gt;writepage[s]() to annotate bio’s using the
following two functions.</p>
<blockquote>
<div><dl class="simple">
<dt>wbc_init_bio(&#64;wbc, &#64;bio)</dt><dd><p>Should be called for each bio carrying writeback data and
associates the bio with the inode’s owner cgroup and the
corresponding request queue.  This must be called after
a queue (device) has been associated with the bio and
before submission.</p>
</dd>
<dt>wbc_account_cgroup_owner(&#64;wbc, &#64;page, &#64;bytes)</dt><dd><p>Should be called for each data segment being written out.
While this function doesn’t care exactly when it’s called
during the writeback session, it’s the easiest and most
natural to call it as data segments are added to a bio.</p>
</dd>
</dl>
</div></blockquote>
<p>With writeback bio’s annotated, cgroup support can be enabled per
super_block by setting SB_I_CGROUPWB in -&gt;s_iflags.  This allows for
selective disabling of cgroup writeback support which is helpful when
certain filesystem features, e.g. journaled data mode, are
incompatible.</p>
<p>wbc_init_bio() binds the specified bio to its cgroup.  Depending on
the configuration, the bio may be executed at a lower priority and if
the writeback session is holding shared resources, e.g. a journal
entry, may lead to priority inversion.  There is no one easy solution
for the problem.  Filesystems can try to work around specific problem
cases by skipping wbc_init_bio() and using bio_associate_blkg()
directly.</p>
</section>
</section>
<section id="deprecated-v1-core-features">
<h2>Deprecated v1 Core Features<a class="headerlink" href="#deprecated-v1-core-features" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Multiple hierarchies including named ones are not supported.</p></li>
<li><p>All v1 mount options are not supported.</p></li>
<li><p>The “tasks” file is removed and “cgroup.procs” is not sorted.</p></li>
<li><p>“cgroup.clone_children” is removed.</p></li>
<li><p>/proc/cgroups is meaningless for v2.  Use “cgroup.controllers” file
at the root instead.</p></li>
</ul>
</section>
<section id="issues-with-v1-and-rationales-for-v2">
<h2>Issues with v1 and Rationales for v2<a class="headerlink" href="#issues-with-v1-and-rationales-for-v2" title="Permalink to this headline">¶</a></h2>
<section id="multiple-hierarchies">
<h3>Multiple Hierarchies<a class="headerlink" href="#multiple-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>cgroup v1 allowed an arbitrary number of hierarchies and each
hierarchy could host any number of controllers.  While this seemed to
provide a high level of flexibility, it wasn’t useful in practice.</p>
<p>For example, as there is only one instance of each controller, utility
type controllers such as freezer which can be useful in all
hierarchies could only be used in one.  The issue is exacerbated by
the fact that controllers couldn’t be moved to another hierarchy once
hierarchies were populated.  Another issue was that all controllers
bound to a hierarchy were forced to have exactly the same view of the
hierarchy.  It wasn’t possible to vary the granularity depending on
the specific controller.</p>
<p>In practice, these issues heavily limited which controllers could be
put on the same hierarchy and most configurations resorted to putting
each controller on its own hierarchy.  Only closely related ones, such
as the cpu and cpuacct controllers, made sense to be put on the same
hierarchy.  This often meant that userland ended up managing multiple
similar hierarchies repeating the same steps on each hierarchy
whenever a hierarchy management operation was necessary.</p>
<p>Furthermore, support for multiple hierarchies came at a steep cost.
It greatly complicated cgroup core implementation but more importantly
the support for multiple hierarchies restricted how cgroup could be
used in general and what controllers was able to do.</p>
<p>There was no limit on how many hierarchies there might be, which meant
that a thread’s cgroup membership couldn’t be described in finite
length.  The key might contain any number of entries and was unlimited
in length, which made it highly awkward to manipulate and led to
addition of controllers which existed only to identify membership,
which in turn exacerbated the original problem of proliferating number
of hierarchies.</p>
<p>Also, as a controller couldn’t have any expectation regarding the
topologies of hierarchies other controllers might be on, each
controller had to assume that all other controllers were attached to
completely orthogonal hierarchies.  This made it impossible, or at
least very cumbersome, for controllers to cooperate with each other.</p>
<p>In most use cases, putting controllers on hierarchies which are
completely orthogonal to each other isn’t necessary.  What usually is
called for is the ability to have differing levels of granularity
depending on the specific controller.  In other words, hierarchy may
be collapsed from leaf towards root when viewed from specific
controllers.  For example, a given configuration might not care about
how memory is distributed beyond a certain level while still wanting
to control how CPU cycles are distributed.</p>
</section>
<section id="thread-granularity">
<h3>Thread Granularity<a class="headerlink" href="#thread-granularity" title="Permalink to this headline">¶</a></h3>
<p>cgroup v1 allowed threads of a process to belong to different cgroups.
This didn’t make sense for some controllers and those controllers
ended up implementing different ways to ignore such situations but
much more importantly it blurred the line between API exposed to
individual applications and system management interface.</p>
<p>Generally, in-process knowledge is available only to the process
itself; thus, unlike service-level organization of processes,
categorizing threads of a process requires active participation from
the application which owns the target process.</p>
<p>cgroup v1 had an ambiguously defined delegation model which got abused
in combination with thread granularity.  cgroups were delegated to
individual applications so that they can create and manage their own
sub-hierarchies and control resource distributions along them.  This
effectively raised cgroup to the status of a syscall-like API exposed
to lay programs.</p>
<p>First of all, cgroup has a fundamentally inadequate interface to be
exposed this way.  For a process to access its own knobs, it has to
extract the path on the target hierarchy from /proc/self/cgroup,
construct the path by appending the name of the knob to the path, open
and then read and/or write to it.  This is not only extremely clunky
and unusual but also inherently racy.  There is no conventional way to
define transaction across the required steps and nothing can guarantee
that the process would actually be operating on its own sub-hierarchy.</p>
<p>cgroup controllers implemented a number of knobs which would never be
accepted as public APIs because they were just adding control knobs to
system-management pseudo filesystem.  cgroup ended up with interface
knobs which were not properly abstracted or refined and directly
revealed kernel internal details.  These knobs got exposed to
individual applications through the ill-defined delegation mechanism
effectively abusing cgroup as a shortcut to implementing public APIs
without going through the required scrutiny.</p>
<p>This was painful for both userland and kernel.  Userland ended up with
misbehaving and poorly abstracted interfaces and kernel exposing and
locked into constructs inadvertently.</p>
</section>
<section id="competition-between-inner-nodes-and-threads">
<h3>Competition Between Inner Nodes and Threads<a class="headerlink" href="#competition-between-inner-nodes-and-threads" title="Permalink to this headline">¶</a></h3>
<p>cgroup v1 allowed threads to be in any cgroups which created an
interesting problem where threads belonging to a parent cgroup and its
children cgroups competed for resources.  This was nasty as two
different types of entities competed and there was no obvious way to
settle it.  Different controllers did different things.</p>
<p>The cpu controller considered threads and cgroups as equivalents and
mapped nice levels to cgroup weights.  This worked for some cases but
fell flat when children wanted to be allocated specific ratios of CPU
cycles and the number of internal threads fluctuated - the ratios
constantly changed as the number of competing entities fluctuated.
There also were other issues.  The mapping from nice level to weight
wasn’t obvious or universal, and there were various other knobs which
simply weren’t available for threads.</p>
<p>The io controller implicitly created a hidden leaf node for each
cgroup to host the threads.  The hidden leaf had its own copies of all
the knobs with <code class="docutils literal notranslate"><span class="pre">leaf_</span></code> prefixed.  While this allowed equivalent
control over internal threads, it was with serious drawbacks.  It
always added an extra layer of nesting which wouldn’t be necessary
otherwise, made the interface messy and significantly complicated the
implementation.</p>
<p>The memory controller didn’t have a way to control what happened
between internal tasks and child cgroups and the behavior was not
clearly defined.  There were attempts to add ad-hoc behaviors and
knobs to tailor the behavior to specific workloads which would have
led to problems extremely difficult to resolve in the long term.</p>
<p>Multiple controllers struggled with internal tasks and came up with
different ways to deal with it; unfortunately, all the approaches were
severely flawed and, furthermore, the widely different behaviors
made cgroup as a whole highly inconsistent.</p>
<p>This clearly is a problem which needs to be addressed from cgroup core
in a uniform way.</p>
</section>
<section id="other-interface-issues">
<h3>Other Interface Issues<a class="headerlink" href="#other-interface-issues" title="Permalink to this headline">¶</a></h3>
<p>cgroup v1 grew without oversight and developed a large number of
idiosyncrasies and inconsistencies.  One issue on the cgroup core side
was how an empty cgroup was notified - a userland helper binary was
forked and executed for each event.  The event delivery wasn’t
recursive or delegatable.  The limitations of the mechanism also led
to in-kernel event delivery filtering mechanism further complicating
the interface.</p>
<p>Controller interfaces were problematic too.  An extreme example is
controllers completely ignoring hierarchical organization and treating
all cgroups as if they were all located directly under the root
cgroup.  Some controllers exposed a large amount of inconsistent
implementation details to userland.</p>
<p>There also was no consistency across controllers.  When a new cgroup
was created, some controllers defaulted to not imposing extra
restrictions while others disallowed any resource usage until
explicitly configured.  Configuration knobs for the same type of
control used widely differing naming schemes and formats.  Statistics
and information knobs were named arbitrarily and used different
formats and units even in the same controller.</p>
<p>cgroup v2 establishes common conventions where appropriate and updates
controllers so that they expose minimal and consistent interfaces.</p>
</section>
<section id="controller-issues-and-remedies">
<h3>Controller Issues and Remedies<a class="headerlink" href="#controller-issues-and-remedies" title="Permalink to this headline">¶</a></h3>
<section id="id1">
<h4>Memory<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>The original lower boundary, the soft limit, is defined as a limit
that is per default unset.  As a result, the set of cgroups that
global reclaim prefers is opt-in, rather than opt-out.  The costs for
optimizing these mostly negative lookups are so high that the
implementation, despite its enormous size, does not even provide the
basic desirable behavior.  First off, the soft limit has no
hierarchical meaning.  All configured groups are organized in a global
rbtree and treated like equal peers, regardless where they are located
in the hierarchy.  This makes subtree delegation impossible.  Second,
the soft limit reclaim pass is so aggressive that it not just
introduces high allocation latencies into the system, but also impacts
system performance due to overreclaim, to the point where the feature
becomes self-defeating.</p>
<p>The memory.low boundary on the other hand is a top-down allocated
reserve.  A cgroup enjoys reclaim protection when it’s within its
effective low, which makes delegation of subtrees possible. It also
enjoys having reclaim pressure proportional to its overage when
above its effective low.</p>
<p>The original high boundary, the hard limit, is defined as a strict
limit that can not budge, even if the OOM killer has to be called.
But this generally goes against the goal of making the most out of the
available memory.  The memory consumption of workloads varies during
runtime, and that requires users to overcommit.  But doing that with a
strict upper limit requires either a fairly accurate prediction of the
working set size or adding slack to the limit.  Since working set size
estimation is hard and error prone, and getting it wrong results in
OOM kills, most users tend to err on the side of a looser limit and
end up wasting precious resources.</p>
<p>The memory.high boundary on the other hand can be set much more
conservatively.  When hit, it throttles allocations by forcing them
into direct reclaim to work off the excess, but it never invokes the
OOM killer.  As a result, a high boundary that is chosen too
aggressively will not terminate the processes, but instead it will
lead to gradual performance degradation.  The user can monitor this
and make corrections until the minimal memory footprint that still
gives acceptable performance is found.</p>
<p>In extreme cases, with many concurrent allocations and a complete
breakdown of reclaim progress within the group, the high boundary can
be exceeded.  But even then it’s mostly better to satisfy the
allocation from the slack available in other groups or the rest of the
system than killing the group.  Otherwise, memory.max is there to
limit this type of spillover and ultimately contain buggy or even
malicious applications.</p>
<p>Setting the original memory.limit_in_bytes below the current usage was
subject to a race condition, where concurrent charges could cause the
limit setting to fail. memory.max on the other hand will first set the
limit to prevent new charges, and then reclaim and OOM kill until the
new limit is met - or the task writing to memory.max is killed.</p>
<p>The combined memory+swap accounting and limiting is replaced by real
control over swap space.</p>
<p>The main argument for a combined memory+swap facility in the original
cgroup design was that global or parental pressure would always be
able to swap all anonymous memory of a child group, regardless of the
child’s own (possibly untrusted) configuration.  However, untrusted
groups can sabotage swapping by other means - such as referencing its
anonymous memory in a tight loop - and an admin can not assume full
swappability when overcommitting untrusted jobs.</p>
<p>For trusted jobs, on the other hand, a combined counter is not an
intuitive userspace interface, and it flies in the face of the idea
that cgroup controllers should account and limit specific physical
resources.  Swap space is a resource like all others in the system,
and that’s why unified hierarchy allows distributing it separately.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Control Group v2</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#what-is-cgroup">What is cgroup?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-operations">Basic Operations</a><ul>
<li><a class="reference internal" href="#mounting">Mounting</a></li>
<li><a class="reference internal" href="#organizing-processes-and-threads">Organizing Processes and Threads</a><ul>
<li><a class="reference internal" href="#processes">Processes</a></li>
<li><a class="reference internal" href="#threads">Threads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#un-populated-notification">[Un]populated Notification</a></li>
<li><a class="reference internal" href="#controlling-controllers">Controlling Controllers</a><ul>
<li><a class="reference internal" href="#enabling-and-disabling">Enabling and Disabling</a></li>
<li><a class="reference internal" href="#top-down-constraint">Top-down Constraint</a></li>
<li><a class="reference internal" href="#no-internal-process-constraint">No Internal Process Constraint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#delegation">Delegation</a><ul>
<li><a class="reference internal" href="#model-of-delegation">Model of Delegation</a></li>
<li><a class="reference internal" href="#delegation-containment">Delegation Containment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#guidelines">Guidelines</a><ul>
<li><a class="reference internal" href="#organize-once-and-control">Organize Once and Control</a></li>
<li><a class="reference internal" href="#avoid-name-collisions">Avoid Name Collisions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#resource-distribution-models">Resource Distribution Models</a><ul>
<li><a class="reference internal" href="#weights">Weights</a></li>
<li><a class="reference internal" href="#limits">Limits</a></li>
<li><a class="reference internal" href="#protections">Protections</a></li>
<li><a class="reference internal" href="#allocations">Allocations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interface-files">Interface Files</a><ul>
<li><a class="reference internal" href="#format">Format</a></li>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#core-interface-files">Core Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controllers">Controllers</a><ul>
<li><a class="reference internal" href="#cpu">CPU</a><ul>
<li><a class="reference internal" href="#cpu-interface-files">CPU Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory">Memory</a><ul>
<li><a class="reference internal" href="#memory-interface-files">Memory Interface Files</a></li>
<li><a class="reference internal" href="#usage-guidelines">Usage Guidelines</a></li>
<li><a class="reference internal" href="#memory-ownership">Memory Ownership</a></li>
</ul>
</li>
<li><a class="reference internal" href="#io">IO</a><ul>
<li><a class="reference internal" href="#io-interface-files">IO Interface Files</a></li>
<li><a class="reference internal" href="#writeback">Writeback</a></li>
<li><a class="reference internal" href="#io-latency">IO Latency</a></li>
<li><a class="reference internal" href="#how-io-latency-throttling-works">How IO Latency Throttling Works</a></li>
<li><a class="reference internal" href="#io-latency-interface-files">IO Latency Interface Files</a></li>
<li><a class="reference internal" href="#io-priority">IO Priority</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pid">PID</a><ul>
<li><a class="reference internal" href="#pid-interface-files">PID Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpuset">Cpuset</a><ul>
<li><a class="reference internal" href="#cpuset-interface-files">Cpuset Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#device-controller">Device controller</a></li>
<li><a class="reference internal" href="#rdma">RDMA</a><ul>
<li><a class="reference internal" href="#rdma-interface-files">RDMA Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hugetlb">HugeTLB</a><ul>
<li><a class="reference internal" href="#hugetlb-interface-files">HugeTLB Interface Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#misc">Misc</a><ul>
<li><a class="reference internal" href="#misc-interface-files">Misc Interface Files</a></li>
<li><a class="reference internal" href="#migration-and-ownership">Migration and Ownership</a></li>
</ul>
</li>
<li><a class="reference internal" href="#others">Others</a><ul>
<li><a class="reference internal" href="#perf-event">perf_event</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-normative-information">Non-normative information</a><ul>
<li><a class="reference internal" href="#cpu-controller-root-cgroup-process-behaviour">CPU controller root cgroup process behaviour</a></li>
<li><a class="reference internal" href="#io-controller-root-cgroup-process-behaviour">IO controller root cgroup process behaviour</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#namespace">Namespace</a><ul>
<li><a class="reference internal" href="#basics">Basics</a></li>
<li><a class="reference internal" href="#the-root-and-views">The Root and Views</a></li>
<li><a class="reference internal" href="#migration-and-setns-2">Migration and setns(2)</a></li>
<li><a class="reference internal" href="#interaction-with-other-namespaces">Interaction with Other Namespaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#information-on-kernel-programming">Information on Kernel Programming</a><ul>
<li><a class="reference internal" href="#filesystem-support-for-writeback">Filesystem Support for Writeback</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecated-v1-core-features">Deprecated v1 Core Features</a></li>
<li><a class="reference internal" href="#issues-with-v1-and-rationales-for-v2">Issues with v1 and Rationales for v2</a><ul>
<li><a class="reference internal" href="#multiple-hierarchies">Multiple Hierarchies</a></li>
<li><a class="reference internal" href="#thread-granularity">Thread Granularity</a></li>
<li><a class="reference internal" href="#competition-between-inner-nodes-and-threads">Competition Between Inner Nodes and Threads</a></li>
<li><a class="reference internal" href="#other-interface-issues">Other Interface Issues</a></li>
<li><a class="reference internal" href="#controller-issues-and-remedies">Controller Issues and Remedies</a><ul>
<li><a class="reference internal" href="#id1">Memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/admin-guide/cgroup-v2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/admin-guide/cgroup-v2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>