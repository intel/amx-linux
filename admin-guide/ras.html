
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Reliability, Availability and Serviceability &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Real Time Clock (RTC) Drivers for Linux" href="rtc.html" />
    <link rel="prev" title="RapidIO Subsystem Guide" href="rapidio.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="reliability-availability-and-serviceability">
<h1>Reliability, Availability and Serviceability<a class="headerlink" href="#reliability-availability-and-serviceability" title="Permalink to this headline">¶</a></h1>
<section id="ras-concepts">
<h2>RAS concepts<a class="headerlink" href="#ras-concepts" title="Permalink to this headline">¶</a></h2>
<p>Reliability, Availability and Serviceability (RAS) is a concept used on
servers meant to measure their robustness.</p>
<dl class="simple">
<dt>Reliability</dt><dd><p>is the probability that a system will produce correct outputs.</p>
<ul class="simple">
<li><p>Generally measured as Mean Time Between Failures (MTBF)</p></li>
<li><p>Enhanced by features that help to avoid, detect and repair hardware faults</p></li>
</ul>
</dd>
<dt>Availability</dt><dd><p>is the probability that a system is operational at a given time</p>
<ul class="simple">
<li><p>Generally measured as a percentage of downtime per a period of time</p></li>
<li><p>Often uses mechanisms to detect and correct hardware faults in
runtime;</p></li>
</ul>
</dd>
<dt>Serviceability (or maintainability)</dt><dd><p>is the simplicity and speed with which a system can be repaired or
maintained</p>
<ul class="simple">
<li><p>Generally measured on Mean Time Between Repair (MTBR)</p></li>
</ul>
</dd>
</dl>
<section id="improving-ras">
<h3>Improving RAS<a class="headerlink" href="#improving-ras" title="Permalink to this headline">¶</a></h3>
<p>In order to reduce systems downtime, a system should be capable of detecting
hardware errors, and, when possible correcting them in runtime. It should
also provide mechanisms to detect hardware degradation, in order to warn
the system administrator to take the action of replacing a component before
it causes data loss or system downtime.</p>
<p>Among the monitoring measures, the most usual ones include:</p>
<ul class="simple">
<li><p>CPU – detect errors at instruction execution and at L1/L2/L3 caches;</p></li>
<li><p>Memory – add error correction logic (ECC) to detect and correct errors;</p></li>
<li><p>I/O – add CRC checksums for transferred data;</p></li>
<li><p>Storage – RAID, journal file systems, checksums,
Self-Monitoring, Analysis and Reporting Technology (SMART).</p></li>
</ul>
<p>By monitoring the number of occurrences of error detections, it is possible
to identify if the probability of hardware errors is increasing, and, on such
case, do a preventive maintenance to replace a degraded component while
those errors are correctable.</p>
</section>
<section id="types-of-errors">
<h3>Types of errors<a class="headerlink" href="#types-of-errors" title="Permalink to this headline">¶</a></h3>
<p>Most mechanisms used on modern systems use technologies like Hamming
Codes that allow error correction when the number of errors on a bit packet
is below a threshold. If the number of errors is above, those mechanisms
can indicate with a high degree of confidence that an error happened, but
they can’t correct.</p>
<p>Also, sometimes an error occur on a component that it is not used. For
example, a part of the memory that it is not currently allocated.</p>
<p>That defines some categories of errors:</p>
<ul>
<li><p><strong>Correctable Error (CE)</strong> - the error detection mechanism detected and
corrected the error. Such errors are usually not fatal, although some
Kernel mechanisms allow the system administrator to consider them as fatal.</p></li>
<li><p><strong>Uncorrected Error (UE)</strong> - the amount of errors happened above the error
correction threshold, and the system was unable to auto-correct.</p></li>
<li><p><strong>Fatal Error</strong> - when an UE error happens on a critical component of the
system (for example, a piece of the Kernel got corrupted by an UE), the
only reliable way to avoid data corruption is to hang or reboot the machine.</p></li>
<li><p><strong>Non-fatal Error</strong> - when an UE error happens on an unused component,
like a CPU in power down state or an unused memory bank, the system may
still run, eventually replacing the affected hardware by a hot spare,
if available.</p>
<p>Also, when an error happens on a userspace process, it is also possible to
kill such process and let userspace restart it.</p>
</li>
</ul>
<p>The mechanism for handling non-fatal errors is usually complex and may
require the help of some userspace application, in order to apply the
policy desired by the system administrator.</p>
</section>
<section id="identifying-a-bad-hardware-component">
<h3>Identifying a bad hardware component<a class="headerlink" href="#identifying-a-bad-hardware-component" title="Permalink to this headline">¶</a></h3>
<p>Just detecting a hardware flaw is usually not enough, as the system needs
to pinpoint to the minimal replaceable unit (MRU) that should be exchanged
to make the hardware reliable again.</p>
<p>So, it requires not only error logging facilities, but also mechanisms that
will translate the error message to the silkscreen or component label for
the MRU.</p>
<p>Typically, it is very complex for memory, as modern CPUs interlace memory
from different memory modules, in order to provide a better performance. The
DMI BIOS usually have a list of memory module labels, with can be obtained
using the <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code> tool. For example, on a desktop machine, it shows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Memory Device
        Total Width: 64 bits
        Data Width: 64 bits
        Size: 16384 MB
        Form Factor: SODIMM
        Set: None
        Locator: ChannelA-DIMM0
        Bank Locator: BANK 0
        Type: DDR4
        Type Detail: Synchronous
        Speed: 2133 MHz
        Rank: 2
        Configured Clock Speed: 2133 MHz
</pre></div>
</div>
<p>On the above example, a DDR4 SO-DIMM memory module is located at the
system’s memory labeled as “BANK 0”, as given by the <em>bank locator</em> field.
Please notice that, on such system, the <em>total width</em> is equal to the
<em>data width</em>. It means that such memory module doesn’t have error
detection/correction mechanisms.</p>
<p>Unfortunately, not all systems use the same field to specify the memory
bank. On this example, from an older server, <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code> shows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Memory Device
        Array Handle: 0x1000
        Error Information Handle: Not Provided
        Total Width: 72 bits
        Data Width: 64 bits
        Size: 8192 MB
        Form Factor: DIMM
        Set: 1
        Locator: DIMM_A1
        Bank Locator: Not Specified
        Type: DDR3
        Type Detail: Synchronous Registered (Buffered)
        Speed: 1600 MHz
        Rank: 2
        Configured Clock Speed: 1600 MHz
</pre></div>
</div>
<p>There, the DDR3 RDIMM memory module is located at the system’s memory labeled
as “DIMM_A1”, as given by the <em>locator</em> field. Please notice that this
memory module has 64 bits of <em>data width</em> and 72 bits of <em>total width</em>. So,
it has 8 extra bits to be used by error detection and correction mechanisms.
Such kind of memory is called Error-correcting code memory (ECC memory).</p>
<p>To make things even worse, it is not uncommon that systems with different
labels on their system’s board to use exactly the same BIOS, meaning that
the labels provided by the BIOS won’t match the real ones.</p>
</section>
<section id="ecc-memory">
<h3>ECC memory<a class="headerlink" href="#ecc-memory" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in the previous section, ECC memory has extra bits to be
used for error correction. In the above example, a memory module has
64 bits of <em>data width</em>, and 72 bits of <em>total width</em>.  The extra 8
bits which are used for the error detection and correction mechanisms
are referred to as the <em>syndrome</em><a class="footnote-reference brackets" href="#f1" id="id1">1</a><a class="footnote-reference brackets" href="#f2" id="id2">2</a>.</p>
<p>So, when the cpu requests the memory controller to write a word with
<em>data width</em>, the memory controller calculates the <em>syndrome</em> in real time,
using Hamming code, or some other error correction code, like SECDED+,
producing a code with <em>total width</em> size. Such code is then written
on the memory modules.</p>
<p>At read, the <em>total width</em> bits code is converted back, using the same
ECC code used on write, producing a word with <em>data width</em> and a <em>syndrome</em>.
The word with <em>data width</em> is sent to the CPU, even when errors happen.</p>
<p>The memory controller also looks at the <em>syndrome</em> in order to check if
there was an error, and if the ECC code was able to fix such error.
If the error was corrected, a Corrected Error (CE) happened. If not, an
Uncorrected Error (UE) happened.</p>
<p>The information about the CE/UE errors is stored on some special registers
at the memory controller and can be accessed by reading such registers,
either by BIOS, by some special CPUs or by Linux EDAC driver. On x86 64
bit CPUs, such errors can also be retrieved via the Machine Check
Architecture (MCA)<a class="footnote-reference brackets" href="#f3" id="id3">3</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Please notice that several memory controllers allow operation on a
mode called “Lock-Step”, where it groups two memory modules together,
doing 128-bit reads/writes. That gives 16 bits for error correction, with
significantly improves the error correction mechanism, at the expense
that, when an error happens, there’s no way to know what memory module is
to blame. So, it has to blame both memory modules.</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Some memory controllers also allow using memory in mirror mode.
On such mode, the same data is written to two memory modules. At read,
the system checks both memory modules, in order to check if both provide
identical data. On such configuration, when an error happens, there’s no
way to know what memory module is to blame. So, it has to blame both
memory modules (or 4 memory modules, if the system is also on Lock-step
mode).</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>For more details about the Machine Check Architecture (MCA),
please read <a class="reference internal" href="../x86/x86_64/machinecheck.html"><span class="doc">Configurable sysfs parameters for the x86-64 machine check code</span></a> at the Kernel tree.</p>
</dd>
</dl>
</section>
</section>
<section id="edac-error-detection-and-correction">
<h2>EDAC - Error Detection And Correction<a class="headerlink" href="#edac-error-detection-and-correction" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>“bluesmoke” was the name for this device driver subsystem when it
was “out-of-tree” and maintained at <a class="reference external" href="http://bluesmoke.sourceforge.net">http://bluesmoke.sourceforge.net</a>.
That site is mostly archaic now and can be used only for historical
purposes.</p>
<p>When the subsystem was pushed upstream for the first time, on
Kernel 2.6.16, it was renamed to <code class="docutils literal notranslate"><span class="pre">EDAC</span></code>.</p>
</div>
<section id="purpose">
<h3>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">edac</span></code> kernel module’s goal is to detect and report hardware errors
that occur within the computer system running under linux.</p>
</section>
<section id="memory">
<h3>Memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h3>
<p>Memory Correctable Errors (CE) and Uncorrectable Errors (UE) are the
primary errors being harvested. These types of errors are harvested by
the <code class="docutils literal notranslate"><span class="pre">edac_mc</span></code> device.</p>
<p>Detecting CE events, then harvesting those events and reporting them,
<strong>can</strong> but must not necessarily be a predictor of future UE events. With
CE events only, the system can and will continue to operate as no data
has been damaged yet.</p>
<p>However, preventive maintenance and proactive part replacement of memory
modules exhibiting CEs can reduce the likelihood of the dreaded UE events
and system panics.</p>
</section>
<section id="other-hardware-elements">
<h3>Other hardware elements<a class="headerlink" href="#other-hardware-elements" title="Permalink to this headline">¶</a></h3>
<p>A new feature for EDAC, the <code class="docutils literal notranslate"><span class="pre">edac_device</span></code> class of device, was added in
the 2.6.23 version of the kernel.</p>
<p>This new device type allows for non-memory type of ECC hardware detectors
to have their states harvested and presented to userspace via the sysfs
interface.</p>
<p>Some architectures have ECC detectors for L1, L2 and L3 caches,
along with DMA engines, fabric switches, main data path switches,
interconnections, and various other hardware data paths. If the hardware
reports it, then a edac_device device probably can be constructed to
harvest and present that to userspace.</p>
</section>
<section id="pci-bus-scanning">
<h3>PCI bus scanning<a class="headerlink" href="#pci-bus-scanning" title="Permalink to this headline">¶</a></h3>
<p>In addition, PCI devices are scanned for PCI Bus Parity and SERR Errors
in order to determine if errors are occurring during data transfers.</p>
<p>The presence of PCI Parity errors must be examined with a grain of salt.
There are several add-in adapters that do <strong>not</strong> follow the PCI specification
with regards to Parity generation and reporting. The specification says
the vendor should tie the parity status bits to 0 if they do not intend
to generate parity.  Some vendors do not do this, and thus the parity bit
can “float” giving false positives.</p>
<p>There is a PCI device attribute located in sysfs that is checked by
the EDAC PCI scanning code. If that attribute is set, PCI parity/error
scanning is skipped for that device. The attribute is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>broken_parity_status
</pre></div>
</div>
<p>and is located in <code class="docutils literal notranslate"><span class="pre">/sys/devices/pci&lt;XXX&gt;/0000:XX:YY.Z</span></code> directories for
PCI devices.</p>
</section>
<section id="versioning">
<h3>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline">¶</a></h3>
<p>EDAC is composed of a “core” module (<code class="docutils literal notranslate"><span class="pre">edac_core.ko</span></code>) and several Memory
Controller (MC) driver modules. On a given system, the CORE is loaded
and one MC driver will be loaded. Both the CORE and the MC driver (or
<code class="docutils literal notranslate"><span class="pre">edac_device</span></code> driver) have individual versions that reflect current
release level of their respective modules.</p>
<p>Thus, to “report” on what version a system is running, one must report
both the CORE’s and the MC driver’s versions.</p>
</section>
<section id="loading">
<h3>Loading<a class="headerlink" href="#loading" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">edac</span></code> was statically linked with the kernel then no loading
is necessary. If <code class="docutils literal notranslate"><span class="pre">edac</span></code> was built as modules then simply modprobe
the <code class="docutils literal notranslate"><span class="pre">edac</span></code> pieces that you need. You should be able to modprobe
hardware-specific modules and have the dependencies load the necessary
core modules.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ modprobe amd76x_edac
</pre></div>
</div>
<p>loads both the <code class="docutils literal notranslate"><span class="pre">amd76x_edac.ko</span></code> memory controller module and the
<code class="docutils literal notranslate"><span class="pre">edac_mc.ko</span></code> core module.</p>
</section>
<section id="sysfs-interface">
<h3>Sysfs interface<a class="headerlink" href="#sysfs-interface" title="Permalink to this headline">¶</a></h3>
<p>EDAC presents a <code class="docutils literal notranslate"><span class="pre">sysfs</span></code> interface for control and reporting purposes. It
lives in the /sys/devices/system/edac directory.</p>
<p>Within this directory there currently reside 2 components:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>mc</p></td>
<td><p>memory controller(s) system</p></td>
</tr>
<tr class="row-even"><td><p>pci</p></td>
<td><p>PCI control and status system</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="memory-controller-mc-model">
<h3>Memory Controller (mc) Model<a class="headerlink" href="#memory-controller-mc-model" title="Permalink to this headline">¶</a></h3>
<p>Each <code class="docutils literal notranslate"><span class="pre">mc</span></code> device controls a set of memory modules <a class="footnote-reference brackets" href="#f4" id="id4">4</a>. These modules
are laid out in a Chip-Select Row (<code class="docutils literal notranslate"><span class="pre">csrowX</span></code>) and Channel table (<code class="docutils literal notranslate"><span class="pre">chX</span></code>).
There can be multiple csrows and multiple channels.</p>
<dl class="footnote brackets">
<dt class="label" id="f4"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Nowadays, the term DIMM (Dual In-line Memory Module) is widely
used to refer to a memory module, although there are other memory
packaging alternatives, like SO-DIMM, SIMM, etc. The UEFI
specification (Version 2.7) defines a memory module in the Common
Platform Error Record (CPER) section to be an SMBIOS Memory Device
(Type 17). Along this document, and inside the EDAC subsystem, the term
“dimm” is used for all memory modules, even when they use a
different kind of packaging.</p>
</dd>
</dl>
<p>Memory controllers allow for several csrows, with 8 csrows being a
typical value. Yet, the actual number of csrows depends on the layout of
a given motherboard, memory controller and memory module characteristics.</p>
<p>Dual channels allow for dual data length (e. g. 128 bits, on 64 bit systems)
data transfers to/from the CPU from/to memory. Some newer chipsets allow
for more than 2 channels, like Fully Buffered DIMMs (FB-DIMMs) memory
controllers. The following example will assume 2 channels:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>CS Rows</p></th>
<th class="head" colspan="2"><p>Channels</p></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">ch0</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">ch1</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td></td>
<td><p><strong>DIMM_A0</strong></p></td>
<td><p><strong>DIMM_B0</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">csrow0</span></code></p></td>
<td><p>rank0</p></td>
<td><p>rank0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">csrow1</span></code></p></td>
<td><p>rank1</p></td>
<td><p>rank1</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p><strong>DIMM_A1</strong></p></td>
<td><p><strong>DIMM_B1</strong></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">csrow2</span></code></p></td>
<td><p>rank0</p></td>
<td><p>rank0</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">csrow3</span></code></p></td>
<td><p>rank1</p></td>
<td><p>rank1</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In the above example, there are 4 physical slots on the motherboard
for memory DIMMs:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>DIMM_A0</p></td>
<td><p>DIMM_B0</p></td>
</tr>
<tr class="row-even"><td><p>DIMM_A1</p></td>
<td><p>DIMM_B1</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Labels for these slots are usually silk-screened on the motherboard.
Slots labeled <code class="docutils literal notranslate"><span class="pre">A</span></code> are channel 0 in this example. Slots labeled <code class="docutils literal notranslate"><span class="pre">B</span></code> are
channel 1. Notice that there are two csrows possible on a physical DIMM.
These csrows are allocated their csrow assignment based on the slot into
which the memory DIMM is placed. Thus, when 1 DIMM is placed in each
Channel, the csrows cross both DIMMs.</p>
<p>Memory DIMMs come single or dual “ranked”. A rank is a populated csrow.
In the example above 2 dual ranked DIMMs are similarly placed. Thus,
both csrow0 and csrow1 are populated. On the other hand, when 2 single
ranked DIMMs are placed in slots DIMM_A0 and DIMM_B0, then they will
have just one csrow (csrow0) and csrow1 will be empty. The pattern
repeats itself for csrow2 and csrow3. Also note that some memory
controllers don’t have any logic to identify the memory module, see
<code class="docutils literal notranslate"><span class="pre">rankX</span></code> directories below.</p>
<p>The representation of the above is reflected in the directory
tree in EDAC’s sysfs interface. Starting in directory
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/edac/mc</span></code>, each memory controller will be
represented by its own <code class="docutils literal notranslate"><span class="pre">mcX</span></code> directory, where <code class="docutils literal notranslate"><span class="pre">X</span></code> is the
index of the MC:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>..../edac/mc/
           |
           |-&gt;mc0
           |-&gt;mc1
           |-&gt;mc2
           ....
</pre></div>
</div>
<p>Under each <code class="docutils literal notranslate"><span class="pre">mcX</span></code> directory each <code class="docutils literal notranslate"><span class="pre">csrowX</span></code> is again represented by a
<code class="docutils literal notranslate"><span class="pre">csrowX</span></code>, where <code class="docutils literal notranslate"><span class="pre">X</span></code> is the csrow index:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.../mc/mc0/
        |
        |-&gt;csrow0
        |-&gt;csrow2
        |-&gt;csrow3
        ....
</pre></div>
</div>
<p>Notice that there is no csrow1, which indicates that csrow0 is composed
of a single ranked DIMMs. This should also apply in both Channels, in
order to have dual-channel mode be operational. Since both csrow2 and
csrow3 are populated, this indicates a dual ranked set of DIMMs for
channels 0 and 1.</p>
<p>Within each of the <code class="docutils literal notranslate"><span class="pre">mcX</span></code> and <code class="docutils literal notranslate"><span class="pre">csrowX</span></code> directories are several EDAC
control and attribute files.</p>
</section>
<section id="mcx-directories">
<h3><code class="docutils literal notranslate"><span class="pre">mcX</span></code> directories<a class="headerlink" href="#mcx-directories" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">mcX</span></code> directories are EDAC control and attribute files for
this <code class="docutils literal notranslate"><span class="pre">X</span></code> instance of the memory controllers.</p>
<p>For a description of the sysfs API, please see:</p>
<blockquote>
<div><p>Documentation/ABI/testing/sysfs-devices-edac</p>
</div></blockquote>
</section>
<section id="dimmx-or-rankx-directories">
<h3><code class="docutils literal notranslate"><span class="pre">dimmX</span></code> or <code class="docutils literal notranslate"><span class="pre">rankX</span></code> directories<a class="headerlink" href="#dimmx-or-rankx-directories" title="Permalink to this headline">¶</a></h3>
<p>The recommended way to use the EDAC subsystem is to look at the information
provided by the <code class="docutils literal notranslate"><span class="pre">dimmX</span></code> or <code class="docutils literal notranslate"><span class="pre">rankX</span></code> directories <a class="footnote-reference brackets" href="#f5" id="id5">5</a>.</p>
<p>A typical EDAC system has the following structure under
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/edac/</span></code><a class="footnote-reference brackets" href="#f6" id="id6">6</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/
├── mc
│   ├── mc0
│   │   ├── ce_count
│   │   ├── ce_noinfo_count
│   │   ├── dimm0
│   │   │   ├── dimm_ce_count
│   │   │   ├── dimm_dev_type
│   │   │   ├── dimm_edac_mode
│   │   │   ├── dimm_label
│   │   │   ├── dimm_location
│   │   │   ├── dimm_mem_type
│   │   │   ├── dimm_ue_count
│   │   │   ├── size
│   │   │   └── uevent
│   │   ├── max_location
│   │   ├── mc_name
│   │   ├── reset_counters
│   │   ├── seconds_since_reset
│   │   ├── size_mb
│   │   ├── ue_count
│   │   ├── ue_noinfo_count
│   │   └── uevent
│   ├── mc1
│   │   ├── ce_count
│   │   ├── ce_noinfo_count
│   │   ├── dimm0
│   │   │   ├── dimm_ce_count
│   │   │   ├── dimm_dev_type
│   │   │   ├── dimm_edac_mode
│   │   │   ├── dimm_label
│   │   │   ├── dimm_location
│   │   │   ├── dimm_mem_type
│   │   │   ├── dimm_ue_count
│   │   │   ├── size
│   │   │   └── uevent
│   │   ├── max_location
│   │   ├── mc_name
│   │   ├── reset_counters
│   │   ├── seconds_since_reset
│   │   ├── size_mb
│   │   ├── ue_count
│   │   ├── ue_noinfo_count
│   │   └── uevent
│   └── uevent
└── uevent
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">dimmX</span></code> directories are EDAC control and attribute files for
this <code class="docutils literal notranslate"><span class="pre">X</span></code> memory module:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code> - Total memory managed by this csrow attribute file</p>
<blockquote>
<div><p>This attribute file displays, in count of megabytes, the memory
that this csrow contains.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_ue_count</span></code> - Uncorrectable Errors count attribute file</p>
<blockquote>
<div><p>This attribute file displays the total count of uncorrectable
errors that have occurred on this DIMM. If panic_on_ue is set
this counter will not have a chance to increment, since EDAC
will panic the system.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_ce_count</span></code> - Correctable Errors count attribute file</p>
<blockquote>
<div><p>This attribute file displays the total count of correctable
errors that have occurred on this DIMM. This count is very
important to examine. CEs provide early indications that a
DIMM is beginning to fail. This count field should be
monitored for non-zero values and report such information
to the system administrator.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_dev_type</span></code>  - Device type attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of DRAM device is
being utilized on this DIMM.
Examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>x1</p></li>
<li><p>x2</p></li>
<li><p>x4</p></li>
<li><p>x8</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_edac_mode</span></code> - EDAC Mode of operation attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of Error detection
and correction is being utilized.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_label</span></code> - memory module label control file</p>
<blockquote>
<div><p>This control file allows this DIMM to have a label assigned
to it. With this label in the module, when errors occur
the output can provide the DIMM label in the system log.
This becomes vital for panic events to isolate the
cause of the UE event.</p>
<p>DIMM Labels must be assigned after booting, with information
that correctly identifies the physical slot with its
silk screen label. This information is currently very
motherboard specific and determination of this information
must occur in userland at this time.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_location</span></code> - location of the memory module</p>
<blockquote>
<div><p>The location can have up to 3 levels, and describe how the
memory controller identifies the location of a memory module.
Depending on the type of memory and memory controller, it
can be:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>csrow</em> and <em>channel</em> - used when the memory controller
doesn’t identify a single DIMM - e. g. in <code class="docutils literal notranslate"><span class="pre">rankX</span></code> dir;</p></li>
<li><p><em>branch</em>, <em>channel</em>, <em>slot</em> - typically used on FB-DIMM memory
controllers;</p></li>
<li><p><em>channel</em>, <em>slot</em> - used on Nehalem and newer Intel drivers.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimm_mem_type</span></code> - Memory Type attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of memory is currently
on this csrow. Normally, either buffered or unbuffered memory.
Examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Registered-DDR</p></li>
<li><p>Unbuffered-DDR</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="f5"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>On some systems, the memory controller doesn’t have any logic
to identify the memory module. On such systems, the directory is called <code class="docutils literal notranslate"><span class="pre">rankX</span></code> and works on a similar way as the <code class="docutils literal notranslate"><span class="pre">csrowX</span></code> directories.
On modern Intel memory controllers, the memory controller identifies the
memory modules directly. On such systems, the directory is called <code class="docutils literal notranslate"><span class="pre">dimmX</span></code>.</p>
</dd>
<dt class="label" id="f6"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>There are also some <code class="docutils literal notranslate"><span class="pre">power</span></code> directories and <code class="docutils literal notranslate"><span class="pre">subsystem</span></code>
symlinks inside the sysfs mapping that are automatically created by
the sysfs subsystem. Currently, they serve no purpose.</p>
</dd>
</dl>
</section>
<section id="csrowx-directories">
<h3><code class="docutils literal notranslate"><span class="pre">csrowX</span></code> directories<a class="headerlink" href="#csrowx-directories" title="Permalink to this headline">¶</a></h3>
<p>When CONFIG_EDAC_LEGACY_SYSFS is enabled, sysfs will contain the <code class="docutils literal notranslate"><span class="pre">csrowX</span></code>
directories. As this API doesn’t work properly for Rambus, FB-DIMMs and
modern Intel Memory Controllers, this is being deprecated in favor of
<code class="docutils literal notranslate"><span class="pre">dimmX</span></code> directories.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">csrowX</span></code> directories are EDAC control and attribute files for
this <code class="docutils literal notranslate"><span class="pre">X</span></code> instance of csrow:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ue_count</span></code> - Total Uncorrectable Errors count attribute file</p>
<blockquote>
<div><p>This attribute file displays the total count of uncorrectable
errors that have occurred on this csrow. If panic_on_ue is set
this counter will not have a chance to increment, since EDAC
will panic the system.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ce_count</span></code> - Total Correctable Errors count attribute file</p>
<blockquote>
<div><p>This attribute file displays the total count of correctable
errors that have occurred on this csrow. This count is very
important to examine. CEs provide early indications that a
DIMM is beginning to fail. This count field should be
monitored for non-zero values and report such information
to the system administrator.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_mb</span></code> - Total memory managed by this csrow attribute file</p>
<blockquote>
<div><p>This attribute file displays, in count of megabytes, the memory
that this csrow contains.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem_type</span></code> - Memory Type attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of memory is currently
on this csrow. Normally, either buffered or unbuffered memory.
Examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Registered-DDR</p></li>
<li><p>Unbuffered-DDR</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">edac_mode</span></code> - EDAC Mode of operation attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of Error detection
and correction is being utilized.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dev_type</span></code> - Device type attribute file</p>
<blockquote>
<div><p>This attribute file will display what type of DRAM device is
being utilized on this DIMM.
Examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>x1</p></li>
<li><p>x2</p></li>
<li><p>x4</p></li>
<li><p>x8</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch0_ce_count</span></code> - Channel 0 CE Count attribute file</p>
<blockquote>
<div><p>This attribute file will display the count of CEs on this
DIMM located in channel 0.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch0_ue_count</span></code> - Channel 0 UE Count attribute file</p>
<blockquote>
<div><p>This attribute file will display the count of UEs on this
DIMM located in channel 0.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch0_dimm_label</span></code> - Channel 0 DIMM Label control file</p>
<blockquote>
<div><p>This control file allows this DIMM to have a label assigned
to it. With this label in the module, when errors occur
the output can provide the DIMM label in the system log.
This becomes vital for panic events to isolate the
cause of the UE event.</p>
<p>DIMM Labels must be assigned after booting, with information
that correctly identifies the physical slot with its
silk screen label. This information is currently very
motherboard specific and determination of this information
must occur in userland at this time.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch1_ce_count</span></code> - Channel 1 CE Count attribute file</p>
<blockquote>
<div><p>This attribute file will display the count of CEs on this
DIMM located in channel 1.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch1_ue_count</span></code> - Channel 1 UE Count attribute file</p>
<blockquote>
<div><p>This attribute file will display the count of UEs on this
DIMM located in channel 0.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ch1_dimm_label</span></code> - Channel 1 DIMM Label control file</p>
<blockquote>
<div><p>This control file allows this DIMM to have a label assigned
to it. With this label in the module, when errors occur
the output can provide the DIMM label in the system log.
This becomes vital for panic events to isolate the
cause of the UE event.</p>
<p>DIMM Labels must be assigned after booting, with information
that correctly identifies the physical slot with its
silk screen label. This information is currently very
motherboard specific and determination of this information
must occur in userland at this time.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="system-logging">
<h3>System Logging<a class="headerlink" href="#system-logging" title="Permalink to this headline">¶</a></h3>
<p>If logging for UEs and CEs is enabled, then system logs will contain
information indicating that errors have been detected:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EDAC MC0: CE page 0x283, offset 0xce0, grain 8, syndrome 0x6ec3, row 0, channel 1 &quot;DIMM_B1&quot;: amd76x_edac
EDAC MC0: CE page 0x1e5, offset 0xfb0, grain 8, syndrome 0xb741, row 0, channel 1 &quot;DIMM_B1&quot;: amd76x_edac
</pre></div>
</div>
<p>The structure of the message is:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 75%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Content</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>The memory controller</p></td>
<td><p>MC0</p></td>
</tr>
<tr class="row-odd"><td><p>Error type</p></td>
<td><p>CE</p></td>
</tr>
<tr class="row-even"><td><p>Memory page</p></td>
<td><p>0x283</p></td>
</tr>
<tr class="row-odd"><td><p>Offset in the page</p></td>
<td><p>0xce0</p></td>
</tr>
<tr class="row-even"><td><p>The byte granularity
or resolution of the error</p></td>
<td><p>grain 8</p></td>
</tr>
<tr class="row-odd"><td><p>The error syndrome</p></td>
<td><p>0xb741</p></td>
</tr>
<tr class="row-even"><td><p>Memory row</p></td>
<td><p>row 0</p></td>
</tr>
<tr class="row-odd"><td><p>Memory channel</p></td>
<td><p>channel 1</p></td>
</tr>
<tr class="row-even"><td><p>DIMM label, if set prior</p></td>
<td><p>DIMM B1</p></td>
</tr>
<tr class="row-odd"><td><p>And then an optional, driver-specific
message that may have additional
information.</p></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Both UEs and CEs with no info will lack all but memory controller, error
type, a notice of “no info” and then an optional, driver-specific error
message.</p>
</section>
<section id="pci-bus-parity-detection">
<h3>PCI Bus Parity Detection<a class="headerlink" href="#pci-bus-parity-detection" title="Permalink to this headline">¶</a></h3>
<p>On Header Type 00 devices, the primary status is looked at for any
parity error regardless of whether parity is enabled on the device or
not. (The spec indicates parity is generated in some cases). On Header
Type 01 bridges, the secondary status register is also looked at to see
if parity occurred on the bus on the other side of the bridge.</p>
</section>
<section id="sysfs-configuration">
<h3>Sysfs configuration<a class="headerlink" href="#sysfs-configuration" title="Permalink to this headline">¶</a></h3>
<p>Under <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/edac/pci</span></code> are control and attribute files as
follows:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">check_pci_parity</span></code> - Enable/Disable PCI Parity checking control file</p>
<blockquote>
<div><p>This control file enables or disables the PCI Bus Parity scanning
operation. Writing a 1 to this file enables the scanning. Writing
a 0 to this file disables the scanning.</p>
<p>Enable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1&quot; &gt;/sys/devices/system/edac/pci/check_pci_parity
</pre></div>
</div>
<p>Disable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;0&quot; &gt;/sys/devices/system/edac/pci/check_pci_parity
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">pci_parity_count</span></code> - Parity Count</p>
<blockquote>
<div><p>This attribute file will display the number of parity errors that
have been detected.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="module-parameters">
<h3>Module parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">edac_mc_panic_on_ue</span></code> - Panic on UE control file</p>
<blockquote>
<div><p>An uncorrectable error will cause a machine panic.  This is usually
desirable.  It is a bad idea to continue when an uncorrectable error
occurs - it is indeterminate what was uncorrected and the operating
system context might be so mangled that continuing will lead to further
corruption. If the kernel has MCE configured, then EDAC will never
notice the UE.</p>
<p>LOAD TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module/kernel parameter: edac_mc_panic_on_ue=[0|1]
</pre></div>
</div>
<p>RUN TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1&quot; &gt; /sys/module/edac_core/parameters/edac_mc_panic_on_ue
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">edac_mc_log_ue</span></code> - Log UE control file</p>
<blockquote>
<div><p>Generate kernel messages describing uncorrectable errors.  These errors
are reported through the system message log system.  UE statistics
will be accumulated even when UE logging is disabled.</p>
<p>LOAD TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module/kernel parameter: edac_mc_log_ue=[0|1]
</pre></div>
</div>
<p>RUN TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1&quot; &gt; /sys/module/edac_core/parameters/edac_mc_log_ue
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">edac_mc_log_ce</span></code> - Log CE control file</p>
<blockquote>
<div><p>Generate kernel messages describing correctable errors.  These
errors are reported through the system message log system.
CE statistics will be accumulated even when CE logging is disabled.</p>
<p>LOAD TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module/kernel parameter: edac_mc_log_ce=[0|1]
</pre></div>
</div>
<p>RUN TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1&quot; &gt; /sys/module/edac_core/parameters/edac_mc_log_ce
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">edac_mc_poll_msec</span></code> - Polling period control file</p>
<blockquote>
<div><p>The time period, in milliseconds, for polling for error information.
Too small a value wastes resources.  Too large a value might delay
necessary handling of errors and might loose valuable information for
locating the error.  1000 milliseconds (once each second) is the current
default. Systems which require all the bandwidth they can get, may
increase this.</p>
<p>LOAD TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module/kernel parameter: edac_mc_poll_msec=[0|1]
</pre></div>
</div>
<p>RUN TIME:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1000&quot; &gt; /sys/module/edac_core/parameters/edac_mc_poll_msec
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">panic_on_pci_parity</span></code> - Panic on PCI PARITY Error</p>
<blockquote>
<div><p>This control file enables or disables panicking when a parity
error has been detected.</p>
<p>module/kernel parameter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>edac_panic_on_pci_pe=[0|1]
</pre></div>
</div>
<p>Enable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1&quot; &gt; /sys/module/edac_core/parameters/edac_panic_on_pci_pe
</pre></div>
</div>
<p>Disable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;0&quot; &gt; /sys/module/edac_core/parameters/edac_panic_on_pci_pe
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="edac-device-type">
<h3>EDAC device type<a class="headerlink" href="#edac-device-type" title="Permalink to this headline">¶</a></h3>
<p>In the header file, edac_pci.h, there is a series of edac_device structures
and APIs for the EDAC_DEVICE.</p>
<p>User space access to an edac_device is through the sysfs interface.</p>
<p>At the location <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/edac</span></code> (sysfs) new edac_device devices
will appear.</p>
<p>There is a three level tree beneath the above <code class="docutils literal notranslate"><span class="pre">edac</span></code> directory. For example,
the <code class="docutils literal notranslate"><span class="pre">test_device_edac</span></code> device (found at the <a class="reference external" href="http://bluesmoke.sourceforget.net">http://bluesmoke.sourceforget.net</a>
website) installs itself as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/test-instance
</pre></div>
</div>
<p>in this directory are various controls, a symlink and one or more <code class="docutils literal notranslate"><span class="pre">instance</span></code>
directories.</p>
<p>The standard default controls are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>log_ce</p></td>
<td><p>boolean to log CE events</p></td>
</tr>
<tr class="row-even"><td><p>log_ue</p></td>
<td><p>boolean to log UE events</p></td>
</tr>
<tr class="row-odd"><td><p>panic_on_ue</p></td>
<td><p>boolean to <code class="docutils literal notranslate"><span class="pre">panic</span></code> the system if an UE is encountered
(default off, can be set true via startup script)</p></td>
</tr>
<tr class="row-even"><td><p>poll_msec</p></td>
<td><p>time period between POLL cycles for events</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The test_device_edac device adds at least one of its own custom control:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>test_bits</p></td>
<td><p>which in the current test driver does nothing but
show how it is installed. A ported driver can
add one or more such controls and/or attributes
for specific uses.
One out-of-tree driver uses controls here to allow
for ERROR INJECTION operations to hardware
injection registers</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The symlink points to the ‘struct dev’ that is registered for this edac_device.</p>
</section>
<section id="instances">
<h3>Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>One or more instance directories are present. For the <code class="docutils literal notranslate"><span class="pre">test_device_edac</span></code>
case:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>test-instance0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In this directory there are two default counter attributes, which are totals of
counter in deeper subdirectories.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ce_count</p></td>
<td><p>total of CE events of subdirectories</p></td>
</tr>
<tr class="row-even"><td><p>ue_count</p></td>
<td><p>total of UE events of subdirectories</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="blocks">
<h3>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<p>At the lowest directory level is the <code class="docutils literal notranslate"><span class="pre">block</span></code> directory. There can be 0, 1
or more blocks specified in each instance:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>test-block0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In this directory the default attributes are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ce_count</p></td>
<td><p>which is counter of CE events for this <code class="docutils literal notranslate"><span class="pre">block</span></code>
of hardware being monitored</p></td>
</tr>
<tr class="row-even"><td><p>ue_count</p></td>
<td><p>which is counter of UE events for this <code class="docutils literal notranslate"><span class="pre">block</span></code>
of hardware being monitored</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">test_device_edac</span></code> device adds 4 attributes and 1 control:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>test-block-bits-0</p></td>
<td><p>for every POLL cycle this counter
is incremented</p></td>
</tr>
<tr class="row-even"><td><p>test-block-bits-1</p></td>
<td><p>every 10 cycles, this counter is bumped once,
and test-block-bits-0 is set to 0</p></td>
</tr>
<tr class="row-odd"><td><p>test-block-bits-2</p></td>
<td><p>every 100 cycles, this counter is bumped once,
and test-block-bits-1 is set to 0</p></td>
</tr>
<tr class="row-even"><td><p>test-block-bits-3</p></td>
<td><p>every 1000 cycles, this counter is bumped once,
and test-block-bits-2 is set to 0</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>reset-counters</p></td>
<td><p>writing ANY thing to this control will
reset all the above counters.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Use of the <code class="docutils literal notranslate"><span class="pre">test_device_edac</span></code> driver should enable any others to create their own
unique drivers for their hardware systems.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">test_device_edac</span></code> sample driver is located at the
<a class="reference external" href="http://bluesmoke.sourceforge.net">http://bluesmoke.sourceforge.net</a> project site for EDAC.</p>
</section>
<section id="usage-of-edac-apis-on-nehalem-and-newer-intel-cpus">
<h3>Usage of EDAC APIs on Nehalem and newer Intel CPUs<a class="headerlink" href="#usage-of-edac-apis-on-nehalem-and-newer-intel-cpus" title="Permalink to this headline">¶</a></h3>
<p>On older Intel architectures, the memory controller was part of the North
Bridge chipset. Nehalem, Sandy Bridge, Ivy Bridge, Haswell, Sky Lake and
newer Intel architectures integrated an enhanced version of the memory
controller (MC) inside the CPUs.</p>
<p>This chapter will cover the differences of the enhanced memory controllers
found on newer Intel CPUs, such as <code class="docutils literal notranslate"><span class="pre">i7core_edac</span></code>, <code class="docutils literal notranslate"><span class="pre">sb_edac</span></code> and
<code class="docutils literal notranslate"><span class="pre">sbx_edac</span></code> drivers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Xeon E7 processor families use a separate chip for the memory
controller, called Intel Scalable Memory Buffer. This section doesn’t
apply for such families.</p>
</div>
<ol class="arabic">
<li><p>There is one Memory Controller per Quick Patch Interconnect
(QPI). At the driver, the term “socket” means one QPI. This is
associated with a physical CPU socket.</p>
<p>Each MC have 3 physical read channels, 3 physical write channels and
3 logic channels. The driver currently sees it as just 3 channels.
Each channel can have up to 3 DIMMs.</p>
<p>The minimum known unity is DIMMs. There are no information about csrows.
As EDAC API maps the minimum unity is csrows, the driver sequentially
maps channel/DIMM into different csrows.</p>
<p>For example, supposing the following layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ch0 phy rd0, wr0 (0x063f4031): 2 ranks, UDIMMs
  dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
  dimm 1 1024 Mb offset: 4, bank: 8, rank: 1, row: 0x4000, col: 0x400
Ch1 phy rd1, wr1 (0x063f4031): 2 ranks, UDIMMs
  dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
Ch2 phy rd3, wr3 (0x063f4031): 2 ranks, UDIMMs
  dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
</pre></div>
</div>
<p>The driver will map it as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>csrow0: channel 0, dimm0
csrow1: channel 0, dimm1
csrow2: channel 1, dimm0
csrow3: channel 2, dimm0
</pre></div>
</div>
<p>exports one DIMM per csrow.</p>
<p>Each QPI is exported as a different memory controller.</p>
</li>
<li><p>The MC has the ability to inject errors to test drivers. The drivers
implement this functionality via some error injection nodes:</p>
<p>For injecting a memory error, there are some sysfs nodes, under
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/edac/mc/mc?/</span></code>:</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">inject_addrmatch/*</span></code>:</dt><dd><p>Controls the error injection mask register. It is possible to specify
several characteristics of the address to match an error code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dimm = the affected dimm. Numbers are relative to a channel;
rank = the memory rank;
channel = the channel that will generate an error;
bank = the affected bank;
page = the page address;
column (or col) = the address column.
</pre></div>
</div>
<p>each of the above values can be set to “any” to match any valid value.</p>
<p>At driver init, all values are set to any.</p>
<p>For example, to generate an error at rank 1 of dimm 2, for any channel,
any bank, any page, any column:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        echo 2 &gt;/sys/devices/system/edac/mc/mc0/inject_addrmatch/dimm
        echo 1 &gt;/sys/devices/system/edac/mc/mc0/inject_addrmatch/rank

To return to the default behaviour of matching any, you can do::

        echo any &gt;/sys/devices/system/edac/mc/mc0/inject_addrmatch/dimm
        echo any &gt;/sys/devices/system/edac/mc/mc0/inject_addrmatch/rank
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">inject_eccmask</span></code>:</dt><dd><p>specifies what bits will have troubles,</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">inject_section</span></code>:</dt><dd><p>specifies what ECC cache section will get the error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>3 for both
2 for the highest
1 for the lowest
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">inject_type</span></code>:</dt><dd><p>specifies the type of error, being a combination of the following bits:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bit 0 - repeat
bit 1 - ecc
bit 2 - parity
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">inject_enable</span></code>:</dt><dd><p>starts the error generation when something different than 0 is written.</p>
</dd>
</dl>
</li>
</ul>
<p>All inject vars can be read. root permission is needed for write.</p>
<p>Datasheet states that the error will only be generated after a write on an
address that matches inject_addrmatch. It seems, however, that reading will
also produce an error.</p>
<p>For example, the following code will generate an error for any write access
at socket 0, on any DIMM/address on channel 2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 2 &gt;/sys/devices/system/edac/mc/mc0/inject_addrmatch/channel
echo 2 &gt;/sys/devices/system/edac/mc/mc0/inject_type
echo 64 &gt;/sys/devices/system/edac/mc/mc0/inject_eccmask
echo 3 &gt;/sys/devices/system/edac/mc/mc0/inject_section
echo 1 &gt;/sys/devices/system/edac/mc/mc0/inject_enable
dd if=/dev/mem of=/dev/null seek=16k bs=4k count=1 &gt;&amp; /dev/null
</pre></div>
</div>
<p>For socket 1, it is needed to replace “mc0” by “mc1” at the above
commands.</p>
<p>The generated error message will look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EDAC MC0: UE row 0, channel-a= 0 channel-b= 0 labels &quot;-&quot;: NON_FATAL (addr = 0x0075b980, socket=0, Dimm=0, Channel=2, syndrome=0x00000040, count=1, Err=8c0000400001009f:4000080482 (read error: read ECC error))
</pre></div>
</div>
</li>
<li><p>Corrected Error memory register counters</p>
<p>Those newer MCs have some registers to count memory errors. The driver
uses those registers to report Corrected Errors on devices with Registered
DIMMs.</p>
<p>However, those counters don’t work with Unregistered DIMM. As the chipset
offers some counters that also work with UDIMMs (but with a worse level of
granularity than the default ones), the driver exposes those registers for
UDIMM memories.</p>
<p>They can be read by looking at the contents of <code class="docutils literal notranslate"><span class="pre">all_channel_counts/</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ for i in /sys/devices/system/edac/mc/mc0/all_channel_counts/*; do echo $i; cat $i; done
   /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm0
   0
   /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm1
   0
   /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm2
   0
</pre></div>
</div>
<p>What happens here is that errors on different csrows, but at the same
dimm number will increment the same counter.
So, in this memory mapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>csrow0: channel 0, dimm0
csrow1: channel 0, dimm1
csrow2: channel 1, dimm0
csrow3: channel 2, dimm0
</pre></div>
</div>
<p>The hardware will increment udimm0 for an error at the first dimm at either
csrow0, csrow2  or csrow3;</p>
<p>The hardware will increment udimm1 for an error at the second dimm at either
csrow0, csrow2  or csrow3;</p>
<p>The hardware will increment udimm2 for an error at the third dimm at either
csrow0, csrow2  or csrow3;</p>
</li>
<li><p>Standard error counters</p>
<p>The standard error counters are generated when an mcelog error is received
by the driver. Since, with UDIMM, this is counted by software, it is
possible that some errors could be lost. With RDIMM’s, they display the
contents of the registers</p>
</li>
</ol>
</section>
<section id="reference-documents-used-on-amd64-edac">
<h3>Reference documents used on <code class="docutils literal notranslate"><span class="pre">amd64_edac</span></code><a class="headerlink" href="#reference-documents-used-on-amd64-edac" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">amd64_edac</span></code> module is based on the following documents
(available from <a class="reference external" href="http://support.amd.com/en-us/search/tech-docs">http://support.amd.com/en-us/search/tech-docs</a>):</p>
<ol class="arabic simple">
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide for AMD Athlon 64 and AMD
Opteron Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>26094</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.26</p>
</dd>
<dt class="field-even">Link</dt>
<dd class="field-even"><p><a class="reference external" href="http://support.amd.com/TechDocs/26094.PDF">http://support.amd.com/TechDocs/26094.PDF</a></p>
</dd>
</dl>
</li>
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide for AMD NPT Family 0Fh
Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>32559</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.00</p>
</dd>
<dt class="field-even">Issue Date</dt>
<dd class="field-even"><p>May 2006</p>
</dd>
<dt class="field-odd">Link</dt>
<dd class="field-odd"><p><a class="reference external" href="http://support.amd.com/TechDocs/32559.pdf">http://support.amd.com/TechDocs/32559.pdf</a></p>
</dd>
</dl>
</li>
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide (BKDG) For AMD Family 10h
Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>31116</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.00</p>
</dd>
<dt class="field-even">Issue Date</dt>
<dd class="field-even"><p>September 07, 2007</p>
</dd>
<dt class="field-odd">Link</dt>
<dd class="field-odd"><p><a class="reference external" href="http://support.amd.com/TechDocs/31116.pdf">http://support.amd.com/TechDocs/31116.pdf</a></p>
</dd>
</dl>
</li>
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide (BKDG) for AMD Family 15h
Models 30h-3Fh Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>49125</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.06</p>
</dd>
<dt class="field-even">Issue Date</dt>
<dd class="field-even"><p>2/12/2015 (latest release)</p>
</dd>
<dt class="field-odd">Link</dt>
<dd class="field-odd"><p><a class="reference external" href="http://support.amd.com/TechDocs/49125_15h_Models_30h-3Fh_BKDG.pdf">http://support.amd.com/TechDocs/49125_15h_Models_30h-3Fh_BKDG.pdf</a></p>
</dd>
</dl>
</li>
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide (BKDG) for AMD Family 15h
Models 60h-6Fh Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>50742</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.01</p>
</dd>
<dt class="field-even">Issue Date</dt>
<dd class="field-even"><p>7/23/2015 (latest release)</p>
</dd>
<dt class="field-odd">Link</dt>
<dd class="field-odd"><p><a class="reference external" href="http://support.amd.com/TechDocs/50742_15h_Models_60h-6Fh_BKDG.pdf">http://support.amd.com/TechDocs/50742_15h_Models_60h-6Fh_BKDG.pdf</a></p>
</dd>
</dl>
</li>
<li><dl class="field-list simple">
<dt class="field-odd">Title</dt>
<dd class="field-odd"><p>BIOS and Kernel Developer’s Guide (BKDG) for AMD Family 16h
Models 00h-0Fh Processors</p>
</dd>
<dt class="field-even">AMD publication #</dt>
<dd class="field-even"><p>48751</p>
</dd>
<dt class="field-odd">Revision</dt>
<dd class="field-odd"><p>3.03</p>
</dd>
<dt class="field-even">Issue Date</dt>
<dd class="field-even"><p>2/23/2015 (latest release)</p>
</dd>
<dt class="field-odd">Link</dt>
<dd class="field-odd"><p><a class="reference external" href="http://support.amd.com/TechDocs/48751_16h_bkdg.pdf">http://support.amd.com/TechDocs/48751_16h_bkdg.pdf</a></p>
</dd>
</dl>
</li>
</ol>
<section id="credits">
<h4>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Written by Doug Thompson &lt;<a class="reference external" href="mailto:dougthompson&#37;&#52;&#48;xmission&#46;com">dougthompson<span>&#64;</span>xmission<span>&#46;</span>com</a>&gt;</p>
<ul>
<li><p>7 Dec 2005</p></li>
<li><p>17 Jul 2007 Updated</p></li>
</ul>
</li>
<li><p>© Mauro Carvalho Chehab</p>
<ul>
<li><p>05 Aug 2009 Nehalem interface</p></li>
<li><p>26 Oct 2016 Converted to ReST and cleanups at the Nehalem section</p></li>
</ul>
</li>
<li><p>EDAC authors/maintainers:</p>
<ul>
<li><p>Doug Thompson, Dave Jiang, Dave Peterson et al,</p></li>
<li><p>Mauro Carvalho Chehab</p></li>
<li><p>Borislav Petkov</p></li>
<li><p>original author: Thayne Harbaugh</p></li>
</ul>
</li>
</ul>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Reliability, Availability and Serviceability</a><ul>
<li><a class="reference internal" href="#ras-concepts">RAS concepts</a><ul>
<li><a class="reference internal" href="#improving-ras">Improving RAS</a></li>
<li><a class="reference internal" href="#types-of-errors">Types of errors</a></li>
<li><a class="reference internal" href="#identifying-a-bad-hardware-component">Identifying a bad hardware component</a></li>
<li><a class="reference internal" href="#ecc-memory">ECC memory</a></li>
</ul>
</li>
<li><a class="reference internal" href="#edac-error-detection-and-correction">EDAC - Error Detection And Correction</a><ul>
<li><a class="reference internal" href="#purpose">Purpose</a></li>
<li><a class="reference internal" href="#memory">Memory</a></li>
<li><a class="reference internal" href="#other-hardware-elements">Other hardware elements</a></li>
<li><a class="reference internal" href="#pci-bus-scanning">PCI bus scanning</a></li>
<li><a class="reference internal" href="#versioning">Versioning</a></li>
<li><a class="reference internal" href="#loading">Loading</a></li>
<li><a class="reference internal" href="#sysfs-interface">Sysfs interface</a></li>
<li><a class="reference internal" href="#memory-controller-mc-model">Memory Controller (mc) Model</a></li>
<li><a class="reference internal" href="#mcx-directories"><code class="docutils literal notranslate"><span class="pre">mcX</span></code> directories</a></li>
<li><a class="reference internal" href="#dimmx-or-rankx-directories"><code class="docutils literal notranslate"><span class="pre">dimmX</span></code> or <code class="docutils literal notranslate"><span class="pre">rankX</span></code> directories</a></li>
<li><a class="reference internal" href="#csrowx-directories"><code class="docutils literal notranslate"><span class="pre">csrowX</span></code> directories</a></li>
<li><a class="reference internal" href="#system-logging">System Logging</a></li>
<li><a class="reference internal" href="#pci-bus-parity-detection">PCI Bus Parity Detection</a></li>
<li><a class="reference internal" href="#sysfs-configuration">Sysfs configuration</a></li>
<li><a class="reference internal" href="#module-parameters">Module parameters</a></li>
<li><a class="reference internal" href="#edac-device-type">EDAC device type</a></li>
<li><a class="reference internal" href="#instances">Instances</a></li>
<li><a class="reference internal" href="#blocks">Blocks</a></li>
<li><a class="reference internal" href="#usage-of-edac-apis-on-nehalem-and-newer-intel-cpus">Usage of EDAC APIs on Nehalem and newer Intel CPUs</a></li>
<li><a class="reference internal" href="#reference-documents-used-on-amd64-edac">Reference documents used on <code class="docutils literal notranslate"><span class="pre">amd64_edac</span></code></a><ul>
<li><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/admin-guide/ras.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/admin-guide/ras.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>