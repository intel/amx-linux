
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Control Groups &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Block IO Controller" href="blkio-controller.html" />
    <link rel="prev" title="Control Groups version 1" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="control-groups">
<h1>Control Groups<a class="headerlink" href="#control-groups" title="Permalink to this headline">¶</a></h1>
<p>Written by Paul Menage &lt;<a class="reference external" href="mailto:menage&#37;&#52;&#48;google&#46;com">menage<span>&#64;</span>google<span>&#46;</span>com</a>&gt; based on
<a class="reference internal" href="cpusets.html"><span class="doc">CPUSETS</span></a></p>
<p>Original copyright statements from <a class="reference internal" href="cpusets.html"><span class="doc">CPUSETS</span></a>:</p>
<p>Portions Copyright (C) 2004 BULL SA.</p>
<p>Portions Copyright (c) 2004-2006 Silicon Graphics, Inc.</p>
<p>Modified by Paul Jackson &lt;<a class="reference external" href="mailto:pj&#37;&#52;&#48;sgi&#46;com">pj<span>&#64;</span>sgi<span>&#46;</span>com</a>&gt;</p>
<p>Modified by Christoph Lameter &lt;<a class="reference external" href="mailto:cl&#37;&#52;&#48;linux&#46;com">cl<span>&#64;</span>linux<span>&#46;</span>com</a>&gt;</p>
<section id="id1">
<h2>1. Control Groups<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<section id="what-are-cgroups">
<h3>1.1 What are cgroups ?<a class="headerlink" href="#what-are-cgroups" title="Permalink to this headline">¶</a></h3>
<p>Control Groups provide a mechanism for aggregating/partitioning sets of
tasks, and all their future children, into hierarchical groups with
specialized behaviour.</p>
<p>Definitions:</p>
<p>A <em>cgroup</em> associates a set of tasks with a set of parameters for one
or more subsystems.</p>
<p>A <em>subsystem</em> is a module that makes use of the task grouping
facilities provided by cgroups to treat groups of tasks in
particular ways. A subsystem is typically a “resource controller” that
schedules a resource or applies per-cgroup limits, but it may be
anything that wants to act on a group of processes, e.g. a
virtualization subsystem.</p>
<p>A <em>hierarchy</em> is a set of cgroups arranged in a tree, such that
every task in the system is in exactly one of the cgroups in the
hierarchy, and a set of subsystems; each subsystem has system-specific
state attached to each cgroup in the hierarchy.  Each hierarchy has
an instance of the cgroup virtual filesystem associated with it.</p>
<p>At any one time there may be multiple active hierarchies of task
cgroups. Each hierarchy is a partition of all tasks in the system.</p>
<p>User-level code may create and destroy cgroups by name in an
instance of the cgroup virtual file system, specify and query to
which cgroup a task is assigned, and list the task PIDs assigned to
a cgroup. Those creations and assignments only affect the hierarchy
associated with that instance of the cgroup file system.</p>
<p>On their own, the only use for cgroups is for simple job
tracking. The intention is that other subsystems hook into the generic
cgroup support to provide new attributes for cgroups, such as
accounting/limiting the resources which processes in a cgroup can
access. For example, cpusets (see <a class="reference internal" href="cpusets.html"><span class="doc">CPUSETS</span></a>) allow
you to associate a set of CPUs and a set of memory nodes with the
tasks in each cgroup.</p>
</section>
<section id="why-are-cgroups-needed">
<h3>1.2 Why are cgroups needed ?<a class="headerlink" href="#why-are-cgroups-needed" title="Permalink to this headline">¶</a></h3>
<p>There are multiple efforts to provide process aggregations in the
Linux kernel, mainly for resource-tracking purposes. Such efforts
include cpusets, CKRM/ResGroups, UserBeanCounters, and virtual server
namespaces. These all require the basic notion of a
grouping/partitioning of processes, with newly forked processes ending
up in the same group (cgroup) as their parent process.</p>
<p>The kernel cgroup patch provides the minimum essential kernel
mechanisms required to efficiently implement such groups. It has
minimal impact on the system fast paths, and provides hooks for
specific subsystems such as cpusets to provide additional behaviour as
desired.</p>
<p>Multiple hierarchy support is provided to allow for situations where
the division of tasks into cgroups is distinctly different for
different subsystems - having parallel hierarchies allows each
hierarchy to be a natural division of tasks, without having to handle
complex combinations of tasks that would be present if several
unrelated subsystems needed to be forced into the same tree of
cgroups.</p>
<p>At one extreme, each resource controller or subsystem could be in a
separate hierarchy; at the other extreme, all subsystems
would be attached to the same hierarchy.</p>
<p>As an example of a scenario (originally proposed by <a class="reference external" href="mailto:vatsa&#37;&#52;&#48;in&#46;ibm&#46;com">vatsa<span>&#64;</span>in<span>&#46;</span>ibm<span>&#46;</span>com</a>)
that can benefit from multiple hierarchies, consider a large
university server with various users - students, professors, system
tasks etc. The resource planning for this server could be along the
following lines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU :          &quot;Top cpuset&quot;
                /       \
        CPUSet1         CPUSet2
           |               |
        (Professors)    (Students)

        In addition (system tasks) are attached to topcpuset (so
        that they can run anywhere) with a limit of 20%

Memory : Professors (50%), Students (30%), system (20%)

Disk : Professors (50%), Students (30%), system (20%)

Network : WWW browsing (20%), Network File System (60%), others (20%)
                        / \
        Professors (15%)  students (5%)
</pre></div>
</div>
<p>Browsers like Firefox/Lynx go into the WWW network class, while (k)nfsd goes
into the NFS network class.</p>
<p>At the same time Firefox/Lynx will share an appropriate CPU/Memory class
depending on who launched it (prof/student).</p>
<p>With the ability to classify tasks differently for different resources
(by putting those resource subsystems in different hierarchies),
the admin can easily set up a script which receives exec notifications
and depending on who is launching the browser he can:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo browser_pid &gt; /sys/fs/cgroup/&lt;restype&gt;/&lt;userclass&gt;/tasks
</pre></div>
</div>
<p>With only a single hierarchy, he now would potentially have to create
a separate cgroup for every browser launched and associate it with
appropriate network and other resource class.  This may lead to
proliferation of such cgroups.</p>
<p>Also let’s say that the administrator would like to give enhanced network
access temporarily to a student’s browser (since it is night and the user
wants to do online gaming :))  OR give one of the student’s simulation
apps enhanced CPU power.</p>
<p>With ability to write PIDs directly to resource classes, it’s just a
matter of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo pid &gt; /sys/fs/cgroup/network/&lt;new_class&gt;/tasks
(after some time)
# echo pid &gt; /sys/fs/cgroup/network/&lt;orig_class&gt;/tasks
</pre></div>
</div>
<p>Without this ability, the administrator would have to split the cgroup into
multiple separate ones and then associate the new cgroups with the
new resource classes.</p>
</section>
<section id="how-are-cgroups-implemented">
<h3>1.3 How are cgroups implemented ?<a class="headerlink" href="#how-are-cgroups-implemented" title="Permalink to this headline">¶</a></h3>
<p>Control Groups extends the kernel as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>Each task in the system has a reference-counted pointer to a
css_set.</p></li>
<li><p>A css_set contains a set of reference-counted pointers to
cgroup_subsys_state objects, one for each cgroup subsystem
registered in the system. There is no direct link from a task to
the cgroup of which it’s a member in each hierarchy, but this
can be determined by following pointers through the
cgroup_subsys_state objects. This is because accessing the
subsystem state is something that’s expected to happen frequently
and in performance-critical code, whereas operations that require a
task’s actual cgroup assignments (in particular, moving between
cgroups) are less common. A linked list runs through the cg_list
field of each task_struct using the css_set, anchored at
css_set-&gt;tasks.</p></li>
<li><p>A cgroup hierarchy filesystem can be mounted for browsing and
manipulation from user space.</p></li>
<li><p>You can list all the tasks (by PID) attached to any cgroup.</p></li>
</ul>
</div></blockquote>
<p>The implementation of cgroups requires a few, simple hooks
into the rest of the kernel, none in performance-critical paths:</p>
<blockquote>
<div><ul class="simple">
<li><p>in init/main.c, to initialize the root cgroups and initial
css_set at system boot.</p></li>
<li><p>in fork and exit, to attach and detach a task from its css_set.</p></li>
</ul>
</div></blockquote>
<p>In addition, a new file system of type “cgroup” may be mounted, to
enable browsing and modifying the cgroups presently known to the
kernel.  When mounting a cgroup hierarchy, you may specify a
comma-separated list of subsystems to mount as the filesystem mount
options.  By default, mounting the cgroup filesystem attempts to
mount a hierarchy containing all registered subsystems.</p>
<p>If an active hierarchy with exactly the same set of subsystems already
exists, it will be reused for the new mount. If no existing hierarchy
matches, and any of the requested subsystems are in use in an existing
hierarchy, the mount will fail with -EBUSY. Otherwise, a new hierarchy
is activated, associated with the requested subsystems.</p>
<p>It’s not currently possible to bind a new subsystem to an active
cgroup hierarchy, or to unbind a subsystem from an active cgroup
hierarchy. This may be possible in future, but is fraught with nasty
error-recovery issues.</p>
<p>When a cgroup filesystem is unmounted, if there are any
child cgroups created below the top-level cgroup, that hierarchy
will remain active even though unmounted; if there are no
child cgroups then the hierarchy will be deactivated.</p>
<p>No new system calls are added for cgroups - all support for
querying and modifying cgroups is via this cgroup file system.</p>
<p>Each task under /proc has an added file named ‘cgroup’ displaying,
for each active hierarchy, the subsystem names and the cgroup name
as the path relative to the root of the cgroup file system.</p>
<p>Each cgroup is represented by a directory in the cgroup file system
containing the following files describing that cgroup:</p>
<blockquote>
<div><ul class="simple">
<li><p>tasks: list of tasks (by PID) attached to that cgroup.  This list
is not guaranteed to be sorted.  Writing a thread ID into this file
moves the thread into this cgroup.</p></li>
<li><p>cgroup.procs: list of thread group IDs in the cgroup.  This list is
not guaranteed to be sorted or free of duplicate TGIDs, and userspace
should sort/uniquify the list if this property is required.
Writing a thread group ID into this file moves all threads in that
group into this cgroup.</p></li>
<li><p>notify_on_release flag: run the release agent on exit?</p></li>
<li><p>release_agent: the path to use for release notifications (this file
exists in the top cgroup only)</p></li>
</ul>
</div></blockquote>
<p>Other subsystems such as cpusets may add additional files in each
cgroup dir.</p>
<p>New cgroups are created using the mkdir system call or shell
command.  The properties of a cgroup, such as its flags, are
modified by writing to the appropriate file in that cgroups
directory, as listed above.</p>
<p>The named hierarchical structure of nested cgroups allows partitioning
a large system into nested, dynamically changeable, “soft-partitions”.</p>
<p>The attachment of each task, automatically inherited at fork by any
children of that task, to a cgroup allows organizing the work load
on a system into related sets of tasks.  A task may be re-attached to
any other cgroup, if allowed by the permissions on the necessary
cgroup file system directories.</p>
<p>When a task is moved from one cgroup to another, it gets a new
css_set pointer - if there’s an already existing css_set with the
desired collection of cgroups then that group is reused, otherwise a new
css_set is allocated. The appropriate existing css_set is located by
looking into a hash table.</p>
<p>To allow access from a cgroup to the css_sets (and hence tasks)
that comprise it, a set of cg_cgroup_link objects form a lattice;
each cg_cgroup_link is linked into a list of cg_cgroup_links for
a single cgroup on its cgrp_link_list field, and a list of
cg_cgroup_links for a single css_set on its cg_link_list.</p>
<p>Thus the set of tasks in a cgroup can be listed by iterating over
each css_set that references the cgroup, and sub-iterating over
each css_set’s task set.</p>
<p>The use of a Linux virtual file system (vfs) to represent the
cgroup hierarchy provides for a familiar permission and name space
for cgroups, with a minimum of additional kernel code.</p>
</section>
<section id="what-does-notify-on-release-do">
<h3>1.4 What does notify_on_release do ?<a class="headerlink" href="#what-does-notify-on-release-do" title="Permalink to this headline">¶</a></h3>
<p>If the notify_on_release flag is enabled (1) in a cgroup, then
whenever the last task in the cgroup leaves (exits or attaches to
some other cgroup) and the last child cgroup of that cgroup
is removed, then the kernel runs the command specified by the contents
of the “release_agent” file in that hierarchy’s root directory,
supplying the pathname (relative to the mount point of the cgroup
file system) of the abandoned cgroup.  This enables automatic
removal of abandoned cgroups.  The default value of
notify_on_release in the root cgroup at system boot is disabled
(0).  The default value of other cgroups at creation is the current
value of their parents’ notify_on_release settings. The default value of
a cgroup hierarchy’s release_agent path is empty.</p>
</section>
<section id="what-does-clone-children-do">
<h3>1.5 What does clone_children do ?<a class="headerlink" href="#what-does-clone-children-do" title="Permalink to this headline">¶</a></h3>
<p>This flag only affects the cpuset controller. If the clone_children
flag is enabled (1) in a cgroup, a new cpuset cgroup will copy its
configuration from the parent during initialization.</p>
</section>
<section id="how-do-i-use-cgroups">
<h3>1.6 How do I use cgroups ?<a class="headerlink" href="#how-do-i-use-cgroups" title="Permalink to this headline">¶</a></h3>
<p>To start a new job that is to be contained within a cgroup, using
the “cpuset” cgroup subsystem, the steps are something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1) mount -t tmpfs cgroup_root /sys/fs/cgroup
2) mkdir /sys/fs/cgroup/cpuset
3) mount -t cgroup -ocpuset cpuset /sys/fs/cgroup/cpuset
4) Create the new cgroup by doing mkdir&#39;s and write&#39;s (or echo&#39;s) in
   the /sys/fs/cgroup/cpuset virtual file system.
5) Start a task that will be the &quot;founding father&quot; of the new job.
6) Attach that task to the new cgroup by writing its PID to the
   /sys/fs/cgroup/cpuset tasks file for that cgroup.
7) fork, exec or clone the job tasks from this founding father task.
</pre></div>
</div>
<p>For example, the following sequence of commands will setup a cgroup
named “Charlie”, containing just CPUs 2 and 3, and Memory Node 1,
and then start a subshell ‘sh’ in that cgroup:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t tmpfs cgroup_root /sys/fs/cgroup
mkdir /sys/fs/cgroup/cpuset
mount -t cgroup cpuset -ocpuset /sys/fs/cgroup/cpuset
cd /sys/fs/cgroup/cpuset
mkdir Charlie
cd Charlie
/bin/echo 2-3 &gt; cpuset.cpus
/bin/echo 1 &gt; cpuset.mems
/bin/echo $$ &gt; tasks
sh
# The subshell &#39;sh&#39; is now running in cgroup Charlie
# The next line should display &#39;/Charlie&#39;
cat /proc/self/cgroup
</pre></div>
</div>
</section>
</section>
<section id="usage-examples-and-syntax">
<h2>2. Usage Examples and Syntax<a class="headerlink" href="#usage-examples-and-syntax" title="Permalink to this headline">¶</a></h2>
<section id="basic-usage">
<h3>2.1 Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>Creating, modifying, using cgroups can be done through the cgroup
virtual filesystem.</p>
<p>To mount a cgroup hierarchy with all available subsystems, type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t cgroup xxx /sys/fs/cgroup
</pre></div>
</div>
<p>The “xxx” is not interpreted by the cgroup code, but will appear in
/proc/mounts so may be any useful identifying string that you like.</p>
<p>Note: Some subsystems do not work without some user input first.  For instance,
if cpusets are enabled the user will have to populate the cpus and mems files
for each new cgroup created before that group can be used.</p>
<p>As explained in section <cite>1.2 Why are cgroups needed?</cite> you should create
different hierarchies of cgroups for each single resource or group of
resources you want to control. Therefore, you should mount a tmpfs on
/sys/fs/cgroup and create directories for each cgroup resource or resource
group:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t tmpfs cgroup_root /sys/fs/cgroup
# mkdir /sys/fs/cgroup/rg1
</pre></div>
</div>
<p>To mount a cgroup hierarchy with just the cpuset and memory
subsystems, type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t cgroup -o cpuset,memory hier1 /sys/fs/cgroup/rg1
</pre></div>
</div>
<p>While remounting cgroups is currently supported, it is not recommend
to use it. Remounting allows changing bound subsystems and
release_agent. Rebinding is hardly useful as it only works when the
hierarchy is empty and release_agent itself should be replaced with
conventional fsnotify. The support for remounting will be removed in
the future.</p>
<p>To Specify a hierarchy’s release_agent:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t cgroup -o cpuset,release_agent=&quot;/sbin/cpuset_release_agent&quot; \
  xxx /sys/fs/cgroup/rg1
</pre></div>
</div>
<p>Note that specifying ‘release_agent’ more than once will return failure.</p>
<p>Note that changing the set of subsystems is currently only supported
when the hierarchy consists of a single (root) cgroup. Supporting
the ability to arbitrarily bind/unbind subsystems from an existing
cgroup hierarchy is intended to be implemented in the future.</p>
<p>Then under /sys/fs/cgroup/rg1 you can find a tree that corresponds to the
tree of the cgroups in the system. For instance, /sys/fs/cgroup/rg1
is the cgroup that holds the whole system.</p>
<p>If you want to change the value of release_agent:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;/sbin/new_release_agent&quot; &gt; /sys/fs/cgroup/rg1/release_agent
</pre></div>
</div>
<p>It can also be changed via remount.</p>
<p>If you want to create a new cgroup under /sys/fs/cgroup/rg1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cd /sys/fs/cgroup/rg1
# mkdir my_cgroup
</pre></div>
</div>
<p>Now you want to do something with this cgroup:</p>
<blockquote>
<div><p># cd my_cgroup</p>
</div></blockquote>
<p>In this directory you can find several files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls
cgroup.procs notify_on_release tasks
(plus whatever files added by the attached subsystems)
</pre></div>
</div>
<p>Now attach your shell to this cgroup:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># /bin/echo $$ &gt; tasks
</pre></div>
</div>
<p>You can also create cgroups inside your cgroup by using mkdir in this
directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir my_sub_cs
</pre></div>
</div>
<p>To remove a cgroup, just use rmdir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># rmdir my_sub_cs
</pre></div>
</div>
<p>This will fail if the cgroup is in use (has cgroups inside, or
has processes attached, or is held alive by other subsystem-specific
reference).</p>
</section>
<section id="attaching-processes">
<h3>2.2 Attaching processes<a class="headerlink" href="#attaching-processes" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># /bin/echo PID &gt; tasks
</pre></div>
</div>
<p>Note that it is PID, not PIDs. You can only attach ONE task at a time.
If you have several tasks to attach, you have to do it one after another:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># /bin/echo PID1 &gt; tasks
# /bin/echo PID2 &gt; tasks
        ...
# /bin/echo PIDn &gt; tasks
</pre></div>
</div>
<p>You can attach the current shell task by echoing 0:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo 0 &gt; tasks
</pre></div>
</div>
<p>You can use the cgroup.procs file instead of the tasks file to move all
threads in a threadgroup at once. Echoing the PID of any task in a
threadgroup to cgroup.procs causes all tasks in that threadgroup to be
attached to the cgroup. Writing 0 to cgroup.procs moves all tasks
in the writing task’s threadgroup.</p>
<p>Note: Since every task is always a member of exactly one cgroup in each
mounted hierarchy, to remove a task from its current cgroup you must
move it into a new cgroup (possibly the root cgroup) by writing to the
new cgroup’s tasks file.</p>
<p>Note: Due to some restrictions enforced by some cgroup subsystems, moving
a process to another cgroup can fail.</p>
</section>
<section id="mounting-hierarchies-by-name">
<h3>2.3 Mounting hierarchies by name<a class="headerlink" href="#mounting-hierarchies-by-name" title="Permalink to this headline">¶</a></h3>
<p>Passing the name=&lt;x&gt; option when mounting a cgroups hierarchy
associates the given name with the hierarchy.  This can be used when
mounting a pre-existing hierarchy, in order to refer to it by name
rather than by its set of active subsystems.  Each hierarchy is either
nameless, or has a unique name.</p>
<p>The name should match [w.-]+</p>
<p>When passing a name=&lt;x&gt; option for a new hierarchy, you need to
specify subsystems manually; the legacy behaviour of mounting all
subsystems when none are explicitly specified is not supported when
you give a subsystem a name.</p>
<p>The name of the subsystem appears as part of the hierarchy description
in /proc/mounts and /proc/&lt;pid&gt;/cgroups.</p>
</section>
</section>
<section id="kernel-api">
<h2>3. Kernel API<a class="headerlink" href="#kernel-api" title="Permalink to this headline">¶</a></h2>
<section id="overview">
<h3>3.1 Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>Each kernel subsystem that wants to hook into the generic cgroup
system needs to create a cgroup_subsys object. This contains
various methods, which are callbacks from the cgroup system, along
with a subsystem ID which will be assigned by the cgroup system.</p>
<p>Other fields in the cgroup_subsys object include:</p>
<ul class="simple">
<li><p>subsys_id: a unique array index for the subsystem, indicating which
entry in cgroup-&gt;subsys[] this subsystem should be managing.</p></li>
<li><p>name: should be initialized to a unique subsystem name. Should be
no longer than MAX_CGROUP_TYPE_NAMELEN.</p></li>
<li><p>early_init: indicate if the subsystem needs early initialization
at system boot.</p></li>
</ul>
<p>Each cgroup object created by the system has an array of pointers,
indexed by subsystem ID; this pointer is entirely managed by the
subsystem; the generic cgroup code will never touch this pointer.</p>
</section>
<section id="synchronization">
<h3>3.2 Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h3>
<p>There is a global mutex, cgroup_mutex, used by the cgroup
system. This should be taken by anything that wants to modify a
cgroup. It may also be taken to prevent cgroups from being
modified, but more specific locks may be more appropriate in that
situation.</p>
<p>See kernel/cgroup.c for more details.</p>
<p>Subsystems can take/release the cgroup_mutex via the functions
cgroup_lock()/cgroup_unlock().</p>
<p>Accessing a task’s cgroup pointer may be done in the following ways:
- while holding cgroup_mutex
- while holding the task’s alloc_lock (via task_lock())
- inside an <a class="reference internal" href="../../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> section via <a class="reference internal" href="../../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a></p>
</section>
<section id="subsystem-api">
<h3>3.3 Subsystem API<a class="headerlink" href="#subsystem-api" title="Permalink to this headline">¶</a></h3>
<p>Each subsystem should:</p>
<ul class="simple">
<li><p>add an entry in linux/cgroup_subsys.h</p></li>
<li><p>define a cgroup_subsys object called &lt;name&gt;_cgrp_subsys</p></li>
</ul>
<p>Each subsystem may export the following methods. The only mandatory
methods are css_alloc/free. Any others that are null are presumed to
be successful no-ops.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css_alloc(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called to allocate a subsystem state object for a cgroup. The
subsystem should allocate its subsystem state object for the passed
cgroup, returning a pointer to the new object on success or a
ERR_PTR() value. On success, the subsystem pointer should point to
a structure of type cgroup_subsys_state (typically embedded in a
larger subsystem-specific object), which will be initialized by the
cgroup system. Note that this will be called at initialization to
create the root subsystem state for this subsystem; this case can be
identified by the passed cgroup object having a NULL parent (since
it’s the root of the hierarchy) and may be an appropriate place for
initialization code.</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">css_online(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called after &#64;cgrp successfully completed all allocations and made
visible to cgroup_for_each_child/descendant_*() iterators. The
subsystem may choose to fail creation by returning -errno. This
callback can be used to implement reliable state sharing and
propagation along the hierarchy. See the comment on
cgroup_for_each_descendant_pre() for details.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">css_offline(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp);</span></code>
(cgroup_mutex held by caller)</p>
<p>This is the counterpart of css_online() and called iff css_online()
has succeeded on &#64;cgrp. This signifies the beginning of the end of
&#64;cgrp. &#64;cgrp is being removed and the subsystem should start dropping
all references it’s holding on &#64;cgrp. When all references are dropped,
cgroup removal will proceed to the next step - css_free(). After this
callback, &#64;cgrp should be considered dead to the subsystem.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">css_free(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp)</span></code>
(cgroup_mutex held by caller)</p>
<p>The cgroup system is about to free &#64;cgrp; the subsystem should free
its subsystem state object. By the time this method is called, &#64;cgrp
is completely unused; &#64;cgrp-&gt;parent is still valid. (Note - can also
be called for a newly-created cgroup if an error occurs after this
subsystem’s create() method has been called for the new cgroup).</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">can_attach(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp,</span> <span class="pre">struct</span> <span class="pre">cgroup_taskset</span> <span class="pre">*tset)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called prior to moving one or more tasks into a cgroup; if the
subsystem returns an error, this will abort the attach operation.
&#64;tset contains the tasks to be attached and is guaranteed to have at
least one task in it.</p>
<dl class="simple">
<dt>If there are multiple tasks in the taskset, then:</dt><dd><ul class="simple">
<li><p>it’s guaranteed that all are from the same thread group</p></li>
<li><p>&#64;tset contains all tasks from the thread group whether or not
they’re switching cgroups</p></li>
<li><p>the first task is the leader</p></li>
</ul>
</dd>
</dl>
<p>Each &#64;tset entry also contains the task’s old cgroup and tasks which
aren’t switching cgroup can be skipped easily using the
cgroup_taskset_for_each() iterator. Note that this isn’t called on a
fork. If this method returns 0 (success) then this should remain valid
while the caller holds cgroup_mutex and it is ensured that either
attach() or cancel_attach() will be called in future.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">css_reset(struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css)</span></code>
(cgroup_mutex held by caller)</p>
<p>An optional operation which should restore &#64;css’s configuration to the
initial state.  This is currently only used on the unified hierarchy
when a subsystem is disabled on a cgroup through
“cgroup.subtree_control” but should remain enabled because other
subsystems depend on it.  cgroup core makes such a css invisible by
removing the associated interface files and invokes this callback so
that the hidden subsystem can return to the initial neutral state.
This prevents unexpected resource control from a hidden css and
ensures that the configuration is in the initial state when it is made
visible again later.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">cancel_attach(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp,</span> <span class="pre">struct</span> <span class="pre">cgroup_taskset</span> <span class="pre">*tset)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called when a task attach operation has failed after can_attach() has succeeded.
A subsystem whose can_attach() has some side-effects should provide this
function, so that the subsystem can implement a rollback. If not, not necessary.
This will be called only about subsystems whose can_attach() operation have
succeeded. The parameters are identical to can_attach().</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">attach(struct</span> <span class="pre">cgroup</span> <span class="pre">*cgrp,</span> <span class="pre">struct</span> <span class="pre">cgroup_taskset</span> <span class="pre">*tset)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called after the task has been attached to the cgroup, to allow any
post-attachment activity that requires memory allocations or blocking.
The parameters are identical to can_attach().</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">fork(struct</span> <span class="pre">task_struct</span> <span class="pre">*task)</span></code></p>
<p>Called when a task is forked into a cgroup.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">exit(struct</span> <span class="pre">task_struct</span> <span class="pre">*task)</span></code></p>
<p>Called during task exit.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(struct</span> <span class="pre">task_struct</span> <span class="pre">*task)</span></code></p>
<p>Called when the task_struct is freed.</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">bind(struct</span> <span class="pre">cgroup</span> <span class="pre">*root)</span></code>
(cgroup_mutex held by caller)</p>
<p>Called when a cgroup subsystem is rebound to a different hierarchy
and root cgroup. Currently this will only involve movement between
the default hierarchy (which never has sub-cgroups) and a hierarchy
that is being created/destroyed (and hence has no sub-cgroups).</p>
</section>
</section>
<section id="extended-attribute-usage">
<h2>4. Extended attribute usage<a class="headerlink" href="#extended-attribute-usage" title="Permalink to this headline">¶</a></h2>
<p>cgroup filesystem supports certain types of extended attributes in its
directories and files.  The current supported types are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Trusted (XATTR_TRUSTED)</p></li>
<li><p>Security (XATTR_SECURITY)</p></li>
</ul>
</div></blockquote>
<p>Both require CAP_SYS_ADMIN capability to set.</p>
<p>Like in tmpfs, the extended attributes in cgroup filesystem are stored
using kernel memory and it’s advised to keep the usage at minimum.  This
is the reason why user defined extended attributes are not supported, since
any user can do it and there’s no limit in the value size.</p>
<p>The current known users for this feature are SELinux to limit cgroup usage
in containers and systemd for assorted meta data like main PID in a cgroup
(systemd creates a cgroup per service).</p>
</section>
<section id="questions">
<h2>5. Questions<a class="headerlink" href="#questions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Q: what&#39;s up with this &#39;/bin/echo&#39; ?
A: bash&#39;s builtin &#39;echo&#39; command does not check calls to write() against
   errors. If you use it in the cgroup file system, you won&#39;t be
   able to tell whether a command succeeded or failed.

Q: When I attach processes, only the first of the line gets really attached !
A: We can only return one error code per call to write(). So you should also
   put only ONE PID.
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Control Groups</a><ul>
<li><a class="reference internal" href="#id1">1. Control Groups</a><ul>
<li><a class="reference internal" href="#what-are-cgroups">1.1 What are cgroups ?</a></li>
<li><a class="reference internal" href="#why-are-cgroups-needed">1.2 Why are cgroups needed ?</a></li>
<li><a class="reference internal" href="#how-are-cgroups-implemented">1.3 How are cgroups implemented ?</a></li>
<li><a class="reference internal" href="#what-does-notify-on-release-do">1.4 What does notify_on_release do ?</a></li>
<li><a class="reference internal" href="#what-does-clone-children-do">1.5 What does clone_children do ?</a></li>
<li><a class="reference internal" href="#how-do-i-use-cgroups">1.6 How do I use cgroups ?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usage-examples-and-syntax">2. Usage Examples and Syntax</a><ul>
<li><a class="reference internal" href="#basic-usage">2.1 Basic Usage</a></li>
<li><a class="reference internal" href="#attaching-processes">2.2 Attaching processes</a></li>
<li><a class="reference internal" href="#mounting-hierarchies-by-name">2.3 Mounting hierarchies by name</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel-api">3. Kernel API</a><ul>
<li><a class="reference internal" href="#overview">3.1 Overview</a></li>
<li><a class="reference internal" href="#synchronization">3.2 Synchronization</a></li>
<li><a class="reference internal" href="#subsystem-api">3.3 Subsystem API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extended-attribute-usage">4. Extended attribute usage</a></li>
<li><a class="reference internal" href="#questions">5. Questions</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/cgroup-v1/cgroups.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/cgroup-v1/cgroups.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>