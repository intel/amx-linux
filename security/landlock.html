
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Landlock LSM: kernel documentation &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Secrets documentation" href="secrets/index.html" />
    <link rel="prev" title="Digital Signature Verification API" href="digsig.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="landlock-lsm-kernel-documentation">
<h1>Landlock LSM: kernel documentation<a class="headerlink" href="#landlock-lsm-kernel-documentation" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Mickaël Salaün</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>September 2022</p>
</dd>
</dl>
<p>Landlock’s goal is to create scoped access-control (i.e. sandboxing).  To
harden a whole system, this feature should be available to any process,
including unprivileged ones.  Because such process may be compromised or
backdoored (i.e. untrusted), Landlock’s features must be safe to use from the
kernel and other processes point of view.  Landlock’s interface must therefore
expose a minimal attack surface.</p>
<p>Landlock is designed to be usable by unprivileged processes while following the
system security policy enforced by other access control mechanisms (e.g. DAC,
LSM).  Indeed, a Landlock rule shall not interfere with other access-controls
enforced on the system, only add more restrictions.</p>
<p>Any user can enforce Landlock rulesets on their processes.  They are merged and
evaluated according to the inherited ones in a way that ensures that only more
constraints can be added.</p>
<p>User space documentation can be found here:
<a class="reference internal" href="../userspace-api/landlock.html"><span class="doc">Landlock: unprivileged access control</span></a>.</p>
<section id="guiding-principles-for-safe-access-controls">
<h2>Guiding principles for safe access controls<a class="headerlink" href="#guiding-principles-for-safe-access-controls" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A Landlock rule shall be focused on access control on kernel objects instead
of syscall filtering (i.e. syscall arguments), which is the purpose of
seccomp-bpf.</p></li>
<li><p>To avoid multiple kinds of side-channel attacks (e.g. leak of security
policies, CPU-based attacks), Landlock rules shall not be able to
programmatically communicate with user space.</p></li>
<li><p>Kernel access check shall not slow down access request from unsandboxed
processes.</p></li>
<li><p>Computation related to Landlock operations (e.g. enforcing a ruleset) shall
only impact the processes requesting them.</p></li>
</ul>
</section>
<section id="design-choices">
<h2>Design choices<a class="headerlink" href="#design-choices" title="Permalink to this headline">¶</a></h2>
<section id="filesystem-access-rights">
<h3>Filesystem access rights<a class="headerlink" href="#filesystem-access-rights" title="Permalink to this headline">¶</a></h3>
<p>All access rights are tied to an inode and what can be accessed through it.
Reading the content of a directory does not imply to be allowed to read the
content of a listed inode.  Indeed, a file name is local to its parent
directory, and an inode can be referenced by multiple file names thanks to
(hard) links.  Being able to unlink a file only has a direct impact on the
directory, not the unlinked inode.  This is the reason why
<code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACCESS_FS_REMOVE_FILE</span></code> or <code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACCESS_FS_REFER</span></code> are not
allowed to be tied to files but only to directories.</p>
</section>
</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>Userspace tests for backward compatibility, ptrace restrictions and filesystem
support can be found here: <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/landlock/">tools/testing/selftests/landlock/</a>.</p>
</section>
<section id="kernel-structures">
<h2>Kernel structures<a class="headerlink" href="#kernel-structures" title="Permalink to this headline">¶</a></h2>
<section id="object">
<h3>Object<a class="headerlink" href="#object" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.landlock_object_underops">
struct <code class="sig-name descname">landlock_object_underops</code><a class="headerlink" href="#c.landlock_object_underops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operations on an underlying object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_object_underops {
    void (*release)(struct landlock_object *const object) __releases(object-&gt;lock);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Releases the underlying object (e.g. <a class="reference internal" href="../filesystems/api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> for an inode).</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.landlock_object">
struct <code class="sig-name descname">landlock_object</code><a class="headerlink" href="#c.landlock_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Security blob tied to a kernel object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_object {
    refcount_t usage;
    spinlock_t lock;
    void *underobj;
    union {
        struct rcu_head rcu_free;
        const struct landlock_object_underops *underops;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>This counter is used to tie an object to the rules matching
it or to keep it alive while adding a new rule.  If this counter
reaches zero, this struct must not be modified, but this counter can
still be read from within an RCU read-side critical section.  When
adding a new rule to an object with a usage counter of zero, we must
wait until the pointer to this object is set to NULL (or recycled).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Protects against concurrent modifications.  This lock must be
held from the time <strong>usage</strong> drops to zero until any weak references
from <strong>underobj</strong> to this object have been cleaned up.</p>
<p>Lock ordering: inode-&gt;i_lock nests inside this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">underobj</span></code></dt><dd><p>Used when cleaning up an object and to mark an object as
tied to its underlying kernel structure.  This pointer is protected
by <strong>lock</strong>.  Cf. landlock_release_inodes() and release_inode().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_free</span></code></dt><dd><p>Enables lockless use of <strong>usage</strong>, <strong>lock</strong> and
<strong>underobj</strong> from within an RCU read-side critical section.
<strong>rcu_free</strong> and <strong>underops</strong> are only used by
landlock_put_object().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">underops</span></code></dt><dd><p>Enables landlock_put_object() to release the
underlying object (e.g. inode).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The goal of this structure is to enable to tie a set of ephemeral access
rights (pertaining to different domains) to a kernel object (e.g an inode)
in a safe way.  This implies to handle concurrent use and modification.</p>
<p>The lifetime of a <a class="reference internal" href="#c.landlock_object" title="landlock_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_object</span></code></a> depends on the rules referring to
it.</p>
</section>
<section id="filesystem">
<h3>Filesystem<a class="headerlink" href="#filesystem" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.landlock_inode_security">
struct <code class="sig-name descname">landlock_inode_security</code><a class="headerlink" href="#c.landlock_inode_security" title="Permalink to this definition">¶</a></dt>
<dd><p>Inode security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_inode_security {
    struct landlock_object __rcu *object;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">object</span></code></dt><dd><p>Weak pointer to an allocated object.  All assignments of a
new object are protected by the underlying inode-&gt;i_lock.  However,
atomically disassociating <strong>object</strong> from the inode is only protected
by <strong>object-&gt;lock</strong>, from the time <strong>object</strong>’s usage refcount drops to
zero to the time this pointer is nulled out (cf. release_inode() and
hook_sb_delete()).  Indeed, such disassociation doesn’t require
inode-&gt;i_lock thanks to the careful <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> check
performed by get_inode_object().</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Enable to reference a <a class="reference internal" href="#c.landlock_object" title="landlock_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_object</span></code></a> tied to an inode (i.e.
underlying object).</p>
<dl class="type">
<dt id="c.landlock_file_security">
struct <code class="sig-name descname">landlock_file_security</code><a class="headerlink" href="#c.landlock_file_security" title="Permalink to this definition">¶</a></dt>
<dd><p>File security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_file_security {
    access_mask_t allowed_access;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">allowed_access</span></code></dt><dd><p>Access rights that were available at the time of
opening the file. This is not necessarily the full set of access
rights available at that time, but it’s the necessary subset as
needed to authorize later operations on the open file.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This information is populated when opening a file in hook_file_open, and
tracks the relevant Landlock access rights that were available at the time
of opening the file. Other LSM hooks use these rights in order to authorize
operations on already opened files.</p>
<dl class="type">
<dt id="c.landlock_superblock_security">
struct <code class="sig-name descname">landlock_superblock_security</code><a class="headerlink" href="#c.landlock_superblock_security" title="Permalink to this definition">¶</a></dt>
<dd><p>Superblock security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_superblock_security {
    atomic_long_t inode_refs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">inode_refs</span></code></dt><dd><p>Number of pending inodes (from this superblock) that
are being released by release_inode().
Cf. struct super_block-&gt;s_fsnotify_inode_refs .</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Enable hook_sb_delete() to wait for concurrent calls to release_inode().</p>
</section>
<section id="ruleset-and-domain">
<h3>Ruleset and domain<a class="headerlink" href="#ruleset-and-domain" title="Permalink to this headline">¶</a></h3>
<p>A domain is a read-only ruleset tied to a set of subjects (i.e. tasks’
credentials).  Each time a ruleset is enforced on a task, the current domain is
duplicated and the ruleset is imported as a new layer of rules in the new
domain.  Indeed, once in a domain, each rule is tied to a layer level.  To
grant access to an object, at least one rule of each layer must allow the
requested action on the object.  A task can then only transit to a new domain
that is the intersection of the constraints from the current domain and those
of a ruleset provided by the task.</p>
<p>The definition of a subject is implicit for a task sandboxing itself, which
makes the reasoning much easier and helps avoid pitfalls.</p>
<dl class="type">
<dt id="c.landlock_layer">
struct <code class="sig-name descname">landlock_layer</code><a class="headerlink" href="#c.landlock_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Access rights for a given layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_layer {
    u16 level;
    access_mask_t access;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">level</span></code></dt><dd><p>Position of this layer in the layer stack.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access</span></code></dt><dd><p>Bitfield of allowed actions on the kernel object.  They are
relative to the object type (e.g. <code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACTION_FS_READ</span></code>).</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.landlock_rule">
struct <code class="sig-name descname">landlock_rule</code><a class="headerlink" href="#c.landlock_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Access rights tied to an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_rule {
    struct rb_node node;
    struct landlock_object *object;
    u32 num_layers;
    struct landlock_layer layers[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>Node in the ruleset’s red-black tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object</span></code></dt><dd><p>Pointer to identify a kernel object (e.g. an inode).  This
is used as a key for this ruleset element.  This pointer is set once
and never modified.  It always points to an allocated object because
each rule increments the refcount of its object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_layers</span></code></dt><dd><p>Number of entries in <strong>layers</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layers</span></code></dt><dd><p>Stack of layers, from the latest to the newest, implemented
as a flexible array member (FAM).</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.landlock_hierarchy">
struct <code class="sig-name descname">landlock_hierarchy</code><a class="headerlink" href="#c.landlock_hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Node in a ruleset hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_hierarchy {
    struct landlock_hierarchy *parent;
    refcount_t usage;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Pointer to the parent node, or NULL if it is a root
Landlock domain.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>Number of potential children domains plus their parent
domain.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.landlock_ruleset">
struct <code class="sig-name descname">landlock_ruleset</code><a class="headerlink" href="#c.landlock_ruleset" title="Permalink to this definition">¶</a></dt>
<dd><p>Landlock ruleset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_ruleset {
    struct rb_root root;
    struct landlock_hierarchy *hierarchy;
    union {
        struct work_struct work_free;
        struct {
            struct mutex lock;
            refcount_t usage;
            u32 num_rules;
            u32 num_layers;
            access_mask_t fs_access_masks[];
        };
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">root</span></code></dt><dd><p>Root of a red-black tree containing <a class="reference internal" href="#c.landlock_rule" title="landlock_rule"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_rule</span></code></a>
nodes.  Once a ruleset is tied to a process (i.e. as a domain), this
tree is immutable until <strong>usage</strong> reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hierarchy</span></code></dt><dd><p>Enables hierarchy identification even when a parent
domain vanishes.  This is needed for the ptrace protection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_free</span></code></dt><dd><p>Enables to free a ruleset within a lockless
section.  This is only used by
landlock_put_ruleset_deferred() when <strong>usage</strong> reaches zero.
The fields <strong>lock</strong>, <strong>usage</strong>, <strong>num_rules</strong>, <strong>num_layers</strong> and
<strong>fs_access_masks</strong> are then unused.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Protects against concurrent modifications of
<strong>root</strong>, if <strong>usage</strong> is greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>Number of processes (i.e. domains) or file
descriptors referencing this ruleset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rules</span></code></dt><dd><p>Number of non-overlapping (i.e. not for
the same object) rules in this ruleset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_layers</span></code></dt><dd><p>Number of layers that are used in this
ruleset.  This enables to check that all the layers
allow an access request.  A value of 0 identifies a
non-merged ruleset (i.e. not a domain).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_access_masks</span></code></dt><dd><p>Contains the subset of filesystem
actions that are restricted by a ruleset.  A domain
saves all layers of merged rulesets in a stack
(FAM), starting from the first layer to the last
one.  These layers are used when merging rulesets,
for user space backward compatibility (i.e.
future-proof), and to properly handle merged
rulesets without overlapping access rights.  These
layers are set once and never changed for the
lifetime of the ruleset.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This data structure must contain unique entries, be updatable, and quick to
match an object.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Landlock LSM: kernel documentation</a><ul>
<li><a class="reference internal" href="#guiding-principles-for-safe-access-controls">Guiding principles for safe access controls</a></li>
<li><a class="reference internal" href="#design-choices">Design choices</a><ul>
<li><a class="reference internal" href="#filesystem-access-rights">Filesystem access rights</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tests">Tests</a></li>
<li><a class="reference internal" href="#kernel-structures">Kernel structures</a><ul>
<li><a class="reference internal" href="#object">Object</a></li>
<li><a class="reference internal" href="#filesystem">Filesystem</a></li>
<li><a class="reference internal" href="#ruleset-and-domain">Ruleset and domain</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/security/landlock.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/security/landlock.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>