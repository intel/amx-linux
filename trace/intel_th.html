
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Intel(R) Trace Hub (TH) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Lockless Ring Buffer Design" href="ring-buffer-design.html" />
    <link rel="prev" title="Timerlat tracer" href="timerlat-tracer.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="intel-r-trace-hub-th">
<h1>Intel(R) Trace Hub (TH)<a class="headerlink" href="#intel-r-trace-hub-th" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Intel(R) Trace Hub (TH) is a set of hardware blocks that produce,
switch and output trace data from multiple hardware and software
sources over several types of trace output ports encoded in System
Trace Protocol (MIPI STPv2) and is intended to perform full system
debugging. For more information on the hardware, see Intel(R) Trace
Hub developer’s manual [1].</p>
<p>It consists of trace sources, trace destinations (outputs) and a
switch (Global Trace Hub, GTH). These devices are placed on a bus of
their own (“intel_th”), where they can be discovered and configured
via sysfs attributes.</p>
<dl class="simple">
<dt>Currently, the following Intel TH subdevices (blocks) are supported:</dt><dd><ul class="simple">
<li><p>Software Trace Hub (STH), trace source, which is a System Trace
Module (STM) device,</p></li>
<li><p>Memory Storage Unit (MSU), trace output, which allows storing
trace hub output in system memory,</p></li>
<li><p>Parallel Trace Interface output (PTI), trace output to an external
debug host via a PTI port,</p></li>
<li><p>Global Trace Hub (GTH), which is a switch and a central component
of Intel(R) Trace Hub architecture.</p></li>
</ul>
</dd>
</dl>
<p>Common attributes for output devices are described in
Documentation/ABI/testing/sysfs-bus-intel_th-output-devices, the most
notable of them is “active”, which enables or disables trace output
into that particular output device.</p>
<p>GTH allows directing different STP masters into different output ports
via its “masters” attribute group. More detailed GTH interface
description is at Documentation/ABI/testing/sysfs-bus-intel_th-devices-gth.</p>
<p>STH registers an stm class device, through which it provides interface
to userspace and kernelspace software trace sources. See
<a class="reference internal" href="stm.html"><span class="doc">System Trace Module</span></a> for more information on that.</p>
<p>MSU can be configured to collect trace data into a system memory
buffer, which can later on be read from its device nodes via read() or
mmap() interface and directed to a “software sink” driver that will
consume the data and/or relay it further.</p>
<p>On the whole, Intel(R) Trace Hub does not require any special
userspace software to function; everything can be configured, started
and collected via sysfs attributes, and device nodes.</p>
<p>[1] <a class="reference external" href="https://software.intel.com/sites/default/files/managed/d3/3c/intel-th-developer-manual.pdf">https://software.intel.com/sites/default/files/managed/d3/3c/intel-th-developer-manual.pdf</a></p>
</section>
<section id="bus-and-subdevices">
<h2>Bus and Subdevices<a class="headerlink" href="#bus-and-subdevices" title="Permalink to this headline">¶</a></h2>
<p>For each Intel TH device in the system a bus of its own is
created and assigned an id number that reflects the order in which TH
devices were enumerated. All TH subdevices (devices on intel_th bus)
begin with this id: 0-gth, 0-msc0, 0-msc1, 0-pti, 0-sth, which is
followed by device’s name and an optional index.</p>
<p>Output devices also get a device node in /dev/intel_thN, where N is
the Intel TH device id. For example, MSU’s memory buffers, when
allocated, are accessible via /dev/intel_th0/msc{0,1}.</p>
</section>
<section id="quick-example">
<h2>Quick example<a class="headerlink" href="#quick-example" title="Permalink to this headline">¶</a></h2>
<p># figure out which GTH port is the first memory controller:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /sys/bus/intel_th/devices/0-msc0/port
0
</pre></div>
</div>
<p># looks like it’s port 0, configure master 33 to send data to port 0:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 0 &gt; /sys/bus/intel_th/devices/0-gth/masters/33
</pre></div>
</div>
<p># allocate a 2-windowed multiblock buffer on the first memory
# controller, each with 64 pages:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo multi &gt; /sys/bus/intel_th/devices/0-msc0/mode
$ echo 64,64 &gt; /sys/bus/intel_th/devices/0-msc0/nr_pages
</pre></div>
</div>
<p># enable wrapping for this controller, too:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 1 &gt; /sys/bus/intel_th/devices/0-msc0/wrap
</pre></div>
</div>
<p># and enable tracing into this port:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 1 &gt; /sys/bus/intel_th/devices/0-msc0/active
</pre></div>
</div>
<p># .. send data to master 33, see <a class="reference internal" href="stm.html"><span class="doc">System Trace Module</span></a> for more details ..
# .. wait for traces to pile up ..
# .. and stop the trace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 0 &gt; /sys/bus/intel_th/devices/0-msc0/active
</pre></div>
</div>
<p># and now you can collect the trace from the device node:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /dev/intel_th0/msc0 &gt; my_stp_trace
</pre></div>
</div>
</section>
<section id="host-debugger-mode">
<h2>Host Debugger Mode<a class="headerlink" href="#host-debugger-mode" title="Permalink to this headline">¶</a></h2>
<p>It is possible to configure the Trace Hub and control its trace
capture from a remote debug host, which should be connected via one of
the hardware debugging interfaces, which will then be used to both
control Intel Trace Hub and transfer its trace data to the debug host.</p>
<p>The driver needs to be told that such an arrangement is taking place
so that it does not touch any capture/port configuration and avoids
conflicting with the debug host’s configuration accesses. The only
activity that the driver will perform in this mode is collecting
software traces to the Software Trace Hub (an stm class device). The
user is still responsible for setting up adequate master/channel
mappings that the decoder on the receiving end would recognize.</p>
<p>In order to enable the host mode, set the ‘host_mode’ parameter of the
‘intel_th’ kernel module to ‘y’. None of the virtual output devices
will show up on the intel_th bus. Also, trace configuration and
capture controlling attribute groups of the ‘gth’ device will not be
exposed. The ‘sth’ device will operate as usual.</p>
</section>
<section id="software-sinks">
<h2>Software Sinks<a class="headerlink" href="#software-sinks" title="Permalink to this headline">¶</a></h2>
<p>The Memory Storage Unit (MSU) driver provides an in-kernel API for
drivers to register themselves as software sinks for the trace data.
Such drivers can further export the data via other devices, such as
USB device controllers or network cards.</p>
<dl class="simple">
<dt>The API has two main parts::</dt><dd><ul class="simple">
<li><p>notifying the software sink that a particular window is full, and
“locking” that window, that is, making it unavailable for the trace
collection; when this happens, the MSU driver will automatically
switch to the next window in the buffer if it is unlocked, or stop
the trace capture if it’s not;</p></li>
<li><p>tracking the “locked” state of windows and providing a way for the
software sink driver to notify the MSU driver when a window is
unlocked and can be used again to collect trace data.</p></li>
</ul>
</dd>
</dl>
<p>An example sink driver, msu-sink illustrates the implementation of a
software sink. Functionally, it simply unlocks windows as soon as they
are full, keeping the MSU running in a circular buffer mode. Unlike the
“multi” mode, it will fill out all the windows in the buffer as opposed
to just the first one. It can be enabled by writing “sink” to the “mode”
file (assuming msu-sink.ko is loaded).</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Intel(R) Trace Hub (TH)</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#bus-and-subdevices">Bus and Subdevices</a></li>
<li><a class="reference internal" href="#quick-example">Quick example</a></li>
<li><a class="reference internal" href="#host-debugger-mode">Host Debugger Mode</a></li>
<li><a class="reference internal" href="#software-sinks">Software Sinks</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/trace/intel_th.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/trace/intel_th.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>