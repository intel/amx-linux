
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Lockless Ring Buffer Design &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="System Trace Module" href="stm.html" />
    <link rel="prev" title="Intel(R) Trace Hub (TH)" href="intel_th.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="lockless-ring-buffer-design">
<h1>Lockless Ring Buffer Design<a class="headerlink" href="#lockless-ring-buffer-design" title="Permalink to this headline">¶</a></h1>
<p>Copyright 2009 Red Hat Inc.</p>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Steven Rostedt &lt;<a class="reference external" href="mailto:srostedt&#37;&#52;&#48;redhat&#46;com">srostedt<span>&#64;</span>redhat<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">License</dt>
<dd class="field-even"><p>The GNU Free Documentation License, Version 1.2
(dual licensed under the GPL v2)</p>
</dd>
<dt class="field-odd">Reviewers</dt>
<dd class="field-odd"><p>Mathieu Desnoyers, Huang Ying, Hidetoshi Seto,
and Frederic Weisbecker.</p>
</dd>
</dl>
<p>Written for: 2.6.31</p>
<section id="terminology-used-in-this-document">
<h2>Terminology used in this Document<a class="headerlink" href="#terminology-used-in-this-document" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>tail</dt><dd><ul class="simple">
<li><p>where new writes happen in the ring buffer.</p></li>
</ul>
</dd>
<dt>head</dt><dd><ul class="simple">
<li><p>where new reads happen in the ring buffer.</p></li>
</ul>
</dd>
<dt>producer</dt><dd><ul class="simple">
<li><p>the task that writes into the ring buffer (same as writer)</p></li>
</ul>
</dd>
<dt>writer</dt><dd><ul class="simple">
<li><p>same as producer</p></li>
</ul>
</dd>
<dt>consumer</dt><dd><ul class="simple">
<li><p>the task that reads from the buffer (same as reader)</p></li>
</ul>
</dd>
<dt>reader</dt><dd><ul class="simple">
<li><p>same as consumer.</p></li>
</ul>
</dd>
<dt>reader_page</dt><dd><ul class="simple">
<li><p>A page outside the ring buffer used solely (for the most part)
by the reader.</p></li>
</ul>
</dd>
<dt>head_page</dt><dd><ul class="simple">
<li><p>a pointer to the page that the reader will use next</p></li>
</ul>
</dd>
<dt>tail_page</dt><dd><ul class="simple">
<li><p>a pointer to the page that will be written to next</p></li>
</ul>
</dd>
<dt>commit_page</dt><dd><ul class="simple">
<li><p>a pointer to the page with the last finished non-nested write.</p></li>
</ul>
</dd>
<dt>cmpxchg</dt><dd><ul>
<li><p>hardware-assisted atomic transaction that performs the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A = B if previous A == C

R = cmpxchg(A, C, B) is saying that we replace A with B if and only
    if current A is equal to C, and we put the old (current)
    A into R

R gets the previous A regardless if A is updated with B or not.
</pre></div>
</div>
<p>To see if the update was successful a compare of <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">==</span> <span class="pre">C</span></code>
may be used.</p>
</li>
</ul>
</dd>
</dl>
</section>
<section id="the-generic-ring-buffer">
<h2>The Generic Ring Buffer<a class="headerlink" href="#the-generic-ring-buffer" title="Permalink to this headline">¶</a></h2>
<p>The ring buffer can be used in either an overwrite mode or in
producer/consumer mode.</p>
<p>Producer/consumer mode is where if the producer were to fill up the
buffer before the consumer could free up anything, the producer
will stop writing to the buffer. This will lose most recent events.</p>
<p>Overwrite mode is where if the producer were to fill up the buffer
before the consumer could free up anything, the producer will
overwrite the older data. This will lose the oldest events.</p>
<p>No two writers can write at the same time (on the same per-cpu buffer),
but a writer may interrupt another writer, but it must finish writing
before the previous writer may continue. This is very important to the
algorithm. The writers act like a “stack”. The way interrupts works
enforces this behavior:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>writer1 start
   &lt;preempted&gt; writer2 start
       &lt;preempted&gt; writer3 start
                   writer3 finishes
               writer2 finishes
writer1 finishes
</pre></div>
</div>
<p>This is very much like a writer being preempted by an interrupt and
the interrupt doing a write as well.</p>
<p>Readers can happen at any time. But no two readers may run at the
same time, nor can a reader preempt/interrupt another reader. A reader
cannot preempt/interrupt a writer, but it may read/consume from the
buffer at the same time as a writer is writing, but the reader must be
on another processor to do so. A reader may read on its own processor
and can be preempted by a writer.</p>
<p>A writer can preempt a reader, but a reader cannot preempt a writer.
But a reader can read the buffer at the same time (on another processor)
as a writer.</p>
<p>The ring buffer is made up of a list of pages held together by a linked list.</p>
<p>At initialization a reader page is allocated for the reader that is not
part of the ring buffer.</p>
<p>The head_page, tail_page and commit_page are all initialized to point
to the same page.</p>
<p>The reader page is initialized to have its next pointer pointing to
the head page, and its previous pointer pointing to a page before
the head page.</p>
<p>The reader has its own page to use. At start up time, this page is
allocated but is not attached to the list. When the reader wants
to read from the buffer, if its page is empty (like it is on start-up),
it will swap its page with the head_page. The old reader page will
become part of the ring buffer and the head_page will be removed.
The page after the inserted page (old reader_page) will become the
new head page.</p>
<p>Once the new page is given to the reader, the reader could do what
it wants with it, as long as a writer has left that page.</p>
<p>A sample of how the reader page is swapped: Note this does not
show the head page in the buffer, it is for demonstrating a swap
only.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------+
|reader|          RING BUFFER
|page  |
+------+
                +---+   +---+   +---+
                |   |--&gt;|   |--&gt;|   |
                |   |&lt;--|   |&lt;--|   |
                +---+   +---+   +---+
                 ^ |             ^ |
                 | +-------------+ |
                 +-----------------+


+------+
|reader|          RING BUFFER
|page  |-------------------+
+------+                   v
  |             +---+   +---+   +---+
  |             |   |--&gt;|   |--&gt;|   |
  |             |   |&lt;--|   |&lt;--|   |&lt;-+
  |             +---+   +---+   +---+  |
  |              ^ |             ^ |   |
  |              | +-------------+ |   |
  |              +-----------------+   |
  +------------------------------------+

+------+
|reader|          RING BUFFER
|page  |-------------------+
+------+ &lt;---------------+ v
  |  ^          +---+   +---+   +---+
  |  |          |   |--&gt;|   |--&gt;|   |
  |  |          |   |   |   |&lt;--|   |&lt;-+
  |  |          +---+   +---+   +---+  |
  |  |             |             ^ |   |
  |  |             +-------------+ |   |
  |  +-----------------------------+   |
  +------------------------------------+

+------+
|buffer|          RING BUFFER
|page  |-------------------+
+------+ &lt;---------------+ v
  |  ^          +---+   +---+   +---+
  |  |          |   |   |   |--&gt;|   |
  |  |  New     |   |   |   |&lt;--|   |&lt;-+
  |  | Reader   +---+   +---+   +---+  |
  |  |  page ----^                 |   |
  |  |                             |   |
  |  +-----------------------------+   |
  +------------------------------------+
</pre></div>
</div>
<p>It is possible that the page swapped is the commit page and the tail page,
if what is in the ring buffer is less than what is held in a buffer page.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          reader page    commit page   tail page
              |              |             |
              v              |             |
             +---+           |             |
             |   |&lt;----------+             |
             |   |&lt;------------------------+
             |   |------+
             +---+      |
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>This case is still valid for this algorithm.
When the writer leaves the page, it simply goes into the ring buffer
since the reader page still points to the next location in the ring
buffer.</p>
<p>The main pointers:</p>
<blockquote>
<div><dl class="simple">
<dt>reader page</dt><dd><ul class="simple">
<li><p>The page used solely by the reader and is not part
of the ring buffer (may be swapped in)</p></li>
</ul>
</dd>
<dt>head page</dt><dd><ul class="simple">
<li><p>the next page in the ring buffer that will be swapped
with the reader page.</p></li>
</ul>
</dd>
<dt>tail page</dt><dd><ul class="simple">
<li><p>the page where the next write will take place.</p></li>
</ul>
</dd>
<dt>commit page</dt><dd><ul class="simple">
<li><p>the page that last finished a write.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>The commit page only is updated by the outermost writer in the
writer stack. A writer that preempts another writer will not move the
commit page.</p>
<p>When data is written into the ring buffer, a position is reserved
in the ring buffer and passed back to the writer. When the writer
is finished writing data into that position, it commits the write.</p>
<p>Another write (or a read) may take place at anytime during this
transaction. If another write happens it must finish before continuing
with the previous write.</p>
<blockquote>
<div><blockquote>
<div><p>Write reserve:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Buffer page
+---------+
|written  |
+---------+  &lt;--- given back to writer (current commit)
|reserved |
+---------+ &lt;--- tail pointer
| empty   |
+---------+
</pre></div>
</div>
<p>Write commit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Buffer page
+---------+
|written  |
+---------+
|written  |
+---------+  &lt;--- next position for write (current commit)
| empty   |
+---------+
</pre></div>
</div>
</div></blockquote>
<p>If a write happens after the first reserve:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     Buffer page
    +---------+
    |written  |
    +---------+  &lt;-- current commit
    |reserved |
    +---------+  &lt;--- given back to second writer
    |reserved |
    +---------+ &lt;--- tail pointer

After second writer commits::


     Buffer page
    +---------+
    |written  |
    +---------+  &lt;--(last full commit)
    |reserved |
    +---------+
    |pending  |
    |commit   |
    +---------+ &lt;--- tail pointer

When the first writer commits::

     Buffer page
    +---------+
    |written  |
    +---------+
    |written  |
    +---------+
    |written  |
    +---------+  &lt;--(last full commit and tail pointer)
</pre></div>
</div>
</div></blockquote>
<p>The commit pointer points to the last write location that was
committed without preempting another write. When a write that
preempted another write is committed, it only becomes a pending commit
and will not be a full commit until all writes have been committed.</p>
<p>The commit page points to the page that has the last full commit.
The tail page points to the page with the last write (before
committing).</p>
<p>The tail page is always equal to or after the commit page. It may
be several pages ahead. If the tail page catches up to the commit
page then no more writes may take place (regardless of the mode
of the ring buffer: overwrite and produce/consumer).</p>
<p>The order of pages is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>head page
commit page
tail page
</pre></div>
</div>
<p>Possible scenario:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                             tail page
  head page         commit page  |
      |                 |        |
      v                 v        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>There is a special case that the head page is after either the commit page
and possibly the tail page. That is when the commit (and tail) page has been
swapped with the reader page. This is because the head page is always
part of the ring buffer, but the reader page is not. Whenever there
has been less than a full page that has been committed inside the ring buffer,
and a reader swaps out a page, it will be swapping out the commit page.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          reader page    commit page   tail page
              |              |             |
              v              |             |
             +---+           |             |
             |   |&lt;----------+             |
             |   |&lt;------------------------+
             |   |------+
             +---+      |
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
                        ^
                        |
                    head page
</pre></div>
</div>
<p>In this case, the head page will not move when the tail and commit
move back into the ring buffer.</p>
<p>The reader cannot swap a page into the ring buffer if the commit page
is still on that page. If the read meets the last commit (real commit
not pending or reserved), then there is nothing more to read.
The buffer is considered empty until another full commit finishes.</p>
<p>When the tail meets the head page, if the buffer is in overwrite mode,
the head page will be pushed ahead one. If the buffer is in producer/consumer
mode, the write will fail.</p>
<p>Overwrite mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
                        ^
                        |
                    head page


            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
                                 ^
                                 |
                             head page


                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
                                 ^
                                 |
                             head page
</pre></div>
</div>
<p>Note, the reader page will still point to the previous head page.
But when a swap takes place, it will use the most recent head page.</p>
</section>
<section id="making-the-ring-buffer-lockless">
<h2>Making the Ring Buffer Lockless:<a class="headerlink" href="#making-the-ring-buffer-lockless" title="Permalink to this headline">¶</a></h2>
<p>The main idea behind the lockless algorithm is to combine the moving
of the head_page pointer with the swapping of pages with the reader.
State flags are placed inside the pointer to the page. To do this,
each page must be aligned in memory by 4 bytes. This will allow the 2
least significant bits of the address to be used as flags, since
they will always be zero for the address. To get the address,
simply mask out the flags:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MASK = ~3

address &amp; MASK
</pre></div>
</div>
<p>Two flags will be kept by these two bits:</p>
<blockquote>
<div><dl class="simple">
<dt>HEADER</dt><dd><ul class="simple">
<li><p>the page being pointed to is a head page</p></li>
</ul>
</dd>
<dt>UPDATE</dt><dd><ul class="simple">
<li><p>the page being pointed to is being updated by a writer
and was or is about to be a head page.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          reader page
              |
              v
            +---+
            |   |------+
            +---+      |
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The above pointer “-H-&gt;” would have the HEADER flag set. That is
the next page is the next page to be swapped out by the reader.
This pointer means the next page is the head page.</p>
<p>When the tail page meets the head pointer, it will use cmpxchg to
change the pointer to the UPDATE state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+

            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>“-U-&gt;” represents a pointer in the UPDATE state.</p>
<p>Any access to the reader will need to take some sort of lock to serialize
the readers. But the writers will never take a lock to write to the
ring buffer. This means we only need to worry about a single reader,
and writes only preempt in “stack” formation.</p>
<p>When the reader tries to swap the page with the ring buffer, it
will also use cmpxchg. If the flag bit in the pointer to the
head page does not have the HEADER flag set, the compare will fail
and the reader will need to look for the new head page and try again.
Note, the flags UPDATE and HEADER are never set at the same time.</p>
<p>The reader swaps the reader page as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------+
|reader|          RING BUFFER
|page  |
+------+
                +---+    +---+    +---+
                |   |---&gt;|   |---&gt;|   |
                |   |&lt;---|   |&lt;---|   |
                +---+    +---+    +---+
                 ^ |               ^ |
                 | +---------------+ |
                 +-----H-------------+
</pre></div>
</div>
<p>The reader sets the reader page next pointer as HEADER to the page after
the head page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------+
|reader|          RING BUFFER
|page  |-------H-----------+
+------+                   v
  |             +---+    +---+    +---+
  |             |   |---&gt;|   |---&gt;|   |
  |             |   |&lt;---|   |&lt;---|   |&lt;-+
  |             +---+    +---+    +---+  |
  |              ^ |               ^ |   |
  |              | +---------------+ |   |
  |              +-----H-------------+   |
  +--------------------------------------+
</pre></div>
</div>
<p>It does a cmpxchg with the pointer to the previous head page to make it
point to the reader page. Note that the new pointer does not have the HEADER
flag set.  This action atomically moves the head page forward:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------+
|reader|          RING BUFFER
|page  |-------H-----------+
+------+                   v
  |  ^          +---+   +---+   +---+
  |  |          |   |--&gt;|   |--&gt;|   |
  |  |          |   |&lt;--|   |&lt;--|   |&lt;-+
  |  |          +---+   +---+   +---+  |
  |  |             |             ^ |   |
  |  |             +-------------+ |   |
  |  +-----------------------------+   |
  +------------------------------------+
</pre></div>
</div>
<p>After the new head page is set, the previous pointer of the head page is
updated to the reader page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------+
|reader|          RING BUFFER
|page  |-------H-----------+
+------+ &lt;---------------+ v
  |  ^          +---+   +---+   +---+
  |  |          |   |--&gt;|   |--&gt;|   |
  |  |          |   |   |   |&lt;--|   |&lt;-+
  |  |          +---+   +---+   +---+  |
  |  |             |             ^ |   |
  |  |             +-------------+ |   |
  |  +-----------------------------+   |
  +------------------------------------+

+------+
|buffer|          RING BUFFER
|page  |-------H-----------+  &lt;--- New head page
+------+ &lt;---------------+ v
  |  ^          +---+   +---+   +---+
  |  |          |   |   |   |--&gt;|   |
  |  |  New     |   |   |   |&lt;--|   |&lt;-+
  |  | Reader   +---+   +---+   +---+  |
  |  |  page ----^                 |   |
  |  |                             |   |
  |  +-----------------------------+   |
  +------------------------------------+
</pre></div>
</div>
<p>Another important point: The page that the reader page points back to
by its previous pointer (the one that now points to the new head page)
never points back to the reader page. That is because the reader page is
not part of the ring buffer. Traversing the ring buffer via the next pointers
will always stay in the ring buffer. Traversing the ring buffer via the
prev pointers may not.</p>
<p>Note, the way to determine a reader page is simply by examining the previous
pointer of the page. If the next pointer of the previous page does not
point back to the original page, then the original page is a reader page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> +--------+
 | reader |  next   +----+
 |  page  |--------&gt;|    |&lt;====== (buffer page)
 +--------+         +----+
     |                | ^
     |                v | next
prev |              +----+
     +-------------&gt;|    |
                    +----+
</pre></div>
</div>
<p>The way the head page moves forward:</p>
<p>When the tail page meets the head page and the buffer is in overwrite mode
and more writes take place, the head page must be moved forward before the
writer may move the tail page. The way this is done is that the writer
performs a cmpxchg to convert the pointer to the head page from the HEADER
flag to have the UPDATE flag set. Once this is done, the reader will
not be able to swap the head page from the buffer, nor will it be able to
move the head page, until the writer is finished with the move.</p>
<p>This eliminates any races that the reader can have on the writer. The reader
must spin, and this is why the reader cannot preempt the writer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+

            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The following page will be made into the new head page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>After the new head page has been set, we can set the old head page
pointer back to NORMAL:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>After the head page has been moved, the tail page may now move forward:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The above are the trivial updates. Now for the more complex scenarios.</p>
<p>As stated before, if enough writes preempt the first write, the
tail page may make it all the way around the buffer and meet the commit
page. At this time, we must start dropping writes (usually with some kind
of warning to the user). But what happens if the commit was still on the
reader page? The commit page is not part of the ring buffer. The tail page
must account for this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          reader page    commit page
              |              |
              v              |
             +---+           |
             |   |&lt;----------+
             |   |
             |   |------+
             +---+      |
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
               ^
               |
           tail page
</pre></div>
</div>
<p>If the tail page were to simply push the head page forward, the commit when
leaving the reader page would not be pointing to the correct page.</p>
<p>The solution to this is to test if the commit page is on the reader page
before pushing the head page. If it is, then it can be assumed that the
tail page wrapped the buffer, and we must drop new writes.</p>
<p>This is not a race condition, because the commit page can only be moved
by the outermost writer (the writer that was preempted).
This means that the commit will not move while a writer is moving the
tail page. The reader cannot swap the reader page if it is also being
used as the commit page. The reader can simply check that the commit
is off the reader page. Once the commit page leaves the reader page
it will never go back on it unless a reader does another swap with the
buffer page that is also the commit page.</p>
</section>
<section id="nested-writes">
<h2>Nested writes<a class="headerlink" href="#nested-writes" title="Permalink to this headline">¶</a></h2>
<p>In the pushing forward of the tail page we must first push forward
the head page if the head page is the next page. If the head page
is not the next page, the tail page is simply updated with a cmpxchg.</p>
<p>Only writers move the tail page. This must be done atomically to protect
against nested writers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>temp_page = tail_page
next_page = temp_page-&gt;next
cmpxchg(tail_page, temp_page, next_page)
</pre></div>
</div>
<p>The above will update the tail page if it is still pointing to the expected
page. If this fails, a nested write pushed it forward, the current write
does not need to push it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           temp page
               |
               v
            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Nested write comes in and moves the tail page forward:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    tail page (moved by nested writer)
            temp page   |
               |        |
               v        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The above would fail the cmpxchg, but since the tail page has already
been moved forward, the writer will just try again to reserve storage
on the new tail page.</p>
<p>But the moving of the head page is a bit more complex:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The write converts the head page pointer to UPDATE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>But if a nested writer preempts here, it will see that the next
page is a head page, but it is also nested. It will detect that
it is nested and will save that information. The detection is the
fact that it sees the UPDATE flag instead of a HEADER or NORMAL
pointer.</p>
<p>The nested writer will set the new head page pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>But it will not reset the update back to normal. Only the writer
that converted a pointer from HEAD to UPDATE will convert it back
to NORMAL:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>After the nested writer finishes, the outermost writer will convert
the UPDATE pointer to NORMAL:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>It can be even more complex if several nested writes came in and moved
the tail page ahead several pages:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-H-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The write converts the head page pointer to UPDATE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Next writer comes in, and sees the update and sets up the new
head page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(second writer)

           tail page
               |
               v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The nested writer moves the tail page forward. But does not set the old
update page to NORMAL because it is not the outermost writer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Another writer preempts and sees the page after the tail page is a head page.
It changes it from HEAD to UPDATE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(third writer)

                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-U-&gt;|   |---&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The writer will move the head page forward:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(third writer)

                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-U-&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>But now that the third writer did change the HEAD flag to UPDATE it
will convert it to normal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(third writer)

                    tail page
                        |
                        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Then it will move the tail page, and return back to the second writer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(second writer)

                             tail page
                                 |
                                 v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The second writer will fail to move the tail page because it was already
moved, so it will try again and add its data to the new tail page.
It will return to the first writer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

                             tail page
                                 |
                                 v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>The first writer cannot know atomically if the tail page moved
while it updates the HEAD page. It will then update the head page to
what it thinks is the new head page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

                             tail page
                                 |
                                 v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Since the cmpxchg returns the old value of the pointer the first writer
will see it succeeded in updating the pointer from NORMAL to HEAD.
But as we can see, this is not good enough. It must also check to see
if the tail page is either where it use to be or on the next page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

               A        B    tail page
               |        |        |
               v        v        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |-H-&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>If tail page != A and tail page != B, then it must reset the pointer
back to NORMAL. The fact that it only needs to worry about nested
writers means that it only needs to check this after setting the HEAD page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

               A        B    tail page
               |        |        |
               v        v        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |-U-&gt;|   |---&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
<p>Now the writer can update the head page. This is also why the head page must
remain in UPDATE and only reset by the outermost writer. This prevents
the reader from seeing the incorrect head page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(first writer)

               A        B    tail page
               |        |        |
               v        v        v
    +---+    +---+    +---+    +---+
&lt;---|   |---&gt;|   |---&gt;|   |---&gt;|   |-H-&gt;
---&gt;|   |&lt;---|   |&lt;---|   |&lt;---|   |&lt;---
    +---+    +---+    +---+    +---+
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Lockless Ring Buffer Design</a><ul>
<li><a class="reference internal" href="#terminology-used-in-this-document">Terminology used in this Document</a></li>
<li><a class="reference internal" href="#the-generic-ring-buffer">The Generic Ring Buffer</a></li>
<li><a class="reference internal" href="#making-the-ring-buffer-lockless">Making the Ring Buffer Lockless:</a></li>
<li><a class="reference internal" href="#nested-writes">Nested writes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/trace/ring-buffer-design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/trace/ring-buffer-design.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>