
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Introduction to Netlink &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Platform Profile Selection (e.g. /sys/firmware/acpi/platform_profile)" href="../sysfs-platform_profile.html" />
    <link rel="prev" title="Netlink Handbook" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="introduction-to-netlink">
<h1>Introduction to Netlink<a class="headerlink" href="#introduction-to-netlink" title="Permalink to this headline">¶</a></h1>
<p>Netlink is often described as an ioctl() replacement.
It aims to replace fixed-format C structures as supplied
to ioctl() with a format which allows an easy way to add
or extended the arguments.</p>
<p>To achieve this Netlink uses a minimal fixed-format metadata header
followed by multiple attributes in the TLV (type, length, value) format.</p>
<p>Unfortunately the protocol has evolved over the years, in an organic
and undocumented fashion, making it hard to coherently explain.
To make the most practical sense this document starts by describing
netlink as it is used today and dives into more “historical” uses
in later sections.</p>
<section id="opening-a-socket">
<h2>Opening a socket<a class="headerlink" href="#opening-a-socket" title="Permalink to this headline">¶</a></h2>
<p>Netlink communication happens over sockets, a socket needs to be
opened first:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_RAW</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_GENERIC</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The use of sockets allows for a natural way of exchanging information
in both directions (to and from the kernel). The operations are still
performed synchronously when applications send() the request but
a separate recv() system call is needed to read the reply.</p>
<p>A very simplified flow of a Netlink “call” will therefore look
something like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_RAW</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_GENERIC</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* format the request */</span><span class="w"></span>
<span class="n">send</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">request</span><span class="p">));</span><span class="w"></span>
<span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="n">RSP_BUFFER_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* interpret the response */</span><span class="w"></span>
</pre></div>
</div>
<p>Netlink also provides natural support for “dumping”, i.e. communicating
to user space all objects of a certain type (e.g. dumping all network
interfaces).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_RAW</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_GENERIC</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* format the dump request */</span><span class="w"></span>
<span class="n">send</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">request</span><span class="p">));</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">RSP_BUFFER_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* one recv() call can read multiple messages, hence the loop below */</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">nl_msg</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nl_msg</span><span class="p">.</span><span class="n">nlmsg_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NLMSG_DONE</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">dump_finished</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* process the object */</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nl">dump_finished</span><span class="p">:</span><span class="w"></span>
</pre></div>
</div>
<p>The first two arguments of the socket() call require little explanation -
it is opening a Netlink socket, with all headers provided by the user
(hence NETLINK, RAW). The last argument is the protocol within Netlink.
This field used to identify the subsystem with which the socket will
communicate.</p>
<section id="classic-vs-generic-netlink">
<h3>Classic vs Generic Netlink<a class="headerlink" href="#classic-vs-generic-netlink" title="Permalink to this headline">¶</a></h3>
<p>Initial implementation of Netlink depended on a static allocation
of IDs to subsystems and provided little supporting infrastructure.
Let us refer to those protocols collectively as <strong>Classic Netlink</strong>.
The list of them is defined on top of the <code class="docutils literal notranslate"><span class="pre">include/uapi/linux/netlink.h</span></code>
file, they include among others - general networking (NETLINK_ROUTE),
iSCSI (NETLINK_ISCSI), and audit (NETLINK_AUDIT).</p>
<p><strong>Generic Netlink</strong> (introduced in 2005) allows for dynamic registration of
subsystems (and subsystem ID allocation), introspection and simplifies
implementing the kernel side of the interface.</p>
<p>The following section describes how to use Generic Netlink, as the
number of subsystems using Generic Netlink outnumbers the older
protocols by an order of magnitude. There are also no plans for adding
more Classic Netlink protocols to the kernel.
Basic information on how communicating with core networking parts of
the Linux kernel (or another of the 20 subsystems using Classic
Netlink) differs from Generic Netlink is provided later in this document.</p>
</section>
</section>
<section id="generic-netlink">
<h2>Generic Netlink<a class="headerlink" href="#generic-netlink" title="Permalink to this headline">¶</a></h2>
<p>In addition to the Netlink fixed metadata header each Netlink protocol
defines its own fixed metadata header. (Similarly to how network
headers stack - Ethernet &gt; IP &gt; TCP we have Netlink &gt; Generic N. &gt; Family.)</p>
<p>A Netlink message always starts with struct nlmsghdr, which is followed
by a protocol-specific header. In case of Generic Netlink the protocol
header is struct genlmsghdr.</p>
<p>The practical meaning of the fields in case of Generic Netlink is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">nlmsghdr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">__u32</span><span class="w">   </span><span class="n">nlmsg_len</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Length of message including headers */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u16</span><span class="w">   </span><span class="n">nlmsg_type</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Generic Netlink Family (subsystem) ID */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u16</span><span class="w">   </span><span class="n">nlmsg_flags</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Flags - request or dump */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u32</span><span class="w">   </span><span class="n">nlmsg_seq</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Sequence number */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u32</span><span class="w">   </span><span class="n">nlmsg_pid</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Port ID, set to 0 */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">genlmsghdr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">__u8</span><span class="w">    </span><span class="n">cmd</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Command, as defined by the Family */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u8</span><span class="w">    </span><span class="n">version</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Irrelevant, set to 1 */</span><span class="w"></span>
<span class="w">      </span><span class="n">__u16</span><span class="w">   </span><span class="n">reserved</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Reserved, set to 0 */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="cm">/* TLV attributes follow... */</span><span class="w"></span>
</pre></div>
</div>
<p>In Classic Netlink <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_type</span></code> used to identify
which operation within the subsystem the message was referring to
(e.g. get information about a netdev). Generic Netlink needs to mux
multiple subsystems in a single protocol so it uses this field to
identify the subsystem, and <code class="xref c c-member docutils literal notranslate"><span class="pre">genlmsghdr.cmd</span></code> identifies
the operation instead. (See <a class="reference internal" href="#res-fam"><span class="std std-ref">Resolving the Family ID</span></a> for
information on how to find the Family ID of the subsystem of interest.)
Note that the first 16 values (0 - 15) of this field are reserved for
control messages both in Classic Netlink and Generic Netlink.
See <a class="reference internal" href="#nl-msg-type"><span class="std std-ref">Netlink message types</span></a> for more details.</p>
<p>There are 3 usual types of message exchanges on a Netlink socket:</p>
<blockquote>
<div><ul class="simple">
<li><p>performing a single action (<code class="docutils literal notranslate"><span class="pre">do</span></code>);</p></li>
<li><p>dumping information (<code class="docutils literal notranslate"><span class="pre">dump</span></code>);</p></li>
<li><p>getting asynchronous notifications (<code class="docutils literal notranslate"><span class="pre">multicast</span></code>).</p></li>
</ul>
</div></blockquote>
<p>Classic Netlink is very flexible and presumably allows other types
of exchanges to happen, but in practice those are the three that get
used.</p>
<p>Asynchronous notifications are sent by the kernel and received by
the user sockets which subscribed to them. <code class="docutils literal notranslate"><span class="pre">do</span></code> and <code class="docutils literal notranslate"><span class="pre">dump</span></code> requests
are initiated by the user. <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_flags</span></code> should
be set as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>for <code class="docutils literal notranslate"><span class="pre">do</span></code>: <code class="docutils literal notranslate"><span class="pre">NLM_F_REQUEST</span> <span class="pre">|</span> <span class="pre">NLM_F_ACK</span></code></p></li>
<li><p>for <code class="docutils literal notranslate"><span class="pre">dump</span></code>: <code class="docutils literal notranslate"><span class="pre">NLM_F_REQUEST</span> <span class="pre">|</span> <span class="pre">NLM_F_ACK</span> <span class="pre">|</span> <span class="pre">NLM_F_DUMP</span></code></p></li>
</ul>
</div></blockquote>
<p><code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_seq</span></code> should be a set to a monotonically
increasing value. The value gets echoed back in responses and doesn’t
matter in practice, but setting it to an increasing value for each
message sent is considered good hygiene. The purpose of the field is
matching responses to requests. Asynchronous notifications will have
<code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_seq</span></code> of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_pid</span></code> is the Netlink equivalent of an address.
This field can be set to <code class="docutils literal notranslate"><span class="pre">0</span></code> when talking to the kernel.
See <a class="reference internal" href="#nlmsg-pid"><span class="std std-ref">nlmsg_pid</span></a> for the (uncommon) uses of the field.</p>
<p>The expected use for <code class="xref c c-member docutils literal notranslate"><span class="pre">genlmsghdr.version</span></code> was to allow
versioning of the APIs provided by the subsystems. No subsystem to
date made significant use of this field, so setting it to <code class="docutils literal notranslate"><span class="pre">1</span></code> seems
like a safe bet.</p>
<section id="netlink-message-types">
<span id="nl-msg-type"></span><h3>Netlink message types<a class="headerlink" href="#netlink-message-types" title="Permalink to this headline">¶</a></h3>
<p>As previously mentioned <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_type</span></code> carries
protocol specific values but the first 16 identifiers are reserved
(first subsystem specific message type should be equal to
<code class="docutils literal notranslate"><span class="pre">NLMSG_MIN_TYPE</span></code> which is <code class="docutils literal notranslate"><span class="pre">0x10</span></code>).</p>
<p>There are only 4 Netlink control messages defined:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NLMSG_NOOP</span></code> - ignore the message, not used in practice;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> - carries the return code of an operation;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code> - marks the end of a dump;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NLMSG_OVERRUN</span></code> - socket buffer has overflown, not used to date.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> and <code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code> are of practical importance.
They carry return codes for operations. Note that unless
the <code class="docutils literal notranslate"><span class="pre">NLM_F_ACK</span></code> flag is set on the request Netlink will not respond
with <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> if there is no error. To avoid having to special-case
this quirk it is recommended to always set <code class="docutils literal notranslate"><span class="pre">NLM_F_ACK</span></code>.</p>
<p>The format of <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> is described by struct nlmsgerr:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>----------------------------------------------
| struct nlmsghdr - response header          |
----------------------------------------------
|    int error                               |
----------------------------------------------
| struct nlmsghdr - original request header |
----------------------------------------------
| ** optionally (1) payload of the request   |
----------------------------------------------
| ** optionally (2) extended ACK             |
----------------------------------------------
</pre></div>
</div>
<p>There are two instances of struct nlmsghdr here, first of the response
and second of the request. <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> carries the information about
the request which led to the error. This could be useful when trying
to match requests to responses or re-parse the request to dump it into
logs.</p>
<p>The payload of the request is not echoed in messages reporting success
(<code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">==</span> <span class="pre">0</span></code>) or if <code class="docutils literal notranslate"><span class="pre">NETLINK_CAP_ACK</span></code> setsockopt() was set.
The latter is common
and perhaps recommended as having to read a copy of every request back
from the kernel is rather wasteful. The absence of request payload
is indicated by <code class="docutils literal notranslate"><span class="pre">NLM_F_CAPPED</span></code> in <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_flags</span></code>.</p>
<p>The second optional element of <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> are the extended ACK
attributes. See <a class="reference internal" href="#ext-ack"><span class="std std-ref">Extended ACK</span></a> for more details. The presence
of extended ACK is indicated by <code class="docutils literal notranslate"><span class="pre">NLM_F_ACK_TLVS</span></code> in
<code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_flags</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code> is simpler, the request is never echoed but the extended
ACK attributes may be present:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>----------------------------------------------
| struct nlmsghdr - response header          |
----------------------------------------------
|    int error                               |
----------------------------------------------
| ** optionally extended ACK                 |
----------------------------------------------
</pre></div>
</div>
</section>
<section id="resolving-the-family-id">
<span id="res-fam"></span><h3>Resolving the Family ID<a class="headerlink" href="#resolving-the-family-id" title="Permalink to this headline">¶</a></h3>
<p>This section explains how to find the Family ID of a subsystem.
It also serves as an example of Generic Netlink communication.</p>
<p>Generic Netlink is itself a subsystem exposed via the Generic Netlink API.
To avoid a circular dependency Generic Netlink has a statically allocated
Family ID (<code class="docutils literal notranslate"><span class="pre">GENL_ID_CTRL</span></code> which is equal to <code class="docutils literal notranslate"><span class="pre">NLMSG_MIN_TYPE</span></code>).
The Generic Netlink family implements a command used to find out information
about other families (<code class="docutils literal notranslate"><span class="pre">CTRL_CMD_GETFAMILY</span></code>).</p>
<p>To get information about the Generic Netlink family named for example
<code class="docutils literal notranslate"><span class="pre">&quot;test1&quot;</span></code> we need to send a message on the previously opened Generic Netlink
socket. The message should target the Generic Netlink Family (1), be a
<code class="docutils literal notranslate"><span class="pre">do</span></code> (2) call to <code class="docutils literal notranslate"><span class="pre">CTRL_CMD_GETFAMILY</span></code> (3). A <code class="docutils literal notranslate"><span class="pre">dump</span></code> version of this
call would make the kernel respond with information about <em>all</em> the families
it knows about. Last but not least the name of the family in question has
to be specified (4) as an attribute with the appropriate type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr:
  __u32 nlmsg_len:    32
  __u16 nlmsg_type:   GENL_ID_CTRL               // (1)
  __u16 nlmsg_flags:  NLM_F_REQUEST | NLM_F_ACK  // (2)
  __u32 nlmsg_seq:    1
  __u32 nlmsg_pid:    0

struct genlmsghdr:
  __u8 cmd:           CTRL_CMD_GETFAMILY         // (3)
  __u8 version:       2 /* or 1, doesn&#39;t matter */
  __u16 reserved:     0

struct nlattr:                                   // (4)
  __u16 nla_len:      10
  __u16 nla_type:     CTRL_ATTR_FAMILY_NAME
  char data:          test1\0

(padding:)
  char data:          \0\0
</pre></div>
</div>
<p>The length fields in Netlink (<code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_len</span></code>
and <code class="xref c c-member docutils literal notranslate"><span class="pre">nlattr.nla_len</span></code>) always <em>include</em> the header.
Attribute headers in netlink must be aligned to 4 bytes from the start
of the message, hence the extra <code class="docutils literal notranslate"><span class="pre">\0\0</span></code> after <code class="docutils literal notranslate"><span class="pre">CTRL_ATTR_FAMILY_NAME</span></code>.
The attribute lengths <em>exclude</em> the padding.</p>
<p>If the family is found kernel will reply with two messages, the response
with all the information about the family:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Message #1 - reply */
struct nlmsghdr:
  __u32 nlmsg_len:    136
  __u16 nlmsg_type:   GENL_ID_CTRL
  __u16 nlmsg_flags:  0
  __u32 nlmsg_seq:    1    /* echoed from our request */
  __u32 nlmsg_pid:    5831 /* The PID of our user space process */

struct genlmsghdr:
  __u8 cmd:           CTRL_CMD_GETFAMILY
  __u8 version:       2
  __u16 reserved:     0

struct nlattr:
  __u16 nla_len:      10
  __u16 nla_type:     CTRL_ATTR_FAMILY_NAME
  char data:          test1\0

(padding:)
  data:               \0\0

struct nlattr:
  __u16 nla_len:      6
  __u16 nla_type:     CTRL_ATTR_FAMILY_ID
  __u16:              123  /* The Family ID we are after */

(padding:)
  char data:          \0\0

struct nlattr:
  __u16 nla_len:      9
  __u16 nla_type:     CTRL_ATTR_FAMILY_VERSION
  __u16:              1

/* ... etc, more attributes will follow. */
</pre></div>
</div>
<p>And the error code (success) since <code class="docutils literal notranslate"><span class="pre">NLM_F_ACK</span></code> had been set on the request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Message #2 - the ACK */
struct nlmsghdr:
  __u32 nlmsg_len:    36
  __u16 nlmsg_type:   NLMSG_ERROR
  __u16 nlmsg_flags:  NLM_F_CAPPED /* There won&#39;t be a payload */
  __u32 nlmsg_seq:    1    /* echoed from our request */
  __u32 nlmsg_pid:    5831 /* The PID of our user space process */

int error:            0

struct nlmsghdr: /* Copy of the request header as we sent it */
  __u32 nlmsg_len:    32
  __u16 nlmsg_type:   GENL_ID_CTRL
  __u16 nlmsg_flags:  NLM_F_REQUEST | NLM_F_ACK
  __u32 nlmsg_seq:    1
  __u32 nlmsg_pid:    0
</pre></div>
</div>
<p>The order of attributes (struct nlattr) is not guaranteed so the user
has to walk the attributes and parse them.</p>
<p>Note that Generic Netlink sockets are not associated or bound to a single
family. A socket can be used to exchange messages with many different
families, selecting the recipient family on message-by-message basis using
the <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_type</span></code> field.</p>
</section>
<section id="extended-ack">
<span id="ext-ack"></span><h3>Extended ACK<a class="headerlink" href="#extended-ack" title="Permalink to this headline">¶</a></h3>
<p>Extended ACK controls reporting of additional error/warning TLVs
in <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> and <code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code> messages. To maintain backward
compatibility this feature has to be explicitly enabled by setting
the <code class="docutils literal notranslate"><span class="pre">NETLINK_EXT_ACK</span></code> setsockopt() to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Types of extended ack attributes are defined in enum nlmsgerr_attrs.
The most commonly used attributes are <code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MSG</span></code>,
<code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_OFFS</span></code> and <code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_*</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MSG</span></code> carries a message in English describing
the encountered problem. These messages are far more detailed
than what can be expressed thru standard UNIX error codes.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_OFFS</span></code> points to the attribute which caused the problem.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_TYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_NEST</span></code>
inform about a missing attribute.</p>
<p>Extended ACKs can be reported on errors as well as in case of success.
The latter should be treated as a warning.</p>
<p>Extended ACKs greatly improve the usability of Netlink and should
always be enabled, appropriately parsed and reported to the user.</p>
</section>
</section>
<section id="advanced-topics">
<h2>Advanced topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<section id="dump-consistency">
<h3>Dump consistency<a class="headerlink" href="#dump-consistency" title="Permalink to this headline">¶</a></h3>
<p>Some of the data structures kernel uses for storing objects make
it hard to provide an atomic snapshot of all the objects in a dump
(without impacting the fast-paths updating them).</p>
<p>Kernel may set the <code class="docutils literal notranslate"><span class="pre">NLM_F_DUMP_INTR</span></code> flag on any message in a dump
(including the <code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code> message) if the dump was interrupted and
may be inconsistent (e.g. missing objects). User space should retry
the dump if it sees the flag set.</p>
</section>
<section id="introspection">
<h3>Introspection<a class="headerlink" href="#introspection" title="Permalink to this headline">¶</a></h3>
<p>The basic introspection abilities are enabled by access to the Family
object as reported in <a class="reference internal" href="#res-fam"><span class="std std-ref">Resolving the Family ID</span></a>. User can query information about
the Generic Netlink family, including which operations are supported
by the kernel and what attributes the kernel understands.
Family information includes the highest ID of an attribute kernel can parse,
a separate command (<code class="docutils literal notranslate"><span class="pre">CTRL_CMD_GETPOLICY</span></code>) provides detailed information
about supported attributes, including ranges of values the kernel accepts.</p>
<p>Querying family information is useful in cases when user space needs
to make sure that the kernel has support for a feature before issuing
a request.</p>
</section>
<section id="nlmsg-pid">
<span id="id1"></span><h3>nlmsg_pid<a class="headerlink" href="#nlmsg-pid" title="Permalink to this headline">¶</a></h3>
<p><code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_pid</span></code> is the Netlink equivalent of an address.
It is referred to as Port ID, sometimes Process ID because for historical
reasons if the application does not select (bind() to) an explicit Port ID
kernel will automatically assign it the ID equal to its Process ID
(as reported by the getpid() system call).</p>
<p>Similarly to the bind() semantics of the TCP/IP network protocols the value
of zero means “assign automatically”, hence it is common for applications
to leave the <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_pid</span></code> field initialized to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The field is still used today in rare cases when kernel needs to send
a unicast notification. User space application can use bind() to associate
its socket with a specific PID, it then communicates its PID to the kernel.
This way the kernel can reach the specific user space process.</p>
<p>This sort of communication is utilized in UMH (User Mode Helper)-like
scenarios when kernel needs to trigger user space processing or ask user
space for a policy decision.</p>
</section>
<section id="multicast-notifications">
<h3>Multicast notifications<a class="headerlink" href="#multicast-notifications" title="Permalink to this headline">¶</a></h3>
<p>One of the strengths of Netlink is the ability to send event notifications
to user space. This is a unidirectional form of communication (kernel -&gt;
user) and does not involve any control messages like <code class="docutils literal notranslate"><span class="pre">NLMSG_ERROR</span></code> or
<code class="docutils literal notranslate"><span class="pre">NLMSG_DONE</span></code>.</p>
<p>For example the Generic Netlink family itself defines a set of multicast
notifications about registered families. When a new family is added the
sockets subscribed to the notifications will get the following message:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr:
  __u32 nlmsg_len:    136
  __u16 nlmsg_type:   GENL_ID_CTRL
  __u16 nlmsg_flags:  0
  __u32 nlmsg_seq:    0
  __u32 nlmsg_pid:    0

struct genlmsghdr:
  __u8 cmd:           CTRL_CMD_NEWFAMILY
  __u8 version:       2
  __u16 reserved:     0

struct nlattr:
  __u16 nla_len:      10
  __u16 nla_type:     CTRL_ATTR_FAMILY_NAME
  char data:          test1\0

(padding:)
  data:               \0\0

struct nlattr:
  __u16 nla_len:      6
  __u16 nla_type:     CTRL_ATTR_FAMILY_ID
  __u16:              123  /* The Family ID we are after */

(padding:)
  char data:          \0\0

struct nlattr:
  __u16 nla_len:      9
  __u16 nla_type:     CTRL_ATTR_FAMILY_VERSION
  __u16:              1

/* ... etc, more attributes will follow. */
</pre></div>
</div>
<p>The notification contains the same information as the response
to the <code class="docutils literal notranslate"><span class="pre">CTRL_CMD_GETFAMILY</span></code> request.</p>
<p>The Netlink headers of the notification are mostly 0 and irrelevant.
The <code class="xref c c-member docutils literal notranslate"><span class="pre">nlmsghdr.nlmsg_seq</span></code> may be either zero or a monotonically
increasing notification sequence number maintained by the family.</p>
<p>To receive notifications the user socket must subscribe to the relevant
notification group. Much like the Family ID, the Group ID for a given
multicast group is dynamic and can be found inside the Family information.
The <code class="docutils literal notranslate"><span class="pre">CTRL_ATTR_MCAST_GROUPS</span></code> attribute contains nests with names
(<code class="docutils literal notranslate"><span class="pre">CTRL_ATTR_MCAST_GRP_NAME</span></code>) and IDs (<code class="docutils literal notranslate"><span class="pre">CTRL_ATTR_MCAST_GRP_ID</span></code>) of
the groups family.</p>
<p>Once the Group ID is known a setsockopt() call adds the socket to the group:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">group_id</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* .. find the group ID... */</span><span class="w"></span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_ADD_MEMBERSHIP</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="o">&amp;</span><span class="n">group_id</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">group_id</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>The socket will now receive notifications.</p>
<p>It is recommended to use separate sockets for receiving notifications
and sending requests to the kernel. The asynchronous nature of notifications
means that they may get mixed in with the responses making the message
handling much harder.</p>
</section>
<section id="buffer-sizing">
<h3>Buffer sizing<a class="headerlink" href="#buffer-sizing" title="Permalink to this headline">¶</a></h3>
<p>Netlink sockets are datagram sockets rather than stream sockets,
meaning that each message must be received in its entirety by a single
recv()/recvmsg() system call. If the buffer provided by the user is too
short, the message will be truncated and the <code class="docutils literal notranslate"><span class="pre">MSG_TRUNC</span></code> flag set
in struct msghdr (struct msghdr is the second argument
of the recvmsg() system call, <em>not</em> a Netlink header).</p>
<p>Upon truncation the remaining part of the message is discarded.</p>
<p>Netlink expects that the user buffer will be at least 8kB or a page
size of the CPU architecture, whichever is bigger. Particular Netlink
families may, however, require a larger buffer. 32kB buffer is recommended
for most efficient handling of dumps (larger buffer fits more dumped
objects and therefore fewer recvmsg() calls are needed).</p>
</section>
</section>
<section id="classic-netlink">
<h2>Classic Netlink<a class="headerlink" href="#classic-netlink" title="Permalink to this headline">¶</a></h2>
<p>The main differences between Classic and Generic Netlink are the dynamic
allocation of subsystem identifiers and availability of introspection.
In theory the protocol does not differ significantly, however, in practice
Classic Netlink experimented with concepts which were abandoned in Generic
Netlink (really, they usually only found use in a small corner of a single
subsystem). This section is meant as an explainer of a few of such concepts,
with the explicit goal of giving the Generic Netlink
users the confidence to ignore them when reading the uAPI headers.</p>
<p>Most of the concepts and examples here refer to the <code class="docutils literal notranslate"><span class="pre">NETLINK_ROUTE</span></code> family,
which covers much of the configuration of the Linux networking stack.
Real documentation of that family, deserves a chapter (or a book) of its own.</p>
<section id="families">
<h3>Families<a class="headerlink" href="#families" title="Permalink to this headline">¶</a></h3>
<p>Netlink refers to subsystems as families. This is a remnant of using
sockets and the concept of protocol families, which are part of message
demultiplexing in <code class="docutils literal notranslate"><span class="pre">NETLINK_ROUTE</span></code>.</p>
<p>Sadly every layer of encapsulation likes to refer to whatever it’s carrying
as “families” making the term very confusing:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>AF_NETLINK is a bona fide socket protocol family</p></li>
<li><p>AF_NETLINK’s documentation refers to what comes after its own
header (struct nlmsghdr) in a message as a “Family Header”</p></li>
<li><p>Generic Netlink is a family for AF_NETLINK (struct genlmsghdr follows
struct nlmsghdr), yet it also calls its users “Families”.</p></li>
</ol>
</div></blockquote>
<p>Note that the Generic Netlink Family IDs are in a different “ID space”
and overlap with Classic Netlink protocol numbers (e.g. <code class="docutils literal notranslate"><span class="pre">NETLINK_CRYPTO</span></code>
has the Classic Netlink protocol ID of 21 which Generic Netlink will
happily allocate to one of its families as well).</p>
</section>
<section id="strict-checking">
<h3>Strict checking<a class="headerlink" href="#strict-checking" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">NETLINK_GET_STRICT_CHK</span></code> socket option enables strict input checking
in <code class="docutils literal notranslate"><span class="pre">NETLINK_ROUTE</span></code>. It was needed because historically kernel did not
validate the fields of structures it didn’t process. This made it impossible
to start using those fields later without risking regressions in applications
which initialized them incorrectly or not at all.</p>
<p><code class="docutils literal notranslate"><span class="pre">NETLINK_GET_STRICT_CHK</span></code> declares that the application is initializing
all fields correctly. It also opts into validating that message does not
contain trailing data and requests that kernel rejects attributes with
type higher than largest attribute type known to the kernel.</p>
<p><code class="docutils literal notranslate"><span class="pre">NETLINK_GET_STRICT_CHK</span></code> is not used outside of <code class="docutils literal notranslate"><span class="pre">NETLINK_ROUTE</span></code>.</p>
</section>
<section id="unknown-attributes">
<h3>Unknown attributes<a class="headerlink" href="#unknown-attributes" title="Permalink to this headline">¶</a></h3>
<p>Historically Netlink ignored all unknown attributes. The thinking was that
it would free the application from having to probe what kernel supports.
The application could make a request to change the state and check which
parts of the request “stuck”.</p>
<p>This is no longer the case for new Generic Netlink families and those opting
in to strict checking. See enum netlink_validation for validation types
performed.</p>
</section>
<section id="fixed-metadata-and-structures">
<h3>Fixed metadata and structures<a class="headerlink" href="#fixed-metadata-and-structures" title="Permalink to this headline">¶</a></h3>
<p>Classic Netlink made liberal use of fixed-format structures within
the messages. Messages would commonly have a structure with
a considerable number of fields after struct nlmsghdr. It was also
common to put structures with multiple members inside attributes,
without breaking each member into an attribute of its own.</p>
<p>This has caused problems with validation and extensibility and
therefore using binary structures is actively discouraged for new
attributes.</p>
</section>
<section id="request-types">
<h3>Request types<a class="headerlink" href="#request-types" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">NETLINK_ROUTE</span></code> categorized requests into 4 types <code class="docutils literal notranslate"><span class="pre">NEW</span></code>, <code class="docutils literal notranslate"><span class="pre">DEL</span></code>, <code class="docutils literal notranslate"><span class="pre">GET</span></code>,
and <code class="docutils literal notranslate"><span class="pre">SET</span></code>. Each object can handle all or some of those requests
(objects being netdevs, routes, addresses, qdiscs etc.) Request type
is defined by the 2 lowest bits of the message type, so commands for
new objects would always be allocated with a stride of 4.</p>
<p>Each object would also have it’s own fixed metadata shared by all request
types (e.g. struct ifinfomsg for netdev requests, struct ifaddrmsg for address
requests, struct tcmsg for qdisc requests).</p>
<p>Even though other protocols and Generic Netlink commands often use
the same verbs in their message names (<code class="docutils literal notranslate"><span class="pre">GET</span></code>, <code class="docutils literal notranslate"><span class="pre">SET</span></code>) the concept
of request types did not find wider adoption.</p>
</section>
<section id="notification-echo">
<h3>Notification echo<a class="headerlink" href="#notification-echo" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">NLM_F_ECHO</span></code> requests for notifications resulting from the request
to be queued onto the requesting socket. This is useful to discover
the impact of the request.</p>
<p>Note that this feature is not universally implemented.</p>
</section>
<section id="other-request-type-specific-flags">
<h3>Other request-type-specific flags<a class="headerlink" href="#other-request-type-specific-flags" title="Permalink to this headline">¶</a></h3>
<p>Classic Netlink defined various flags for its <code class="docutils literal notranslate"><span class="pre">GET</span></code>, <code class="docutils literal notranslate"><span class="pre">NEW</span></code>
and <code class="docutils literal notranslate"><span class="pre">DEL</span></code> requests in the upper byte of nlmsg_flags in struct nlmsghdr.
Since request types have not been generalized the request type specific
flags are rarely used (and considered deprecated for new families).</p>
<p>For <code class="docutils literal notranslate"><span class="pre">GET</span></code> - <code class="docutils literal notranslate"><span class="pre">NLM_F_ROOT</span></code> and <code class="docutils literal notranslate"><span class="pre">NLM_F_MATCH</span></code> are combined into
<code class="docutils literal notranslate"><span class="pre">NLM_F_DUMP</span></code>, and not used separately. <code class="docutils literal notranslate"><span class="pre">NLM_F_ATOMIC</span></code> is never used.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">DEL</span></code> - <code class="docutils literal notranslate"><span class="pre">NLM_F_NONREC</span></code> is only used by nftables and <code class="docutils literal notranslate"><span class="pre">NLM_F_BULK</span></code>
only by FDB some operations.</p>
<p>The flags for <code class="docutils literal notranslate"><span class="pre">NEW</span></code> are used most commonly in classic Netlink. Unfortunately,
the meaning is not crystal clear. The following description is based on the
best guess of the intention of the authors, and in practice all families
stray from it in one way or another. <code class="docutils literal notranslate"><span class="pre">NLM_F_REPLACE</span></code> asks to replace
an existing object, if no matching object exists the operation should fail.
<code class="docutils literal notranslate"><span class="pre">NLM_F_EXCL</span></code> has the opposite semantics and only succeeds if object already
existed.
<code class="docutils literal notranslate"><span class="pre">NLM_F_CREATE</span></code> asks for the object to be created if it does not
exist, it can be combined with <code class="docutils literal notranslate"><span class="pre">NLM_F_REPLACE</span></code> and <code class="docutils literal notranslate"><span class="pre">NLM_F_EXCL</span></code>.</p>
<p>A comment in the main Netlink uAPI header states:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>4.4BSD ADD           NLM_F_CREATE|NLM_F_EXCL
4.4BSD CHANGE        NLM_F_REPLACE

True CHANGE          NLM_F_CREATE|NLM_F_REPLACE
Append               NLM_F_CREATE
Check                NLM_F_EXCL
</pre></div>
</div>
<p>which seems to indicate that those flags predate request types.
<code class="docutils literal notranslate"><span class="pre">NLM_F_REPLACE</span></code> without <code class="docutils literal notranslate"><span class="pre">NLM_F_CREATE</span></code> was initially used instead
of <code class="docutils literal notranslate"><span class="pre">SET</span></code> commands.
<code class="docutils literal notranslate"><span class="pre">NLM_F_EXCL</span></code> without <code class="docutils literal notranslate"><span class="pre">NLM_F_CREATE</span></code> was used to check if object exists
without creating it, presumably predating <code class="docutils literal notranslate"><span class="pre">GET</span></code> commands.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLM_F_APPEND</span></code> indicates that if one key can have multiple objects associated
with it (e.g. multiple next-hop objects for a route) the new object should be
added to the list rather than replacing the entire list.</p>
</section>
</section>
<section id="uapi-reference">
<h2>uAPI reference<a class="headerlink" href="#uapi-reference" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.V4L.nlmsghdr">
struct <code class="sig-name descname">nlmsghdr</code><a class="headerlink" href="#c.V4L.nlmsghdr" title="Permalink to this definition">¶</a></dt>
<dd><p>fixed format metadata header of Netlink messages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr {
    __u32 nlmsg_len;
    __u16 nlmsg_type;
    __u16 nlmsg_flags;
    __u32 nlmsg_seq;
    __u32 nlmsg_pid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">nlmsg_len</span></code></dt><dd><p>Length of message including header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nlmsg_type</span></code></dt><dd><p>Message content type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nlmsg_flags</span></code></dt><dd><p>Additional flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nlmsg_seq</span></code></dt><dd><p>Sequence number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nlmsg_pid</span></code></dt><dd><p>Sending process port ID</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.V4L.nlmsgerr_attrs">
enum <code class="sig-name descname">nlmsgerr_attrs</code><a class="headerlink" href="#c.V4L.nlmsgerr_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>nlmsgerr attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_UNUSED</span></code></dt><dd><p>unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MSG</span></code></dt><dd><p>error message string (string)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_OFFS</span></code></dt><dd><p>offset of the invalid attribute in the original
message, counting from the beginning of the header (u32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_COOKIE</span></code></dt><dd><p>arbitrary subsystem specific cookie to
be used - in the success case - to identify a created
object or operation or similar (binary)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_POLICY</span></code></dt><dd><p>policy for a rejected attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_TYPE</span></code></dt><dd><p>type of a missing required attribute,
<code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_NEST</span></code> will not be present if the attribute was
missing at the message level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MISS_NEST</span></code></dt><dd><p>offset of the nest where attribute was missing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__NLMSGERR_ATTR_MAX</span></code></dt><dd><p>number of attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NLMSGERR_ATTR_MAX</span></code></dt><dd><p>highest attribute number</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.V4L.netlink_attribute_type">
enum <code class="sig-name descname">netlink_attribute_type</code><a class="headerlink" href="#c.V4L.netlink_attribute_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of an attribute</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_INVALID</span></code></dt><dd><p>unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_FLAG</span></code></dt><dd><p>flag attribute (present/not present)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_U8</span></code></dt><dd><p>8-bit unsigned attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_U16</span></code></dt><dd><p>16-bit unsigned attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_U32</span></code></dt><dd><p>32-bit unsigned attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_U64</span></code></dt><dd><p>64-bit unsigned attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_S8</span></code></dt><dd><p>8-bit signed attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_S16</span></code></dt><dd><p>16-bit signed attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_S32</span></code></dt><dd><p>32-bit signed attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_S64</span></code></dt><dd><p>64-bit signed attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_BINARY</span></code></dt><dd><p>binary data, min/max length may be specified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_STRING</span></code></dt><dd><p>string, min/max length may be specified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_NUL_STRING</span></code></dt><dd><p>NUL-terminated string,
min/max length may be specified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_NESTED</span></code></dt><dd><p>nested, i.e. the content of this attribute
consists of sub-attributes. The nested policy and maxtype
inside may be specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_NESTED_ARRAY</span></code></dt><dd><p>nested array, i.e. the content of this
attribute contains sub-attributes whose type is irrelevant
(just used to separate the array entries) and each such array
entry has attributes again, the policy for those inner ones
and the corresponding maxtype may be specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_ATTR_TYPE_BITFIELD32</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nla_bitfield32</span></code> attribute</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.V4L.netlink_policy_type_attr">
enum <code class="sig-name descname">netlink_policy_type_attr</code><a class="headerlink" href="#c.V4L.netlink_policy_type_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>policy type attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_UNSPEC</span></code></dt><dd><p>unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_TYPE</span></code></dt><dd><p>type of the attribute,
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">netlink_attribute_type</span></code> (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MIN_VALUE_S</span></code></dt><dd><p>minimum value for signed
integers (S64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MAX_VALUE_S</span></code></dt><dd><p>maximum value for signed
integers (S64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MIN_VALUE_U</span></code></dt><dd><p>minimum value for unsigned
integers (U64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MAX_VALUE_U</span></code></dt><dd><p>maximum value for unsigned
integers (U64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MIN_LENGTH</span></code></dt><dd><p>minimum length for binary
attributes, no minimum if not given (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MAX_LENGTH</span></code></dt><dd><p>maximum length for binary
attributes, no maximum if not given (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_POLICY_IDX</span></code></dt><dd><p>sub policy for nested and
nested array types (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE</span></code></dt><dd><p>maximum sub policy
attribute for nested and nested array types, this can
in theory be &lt; the size of the policy pointed to by
the index, if limited inside the nesting (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_BITFIELD32_MASK</span></code></dt><dd><p>valid mask for the
bitfield32 type (U32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_PAD</span></code></dt><dd><p>pad attribute for 64-bit alignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MASK</span></code></dt><dd><p>mask of valid bits for unsigned integers (U64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__NL_POLICY_TYPE_ATTR_MAX</span></code></dt><dd><p>number of attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NL_POLICY_TYPE_ATTR_MAX</span></code></dt><dd><p>highest attribute number</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction to Netlink</a><ul>
<li><a class="reference internal" href="#opening-a-socket">Opening a socket</a><ul>
<li><a class="reference internal" href="#classic-vs-generic-netlink">Classic vs Generic Netlink</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-netlink">Generic Netlink</a><ul>
<li><a class="reference internal" href="#netlink-message-types">Netlink message types</a></li>
<li><a class="reference internal" href="#resolving-the-family-id">Resolving the Family ID</a></li>
<li><a class="reference internal" href="#extended-ack">Extended ACK</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics">Advanced topics</a><ul>
<li><a class="reference internal" href="#dump-consistency">Dump consistency</a></li>
<li><a class="reference internal" href="#introspection">Introspection</a></li>
<li><a class="reference internal" href="#nlmsg-pid">nlmsg_pid</a></li>
<li><a class="reference internal" href="#multicast-notifications">Multicast notifications</a></li>
<li><a class="reference internal" href="#buffer-sizing">Buffer sizing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classic-netlink">Classic Netlink</a><ul>
<li><a class="reference internal" href="#families">Families</a></li>
<li><a class="reference internal" href="#strict-checking">Strict checking</a></li>
<li><a class="reference internal" href="#unknown-attributes">Unknown attributes</a></li>
<li><a class="reference internal" href="#fixed-metadata-and-structures">Fixed metadata and structures</a></li>
<li><a class="reference internal" href="#request-types">Request types</a></li>
<li><a class="reference internal" href="#notification-echo">Notification echo</a></li>
<li><a class="reference internal" href="#other-request-type-specific-flags">Other request-type-specific flags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uapi-reference">uAPI reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/userspace-api/netlink/intro.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/userspace-api/netlink/intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>