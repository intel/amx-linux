
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>6.1. Introduction &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="6.5. LIRC Function Reference" href="lirc-func.html" />
    <link rel="prev" title="6. LIRC Device Interface" href="lirc-dev.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="introduction">
<span id="lirc-dev-intro"></span><h1><span class="section-number">6.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>LIRC stands for Linux Infrared Remote Control. The LIRC device interface is
a bi-directional interface for transporting raw IR and decoded scancodes
data between userspace and kernelspace. Fundamentally, it is just a chardev
(/dev/lircX, for X = 0, 1, 2, …), with a number of standard struct
file_operations defined on it. With respect to transporting raw IR and
decoded scancodes to and fro, the essential fops are read, write and ioctl.</p>
<p>It is also possible to attach a BPF program to a LIRC device for decoding
raw IR into scancodes.</p>
<p>Example dmesg output upon a driver registering w/LIRC:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dmesg |grep lirc_dev
rc rc0: lirc_dev: driver mceusb registered at minor = 0, raw IR receiver, raw IR transmitter
</pre></div>
</div>
<p>What you should see for a chardev:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -l /dev/lirc*
crw-rw---- 1 root root 248, 0 Jul 2 22:20 /dev/lirc0
</pre></div>
</div>
<p>Note that the package <a class="reference external" href="https://git.linuxtv.org/v4l-utils.git/">v4l-utils</a>
contains tools for working with LIRC devices:</p>
<blockquote>
<div><ul class="simple">
<li><p>ir-ctl: can receive raw IR and transmit IR, as well as query LIRC
device features.</p></li>
<li><p>ir-keytable: can load keymaps; allows you to set IR kernel protocols; load
BPF IR decoders and test IR decoding. Some BPF IR decoders are also
provided.</p></li>
</ul>
</div></blockquote>
</section>
<section id="lirc-modes">
<span id="id1"></span><h1><span class="section-number">6.2. </span>LIRC modes<a class="headerlink" href="#lirc-modes" title="Permalink to this headline">¶</a></h1>
<p>LIRC supports some modes of receiving and sending IR codes, as shown
on the following table.</p>
<p id="lirc-scancode-flag-repeat"><span id="lirc-scancode-flag-toggle"></span><span id="lirc-mode-scancode"></span><code class="docutils literal notranslate"><span class="pre">LIRC_MODE_SCANCODE</span></code></p>
<blockquote>
<div><p>This mode is for both sending and receiving IR.</p>
<p>For transmitting (aka sending), create a struct lirc_scancode with
the desired scancode set in the <code class="docutils literal notranslate"><span class="pre">scancode</span></code> member, <code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code>
set to the <a class="reference internal" href="rc-protos.html#remote-controllers-protocols"><span class="std std-ref">IR protocol</span></a>, and all other
members set to 0. Write this struct to the lirc device.</p>
<p>For receiving, you read struct lirc_scancode from the LIRC device.
The <code class="docutils literal notranslate"><span class="pre">scancode</span></code> field is set to the received scancode and the
<a class="reference internal" href="rc-protos.html#remote-controllers-protocols"><span class="std std-ref">IR protocol</span></a> is set in
<code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code>. If the scancode maps to a valid key code, this is set
in the <code class="docutils literal notranslate"><span class="pre">keycode</span></code> field, else it is set to <code class="docutils literal notranslate"><span class="pre">KEY_RESERVED</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> can have <code class="docutils literal notranslate"><span class="pre">LIRC_SCANCODE_FLAG_TOGGLE</span></code> set if the toggle
bit is set in protocols that support it (e.g. rc-5 and rc-6), or
<code class="docutils literal notranslate"><span class="pre">LIRC_SCANCODE_FLAG_REPEAT</span></code> for when a repeat is received for protocols
that support it (e.g. nec).</p>
<p>In the Sanyo and NEC protocol, if you hold a button on remote, rather than
repeating the entire scancode, the remote sends a shorter message with
no scancode, which just means button is held, a “repeat”. When this is
received, the <code class="docutils literal notranslate"><span class="pre">LIRC_SCANCODE_FLAG_REPEAT</span></code> is set and the scancode and
keycode is repeated.</p>
<p>With nec, there is no way to distinguish “button hold” from “repeatedly
pressing the same button”. The rc-5 and rc-6 protocols have a toggle bit.
When a button is released and pressed again, the toggle bit is inverted.
If the toggle bit is set, the <code class="docutils literal notranslate"><span class="pre">LIRC_SCANCODE_FLAG_TOGGLE</span></code> is set.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> field is filled with the time nanoseconds
(in <code class="docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC</span></code>) when the scancode was decoded.</p>
</div></blockquote>
<p id="lirc-mode-mode2"><code class="docutils literal notranslate"><span class="pre">LIRC_MODE_MODE2</span></code></p>
<blockquote>
<div><p>The driver returns a sequence of pulse and space codes to userspace,
as a series of u32 values.</p>
<p>This mode is used only for IR receive.</p>
<p>The upper 8 bits determine the packet type, and the lower 24 bits
the payload. Use <code class="docutils literal notranslate"><span class="pre">LIRC_VALUE()</span></code> macro to get the payload, and
the macro <code class="docutils literal notranslate"><span class="pre">LIRC_MODE2()</span></code> will give you the type, which
is one of:</p>
<p><code class="docutils literal notranslate"><span class="pre">LIRC_MODE2_PULSE</span></code></p>
<blockquote>
<div><p>Signifies the presence of IR in microseconds, also known as <em>flash</em>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LIRC_MODE2_SPACE</span></code></p>
<blockquote>
<div><p>Signifies absence of IR in microseconds, also known as <em>gap</em>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LIRC_MODE2_FREQUENCY</span></code></p>
<blockquote>
<div><p>If measurement of the carrier frequency was enabled with
<a class="reference internal" href="lirc-set-measure-carrier-mode.html#lirc-set-measure-carrier-mode"><span class="std std-ref">ioctl LIRC_SET_MEASURE_CARRIER_MODE</span></a> then this packet gives you
the carrier frequency in Hertz.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LIRC_MODE2_TIMEOUT</span></code></p>
<blockquote>
<div><p>When the timeout set with <a class="reference internal" href="lirc-set-rec-timeout.html#lirc-set-rec-timeout"><span class="std std-ref">ioctl LIRC_GET_REC_TIMEOUT and LIRC_SET_REC_TIMEOUT</span></a> expires due
to no IR being detected, this packet will be sent, with the number
of microseconds with no IR.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LIRC_MODE2_OVERFLOW</span></code></p>
<blockquote>
<div><p>Signifies that the IR receiver encounter an overflow, and some IR
is missing. The IR data after this should be correct again. The
actual value is not important, but this is set to 0xffffff by the
kernel for compatibility with lircd.</p>
</div></blockquote>
</div></blockquote>
<p id="lirc-mode-pulse"><code class="docutils literal notranslate"><span class="pre">LIRC_MODE_PULSE</span></code></p>
<blockquote>
<div><p>In pulse mode, a sequence of pulse/space integer values are written to the
lirc device using <a class="reference internal" href="lirc-write.html#lirc-write"><span class="std std-ref">LIRC write()</span></a>.</p>
<p>The values are alternating pulse and space lengths, in microseconds. The
first and last entry must be a pulse, so there must be an odd number
of entries.</p>
<p>This mode is used only for IR send.</p>
</div></blockquote>
</section>
<section id="data-types-used-by-lirc-mode-scancode">
<h1><span class="section-number">6.3. </span>Data types used by LIRC_MODE_SCANCODE<a class="headerlink" href="#data-types-used-by-lirc-mode-scancode" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.MC.lirc_scancode">
struct <code class="sig-name descname">lirc_scancode</code><a class="headerlink" href="#c.MC.lirc_scancode" title="Permalink to this definition">¶</a></dt>
<dd><p>decoded scancode with protocol for use with LIRC_MODE_SCANCODE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct lirc_scancode {
    __u64 timestamp;
    __u16 flags;
    __u16 rc_proto;
    __u32 keycode;
    __u64 scancode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>Timestamp in nanoseconds using CLOCK_MONOTONIC when IR
was decoded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>should be 0 for transmit. When receiving scancodes,
LIRC_SCANCODE_FLAG_TOGGLE or LIRC_SCANCODE_FLAG_REPEAT can be set
depending on the protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_proto</span></code></dt><dd><p>see enum rc_proto</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycode</span></code></dt><dd><p>the translated keycode. Set to 0 for transmit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode</span></code></dt><dd><p>the scancode received or to be sent</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.MC.rc_proto">
enum <code class="sig-name descname">rc_proto</code><a class="headerlink" href="#c.MC.rc_proto" title="Permalink to this definition">¶</a></dt>
<dd><p>the Remote Controller protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_UNKNOWN</span></code></dt><dd><p>Protocol not known</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_OTHER</span></code></dt><dd><p>Protocol known but proprietary</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC5</span></code></dt><dd><p>Philips RC5 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC5X_20</span></code></dt><dd><p>Philips RC5x 20 bit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC5_SZ</span></code></dt><dd><p>StreamZap variant of RC5</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_JVC</span></code></dt><dd><p>JVC protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_SONY12</span></code></dt><dd><p>Sony 12 bit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_SONY15</span></code></dt><dd><p>Sony 15 bit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_SONY20</span></code></dt><dd><p>Sony 20 bit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_NEC</span></code></dt><dd><p>NEC protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_NECX</span></code></dt><dd><p>Extended NEC protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_NEC32</span></code></dt><dd><p>NEC 32 bit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_SANYO</span></code></dt><dd><p>Sanyo protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_MCIR2_KBD</span></code></dt><dd><p>RC6-ish MCE keyboard</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_MCIR2_MSE</span></code></dt><dd><p>RC6-ish MCE mouse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC6_0</span></code></dt><dd><p>Philips RC6-0-16 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC6_6A_20</span></code></dt><dd><p>Philips RC6-6A-20 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC6_6A_24</span></code></dt><dd><p>Philips RC6-6A-24 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC6_6A_32</span></code></dt><dd><p>Philips RC6-6A-32 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RC6_MCE</span></code></dt><dd><p>MCE (Philips RC6-6A-32 subtype) protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_SHARP</span></code></dt><dd><p>Sharp protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_XMP</span></code></dt><dd><p>XMP protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_CEC</span></code></dt><dd><p>CEC protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_IMON</span></code></dt><dd><p>iMon Pad protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RCMM12</span></code></dt><dd><p>RC-MM protocol 12 bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RCMM24</span></code></dt><dd><p>RC-MM protocol 24 bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_RCMM32</span></code></dt><dd><p>RC-MM protocol 32 bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_XBOX_DVD</span></code></dt><dd><p>Xbox DVD Movie Playback Kit protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_PROTO_MAX</span></code></dt><dd><p>Maximum value of enum rc_proto</p>
</dd>
</dl>
</div>
</section>
<section id="bpf-based-ir-decoder">
<h1><span class="section-number">6.4. </span>BPF based IR decoder<a class="headerlink" href="#bpf-based-ir-decoder" title="Permalink to this headline">¶</a></h1>
<p>The kernel has support for decoding the most common
<a class="reference internal" href="rc-protos.html#remote-controllers-protocols"><span class="std std-ref">IR protocols</span></a>, but there
are many protocols which are not supported. To support these, it is possible
to load an BPF program which does the decoding. This can only be done on
LIRC devices which support reading raw IR.</p>
<p>First, using the <a class="reference external" href="http://man7.org/linux/man-pages/man2/bpf.2.html">bpf(2)</a> syscall with the <code class="docutils literal notranslate"><span class="pre">BPF_LOAD_PROG</span></code> argument,
program must be loaded of type <code class="docutils literal notranslate"><span class="pre">BPF_PROG_TYPE_LIRC_MODE2</span></code>. Once attached
to the LIRC device, this program will be called for each pulse, space or
timeout event on the LIRC device. The context for the BPF program is a
pointer to a unsigned int, which is a <a class="reference internal" href="#lirc-mode-mode2"><span class="std std-ref">LIRC_MODE_MODE2</span></a>
value. When the program has decoded the scancode, it can be submitted using
the BPF functions <code class="docutils literal notranslate"><span class="pre">bpf_rc_keydown()</span></code> or <code class="docutils literal notranslate"><span class="pre">bpf_rc_repeat()</span></code>. Mouse or pointer
movements can be reported using <code class="docutils literal notranslate"><span class="pre">bpf_rc_pointer_rel()</span></code>.</p>
<p>Once you have the file descriptor for the <code class="docutils literal notranslate"><span class="pre">BPF_PROG_TYPE_LIRC_MODE2</span></code> BPF
program, it can be attached to the LIRC device using the <a class="reference external" href="http://man7.org/linux/man-pages/man2/bpf.2.html">bpf(2)</a> syscall.
The target must be the file descriptor for the LIRC device, and the
attach type must be <code class="docutils literal notranslate"><span class="pre">BPF_LIRC_MODE2</span></code>. No more than 64 BPF programs can be
attached to a single LIRC device at a time.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.1. Introduction</a></li>
<li><a class="reference internal" href="#lirc-modes">6.2. LIRC modes</a></li>
<li><a class="reference internal" href="#data-types-used-by-lirc-mode-scancode">6.3. Data types used by LIRC_MODE_SCANCODE</a></li>
<li><a class="reference internal" href="#bpf-based-ir-decoder">6.4. BPF based IR decoder</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/rc/lirc-dev-intro.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/rc/lirc-dev-intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>