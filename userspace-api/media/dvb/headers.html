
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>8. Digital TV uAPI header files &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Part III - Remote Controller API" href="../rc/remote_controllers.html" />
    <link rel="prev" title="7. Examples" href="examples.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="digital-tv-uapi-header-files">
<h1><span class="section-number">8. </span>Digital TV uAPI header files<a class="headerlink" href="#digital-tv-uapi-header-files" title="Permalink to this headline">¶</a></h1>
<section id="digital-tv-uapi-headers">
<h2><span class="section-number">8.1. </span>Digital TV uAPI headers<a class="headerlink" href="#digital-tv-uapi-headers" title="Permalink to this headline">¶</a></h2>
<section id="frontend-h">
<h3><span class="section-number">8.1.1. </span>frontend.h<a class="headerlink" href="#frontend-h" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">/* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 * frontend.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;<a class="reference external" href="mailto:marcus&#37;&#52;&#48;convergence&#46;de">marcus<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  Ralph  Metzler &lt;<a class="reference external" href="mailto:ralph&#37;&#52;&#48;convergence&#46;de">ralph<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  Holger Waechtler &lt;<a class="reference external" href="mailto:holger&#37;&#52;&#48;convergence&#46;de">holger<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  Andre Draszik &lt;<a class="reference external" href="mailto:ad&#37;&#52;&#48;convergence&#46;de">ad<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  for convergence integrated media GmbH
 */

#ifndef _DVBFRONTEND_H_
#define _DVBFRONTEND_H_

#include &lt;linux/types.h&gt;

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_caps</span></code> - Frontend capabilities
 *
 * &#64;FE_IS_STUPID:                       There's something wrong at the
 *                                      frontend, and it can't report its
 *                                      capabilities.
 * &#64;FE_CAN_INVERSION_AUTO:              Can auto-detect frequency spectral
 *                                      band inversion
 * &#64;FE_CAN_FEC_1_2:                     Supports FEC 1/2
 * &#64;FE_CAN_FEC_2_3:                     Supports FEC 2/3
 * &#64;FE_CAN_FEC_3_4:                     Supports FEC 3/4
 * &#64;FE_CAN_FEC_4_5:                     Supports FEC 4/5
 * &#64;FE_CAN_FEC_5_6:                     Supports FEC 5/6
 * &#64;FE_CAN_FEC_6_7:                     Supports FEC 6/7
 * &#64;FE_CAN_FEC_7_8:                     Supports FEC 7/8
 * &#64;FE_CAN_FEC_8_9:                     Supports FEC 8/9
 * &#64;FE_CAN_FEC_AUTO:                    Can auto-detect FEC
 * &#64;FE_CAN_QPSK:                        Supports QPSK modulation
 * &#64;FE_CAN_QAM_16:                      Supports 16-QAM modulation
 * &#64;FE_CAN_QAM_32:                      Supports 32-QAM modulation
 * &#64;FE_CAN_QAM_64:                      Supports 64-QAM modulation
 * &#64;FE_CAN_QAM_128:                     Supports 128-QAM modulation
 * &#64;FE_CAN_QAM_256:                     Supports 256-QAM modulation
 * &#64;FE_CAN_QAM_AUTO:                    Can auto-detect QAM modulation
 * &#64;FE_CAN_TRANSMISSION_MODE_AUTO:      Can auto-detect transmission mode
 * &#64;FE_CAN_BANDWIDTH_AUTO:              Can auto-detect bandwidth
 * &#64;FE_CAN_GUARD_INTERVAL_AUTO:         Can auto-detect guard interval
 * &#64;FE_CAN_HIERARCHY_AUTO:              Can auto-detect hierarchy
 * &#64;FE_CAN_8VSB:                        Supports 8-VSB modulation
 * &#64;FE_CAN_16VSB:                       Supporta 16-VSB modulation
 * &#64;FE_HAS_EXTENDED_CAPS:               Unused
 * &#64;FE_CAN_MULTISTREAM:                 Supports multistream filtering
 * &#64;FE_CAN_TURBO_FEC:                   Supports &quot;turbo FEC&quot; modulation
 * &#64;FE_CAN_2G_MODULATION:               Supports &quot;2nd generation&quot; modulation,
 *                                      e. g. DVB-S2, DVB-T2, DVB-C2
 * &#64;FE_NEEDS_BENDING:                   Unused
 * &#64;FE_CAN_RECOVER:                     Can recover from a cable unplug
 *                                      automatically
 * &#64;FE_CAN_MUTE_TS:                     Can stop spurious TS data output
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_caps</span></code> {
        FE_IS_STUPID                    = 0,
        FE_CAN_INVERSION_AUTO           = 0x1,
        FE_CAN_FEC_1_2                  = 0x2,
        FE_CAN_FEC_2_3                  = 0x4,
        FE_CAN_FEC_3_4                  = 0x8,
        FE_CAN_FEC_4_5                  = 0x10,
        FE_CAN_FEC_5_6                  = 0x20,
        FE_CAN_FEC_6_7                  = 0x40,
        FE_CAN_FEC_7_8                  = 0x80,
        FE_CAN_FEC_8_9                  = 0x100,
        FE_CAN_FEC_AUTO                 = 0x200,
        FE_CAN_QPSK                     = 0x400,
        FE_CAN_QAM_16                   = 0x800,
        FE_CAN_QAM_32                   = 0x1000,
        FE_CAN_QAM_64                   = 0x2000,
        FE_CAN_QAM_128                  = 0x4000,
        FE_CAN_QAM_256                  = 0x8000,
        FE_CAN_QAM_AUTO                 = 0x10000,
        FE_CAN_TRANSMISSION_MODE_AUTO   = 0x20000,
        FE_CAN_BANDWIDTH_AUTO           = 0x40000,
        FE_CAN_GUARD_INTERVAL_AUTO      = 0x80000,
        FE_CAN_HIERARCHY_AUTO           = 0x100000,
        FE_CAN_8VSB                     = 0x200000,
        FE_CAN_16VSB                    = 0x400000,
        FE_HAS_EXTENDED_CAPS            = 0x800000,
        FE_CAN_MULTISTREAM              = 0x4000000,
        FE_CAN_TURBO_FEC                = 0x8000000,
        FE_CAN_2G_MODULATION            = 0x10000000,
        FE_NEEDS_BENDING                = 0x20000000,
        FE_CAN_RECOVER                  = 0x40000000,
        FE_CAN_MUTE_TS                  = 0x80000000
};

/*
 * <strong>DEPRECATED</strong>: Should be kept just due to backward compatibility.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_type</span></code> {
        <a class="reference internal" href="fe-type-t.html#fe-qpsk"><span class="std std-ref">FE_QPSK</span></a>,
        <a class="reference internal" href="fe-type-t.html#fe-qam"><span class="std std-ref">FE_QAM</span></a>,
        <a class="reference internal" href="fe-type-t.html#fe-ofdm"><span class="std std-ref">FE_OFDM</span></a>,
        <a class="reference internal" href="fe-type-t.html#fe-atsc"><span class="std std-ref">FE_ATSC</span></a>
};

/**
 * struct dvb_frontend_info - Frontend properties and capabilities
 *
 * &#64;name:                       Name of the frontend
 * &#64;type:                       ****DEPRECATED****.
 *                              Should not be used on modern programs,
 *                              as a frontend may have more than one type.
 *                              In order to get the support types of a given
 *                              frontend, use :c:type:`DTV_ENUM_DELSYS`
 *                              instead.
 * &#64;frequency_min:              Minimal frequency supported by the frontend.
 * &#64;frequency_max:              Minimal frequency supported by the frontend.
 * &#64;frequency_stepsize:         All frequencies are multiple of this value.
 * &#64;frequency_tolerance:        Frequency tolerance.
 * &#64;symbol_rate_min:            Minimal symbol rate, in bauds
 *                              (for Cable/Satellite systems).
 * &#64;symbol_rate_max:            Maximal symbol rate, in bauds
 *                              (for Cable/Satellite systems).
 * &#64;symbol_rate_tolerance:      Maximal symbol rate tolerance, in ppm
 *                              (for Cable/Satellite systems).
 * &#64;notifier_delay:             ****DEPRECATED****. Not used by any driver.
 * &#64;caps:                       Capabilities supported by the frontend,
 *                              as specified in &amp;enum fe_caps.
 *
 * .. note:
 *
 *    #. The frequencies are specified in Hz for Terrestrial and Cable
 *       systems.
 *    #. The frequencies are specified in kHz for Satellite systems.
 */
struct dvb_frontend_info {
        char       name[128];
        enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_type</span></code> type;      /* <strong>DEPRECATED</strong>. Use <a class="reference internal" href="fe_property_parameters.html#dtv-enum-delsys"><span class="std std-ref">DTV_ENUM_DELSYS</span></a> instead */
        __u32      frequency_min;
        __u32      frequency_max;
        __u32      frequency_stepsize;
        __u32      frequency_tolerance;
        __u32      symbol_rate_min;
        __u32      symbol_rate_max;
        __u32      symbol_rate_tolerance;
        __u32      notifier_delay;              /* <strong>DEPRECATED</strong> */
        enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_caps</span></code> caps;
};

/**
 * struct dvb_diseqc_master_cmd - DiSEqC master command
 *
 * &#64;msg:
 *      DiSEqC message to be sent. It contains a 3 bytes header with:
 *      framing + address + command, and an optional argument
 *      of up to 3 bytes of data.
 * &#64;msg_len:
 *      Length of the DiSEqC message. Valid values are 3 to 6.
 *
 * Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
 * the possible messages that can be used.
 */
struct dvb_diseqc_master_cmd {
        __u8 msg[6];
        __u8 msg_len;
};

/**
 * struct dvb_diseqc_slave_reply - DiSEqC received data
 *
 * &#64;msg:
 *      DiSEqC message buffer to store a message received via DiSEqC.
 *      It contains one byte header with: framing and
 *      an optional argument of up to 3 bytes of data.
 * &#64;msg_len:
 *      Length of the DiSEqC message. Valid values are 0 to 4,
 *      where 0 means no message.
 * &#64;timeout:
 *      Return from ioctl after timeout ms with errorcode when
 *      no message was received.
 *
 * Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
 * the possible messages that can be used.
 */
struct dvb_diseqc_slave_reply {
        __u8 msg[4];
        __u8 msg_len;
        int  timeout;
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_voltage</span></code> - DC Voltage used to feed the LNBf
 *
 * &#64;SEC_VOLTAGE_13:     Output 13V to the LNBf
 * &#64;SEC_VOLTAGE_18:     Output 18V to the LNBf
 * &#64;SEC_VOLTAGE_OFF:    Don't feed the LNBf with a DC voltage
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_voltage</span></code> {
        SEC_VOLTAGE_13,
        SEC_VOLTAGE_18,
        SEC_VOLTAGE_OFF
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_tone_mode</span></code> - Type of tone to be send to the LNBf.
 * &#64;SEC_TONE_ON:        Sends a 22kHz tone burst to the antenna.
 * &#64;SEC_TONE_OFF:       Don't send a 22kHz tone to the antenna (except
 *                      if the ``FE_DISEQC_*`` ioctls are called).
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_tone_mode</span></code> {
        SEC_TONE_ON,
        SEC_TONE_OFF
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_mini_cmd</span></code> - Type of mini burst to be sent
 *
 * &#64;SEC_MINI_A:         Sends a mini-DiSEqC 22kHz '0' Tone Burst to select
 *                      satellite-A
 * &#64;SEC_MINI_B:         Sends a mini-DiSEqC 22kHz '1' Data Burst to select
 *                      satellite-B
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_mini_cmd</span></code> {
        SEC_MINI_A,
        SEC_MINI_B
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code> - Enumerates the possible frontend status.
 * &#64;FE_NONE:            The frontend doesn't have any kind of lock.
 *                      That's the initial frontend status
 * &#64;FE_HAS_SIGNAL:      Has found something above the noise level.
 * &#64;FE_HAS_CARRIER:     Has found a signal.
 * &#64;FE_HAS_VITERBI:     FEC inner coding (Viterbi, LDPC or other inner code).
 *                      is stable.
 * &#64;FE_HAS_SYNC:        Synchronization bytes was found.
 * &#64;FE_HAS_LOCK:        Digital TV were locked and everything is working.
 * &#64;FE_TIMEDOUT:        Fo lock within the last about 2 seconds.
 * &#64;FE_REINIT:          Frontend was reinitialized, application is recommended
 *                      to reset DiSEqC, tone and parameters.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code> {
        FE_NONE                 = 0x00,
        FE_HAS_SIGNAL           = 0x01,
        FE_HAS_CARRIER          = 0x02,
        FE_HAS_VITERBI          = 0x04,
        FE_HAS_SYNC             = 0x08,
        FE_HAS_LOCK             = 0x10,
        FE_TIMEDOUT             = 0x20,
        FE_REINIT               = 0x40,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_spectral_inversion</span></code> - Type of inversion band
 *
 * &#64;INVERSION_OFF:      Don't do spectral band inversion.
 * &#64;INVERSION_ON:       Do spectral band inversion.
 * &#64;INVERSION_AUTO:     Autodetect spectral band inversion.
 *
 * This parameter indicates if spectral inversion should be presumed or
 * not. In the automatic setting (``INVERSION_AUTO``) the hardware will try
 * to figure out the correct setting by itself. If the hardware doesn't
 * support, the %dvb_frontend will try to lock at the carrier first with
 * inversion off. If it fails, it will try to enable inversion.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_spectral_inversion</span></code> {
        INVERSION_OFF,
        INVERSION_ON,
        INVERSION_AUTO
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate</span></code> - Type of Forward Error Correction (FEC)
 *
 * &#64;FEC_NONE: No Forward Error Correction Code
 * &#64;FEC_1_2:  Forward Error Correction Code 1/2
 * &#64;FEC_2_3:  Forward Error Correction Code 2/3
 * &#64;FEC_3_4:  Forward Error Correction Code 3/4
 * &#64;FEC_4_5:  Forward Error Correction Code 4/5
 * &#64;FEC_5_6:  Forward Error Correction Code 5/6
 * &#64;FEC_6_7:  Forward Error Correction Code 6/7
 * &#64;FEC_7_8:  Forward Error Correction Code 7/8
 * &#64;FEC_8_9:  Forward Error Correction Code 8/9
 * &#64;FEC_AUTO: Autodetect Error Correction Code
 * &#64;FEC_3_5:  Forward Error Correction Code 3/5
 * &#64;FEC_9_10: Forward Error Correction Code 9/10
 * &#64;FEC_2_5:  Forward Error Correction Code 2/5
 * &#64;FEC_1_3:  Forward Error Correction Code 1/3
 * &#64;FEC_1_4:  Forward Error Correction Code 1/4
 * &#64;FEC_5_9:  Forward Error Correction Code 5/9
 * &#64;FEC_7_9:  Forward Error Correction Code 7/9
 * &#64;FEC_8_15:  Forward Error Correction Code 8/15
 * &#64;FEC_11_15: Forward Error Correction Code 11/15
 * &#64;FEC_13_18: Forward Error Correction Code 13/18
 * &#64;FEC_9_20:  Forward Error Correction Code 9/20
 * &#64;FEC_11_20: Forward Error Correction Code 11/20
 * &#64;FEC_23_36: Forward Error Correction Code 23/36
 * &#64;FEC_25_36: Forward Error Correction Code 25/36
 * &#64;FEC_13_45: Forward Error Correction Code 13/45
 * &#64;FEC_26_45: Forward Error Correction Code 26/45
 * &#64;FEC_28_45: Forward Error Correction Code 28/45
 * &#64;FEC_32_45: Forward Error Correction Code 32/45
 * &#64;FEC_77_90: Forward Error Correction Code 77/90
 *
 * Please note that not all FEC types are supported by a given standard.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate</span></code> {
        FEC_NONE = 0,
        FEC_1_2,
        FEC_2_3,
        FEC_3_4,
        FEC_4_5,
        FEC_5_6,
        FEC_6_7,
        FEC_7_8,
        FEC_8_9,
        FEC_AUTO,
        FEC_3_5,
        FEC_9_10,
        FEC_2_5,
        FEC_1_3,
        FEC_1_4,
        FEC_5_9,
        FEC_7_9,
        FEC_8_15,
        FEC_11_15,
        FEC_13_18,
        FEC_9_20,
        FEC_11_20,
        FEC_23_36,
        FEC_25_36,
        FEC_13_45,
        FEC_26_45,
        FEC_28_45,
        FEC_32_45,
        FEC_77_90,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation</span></code> - Type of modulation/constellation
 * &#64;QPSK:       QPSK modulation
 * &#64;QAM_16:     16-QAM modulation
 * &#64;QAM_32:     32-QAM modulation
 * &#64;QAM_64:     64-QAM modulation
 * &#64;QAM_128:    128-QAM modulation
 * &#64;QAM_256:    256-QAM modulation
 * &#64;QAM_AUTO:   Autodetect QAM modulation
 * &#64;VSB_8:      8-VSB modulation
 * &#64;VSB_16:     16-VSB modulation
 * &#64;PSK_8:      8-PSK modulation
 * &#64;APSK_16:    16-APSK modulation
 * &#64;APSK_32:    32-APSK modulation
 * &#64;DQPSK:      DQPSK modulation
 * &#64;QAM_4_NR:   4-QAM-NR modulation
 * &#64;QAM_1024:   1024-QAM modulation
 * &#64;QAM_4096:   4096-QAM modulation
 * &#64;APSK_8_L:   8APSK-L modulation
 * &#64;APSK_16_L:  16APSK-L modulation
 * &#64;APSK_32_L:  32APSK-L modulation
 * &#64;APSK_64:    64APSK modulation
 * &#64;APSK_64_L:  64APSK-L modulation
 *
 * Please note that not all modulations are supported by a given standard.
 *
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation</span></code> {
        QPSK,
        QAM_16,
        QAM_32,
        QAM_64,
        QAM_128,
        QAM_256,
        QAM_AUTO,
        VSB_8,
        VSB_16,
        PSK_8,
        APSK_16,
        APSK_32,
        DQPSK,
        QAM_4_NR,
        QAM_1024,
        QAM_4096,
        APSK_8_L,
        APSK_16_L,
        APSK_32_L,
        APSK_64,
        APSK_64_L,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_transmit_mode</span></code> - Transmission mode
 *
 * &#64;TRANSMISSION_MODE_AUTO:
 *      Autodetect transmission mode. The hardware will try to find the
 *      correct FFT-size (if capable) to fill in the missing parameters.
 * &#64;TRANSMISSION_MODE_1K:
 *      Transmission mode 1K
 * &#64;TRANSMISSION_MODE_2K:
 *      Transmission mode 2K
 * &#64;TRANSMISSION_MODE_8K:
 *      Transmission mode 8K
 * &#64;TRANSMISSION_MODE_4K:
 *      Transmission mode 4K
 * &#64;TRANSMISSION_MODE_16K:
 *      Transmission mode 16K
 * &#64;TRANSMISSION_MODE_32K:
 *      Transmission mode 32K
 * &#64;TRANSMISSION_MODE_C1:
 *      Single Carrier (C=1) transmission mode (DTMB only)
 * &#64;TRANSMISSION_MODE_C3780:
 *      Multi Carrier (C=3780) transmission mode (DTMB only)
 *
 * Please note that not all transmission modes are supported by a given
 * standard.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_transmit_mode</span></code> {
        TRANSMISSION_MODE_2K,
        TRANSMISSION_MODE_8K,
        TRANSMISSION_MODE_AUTO,
        TRANSMISSION_MODE_4K,
        TRANSMISSION_MODE_1K,
        TRANSMISSION_MODE_16K,
        TRANSMISSION_MODE_32K,
        TRANSMISSION_MODE_C1,
        TRANSMISSION_MODE_C3780,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_guard_interval</span></code> - Guard interval
 *
 * &#64;GUARD_INTERVAL_AUTO:        Autodetect the guard interval
 * &#64;GUARD_INTERVAL_1_128:       Guard interval 1/128
 * &#64;GUARD_INTERVAL_1_32:        Guard interval 1/32
 * &#64;GUARD_INTERVAL_1_16:        Guard interval 1/16
 * &#64;GUARD_INTERVAL_1_8:         Guard interval 1/8
 * &#64;GUARD_INTERVAL_1_4:         Guard interval 1/4
 * &#64;GUARD_INTERVAL_19_128:      Guard interval 19/128
 * &#64;GUARD_INTERVAL_19_256:      Guard interval 19/256
 * &#64;GUARD_INTERVAL_PN420:       PN length 420 (1/4)
 * &#64;GUARD_INTERVAL_PN595:       PN length 595 (1/6)
 * &#64;GUARD_INTERVAL_PN945:       PN length 945 (1/9)
 * &#64;GUARD_INTERVAL_1_64:        Guard interval 1/64
 *
 * Please note that not all guard intervals are supported by a given standard.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_guard_interval</span></code> {
        GUARD_INTERVAL_1_32,
        GUARD_INTERVAL_1_16,
        GUARD_INTERVAL_1_8,
        GUARD_INTERVAL_1_4,
        GUARD_INTERVAL_AUTO,
        GUARD_INTERVAL_1_128,
        GUARD_INTERVAL_19_128,
        GUARD_INTERVAL_19_256,
        GUARD_INTERVAL_PN420,
        GUARD_INTERVAL_PN595,
        GUARD_INTERVAL_PN945,
        GUARD_INTERVAL_1_64,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_hierarchy</span></code> - Hierarchy
 * &#64;HIERARCHY_NONE:     No hierarchy
 * &#64;HIERARCHY_AUTO:     Autodetect hierarchy (if supported)
 * &#64;HIERARCHY_1:        Hierarchy 1
 * &#64;HIERARCHY_2:        Hierarchy 2
 * &#64;HIERARCHY_4:        Hierarchy 4
 *
 * Please note that not all hierarchy types are supported by a given standard.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_hierarchy</span></code> {
        HIERARCHY_NONE,
        HIERARCHY_1,
        HIERARCHY_2,
        HIERARCHY_4,
        HIERARCHY_AUTO
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_interleaving</span></code> - Interleaving
 * &#64;INTERLEAVING_NONE:  No interleaving.
 * &#64;INTERLEAVING_AUTO:  Auto-detect interleaving.
 * &#64;INTERLEAVING_240:   Interleaving of 240 symbols.
 * &#64;INTERLEAVING_720:   Interleaving of 720 symbols.
 *
 * Please note that, currently, only DTMB uses it.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_interleaving</span></code> {
        INTERLEAVING_NONE,
        INTERLEAVING_AUTO,
        INTERLEAVING_240,
        INTERLEAVING_720,
};

/* DVBv5 property Commands */

#define <a class="reference internal" href="fe_property_parameters.html#dtv-undefined"><span class="std std-ref">DTV_UNDEFINED</span></a>           0
#define <a class="reference internal" href="fe_property_parameters.html#dtv-tune"><span class="std std-ref">DTV_TUNE</span></a>                1
#define <a class="reference internal" href="fe_property_parameters.html#dtv-clear"><span class="std std-ref">DTV_CLEAR</span></a>               2
#define <a class="reference internal" href="fe_property_parameters.html#dtv-frequency"><span class="std std-ref">DTV_FREQUENCY</span></a>           3
#define <a class="reference internal" href="fe_property_parameters.html#dtv-modulation"><span class="std std-ref">DTV_MODULATION</span></a>          4
#define <a class="reference internal" href="fe_property_parameters.html#dtv-bandwidth-hz"><span class="std std-ref">DTV_BANDWIDTH_HZ</span></a>        5
#define <a class="reference internal" href="fe_property_parameters.html#dtv-inversion"><span class="std std-ref">DTV_INVERSION</span></a>           6
#define <a class="reference internal" href="fe_property_parameters.html#dtv-diseqc-master"><span class="std std-ref">DTV_DISEQC_MASTER</span></a>       7
#define <a class="reference internal" href="fe_property_parameters.html#dtv-symbol-rate"><span class="std std-ref">DTV_SYMBOL_RATE</span></a>         8
#define <a class="reference internal" href="fe_property_parameters.html#dtv-inner-fec"><span class="std std-ref">DTV_INNER_FEC</span></a>           9
#define <a class="reference internal" href="fe_property_parameters.html#dtv-voltage"><span class="std std-ref">DTV_VOLTAGE</span></a>             10
#define <a class="reference internal" href="fe_property_parameters.html#dtv-tone"><span class="std std-ref">DTV_TONE</span></a>                11
#define <a class="reference internal" href="fe_property_parameters.html#dtv-pilot"><span class="std std-ref">DTV_PILOT</span></a>               12
#define <a class="reference internal" href="fe_property_parameters.html#dtv-rolloff"><span class="std std-ref">DTV_ROLLOFF</span></a>             13
#define <a class="reference internal" href="fe_property_parameters.html#dtv-diseqc-slave-reply"><span class="std std-ref">DTV_DISEQC_SLAVE_REPLY</span></a>  14

/* Basic enumeration set for querying unlimited capabilities */
#define <a class="reference internal" href="fe_property_parameters.html#dtv-fe-capability-count"><span class="std std-ref">DTV_FE_CAPABILITY_COUNT</span></a> 15
#define <a class="reference internal" href="fe_property_parameters.html#dtv-fe-capability"><span class="std std-ref">DTV_FE_CAPABILITY</span></a>       16
#define <a class="reference internal" href="fe_property_parameters.html#dtv-delivery-system"><span class="std std-ref">DTV_DELIVERY_SYSTEM</span></a>     17

/* ISDB-T and ISDB-Tsb */
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-partial-reception"><span class="std std-ref">DTV_ISDBT_PARTIAL_RECEPTION</span></a>     18
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-sound-broadcasting"><span class="std std-ref">DTV_ISDBT_SOUND_BROADCASTING</span></a>    19

#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-sb-subchannel-id"><span class="std std-ref">DTV_ISDBT_SB_SUBCHANNEL_ID</span></a>      20
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-sb-segment-idx"><span class="std std-ref">DTV_ISDBT_SB_SEGMENT_IDX</span></a>        21
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-sb-segment-count"><span class="std std-ref">DTV_ISDBT_SB_SEGMENT_COUNT</span></a>      22

#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-fec"><span class="std std-ref">DTV_ISDBT_LAYERA_FEC</span></a>                    23
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-modulation"><span class="std std-ref">DTV_ISDBT_LAYERA_MODULATION</span></a>             24
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-segment-count"><span class="std std-ref">DTV_ISDBT_LAYERA_SEGMENT_COUNT</span></a>          25
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-time-interleaving"><span class="std std-ref">DTV_ISDBT_LAYERA_TIME_INTERLEAVING</span></a>      26

#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-fec"><span class="std std-ref">DTV_ISDBT_LAYERB_FEC</span></a>                    27
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-modulation"><span class="std std-ref">DTV_ISDBT_LAYERB_MODULATION</span></a>             28
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-segment-count"><span class="std std-ref">DTV_ISDBT_LAYERB_SEGMENT_COUNT</span></a>          29
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-time-interleaving"><span class="std std-ref">DTV_ISDBT_LAYERB_TIME_INTERLEAVING</span></a>      30

#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-fec"><span class="std std-ref">DTV_ISDBT_LAYERC_FEC</span></a>                    31
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-modulation"><span class="std std-ref">DTV_ISDBT_LAYERC_MODULATION</span></a>             32
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-segment-count"><span class="std std-ref">DTV_ISDBT_LAYERC_SEGMENT_COUNT</span></a>          33
#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-time-interleaving"><span class="std std-ref">DTV_ISDBT_LAYERC_TIME_INTERLEAVING</span></a>      34

#define <a class="reference internal" href="fe_property_parameters.html#dtv-api-version"><span class="std std-ref">DTV_API_VERSION</span></a>         35

#define <a class="reference internal" href="fe_property_parameters.html#dtv-code-rate-hp"><span class="std std-ref">DTV_CODE_RATE_HP</span></a>        36
#define <a class="reference internal" href="fe_property_parameters.html#dtv-code-rate-lp"><span class="std std-ref">DTV_CODE_RATE_LP</span></a>        37
#define <a class="reference internal" href="fe_property_parameters.html#dtv-guard-interval"><span class="std std-ref">DTV_GUARD_INTERVAL</span></a>      38
#define <a class="reference internal" href="fe_property_parameters.html#dtv-transmission-mode"><span class="std std-ref">DTV_TRANSMISSION_MODE</span></a>   39
#define <a class="reference internal" href="fe_property_parameters.html#dtv-hierarchy"><span class="std std-ref">DTV_HIERARCHY</span></a>           40

#define <a class="reference internal" href="fe_property_parameters.html#dtv-isdbt-layer-enabled"><span class="std std-ref">DTV_ISDBT_LAYER_ENABLED</span></a> 41

#define <a class="reference internal" href="fe_property_parameters.html#dtv-stream-id"><span class="std std-ref">DTV_STREAM_ID</span></a>           42
#define DTV_ISDBS_TS_ID_LEGACY  <a class="reference internal" href="fe_property_parameters.html#dtv-stream-id"><span class="std std-ref">DTV_STREAM_ID</span></a>
#define <a class="reference internal" href="fe_property_parameters.html#dtv-dvbt2-plp-id-legacy"><span class="std std-ref">DTV_DVBT2_PLP_ID_LEGACY</span></a> 43

#define <a class="reference internal" href="fe_property_parameters.html#dtv-enum-delsys"><span class="std std-ref">DTV_ENUM_DELSYS</span></a>         44

/* ATSC-MH */
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-fic-ver"><span class="std std-ref">DTV_ATSCMH_FIC_VER</span></a>              45
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-parade-id"><span class="std std-ref">DTV_ATSCMH_PARADE_ID</span></a>            46
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-nog"><span class="std std-ref">DTV_ATSCMH_NOG</span></a>                  47
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-tnog"><span class="std std-ref">DTV_ATSCMH_TNOG</span></a>                 48
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sgn"><span class="std std-ref">DTV_ATSCMH_SGN</span></a>                  49
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-prc"><span class="std std-ref">DTV_ATSCMH_PRC</span></a>                  50
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-rs-frame-mode"><span class="std std-ref">DTV_ATSCMH_RS_FRAME_MODE</span></a>        51
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-rs-frame-ensemble"><span class="std std-ref">DTV_ATSCMH_RS_FRAME_ENSEMBLE</span></a>    52
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-rs-code-mode-pri"><span class="std std-ref">DTV_ATSCMH_RS_CODE_MODE_PRI</span></a>     53
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-rs-code-mode-sec"><span class="std std-ref">DTV_ATSCMH_RS_CODE_MODE_SEC</span></a>     54
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sccc-block-mode"><span class="std std-ref">DTV_ATSCMH_SCCC_BLOCK_MODE</span></a>      55
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sccc-code-mode-a"><span class="std std-ref">DTV_ATSCMH_SCCC_CODE_MODE_A</span></a>     56
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sccc-code-mode-b"><span class="std std-ref">DTV_ATSCMH_SCCC_CODE_MODE_B</span></a>     57
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sccc-code-mode-c"><span class="std std-ref">DTV_ATSCMH_SCCC_CODE_MODE_C</span></a>     58
#define <a class="reference internal" href="fe_property_parameters.html#dtv-atscmh-sccc-code-mode-d"><span class="std std-ref">DTV_ATSCMH_SCCC_CODE_MODE_D</span></a>     59

#define <a class="reference internal" href="fe_property_parameters.html#dtv-interleaving"><span class="std std-ref">DTV_INTERLEAVING</span></a>                        60
#define <a class="reference internal" href="fe_property_parameters.html#dtv-lna"><span class="std std-ref">DTV_LNA</span></a>                                 61

/* Quality parameters */
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-signal-strength"><span class="std std-ref">DTV_STAT_SIGNAL_STRENGTH</span></a>        62
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-cnr"><span class="std std-ref">DTV_STAT_CNR</span></a>                    63
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-pre-error-bit-count"><span class="std std-ref">DTV_STAT_PRE_ERROR_BIT_COUNT</span></a>    64
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-pre-total-bit-count"><span class="std std-ref">DTV_STAT_PRE_TOTAL_BIT_COUNT</span></a>    65
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-post-error-bit-count"><span class="std std-ref">DTV_STAT_POST_ERROR_BIT_COUNT</span></a>   66
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-post-total-bit-count"><span class="std std-ref">DTV_STAT_POST_TOTAL_BIT_COUNT</span></a>   67
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-error-block-count"><span class="std std-ref">DTV_STAT_ERROR_BLOCK_COUNT</span></a>      68
#define <a class="reference internal" href="frontend-stat-properties.html#dtv-stat-total-block-count"><span class="std std-ref">DTV_STAT_TOTAL_BLOCK_COUNT</span></a>      69

/* Physical layer scrambling */
#define <a class="reference internal" href="fe_property_parameters.html#dtv-scrambling-sequence-index"><span class="std std-ref">DTV_SCRAMBLING_SEQUENCE_INDEX</span></a>   70

#define DTV_MAX_COMMAND         <a class="reference internal" href="fe_property_parameters.html#dtv-scrambling-sequence-index"><span class="std std-ref">DTV_SCRAMBLING_SEQUENCE_INDEX</span></a>

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_pilot</span></code> - Type of pilot tone
 *
 * &#64;PILOT_ON:   Pilot tones enabled
 * &#64;PILOT_OFF:  Pilot tones disabled
 * &#64;PILOT_AUTO: Autodetect pilot tones
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_pilot</span></code> {
        PILOT_ON,
        PILOT_OFF,
        PILOT_AUTO,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_rolloff</span></code> - Rolloff factor
 * &#64;ROLLOFF_35:         Roloff factor: α=35%
 * &#64;ROLLOFF_20:         Roloff factor: α=20%
 * &#64;ROLLOFF_25:         Roloff factor: α=25%
 * &#64;ROLLOFF_AUTO:       Auto-detect the roloff factor.
 * &#64;ROLLOFF_15:         Rolloff factor: α=15%
 * &#64;ROLLOFF_10:         Rolloff factor: α=10%
 * &#64;ROLLOFF_5:          Rolloff factor: α=5%
 *
 * .. note:
 *
 *    Roloff factor of 35% is implied on DVB-S. On DVB-S2, it is default.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_rolloff</span></code> {
        ROLLOFF_35,
        ROLLOFF_20,
        ROLLOFF_25,
        ROLLOFF_AUTO,
        ROLLOFF_15,
        ROLLOFF_10,
        ROLLOFF_5,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_delivery_system</span></code> - Type of the delivery system
 *
 * &#64;SYS_UNDEFINED:
 *      Undefined standard. Generally, indicates an error
 * &#64;SYS_DVBC_ANNEX_A:
 *      Cable TV: DVB-C following ITU-T J.83 Annex A spec
 * &#64;SYS_DVBC_ANNEX_B:
 *      Cable TV: DVB-C following ITU-T J.83 Annex B spec (ClearQAM)
 * &#64;SYS_DVBC_ANNEX_C:
 *      Cable TV: DVB-C following ITU-T J.83 Annex C spec
 * &#64;SYS_DVBC2:
 *      Cable TV: DVB-C2
 * &#64;SYS_ISDBC:
 *      Cable TV: ISDB-C (no drivers yet)
 * &#64;SYS_DVBT:
 *      Terrestrial TV: DVB-T
 * &#64;SYS_DVBT2:
 *      Terrestrial TV: DVB-T2
 * &#64;SYS_ISDBT:
 *      Terrestrial TV: ISDB-T
 * &#64;SYS_ATSC:
 *      Terrestrial TV: ATSC
 * &#64;SYS_ATSCMH:
 *      Terrestrial TV (mobile): ATSC-M/H
 * &#64;SYS_DTMB:
 *      Terrestrial TV: DTMB
 * &#64;SYS_DVBS:
 *      Satellite TV: DVB-S
 * &#64;SYS_DVBS2:
 *      Satellite TV: DVB-S2 and DVB-S2X
 * &#64;SYS_TURBO:
 *      Satellite TV: DVB-S Turbo
 * &#64;SYS_ISDBS:
 *      Satellite TV: ISDB-S
 * &#64;SYS_DAB:
 *      Digital audio: DAB (not fully supported)
 * &#64;SYS_DSS:
 *      Satellite TV: DSS (not fully supported)
 * &#64;SYS_CMMB:
 *      Terrestrial TV (mobile): CMMB (not fully supported)
 * &#64;SYS_DVBH:
 *      Terrestrial TV (mobile): DVB-H (standard deprecated)
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_delivery_system</span></code> {
        SYS_UNDEFINED,
        SYS_DVBC_ANNEX_A,
        SYS_DVBC_ANNEX_B,
        SYS_DVBT,
        SYS_DSS,
        SYS_DVBS,
        SYS_DVBS2,
        SYS_DVBH,
        SYS_ISDBT,
        SYS_ISDBS,
        SYS_ISDBC,
        SYS_ATSC,
        SYS_ATSCMH,
        SYS_DTMB,
        SYS_CMMB,
        SYS_DAB,
        SYS_DVBT2,
        SYS_TURBO,
        SYS_DVBC_ANNEX_C,
        SYS_DVBC2,
};

/* backward compatibility definitions for delivery systems */
#define SYS_DVBC_ANNEX_AC       SYS_DVBC_ANNEX_A
#define SYS_DMBTH               SYS_DTMB /* DMB-TH is legacy name, use DTMB */

/* ATSC-MH specific parameters */

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_sccc_block_mode</span></code> - Type of Series Concatenated Convolutional
 *                               Code Block Mode.
 *
 * &#64;ATSCMH_SCCC_BLK_SEP:
 *      Separate SCCC: the SCCC outer code mode shall be set independently
 *      for each Group Region (A, B, C, D)
 * &#64;ATSCMH_SCCC_BLK_COMB:
 *      Combined SCCC: all four Regions shall have the same SCCC outer
 *      code mode.
 * &#64;ATSCMH_SCCC_BLK_RES:
 *      Reserved. Shouldn't be used.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_sccc_block_mode</span></code> {
        ATSCMH_SCCC_BLK_SEP      = 0,
        ATSCMH_SCCC_BLK_COMB     = 1,
        ATSCMH_SCCC_BLK_RES      = 2,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode</span></code> - Type of Series Concatenated Convolutional
 *                              Code Rate.
 *
 * &#64;ATSCMH_SCCC_CODE_HLF:
 *      The outer code rate of a SCCC Block is 1/2 rate.
 * &#64;ATSCMH_SCCC_CODE_QTR:
 *      The outer code rate of a SCCC Block is 1/4 rate.
 * &#64;ATSCMH_SCCC_CODE_RES:
 *      Reserved. Should not be used.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode</span></code> {
        ATSCMH_SCCC_CODE_HLF     = 0,
        ATSCMH_SCCC_CODE_QTR     = 1,
        ATSCMH_SCCC_CODE_RES     = 2,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_frame_ensemble</span></code> - Reed Solomon(RS) frame ensemble.
 *
 * &#64;ATSCMH_RSFRAME_ENS_PRI:     Primary Ensemble.
 * &#64;ATSCMH_RSFRAME_ENS_SEC:     Secondary Ensemble.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_frame_ensemble</span></code> {
        ATSCMH_RSFRAME_ENS_PRI   = 0,
        ATSCMH_RSFRAME_ENS_SEC   = 1,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_frame_mode</span></code> - Reed Solomon (RS) frame mode.
 *
 * &#64;ATSCMH_RSFRAME_PRI_ONLY:
 *      Single Frame: There is only a primary RS Frame for all Group
 *      Regions.
 * &#64;ATSCMH_RSFRAME_PRI_SEC:
 *      Dual Frame: There are two separate RS Frames: Primary RS Frame for
 *      Group Region A and B and Secondary RS Frame for Group Region C and
 *      D.
 * &#64;ATSCMH_RSFRAME_RES:
 *      Reserved. Shouldn't be used.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_frame_mode</span></code> {
        ATSCMH_RSFRAME_PRI_ONLY  = 0,
        ATSCMH_RSFRAME_PRI_SEC   = 1,
        ATSCMH_RSFRAME_RES       = 2,
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_code_mode</span></code> - ATSC-M/H Reed Solomon modes
 * &#64;ATSCMH_RSCODE_211_187:      Reed Solomon code (211,187).
 * &#64;ATSCMH_RSCODE_223_187:      Reed Solomon code (223,187).
 * &#64;ATSCMH_RSCODE_235_187:      Reed Solomon code (235,187).
 * &#64;ATSCMH_RSCODE_RES:          Reserved. Shouldn't be used.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">atscmh_rs_code_mode</span></code> {
        ATSCMH_RSCODE_211_187    = 0,
        ATSCMH_RSCODE_223_187    = 1,
        ATSCMH_RSCODE_235_187    = 2,
        ATSCMH_RSCODE_RES        = 3,
};

#define <a class="reference internal" href="fe_property_parameters.html#dtv-stream-id"><span class="std std-ref">NO_STREAM_ID_FILTER</span></a>     (~0U)
#define <a class="reference internal" href="fe_property_parameters.html#dtv-lna"><span class="std std-ref">LNA_AUTO</span></a>                (~0U)

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fecap_scale_params</span></code> - scale types for the quality parameters.
 *
 * &#64;FE_SCALE_NOT_AVAILABLE: That QoS measure is not available. That
 *                          could indicate a temporary or a permanent
 *                          condition.
 * &#64;FE_SCALE_DECIBEL: The scale is measured in 0.001 dB steps, typically
 *                    used on signal measures.
 * &#64;FE_SCALE_RELATIVE: The scale is a relative percentual measure,
 *                     ranging from 0 (0%) to 0xffff (100%).
 * &#64;FE_SCALE_COUNTER: The scale counts the occurrence of an event, like
 *                    bit error, block error, lapsed time.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fecap_scale_params</span></code> {
        FE_SCALE_NOT_AVAILABLE = 0,
        FE_SCALE_DECIBEL,
        FE_SCALE_RELATIVE,
        FE_SCALE_COUNTER
};

/**
 * struct dtv_stats - Used for reading a DTV status property
 *
 * &#64;scale:
 *      Filled with enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fecap_scale_params</span></code> - the scale in usage
 *      for that parameter
 *
 * &#64;svalue:
 *      integer value of the measure, for %FE_SCALE_DECIBEL,
 *      used for dB measures. The unit is 0.001 dB.
 *
 * &#64;uvalue:
 *      unsigned integer value of the measure, used when &#64;scale is
 *      either %FE_SCALE_RELATIVE or %FE_SCALE_COUNTER.
 *
 * For most delivery systems, this will return a single value for each
 * parameter.
 *
 * It should be noticed, however, that new OFDM delivery systems like
 * ISDB can use different modulation types for each group of carriers.
 * On such standards, up to 8 groups of statistics can be provided, one
 * for each carrier group (called &quot;layer&quot; on ISDB).
 *
 * In order to be consistent with other delivery systems, the first
 * value refers to the entire set of carriers (&quot;global&quot;).
 *
 * &#64;scale should use the value %FE_SCALE_NOT_AVAILABLE when
 * the value for the entire group of carriers or from one specific layer
 * is not provided by the hardware.
 *
 * &#64;len should be filled with the latest filled status + 1.
 *
 * In other words, for ISDB, those values should be filled like::
 *
 *      u.st.stat.svalue[0] = global statistics;
 *      u.st.stat.scale[0] = FE_SCALE_DECIBEL;
 *      u.st.stat.value[1] = layer A statistics;
 *      u.st.stat.scale[1] = FE_SCALE_NOT_AVAILABLE (if not available);
 *      u.st.stat.svalue[2] = layer B statistics;
 *      u.st.stat.scale[2] = FE_SCALE_DECIBEL;
 *      u.st.stat.svalue[3] = layer C statistics;
 *      u.st.stat.scale[3] = FE_SCALE_DECIBEL;
 *      u.st.len = 4;
 */
struct dtv_stats {
        __u8 scale;     /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fecap_scale_params</span></code> type */
        union {
                __u64 uvalue;   /* for counters and relative scales */
                __s64 svalue;   /* for 0.001 dB measures */
        };
} __attribute__ ((packed));

#define MAX_DTV_STATS   4

/**
 * struct dtv_fe_stats - store Digital TV frontend statistics
 *
 * &#64;len:        length of the statistics - if zero, stats is disabled.
 * &#64;stat:       array with digital TV statistics.
 *
 * On most standards, &#64;len can either be 0 or 1. However, for ISDB, each
 * layer is modulated in separate. So, each layer may have its own set
 * of statistics. If so, stat[0] carries on a global value for the property.
 * Indexes 1 to 3 means layer A to B.
 */
struct dtv_fe_stats {
        __u8 len;
        struct dtv_stats stat[MAX_DTV_STATS];
} __attribute__ ((packed));

/**
 * struct dtv_property - store one of frontend command and its value
 *
 * &#64;cmd:                Digital TV command.
 * &#64;reserved:           Not used.
 * &#64;u:                  Union with the values for the command.
 * &#64;u.data:             A unsigned 32 bits integer with command value.
 * &#64;u.buffer:           Struct to store bigger properties.
 *                      Currently unused.
 * &#64;u.buffer.data:      an unsigned 32-bits array.
 * &#64;u.buffer.len:       number of elements of the buffer.
 * &#64;u.buffer.reserved1: Reserved.
 * &#64;u.buffer.reserved2: Reserved.
 * &#64;u.st:               a &amp;struct dtv_fe_stats array of statistics.
 * &#64;result:             Currently unused.
 *
 */
struct dtv_property {
        __u32 cmd;
        __u32 reserved[3];
        union {
                __u32 data;
                struct dtv_fe_stats st;
                struct {
                        __u8 data[32];
                        __u32 len;
                        __u32 reserved1[3];
                        void *reserved2;
                } buffer;
        } u;
        int result;
} __attribute__ ((packed));

/* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
#define DTV_IOCTL_MAX_MSGS 64

/**
 * struct dtv_properties - a set of command/value pairs.
 *
 * &#64;num:        amount of commands stored at the struct.
 * &#64;props:      a pointer to &amp;struct dtv_property.
 */
struct dtv_properties {
        __u32 num;
        struct dtv_property *props;
};

/*
 * When set, this flag will disable any zigzagging or other &quot;normal&quot; tuning
 * behavior. Additionally, there will be no automatic monitoring of the lock
 * status, and hence no frontend events will be generated. If a frontend device
 * is closed, this flag will be automatically turned off when the device is
 * reopened read-write.
 */
#define <code class="xref c c-func docutils literal notranslate"><span class="pre">FE_TUNE_MODE_ONESHOT</span></code> 0x01

/* Digital TV Frontend API calls */

#define <a class="reference internal" href="fe-get-info.html#fe-get-info"><span class="std std-ref">FE_GET_INFO</span></a>                _IOR('o', 61, struct dvb_frontend_info)

#define <a class="reference internal" href="fe-diseqc-reset-overload.html#fe-diseqc-reset-overload"><span class="std std-ref">FE_DISEQC_RESET_OVERLOAD</span></a>   _IO('o', 62)
#define <a class="reference internal" href="fe-diseqc-send-master-cmd.html#fe-diseqc-send-master-cmd"><span class="std std-ref">FE_DISEQC_SEND_MASTER_CMD</span></a>  _IOW('o', 63, struct dvb_diseqc_master_cmd)
#define <a class="reference internal" href="fe-diseqc-recv-slave-reply.html#fe-diseqc-recv-slave-reply"><span class="std std-ref">FE_DISEQC_RECV_SLAVE_REPLY</span></a> _IOR('o', 64, struct dvb_diseqc_slave_reply)
#define <a class="reference internal" href="fe-diseqc-send-burst.html#fe-diseqc-send-burst"><span class="std std-ref">FE_DISEQC_SEND_BURST</span></a>       _IO('o', 65)  /* <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_mini_cmd_t</span></code> */

#define <a class="reference internal" href="fe-set-tone.html#fe-set-tone"><span class="std std-ref">FE_SET_TONE</span></a>                _IO('o', 66)  /* <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_tone_mode_t</span></code> */
#define <a class="reference internal" href="fe-set-voltage.html#fe-set-voltage"><span class="std std-ref">FE_SET_VOLTAGE</span></a>             _IO('o', 67)  /* <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_voltage_t</span></code> */
#define <a class="reference internal" href="fe-enable-high-lnb-voltage.html#fe-enable-high-lnb-voltage"><span class="std std-ref">FE_ENABLE_HIGH_LNB_VOLTAGE</span></a> _IO('o', 68)  /* int */

#define <a class="reference internal" href="fe-read-status.html#fe-read-status"><span class="std std-ref">FE_READ_STATUS</span></a>             _IOR('o', 69, <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status_t</span></code>)
#define <a class="reference internal" href="fe-read-ber.html#fe-read-ber"><span class="std std-ref">FE_READ_BER</span></a>                _IOR('o', 70, __u32)
#define <a class="reference internal" href="fe-read-signal-strength.html#fe-read-signal-strength"><span class="std std-ref">FE_READ_SIGNAL_STRENGTH</span></a>    _IOR('o', 71, __u16)
#define <a class="reference internal" href="fe-read-snr.html#fe-read-snr"><span class="std std-ref">FE_READ_SNR</span></a>                _IOR('o', 72, __u16)
#define <a class="reference internal" href="fe-read-uncorrected-blocks.html#fe-read-uncorrected-blocks"><span class="std std-ref">FE_READ_UNCORRECTED_BLOCKS</span></a> _IOR('o', 73, __u32)

#define <a class="reference internal" href="fe-set-frontend-tune-mode.html#fe-set-frontend-tune-mode"><span class="std std-ref">FE_SET_FRONTEND_TUNE_MODE</span></a>  _IO('o', 81) /* unsigned int */
#define <a class="reference internal" href="fe-get-event.html#fe-get-event"><span class="std std-ref">FE_GET_EVENT</span></a>               _IOR('o', 78, struct dvb_frontend_event)

#define <a class="reference internal" href="fe-dishnetwork-send-legacy-cmd.html#fe-dishnetwork-send-legacy-cmd"><span class="std std-ref">FE_DISHNETWORK_SEND_LEGACY_CMD</span></a> _IO('o', 80) /* unsigned int */

#define <code class="xref c c-type docutils literal notranslate"><span class="pre">FE_SET_PROPERTY</span></code>            _IOW('o', 82, struct dtv_properties)
#define <a class="reference internal" href="fe-get-property.html#fe-get-property"><span class="std std-ref">FE_GET_PROPERTY</span></a>            _IOR('o', 83, struct dtv_properties)

#if defined(__DVB_CORE__) || !defined(__KERNEL__)

/*
 * <strong>DEPRECATED</strong>: Everything below is deprecated in favor of DVBv5 API
 *
 * The DVBv3 only ioctls, structs and enums should not be used on
 * newer programs, as it doesn't support the second generation of
 * digital TV standards, nor supports newer delivery systems.
 * They also don't support modern frontends with usually support multiple
 * delivery systems.
 *
 * Drivers shouldn't use them.
 *
 * New applications should use DVBv5 delivery system instead
 */

/*
 */

enum <a class="reference internal" href="fe-bandwidth-t.html#c.fe_bandwidth" title="fe_bandwidth"><code class="xref c c-type docutils literal notranslate"><span class="pre">fe_bandwidth</span></code></a> {
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-8-mhz"><span class="std std-ref">BANDWIDTH_8_MHZ</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-7-mhz"><span class="std std-ref">BANDWIDTH_7_MHZ</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-6-mhz"><span class="std std-ref">BANDWIDTH_6_MHZ</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-auto"><span class="std std-ref">BANDWIDTH_AUTO</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-5-mhz"><span class="std std-ref">BANDWIDTH_5_MHZ</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-10-mhz"><span class="std std-ref">BANDWIDTH_10_MHZ</span></a>,
        <a class="reference internal" href="fe-bandwidth-t.html#bandwidth-1-712-mhz"><span class="std std-ref">BANDWIDTH_1_712_MHZ</span></a>,
};

/* This is kept for legacy userspace support */
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_voltage</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_voltage_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_caps</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_caps_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_type</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_type_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_tone_mode</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_tone_mode_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_mini_cmd</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_sec_mini_cmd_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_spectral_inversion</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_spectral_inversion_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_transmit_mode</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_transmit_mode_t</span></code>;
typedef enum <a class="reference internal" href="fe-bandwidth-t.html#c.fe_bandwidth" title="fe_bandwidth"><code class="xref c c-type docutils literal notranslate"><span class="pre">fe_bandwidth</span></code></a> <a class="reference internal" href="fe-bandwidth-t.html#c.fe_bandwidth" title="fe_bandwidth"><code class="xref c c-type docutils literal notranslate"><span class="pre">fe_bandwidth_t</span></code></a>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_guard_interval</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_guard_interval_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_hierarchy</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_hierarchy_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_pilot</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_pilot_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_rolloff</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_rolloff_t</span></code>;
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_delivery_system</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_delivery_system_t</span></code>;

/* DVBv3 structs */

struct dvb_qpsk_parameters {
        __u32           symbol_rate;  /* symbol rate in Symbols per second */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate_t</span></code>  fec_inner;    /* forward error correction (see above) */
};

struct dvb_qam_parameters {
        __u32           symbol_rate; /* symbol rate in Symbols per second */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate_t</span></code>  fec_inner;   /* forward error correction (see above) */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation_t</span></code> modulation;  /* modulation type (see above) */
};

struct dvb_vsb_parameters {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation_t</span></code> modulation;  /* modulation type (see above) */
};

struct dvb_ofdm_parameters {
        <a class="reference internal" href="fe-bandwidth-t.html#c.fe_bandwidth" title="fe_bandwidth"><code class="xref c c-type docutils literal notranslate"><span class="pre">fe_bandwidth_t</span></code></a>      bandwidth;
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate_t</span></code>      code_rate_HP;  /* high priority stream code rate */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_code_rate_t</span></code>      code_rate_LP;  /* low priority stream code rate */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_modulation_t</span></code>     constellation; /* modulation type (see above) */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_transmit_mode_t</span></code>  transmission_mode;
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_guard_interval_t</span></code> guard_interval;
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_hierarchy_t</span></code>      hierarchy_information;
};

struct dvb_frontend_parameters {
        __u32 frequency;  /* (absolute) frequency in Hz for DVB-C/DVB-T/ATSC */
                          /* intermediate frequency in kHz for DVB-S */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_spectral_inversion_t</span></code> inversion;
        union {
                struct dvb_qpsk_parameters qpsk;        /* DVB-S */
                struct dvb_qam_parameters  qam;         /* DVB-C */
                struct dvb_ofdm_parameters ofdm;        /* DVB-T */
                struct dvb_vsb_parameters vsb;          /* ATSC */
        } u;
};

struct dvb_frontend_event {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status_t</span></code> status;
        struct dvb_frontend_parameters parameters;
};

/* DVBv3 API calls */

#define <a class="reference internal" href="fe-set-frontend.html#fe-set-frontend"><span class="std std-ref">FE_SET_FRONTEND</span></a>            _IOW('o', 76, struct dvb_frontend_parameters)
#define <a class="reference internal" href="fe-get-frontend.html#fe-get-frontend"><span class="std std-ref">FE_GET_FRONTEND</span></a>            _IOR('o', 77, struct dvb_frontend_parameters)

#endif

#endif /*_DVBFRONTEND_H_*/</pre>
</section>
<section id="dmx-h">
<h3><span class="section-number">8.1.2. </span>dmx.h<a class="headerlink" href="#dmx-h" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">/* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 * dmx.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;<a class="reference external" href="mailto:marcus&#37;&#52;&#48;convergence&#46;de">marcus<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  &amp; Ralph  Metzler &lt;<a class="reference external" href="mailto:ralph&#37;&#52;&#48;convergence&#46;de">ralph<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                    for convergence integrated media GmbH
 */

#ifndef _UAPI_DVBDMX_H_
#define _UAPI_DVBDMX_H_

#include &lt;linux/types.h&gt;
#ifndef __KERNEL__
#include &lt;time.h&gt;
#endif

#define DMX_FILTER_SIZE 16

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_output</span></code> - Output for the demux.
 *
 * &#64;:c:type:<cite>DMX_OUT_DECODER &lt;dmx_output&gt;</cite>:
 *      Streaming directly to decoder.
 * &#64;:c:type:<cite>DMX_OUT_TAP &lt;dmx_output&gt;</cite>:
 *      Output going to a memory buffer (to be retrieved via the read command).
 *      Delivers the stream output to the demux device on which the ioctl
 *      is called.
 * &#64;:c:type:<cite>DMX_OUT_TS_TAP &lt;dmx_output&gt;</cite>:
 *      Output multiplexed into a new TS (to be retrieved by reading from the
 *      logical DVR device). Routes output to the logical DVR device
 *      ``/dev/dvb/adapter?/dvr?``, which delivers a TS multiplexed from all
 *      filters for which &#64;:c:type:<cite>DMX_OUT_TS_TAP &lt;dmx_output&gt;</cite> was specified.
 * &#64;:c:type:<cite>DMX_OUT_TSDEMUX_TAP &lt;dmx_output&gt;</cite>:
 *      Like &#64;:c:type:<cite>DMX_OUT_TS_TAP &lt;dmx_output&gt;</cite> but retrieved from the DMX device.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_output</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_OUT_DECODER</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_OUT_TAP</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_OUT_TS_TAP</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_OUT_TSDEMUX_TAP</span></code>
};

/**
 * <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_input</span></code> - Input from the demux.
 *
 * &#64;:c:type:<cite>DMX_IN_FRONTEND &lt;dmx_input&gt;</cite>:    Input from a front-end device.
 * &#64;:c:type:<cite>DMX_IN_DVR &lt;dmx_input&gt;</cite>:         Input from the logical DVR device.
 */
<code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_input</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_IN_FRONTEND</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_IN_DVR</span></code>
};

/**
 * <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_ts_pes</span></code> - type of the PES filter.
 *
 * &#64;:c:type:<cite>DMX_PES_AUDIO0 &lt;dmx_pes_type&gt;</cite>:     first audio PID. Also referred as &#64;DMX_PES_AUDIO.
 * &#64;:c:type:<cite>DMX_PES_VIDEO0 &lt;dmx_pes_type&gt;</cite>:     first video PID. Also referred as &#64;DMX_PES_VIDEO.
 * &#64;:c:type:<cite>DMX_PES_TELETEXT0 &lt;dmx_pes_type&gt;</cite>:  first teletext PID. Also referred as &#64;DMX_PES_TELETEXT.
 * &#64;:c:type:<cite>DMX_PES_SUBTITLE0 &lt;dmx_pes_type&gt;</cite>:  first subtitle PID. Also referred as &#64;DMX_PES_SUBTITLE.
 * &#64;:c:type:<cite>DMX_PES_PCR0 &lt;dmx_pes_type&gt;</cite>:       first Program Clock Reference PID.
 *                      Also referred as &#64;DMX_PES_PCR.
 *
 * &#64;:c:type:<cite>DMX_PES_AUDIO1 &lt;dmx_pes_type&gt;</cite>:     second audio PID.
 * &#64;:c:type:<cite>DMX_PES_VIDEO1 &lt;dmx_pes_type&gt;</cite>:     second video PID.
 * &#64;:c:type:<cite>DMX_PES_TELETEXT1 &lt;dmx_pes_type&gt;</cite>:  second teletext PID.
 * &#64;:c:type:<cite>DMX_PES_SUBTITLE1 &lt;dmx_pes_type&gt;</cite>:  second subtitle PID.
 * &#64;:c:type:<cite>DMX_PES_PCR1 &lt;dmx_pes_type&gt;</cite>:       second Program Clock Reference PID.
 *
 * &#64;:c:type:<cite>DMX_PES_AUDIO2 &lt;dmx_pes_type&gt;</cite>:     third audio PID.
 * &#64;:c:type:<cite>DMX_PES_VIDEO2 &lt;dmx_pes_type&gt;</cite>:     third video PID.
 * &#64;:c:type:<cite>DMX_PES_TELETEXT2 &lt;dmx_pes_type&gt;</cite>:  third teletext PID.
 * &#64;:c:type:<cite>DMX_PES_SUBTITLE2 &lt;dmx_pes_type&gt;</cite>:  third subtitle PID.
 * &#64;:c:type:<cite>DMX_PES_PCR2 &lt;dmx_pes_type&gt;</cite>:       third Program Clock Reference PID.
 *
 * &#64;:c:type:<cite>DMX_PES_AUDIO3 &lt;dmx_pes_type&gt;</cite>:     fourth audio PID.
 * &#64;:c:type:<cite>DMX_PES_VIDEO3 &lt;dmx_pes_type&gt;</cite>:     fourth video PID.
 * &#64;:c:type:<cite>DMX_PES_TELETEXT3 &lt;dmx_pes_type&gt;</cite>:  fourth teletext PID.
 * &#64;:c:type:<cite>DMX_PES_SUBTITLE3 &lt;dmx_pes_type&gt;</cite>:  fourth subtitle PID.
 * &#64;:c:type:<cite>DMX_PES_PCR3 &lt;dmx_pes_type&gt;</cite>:       fourth Program Clock Reference PID.
 *
 * &#64;:c:type:<cite>DMX_PES_OTHER &lt;dmx_pes_type&gt;</cite>:      any other PID.
 */

<code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_ts_pes</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_AUDIO0</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_VIDEO0</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_TELETEXT0</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_SUBTITLE0</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_PCR0</span></code>,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_AUDIO1</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_VIDEO1</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_TELETEXT1</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_SUBTITLE1</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_PCR1</span></code>,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_AUDIO2</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_VIDEO2</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_TELETEXT2</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_SUBTITLE2</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_PCR2</span></code>,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_AUDIO3</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_VIDEO3</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_TELETEXT3</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_SUBTITLE3</span></code>,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_PCR3</span></code>,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_OTHER</span></code>
};

#define DMX_PES_AUDIO    <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_AUDIO0</span></code>
#define DMX_PES_VIDEO    <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_VIDEO0</span></code>
#define DMX_PES_TELETEXT <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_TELETEXT0</span></code>
#define DMX_PES_SUBTITLE <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_SUBTITLE0</span></code>
#define DMX_PES_PCR      <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_PES_PCR0</span></code>

/**
 * struct dmx_filter - Specifies a section header filter.
 *
 * &#64;filter: bit array with bits to be matched at the section header.
 * &#64;mask: bits that are valid at the filter bit array.
 * &#64;mode: mode of match: if bit is zero, it will match if equal (positive
 *        match); if bit is one, it will match if the bit is negated.
 *
 * Note: All arrays in this struct have a size of DMX_FILTER_SIZE (16 bytes).
 */
struct dmx_filter {
        __u8  filter[DMX_FILTER_SIZE];
        __u8  mask[DMX_FILTER_SIZE];
        __u8  mode[DMX_FILTER_SIZE];
};

/**
 * struct dmx_sct_filter_params - Specifies a section filter.
 *
 * &#64;pid: PID to be filtered.
 * &#64;filter: section header filter, as defined by &amp;struct dmx_filter.
 * &#64;timeout: maximum time to filter, in milliseconds.
 * &#64;flags: extra flags for the section filter.
 *
 * Carries the configuration for a MPEG-TS section filter.
 *
 * The &#64;flags can be:
 *
 *      - %DMX_CHECK_CRC - only deliver sections where the CRC check succeeded;
 *      - %DMX_ONESHOT - disable the section filter after one section
 *        has been delivered;
 *      - %DMX_IMMEDIATE_START - Start filter immediately without requiring a
 *        :ref:`DMX_START`.
 */
struct dmx_sct_filter_params {
        __u16             pid;
        struct dmx_filter filter;
        __u32             timeout;
        __u32             flags;
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_CHECK_CRC</span></code>       1
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_ONESHOT</span></code>         2
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_IMMEDIATE_START</span></code> 4
};

/**
 * struct dmx_pes_filter_params - Specifies Packetized Elementary Stream (PES)
 *      filter parameters.
 *
 * &#64;pid:        PID to be filtered.
 * &#64;input:      Demux input, as specified by &amp;enum dmx_input.
 * &#64;output:     Demux output, as specified by &amp;enum dmx_output.
 * &#64;pes_type:   Type of the pes filter, as specified by &amp;enum dmx_pes_type.
 * &#64;flags:      Demux PES flags.
 */
struct dmx_pes_filter_params {
        __u16           pid;
        <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_input</span></code>  input;
        enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_output</span></code> output;
        <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_ts_pes</span></code> pes_type;
        __u32           flags;
};

/**
 * struct dmx_stc - Stores System Time Counter (STC) information.
 *
 * &#64;num: input data: number of the STC, from 0 to N.
 * &#64;base: output: divisor for STC to get 90 kHz clock.
 * &#64;stc: output: stc in &#64;base * 90 kHz units.
 */
struct dmx_stc {
        unsigned int num;
        unsigned int base;
        __u64 stc;
};

/**
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_buffer_flags</span></code> - DMX memory-mapped buffer flags
 *
 * &#64;:c:type:<cite>DMX_BUFFER_FLAG_HAD_CRC32_DISCARD &lt;dmx_buffer_flags&gt;</cite>:
 *      Indicates that the Kernel discarded one or more frames due to wrong
 *      CRC32 checksum.
 * &#64;:c:type:<cite>DMX_BUFFER_FLAG_TEI &lt;dmx_buffer_flags&gt;</cite>:
 *      Indicates that the Kernel has detected a Transport Error indicator
 *      (TEI) on a filtered pid.
 * &#64;:c:type:<cite>DMX_BUFFER_PKT_COUNTER_MISMATCH &lt;dmx_buffer_flags&gt;</cite>:
 *      Indicates that the Kernel has detected a packet counter mismatch
 *      on a filtered pid.
 * &#64;:c:type:<cite>DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED &lt;dmx_buffer_flags&gt;</cite>:
 *      Indicates that the Kernel has detected one or more frame discontinuity.
 * &#64;:c:type:<cite>DMX_BUFFER_FLAG_DISCONTINUITY_INDICATOR &lt;dmx_buffer_flags&gt;</cite>:
 *      Received at least one packet with a frame discontinuity indicator.
 */

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_buffer_flags</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_BUFFER_FLAG_HAD_CRC32_DISCARD</span></code>               = 1 &lt;&lt; 0,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_BUFFER_FLAG_TEI</span></code>                             = 1 &lt;&lt; 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_BUFFER_PKT_COUNTER_MISMATCH</span></code>                 = 1 &lt;&lt; 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED</span></code>          = 1 &lt;&lt; 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_BUFFER_FLAG_DISCONTINUITY_INDICATOR</span></code>         = 1 &lt;&lt; 4,
};

/**
 * struct dmx_buffer - dmx buffer info
 *
 * &#64;index:      id number of the buffer
 * &#64;bytesused:  number of bytes occupied by data in the buffer (payload);
 * &#64;offset:     for buffers with memory == DMX_MEMORY_MMAP;
 *              offset from the start of the device memory for this plane,
 *              (or a &quot;cookie&quot; that should be passed to mmap() as offset)
 * &#64;length:     size in bytes of the buffer
 * &#64;flags:      bit array of buffer flags as defined by &amp;enum dmx_buffer_flags.
 *              Filled only at &amp;DMX_DQBUF.
 * &#64;count:      monotonic counter for filled buffers. Helps to identify
 *              data stream loses. Filled only at &amp;DMX_DQBUF.
 *
 * Contains data exchanged by application and driver using one of the streaming
 * I/O methods.
 *
 * Please notice that, for &amp;DMX_QBUF, only &#64;index should be filled.
 * On &amp;DMX_DQBUF calls, all fields will be filled by the Kernel.
 */
struct dmx_buffer {
        __u32                   index;
        __u32                   bytesused;
        __u32                   offset;
        __u32                   length;
        __u32                   flags;
        __u32                   count;
};

/**
 * struct dmx_requestbuffers - request dmx buffer information
 *
 * &#64;count:      number of requested buffers,
 * &#64;size:       size in bytes of the requested buffer
 *
 * Contains data used for requesting a dmx buffer.
 * All reserved fields must be set to zero.
 */
struct dmx_requestbuffers {
        __u32                   count;
        __u32                   size;
};

/**
 * struct dmx_exportbuffer - export of dmx buffer as DMABUF file descriptor
 *
 * &#64;index:      id number of the buffer
 * &#64;flags:      flags for newly created file, currently only O_CLOEXEC is
 *              supported, refer to manual of open syscall for more details
 * &#64;fd:         file descriptor associated with DMABUF (set by driver)
 *
 * Contains data used for exporting a dmx buffer as DMABUF file descriptor.
 * The buffer is identified by a 'cookie' returned by <a class="reference internal" href="dmx-querybuf.html#dmx-querybuf"><span class="std std-ref">DMX_QUERYBUF</span></a>
 * (identical to the cookie used to mmap() the buffer to userspace). All
 * reserved fields must be set to zero. The field reserved0 is expected to
 * become a structure 'type' allowing an alternative layout of the structure
 * content. Therefore this field should not be used for any other extensions.
 */
struct dmx_exportbuffer {
        __u32           index;
        __u32           flags;
        __s32           fd;
};

#define <a class="reference internal" href="dmx-start.html#dmx-start"><span class="std std-ref">DMX_START</span></a>                _IO('o', 41)
#define <a class="reference internal" href="dmx-stop.html#dmx-stop"><span class="std std-ref">DMX_STOP</span></a>                 _IO('o', 42)
#define <a class="reference internal" href="dmx-set-filter.html#dmx-set-filter"><span class="std std-ref">DMX_SET_FILTER</span></a>           _IOW('o', 43, struct dmx_sct_filter_params)
#define <a class="reference internal" href="dmx-set-pes-filter.html#dmx-set-pes-filter"><span class="std std-ref">DMX_SET_PES_FILTER</span></a>       _IOW('o', 44, struct dmx_pes_filter_params)
#define <a class="reference internal" href="dmx-set-buffer-size.html#dmx-set-buffer-size"><span class="std std-ref">DMX_SET_BUFFER_SIZE</span></a>      _IO('o', 45)
#define <a class="reference internal" href="dmx-get-pes-pids.html#dmx-get-pes-pids"><span class="std std-ref">DMX_GET_PES_PIDS</span></a>         _IOR('o', 47, __u16[5])
#define <a class="reference internal" href="dmx-get-stc.html#dmx-get-stc"><span class="std std-ref">DMX_GET_STC</span></a>              _IOWR('o', 50, struct dmx_stc)
#define <a class="reference internal" href="dmx-add-pid.html#dmx-add-pid"><span class="std std-ref">DMX_ADD_PID</span></a>              _IOW('o', 51, __u16)
#define <a class="reference internal" href="dmx-remove-pid.html#dmx-remove-pid"><span class="std std-ref">DMX_REMOVE_PID</span></a>           _IOW('o', 52, __u16)

#if !defined(__KERNEL__)

/* This is needed for legacy userspace support */
typedef enum <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_output</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_output_t</span></code>;
typedef <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_input</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_input_t</span></code>;
typedef <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_ts_pes</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_pes_type_t</span></code>;
typedef struct dmx_filter <code class="xref c c-type docutils literal notranslate"><span class="pre">dmx_filter_t</span></code>;

#endif

#define <a class="reference internal" href="dmx-reqbufs.html#dmx-reqbufs"><span class="std std-ref">DMX_REQBUFS</span></a>              _IOWR('o', 60, struct dmx_requestbuffers)
#define <a class="reference internal" href="dmx-querybuf.html#dmx-querybuf"><span class="std std-ref">DMX_QUERYBUF</span></a>             _IOWR('o', 61, struct dmx_buffer)
#define <a class="reference internal" href="dmx-expbuf.html#dmx-expbuf"><span class="std std-ref">DMX_EXPBUF</span></a>               _IOWR('o', 62, struct dmx_exportbuffer)
#define <a class="reference internal" href="dmx-qbuf.html#dmx-qbuf"><span class="std std-ref">DMX_QBUF</span></a>                 _IOWR('o', 63, struct dmx_buffer)
#define <a class="reference internal" href="dmx-qbuf.html#dmx-qbuf"><span class="std std-ref">DMX_DQBUF</span></a>                _IOWR('o', 64, struct dmx_buffer)

#endif /* _DVBDMX_H_ */</pre>
</section>
<section id="ca-h">
<h3><span class="section-number">8.1.3. </span>ca.h<a class="headerlink" href="#ca-h" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">/* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 * ca.h
 *
 * Copyright (C) 2000 Ralph  Metzler &lt;<a class="reference external" href="mailto:ralph&#37;&#52;&#48;convergence&#46;de">ralph<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  &amp; Marcus Metzler &lt;<a class="reference external" href="mailto:marcus&#37;&#52;&#48;convergence&#46;de">marcus<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                    for convergence integrated media GmbH
 */

#ifndef _DVBCA_H_
#define _DVBCA_H_

/**
 * struct ca_slot_info - CA slot interface types and info.
 *
 * &#64;num:        slot number.
 * &#64;type:       slot type.
 * &#64;flags:      flags applicable to the slot.
 *
 * This struct stores the CA slot information.
 *
 * &#64;type can be:
 *
 *      - %CA_CI - CI high level interface;
 *      - %CA_CI_LINK - CI link layer level interface;
 *      - %CA_CI_PHYS - CI physical layer level interface;
 *      - %CA_DESCR - built-in descrambler;
 *      - %CA_SC -simple smart card interface.
 *
 * &#64;flags can be:
 *
 *      - %CA_CI_MODULE_PRESENT - module (or card) inserted;
 *      - %CA_CI_MODULE_READY - module is ready for usage.
 */

struct ca_slot_info {
        int num;
        int type;
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_CI</span></code>            1
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_CI_LINK</span></code>       2
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_CI_PHYS</span></code>       4
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_DESCR</span></code>         8
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_SC</span></code>          128

        unsigned int flags;
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_CI_MODULE_PRESENT</span></code> 1
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_CI_MODULE_READY</span></code>   2
};

/**
 * struct ca_descr_info - descrambler types and info.
 *
 * &#64;num:        number of available descramblers (keys).
 * &#64;type:       type of supported scrambling system.
 *
 * Identifies the number of descramblers and their type.
 *
 * &#64;type can be:
 *
 *      - %CA_ECD - European Common Descrambler (ECD) hardware;
 *      - %CA_NDS - Videoguard (NDS) hardware;
 *      - %CA_DSS - Distributed Sample Scrambling (DSS) hardware.
 */
struct ca_descr_info {
        unsigned int num;
        unsigned int type;
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_ECD</span></code>           1
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_NDS</span></code>           2
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">CA_DSS</span></code>           4
};

/**
 * struct ca_caps - CA slot interface capabilities.
 *
 * &#64;slot_num:   total number of CA card and module slots.
 * &#64;slot_type:  bitmap with all supported types as defined at
 *              &amp;struct ca_slot_info (e. g. %CA_CI, %CA_CI_LINK, etc).
 * &#64;descr_num:  total number of descrambler slots (keys)
 * &#64;descr_type: bitmap with all supported types as defined at
 *              &amp;struct ca_descr_info (e. g. %CA_ECD, %CA_NDS, etc).
 */
struct ca_caps {
        unsigned int slot_num;
        unsigned int slot_type;
        unsigned int descr_num;
        unsigned int descr_type;
};

/**
 * struct ca_msg - a message to/from a CI-CAM
 *
 * &#64;index:      unused
 * &#64;type:       unused
 * &#64;length:     length of the message
 * &#64;msg:        message
 *
 * This struct carries a message to be send/received from a CI CA module.
 */
struct ca_msg {
        unsigned int index;
        unsigned int type;
        unsigned int length;
        unsigned char msg[256];
};

/**
 * struct ca_descr - CA descrambler control words info
 *
 * &#64;index: CA Descrambler slot
 * &#64;parity: control words parity, where 0 means even and 1 means odd
 * &#64;cw: CA Descrambler control words
 */
struct ca_descr {
        unsigned int index;
        unsigned int parity;
        unsigned char cw[8];
};

#define <a class="reference internal" href="ca-reset.html#ca-reset"><span class="std std-ref">CA_RESET</span></a>          _IO('o', 128)
#define <a class="reference internal" href="ca-get-cap.html#ca-get-cap"><span class="std std-ref">CA_GET_CAP</span></a>        _IOR('o', 129, struct ca_caps)
#define <a class="reference internal" href="ca-get-slot-info.html#ca-get-slot-info"><span class="std std-ref">CA_GET_SLOT_INFO</span></a>  _IOR('o', 130, struct ca_slot_info)
#define <a class="reference internal" href="ca-get-descr-info.html#ca-get-descr-info"><span class="std std-ref">CA_GET_DESCR_INFO</span></a> _IOR('o', 131, struct ca_descr_info)
#define <a class="reference internal" href="ca-get-msg.html#ca-get-msg"><span class="std std-ref">CA_GET_MSG</span></a>        _IOR('o', 132, struct ca_msg)
#define <a class="reference internal" href="ca-send-msg.html#ca-send-msg"><span class="std std-ref">CA_SEND_MSG</span></a>       _IOW('o', 133, struct ca_msg)
#define <a class="reference internal" href="ca-set-descr.html#ca-set-descr"><span class="std std-ref">CA_SET_DESCR</span></a>      _IOW('o', 134, struct ca_descr)

#if !defined(__KERNEL__)

/* This is needed for legacy userspace support */
typedef struct ca_slot_info <code class="xref c c-type docutils literal notranslate"><span class="pre">ca_slot_info_t</span></code>;
typedef struct ca_descr_info  <code class="xref c c-type docutils literal notranslate"><span class="pre">ca_descr_info_t</span></code>;
typedef struct ca_caps  <code class="xref c c-type docutils literal notranslate"><span class="pre">ca_caps_t</span></code>;
typedef struct ca_msg <code class="xref c c-type docutils literal notranslate"><span class="pre">ca_msg_t</span></code>;
typedef struct ca_descr <code class="xref c c-type docutils literal notranslate"><span class="pre">ca_descr_t</span></code>;

#endif

#endif</pre>
</section>
<section id="net-h">
<h3><span class="section-number">8.1.4. </span>net.h<a class="headerlink" href="#net-h" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">/* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 * net.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;<a class="reference external" href="mailto:marcus&#37;&#52;&#48;convergence&#46;de">marcus<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                  &amp; Ralph  Metzler &lt;<a class="reference external" href="mailto:ralph&#37;&#52;&#48;convergence&#46;de">ralph<span>&#64;</span>convergence<span>&#46;</span>de</a>&gt;
 *                    for convergence integrated media GmbH
 */

#ifndef _DVBNET_H_
#define _DVBNET_H_

#include &lt;linux/types.h&gt;

/**
 * struct dvb_net_if - describes a DVB network interface
 *
 * &#64;pid: Packet ID (PID) of the MPEG-TS that contains data
 * &#64;if_num: number of the Digital TV interface.
 * &#64;feedtype: Encapsulation type of the feed.
 *
 * A MPEG-TS stream may contain packet IDs with IP packages on it.
 * This struct describes it, and the type of encoding.
 *
 * &#64;feedtype can be:
 *
 *      - %DVB_NET_FEEDTYPE_MPE for MPE encoding
 *      - %DVB_NET_FEEDTYPE_ULE for ULE encoding.
 */
struct dvb_net_if {
        __u16 pid;
        __u16 if_num;
        __u8  feedtype;
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">DVB_NET_FEEDTYPE_MPE</span></code> 0  /* multi protocol encapsulation */
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">DVB_NET_FEEDTYPE_ULE</span></code> 1  /* ultra lightweight encapsulation */
};

#define <a class="reference internal" href="net-add-if.html#net-add-if"><span class="std std-ref">NET_ADD_IF</span></a>    _IOWR('o', 52, struct dvb_net_if)
#define <a class="reference internal" href="net-remove-if.html#net-remove-if"><span class="std std-ref">NET_REMOVE_IF</span></a> _IO('o', 53)
#define <a class="reference internal" href="net-get-if.html#net-get-if"><span class="std std-ref">NET_GET_IF</span></a>    _IOWR('o', 54, struct dvb_net_if)

/* binary compatibility cruft: */
struct __dvb_net_if_old {
        __u16 pid;
        __u16 if_num;
};
#define __NET_ADD_IF_OLD _IOWR('o', 52, struct __dvb_net_if_old)
#define __NET_GET_IF_OLD _IOWR('o', 54, struct __dvb_net_if_old)

#endif /*_DVBNET_H_*/</pre>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Digital TV uAPI header files</a><ul>
<li><a class="reference internal" href="#digital-tv-uapi-headers">8.1. Digital TV uAPI headers</a><ul>
<li><a class="reference internal" href="#frontend-h">8.1.1. frontend.h</a></li>
<li><a class="reference internal" href="#dmx-h">8.1.2. dmx.h</a></li>
<li><a class="reference internal" href="#ca-h">8.1.3. ca.h</a></li>
<li><a class="reference internal" href="#net-h">8.1.4. net.h</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/dvb/headers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/dvb/headers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>