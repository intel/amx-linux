
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.5.3. Memory-to-memory Stateless Video Decoder Interface &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="4.6. Raw VBI Data Interface" href="dev-raw-vbi.html" />
    <link rel="prev" title="4.5.2. Memory-to-Memory Stateful Video Encoder Interface" href="dev-encoder.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="memory-to-memory-stateless-video-decoder-interface">
<span id="stateless-decoder"></span><h1><span class="section-number">4.5.3. </span>Memory-to-memory Stateless Video Decoder Interface<a class="headerlink" href="#memory-to-memory-stateless-video-decoder-interface" title="Permalink to this headline">¶</a></h1>
<p>A stateless decoder is a decoder that works without retaining any kind of state
between processed frames. This means that each frame is decoded independently
of any previous and future frames, and that the client is responsible for
maintaining the decoding state and providing it to the decoder with each
decoding request. This is in contrast to the stateful video decoder interface,
where the hardware and driver maintain the decoding state and all the client
has to do is to provide the raw encoded stream and dequeue decoded frames in
display order.</p>
<p>This section describes how user-space (“the client”) is expected to communicate
with stateless decoders in order to successfully decode an encoded stream.
Compared to stateful codecs, the decoder/client sequence is simpler, but the
cost of this simplicity is extra complexity in the client which is responsible
for maintaining a consistent decoding state.</p>
<p>Stateless decoders make use of the <a class="reference internal" href="../mediactl/request-api.html#media-request-api"><span class="std std-ref">Request API</span></a>. A stateless
decoder must expose the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_CAP_SUPPORTS_REQUESTS</span></code> capability on its
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue when <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_CREATE_BUFS()</span></code>
are invoked.</p>
<p>Depending on the encoded formats supported by the decoder, a single decoded
frame may be the result of several decode requests (for instance, H.264 streams
with multiple slices per frame). Decoders that support such formats must also
expose the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF</span></code> capability on their
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p>
<section id="querying-capabilities">
<h2><span class="section-number">4.5.3.1. </span>Querying capabilities<a class="headerlink" href="#querying-capabilities" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>To enumerate the set of coded formats supported by the decoder, the client
calls <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p>
<ul class="simple">
<li><p>The driver must always return the full set of supported <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> formats,
irrespective of the format currently set on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p></li>
<li><p>Simultaneously, the driver must restrain the set of values returned by
codec-specific capability controls (such as H.264 profiles) to the set
actually supported by the hardware.</p></li>
</ul>
</li>
<li><p>To enumerate the set of supported raw formats, the client calls
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p>
<ul class="simple">
<li><p>The driver must return only the formats supported for the format currently
active on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p></li>
<li><p>Depending on the currently set <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format, the set of supported raw
formats may depend on the value of some codec-dependent controls.
The client is responsible for making sure that these controls are set
before querying the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. Failure to do so will result in the
default values for these controls being used, and a returned set of formats
that may not be usable for the media the client is trying to decode.</p></li>
</ul>
</li>
<li><p>The client may use <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FRAMESIZES()</span></code> to detect supported
resolutions for a given format, passing desired pixel format in
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_frmsizeenum</span></code>’s <code class="docutils literal notranslate"><span class="pre">pixel_format</span></code>.</p></li>
<li><p>Supported profiles and levels for the current <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format, if
applicable, may be queried using their respective controls via
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_QUERYCTRL()</span></code>.</p></li>
</ol>
</section>
<section id="initialization">
<h2><span class="section-number">4.5.3.2. </span>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p>Set the coded format on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>a coded pixel format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>coded width and height parsed from the stream.</p>
</dd>
<dt>other fields</dt><dd><p>follow standard semantics.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format may change the currently set <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
format. The driver will derive a new <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format from the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format being set, including resolution, colorimetry
parameters, etc. If the client needs a specific <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format,
it must adjust it afterwards.</p>
</div>
</li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_EXT_CTRLS()</span></code> to set all the controls (parsed headers,
etc.) required by the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format to enumerate the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> formats.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code> for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue to get the format for the
destination buffers parsed/decoded from the bytestream.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
</dl>
</li>
<li><p><strong>Returned fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>frame buffer resolution for the decoded frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>pixel format for decoded frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_planes</span></code> (for _MPLANE <code class="docutils literal notranslate"><span class="pre">type</span></code> only)</dt><dd><p>number of planes for pixelformat.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sizeimage</span></code>, <code class="docutils literal notranslate"><span class="pre">bytesperline</span></code></dt><dd><p>as per standard semantics; matching frame buffer format.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">pixelformat</span></code> may be any pixel format supported for the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format, based on the hardware capabilities. It is suggested
that the driver chooses the preferred/optimal format for the current
configuration. For example, a YUV format may be preferred over an RGB
format, if an additional conversion step would be required for RGB.</p>
</div>
</li>
<li><p><em>[optional]</em> Enumerate <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> formats via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on
the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. The client may use this ioctl to discover which
alternative raw formats are supported for the current <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format and
select one of them via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The driver will return only formats supported for the currently selected
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format and currently set controls, even if more formats may be
supported by the decoder in general.</p>
<p>For example, a decoder may support YUV and RGB formats for
resolutions 1920x1088 and lower, but only YUV for higher resolutions (due
to hardware limitations). After setting a resolution of 1920x1088 or lower
as the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format, <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> may return a set of
YUV and RGB pixel formats, but after setting a resolution higher than
1920x1088, the driver will not return RGB pixel formats, since they are
unsupported for this resolution.</p>
</div>
</li>
<li><p><em>[optional]</em> Choose a different <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format than suggested via
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code> on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. It is possible for the client to
choose a different format than selected/suggested by the driver in
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code>.</p>
<blockquote>
<div><ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>a raw pixel format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>frame buffer resolution of the decoded stream; typically unchanged from
what was returned with <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code>, but it may be different
if the hardware supports composition and/or scaling.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>After performing this step, the client must perform step 3 again in order
to obtain up-to-date information about the buffers size and layout.</p>
</li>
<li><p>Allocate source (bytestream) buffers via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p>
<blockquote>
<div><ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>actual number of buffers allocated.</p>
</dd>
</dl>
</li>
<li><p>If required, the driver will adjust <code class="docutils literal notranslate"><span class="pre">count</span></code> to be equal or bigger to the
minimum of required number of <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers for the given format and
requested count. The client must check this value after the ioctl returns
to get the actual number of buffers allocated.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Allocate destination (raw format) buffers via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p>
<blockquote>
<div><ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero. The client
is responsible for deducing the minimum number of buffers required
for the stream to be properly decoded (taking e.g. reference frames
into account) and pass an equal or bigger number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics. <code class="docutils literal notranslate"><span class="pre">V4L2_MEMORY_USERPTR</span></code> is not supported
for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>adjusted to allocated number of buffers, in case the codec requires
more buffers than requested.</p>
</dd>
</dl>
</li>
<li><p>The driver must adjust count to the minimum of required number of
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers for the current format, stream configuration and
requested count. The client must check this value after the ioctl
returns to get the number of buffers allocated.</p></li>
</ul>
</div></blockquote>
</li>
<li><dl class="simple">
<dt>Allocate requests (likely one per <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer) via</dt><dd><p><code class="xref c c-func docutils literal notranslate"><span class="pre">MEDIA_IOC_REQUEST_ALLOC()</span></code> on the media device.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Start streaming on both <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> and <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queues via</dt><dd><p><code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code>.</p>
</dd>
</dl>
</li>
</ol>
</section>
<section id="decoding">
<h2><span class="section-number">4.5.3.3. </span>Decoding<a class="headerlink" href="#decoding" title="Permalink to this headline">¶</a></h2>
<p>For each frame, the client is responsible for submitting at least one request to
which the following is attached:</p>
<ul class="simple">
<li><p>The amount of encoded data expected by the codec for its current
configuration, as a buffer submitted to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue. Typically, this
corresponds to one frame worth of encoded data, but some formats may allow (or
require) different amounts per unit.</p></li>
<li><p>All the metadata needed to decode the submitted encoded data, in the form of
controls relevant to the format being decoded.</p></li>
</ul>
<p>The amount of data and contents of the source <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer, as well as the
controls that must be set on the request, depend on the active coded pixel
format and might be affected by codec-specific extended controls, as stated in
documentation of each format.</p>
<p>If there is a possibility that the decoded frame will require one or more
decode requests after the current one in order to be produced, then the client
must set the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF</span></code> flag on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
buffer. This will result in the (potentially partially) decoded <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
buffer not being made available for dequeueing, and reused for the next decode
request if the timestamp of the next <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer has not changed.</p>
<p>A typical frame would thus be decoded using the following sequence:</p>
<ol class="arabic">
<li><p>Queue an <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer containing one unit of encoded bytestream data for
the decoding request, using <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_QBUF()</span></code>.</p>
<blockquote>
<div><ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>index of the buffer being queued.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytesused</span></code></dt><dd><p>number of bytes taken by the encoded data frame in the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_REQUEST_FD</span></code> flag must be set. Additionally, if
we are not sure that the current decode request is the last one needed
to produce a fully decoded frame, then
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF</span></code> must also be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_fd</span></code></dt><dd><p>must be set to the file descriptor of the decoding request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>must be set to a unique value per frame. This value will be propagated
into the decoded frame’s buffer and can also be used to use this frame
as the reference of another. If using multiple decode requests per
frame, then the timestamps of all the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers for a given
frame must be identical. If the timestamp changes, then the currently
held <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer will be made available for dequeuing and the
current request will work on a new <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Set the codec-specific controls for the decoding request, using
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_EXT_CTRLS()</span></code>.</p>
<blockquote>
<div><ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">which</span></code></dt><dd><p>must be <code class="docutils literal notranslate"><span class="pre">V4L2_CTRL_WHICH_REQUEST_VAL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_fd</span></code></dt><dd><p>must be set to the file descriptor of the decoding request.</p>
</dd>
<dt>other fields</dt><dd><p>other fields are set as usual when setting controls. The <code class="docutils literal notranslate"><span class="pre">controls</span></code>
array must contain all the codec-specific controls required to decode
a frame.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to specify the controls in different invocations of
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_EXT_CTRLS()</span></code>, or to overwrite a previously set control, as
long as <code class="docutils literal notranslate"><span class="pre">request_fd</span></code> and <code class="docutils literal notranslate"><span class="pre">which</span></code> are properly set. The controls state
at the moment of request submission is the one that will be considered.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The order in which steps 1 and 2 take place is interchangeable.</p>
</div>
</li>
<li><p>Submit the request by invoking <code class="xref c c-func docutils literal notranslate"><span class="pre">MEDIA_REQUEST_IOC_QUEUE()</span></code> on the
request FD.</p>
<blockquote>
<div><p>If the request is submitted without an <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer, or if some of the
required controls are missing from the request, then
<code class="xref c c-func docutils literal notranslate"><span class="pre">MEDIA_REQUEST_IOC_QUEUE()</span></code> will return <code class="docutils literal notranslate"><span class="pre">-ENOENT</span></code>. If more than one
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer is queued, then it will return <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>.
<code class="xref c c-func docutils literal notranslate"><span class="pre">MEDIA_REQUEST_IOC_QUEUE()</span></code> returning non-zero means that no
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer will be produced for this request.</p>
</div></blockquote>
</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers must not be part of the request, and are queued
independently. They are returned in decode order (i.e. the same order as coded
frames were submitted to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue).</p>
<p>Runtime decoding errors are signaled by the dequeued <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers
carrying the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_ERROR</span></code> flag. If a decoded reference frame has an
error, then all following decoded frames that refer to it also have the
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_ERROR</span></code> flag set, although the decoder will still try to
produce (likely corrupted) frames.</p>
</section>
<section id="buffer-management-while-decoding">
<h2><span class="section-number">4.5.3.4. </span>Buffer management while decoding<a class="headerlink" href="#buffer-management-while-decoding" title="Permalink to this headline">¶</a></h2>
<p>Contrary to stateful decoders, a stateless decoder does not perform any kind of
buffer management: it only guarantees that dequeued <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers can be
used by the client for as long as they are not queued again. “Used” here
encompasses using the buffer for compositing or display.</p>
<p>A dequeued capture buffer can also be used as the reference frame of another
buffer.</p>
<p>A frame is specified as reference by converting its timestamp into nanoseconds,
and storing it into the relevant member of a codec-dependent control structure.
The <code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_timeval_to_ns()</span></code> function must be used to perform that
conversion. The timestamp of a frame can be used to reference it as soon as all
its units of encoded data are successfully submitted to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p>
<p>A decoded buffer containing a reference frame must not be reused as a decoding
target until all the frames referencing it have been decoded. The safest way to
achieve this is to refrain from queueing a reference buffer until all the
decoded frames referencing it have been dequeued. However, if the driver can
guarantee that buffers queued to the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue are processed in queued
order, then user-space can take advantage of this guarantee and queue a
reference buffer when the following conditions are met:</p>
<ol class="arabic simple">
<li><p>All the requests for frames affected by the reference frame have been
queued, and</p></li>
<li><p>A sufficient number of <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers to cover all the decoded
referencing frames have been queued.</p></li>
</ol>
<p>When queuing a decoding request, the driver will increase the reference count of
all the resources associated with reference frames. This means that the client
can e.g. close the DMABUF file descriptors of reference frame buffers if it
won’t need them afterwards.</p>
</section>
<section id="seeking">
<h2><span class="section-number">4.5.3.5. </span>Seeking<a class="headerlink" href="#seeking" title="Permalink to this headline">¶</a></h2>
<p>In order to seek, the client just needs to submit requests using input buffers
corresponding to the new stream position. It must however be aware that
resolution may have changed and follow the dynamic resolution change sequence in
that case. Also depending on the codec used, picture parameters (e.g. SPS/PPS
for H.264) may have changed and the client is responsible for making sure that a
valid state is sent to the decoder.</p>
<p>The client is then free to ignore any returned <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer that comes
from the pre-seek position.</p>
</section>
<section id="pausing">
<h2><span class="section-number">4.5.3.6. </span>Pausing<a class="headerlink" href="#pausing" title="Permalink to this headline">¶</a></h2>
<p>In order to pause, the client can just cease queuing buffers onto the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
queue. Without source bytestream data, there is no data to process and the codec
will remain idle.</p>
</section>
<section id="dynamic-resolution-change">
<h2><span class="section-number">4.5.3.7. </span>Dynamic resolution change<a class="headerlink" href="#dynamic-resolution-change" title="Permalink to this headline">¶</a></h2>
<p>If the client detects a resolution change in the stream, it will need to perform
the initialization sequence again with the new resolution:</p>
<ol class="arabic simple">
<li><p>If the last submitted request resulted in a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer being
held by the use of the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF</span></code> flag, then the
last frame is not available on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. In this case, a
<code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_FLUSH</span></code> command shall be sent. This will make the driver
dequeue the held <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer.</p></li>
<li><p>Wait until all submitted requests have completed and dequeue the
corresponding output buffers.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> on both the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> and <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queues.</p></li>
<li><p>Free all <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue with a buffer count of zero.</p></li>
<li><p>Perform the initialization sequence again (minus the allocation of
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers), with the new resolution set on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.
Note that due to resolution constraints, a different format may need to be
picked on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p></li>
</ol>
</section>
<section id="drain">
<h2><span class="section-number">4.5.3.8. </span>Drain<a class="headerlink" href="#drain" title="Permalink to this headline">¶</a></h2>
<p>If the last submitted request resulted in a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer being
held by the use of the <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF</span></code> flag, then the
last frame is not available on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. In this case, a
<code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_FLUSH</span></code> command shall be sent. This will make the driver
dequeue the held <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer.</p>
<p>After that, in order to drain the stream on a stateless decoder, the client
just needs to wait until all the submitted requests are completed.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.5.3. Memory-to-memory Stateless Video Decoder Interface</a><ul>
<li><a class="reference internal" href="#querying-capabilities">4.5.3.1. Querying capabilities</a></li>
<li><a class="reference internal" href="#initialization">4.5.3.2. Initialization</a></li>
<li><a class="reference internal" href="#decoding">4.5.3.3. Decoding</a></li>
<li><a class="reference internal" href="#buffer-management-while-decoding">4.5.3.4. Buffer management while decoding</a></li>
<li><a class="reference internal" href="#seeking">4.5.3.5. Seeking</a></li>
<li><a class="reference internal" href="#pausing">4.5.3.6. Pausing</a></li>
<li><a class="reference internal" href="#dynamic-resolution-change">4.5.3.7. Dynamic resolution change</a></li>
<li><a class="reference internal" href="#drain">4.5.3.8. Drain</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/v4l/dev-stateless-decoder.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/v4l/dev-stateless-decoder.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>