
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9. Video For Linux Two Header File &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="10. Video Capture Example" href="capture-example.html" />
    <link rel="prev" title="8.1.2. Selection flags" href="v4l2-selection-flags.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="video-for-linux-two-header-file">
<span id="videodev"></span><h1><span class="section-number">9. </span>Video For Linux Two Header File<a class="headerlink" href="#video-for-linux-two-header-file" title="Permalink to this headline">¶</a></h1>
<section id="videodev2-h">
<h2><span class="section-number">9.1. </span>videodev2.h<a class="headerlink" href="#videodev2-h" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause) */
/*
 *  Video for Linux Two header file
 *
 *  Copyright (C) 1999-2012 the contributors
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Alternatively you can redistribute this file under the terms of the
 *  BSD license as stated below:
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *  3. The names of its contributors may not be used to endorse or promote
 *     products derived from this software without specific prior written
 *     permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *      Header file for v4l or V4L2 drivers and applications
 * with public API.
 * All kernel-specific stuff were moved to media/v4l2-dev.h, so
 * no #if __KERNEL tests are allowed here
 *
 *      See https://linuxtv.org for more info
 *
 *      Author: Bill Dirks &lt;<a class="reference external" href="mailto:bill&#37;&#52;&#48;thedirks&#46;org">bill<span>&#64;</span>thedirks<span>&#46;</span>org</a>&gt;
 *              Justin Schoeman
 *              Hans Verkuil &lt;<a class="reference external" href="mailto:hverkuil&#37;&#52;&#48;xs4all&#46;nl">hverkuil<span>&#64;</span>xs4all<span>&#46;</span>nl</a>&gt;
 *              et al.
 */
#ifndef _UAPI__LINUX_VIDEODEV2_H
#define _UAPI__LINUX_VIDEODEV2_H

#ifndef __KERNEL__
#include &lt;sys/time.h&gt;
#endif
#include &lt;linux/compiler.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/v4l2-common.h&gt;
#include &lt;linux/v4l2-controls.h&gt;

/*
 * Common stuff for both V4L1 and V4L2
 * Moved from videodev.h
 */
#define VIDEO_MAX_FRAME               32
#define VIDEO_MAX_PLANES               8

/*
 *      M I S C E L L A N E O U S
 */

/*  Four-character-code (FOURCC) */
#define v4l2_fourcc(a, b, c, d)\
        ((__u32)(a) | ((__u32)(b) &lt;&lt; 8) | ((__u32)(c) &lt;&lt; 16) | ((__u32)(d) &lt;&lt; 24))
#define v4l2_fourcc_be(a, b, c, d)      (v4l2_fourcc(a, b, c, d) | (1U &lt;&lt; 31))

/*
 *      E N U M S
 */
enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a> {
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_ANY</span></code></a>           = 0, /* driver can choose from none,
                                         top, bottom, interlaced
                                         depending on whatever it thinks
                                         is approximate ... */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_NONE</span></code></a>          = 1, /* this device has no fields ... */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_TOP</span></code></a>           = 2, /* top field only */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_BOTTOM</span></code></a>        = 3, /* bottom field only */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code></a>    = 4, /* both fields interlaced */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_TB</span></code></a>        = 5, /* both fields sequential into one
                                         buffer, top-bottom order */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_BT</span></code></a>        = 6, /* same as above + bottom-top order */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_ALTERNATE</span></code></a>     = 7, /* both fields alternating into
                                         separate buffers */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_TB</span></code></a> = 8, /* both fields interlaced, top field
                                         first and the top field is
                                         transmitted first */
        <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_BT</span></code></a> = 9, /* both fields interlaced, top field
                                         first and the bottom field is
                                         transmitted first */
};
#define V4L2_FIELD_HAS_TOP(field)       \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_TOP</span></code></a>      ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_BT</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_TB</span></code></a>   ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_BT</span></code></a>)
#define V4L2_FIELD_HAS_BOTTOM(field)    \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_BOTTOM</span></code></a>   ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_BT</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_TB</span></code></a>   ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_BT</span></code></a>)
#define V4L2_FIELD_HAS_BOTH(field)      \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_BT</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_BT</span></code></a>)
#define V4L2_FIELD_HAS_T_OR_B(field)    \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_BOTTOM</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_TOP</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_ALTERNATE</span></code></a>)
#define V4L2_FIELD_IS_INTERLACED(field) \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED_BT</span></code></a>)
#define V4L2_FIELD_IS_SEQUENTIAL(field) \
        ((field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_TB</span></code></a> ||\
         (field) == <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_SEQ_BT</span></code></a>)

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code>        = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT</span></code>         = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OVERLAY</span></code>        = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VBI_CAPTURE</span></code>          = 4,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VBI_OUTPUT</span></code>           = 5,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</span></code>   = 6,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</span></code>    = 7,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</span></code> = 8,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span></code> = 9,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span></code>  = 10,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SDR_CAPTURE</span></code>          = 11,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SDR_OUTPUT</span></code>           = 12,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_META_CAPTURE</span></code>         = 13,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_META_OUTPUT</span></code>          = 14,
        /* Deprecated, do not use */
        V4L2_BUF_TYPE_PRIVATE              = 0x80,
};

#define V4L2_TYPE_IS_MULTIPLANAR(type)                  \
        ((type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span></code>   \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span></code>)

#define V4L2_TYPE_IS_OUTPUT(type)                               \
        ((type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT</span></code>                   \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span></code>         \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OVERLAY</span></code>               \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</span></code>        \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VBI_OUTPUT</span></code>                  \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</span></code>           \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SDR_OUTPUT</span></code>                  \
         || (type) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_META_OUTPUT</span></code>)

#define V4L2_TYPE_IS_CAPTURE(type) (!V4L2_TYPE_IS_OUTPUT(type))

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_TUNER_RADIO</span></code>             = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_TUNER_ANALOG_TV</span></code>         = 2,
        V4L2_TUNER_DIGITAL_TV        = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_TUNER_SDR</span></code>               = 4,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_TUNER_RF</span></code>                = 5,
};

/* Deprecated, do not use */
#define V4L2_TUNER_ADC  <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_TUNER_SDR</span></code>

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_memory</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_MMAP</span></code>             = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_USERPTR</span></code>          = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_OVERLAY</span></code>          = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_DMABUF</span></code>           = 4,
};

/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_colorspace</span></code> {
        /*
         * Default colorspace, i.e. let the driver figure it out.
         * Can only be used with video capture.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DEFAULT</span></code>       = 0,

        /* SMPTE 170M: used for broadcast NTSC/PAL SDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE170M</span></code>     = 1,

        /* Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709 */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE240M</span></code>     = 2,

        /* Rec.709: used for HDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_REC709</span></code>        = 3,

        /*
         * Deprecated, do not use. No driver will ever return this. This was
         * based on a misunderstanding of the bt878 datasheet.
         */
        V4L2_COLORSPACE_BT878         = 4,

        /*
         * NTSC 1953 colorspace. This only makes sense when dealing with
         * really, really old NTSC recordings. Superseded by SMPTE 170M.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_M</span></code>  = 5,

        /*
         * EBU Tech 3213 PAL/SECAM colorspace.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_BG</span></code> = 6,

        /*
         * Effectively shorthand for <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_601</span></code>
         * and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_JPEG</span></code>          = 7,

        /* For RGB colorspaces such as produces by most webcams. */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code>          = 8,

        /* opRGB colorspace */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_OPRGB</span></code>         = 9,

        /* BT.2020 colorspace, used for UHDTV. */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_BT2020</span></code>        = 10,

        /* Raw colorspace: for RAW unprocessed images */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_RAW</span></code>           = 11,

        /* DCI-P3 colorspace, used by cinema projectors */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DCI_P3</span></code>        = 12,

#ifdef __KERNEL__
        /*
         * Largest supported colorspace value, assigned by the compiler, used
         * by the framework to check for invalid values.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_LAST</span></code>,
#endif
};

/*
 * Determine how COLORSPACE_DEFAULT should map to a proper colorspace.
 * This depends on whether this is a SDTV image (use SMPTE 170M), an
 * HDTV image (use Rec. 709), or something else (use sRGB).
 */
#define V4L2_MAP_COLORSPACE_DEFAULT(is_sdtv, is_hdtv) \
        ((is_sdtv) ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE170M</span></code> : \
         ((is_hdtv) ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_REC709</span></code> : <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code>))

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_xfer_func</span></code> {
        /*
         * Mapping of <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_DEFAULT</span></code> to actual transfer functions
         * for the various colorspaces:
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE170M</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_M</span></code>,
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_BG</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_REC709</span></code> and
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_BT2020</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_709</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_JPEG</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SRGB</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_OPRGB</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_OPRGB</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE240M</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SMPTE240M</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_RAW</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_NONE</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DCI_P3</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_DCI_P3</span></code>
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_DEFAULT</span></code>     = 0,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_709</span></code>         = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SRGB</span></code>        = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_OPRGB</span></code>       = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SMPTE240M</span></code>   = 4,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_NONE</span></code>        = 5,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_DCI_P3</span></code>      = 6,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SMPTE2084</span></code>   = 7,
#ifdef __KERNEL__
        /*
         * Largest supported transfer function value, assigned by the compiler,
         * used by the framework to check for invalid values.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_LAST</span></code>,
#endif
};

/*
 * Determine how XFER_FUNC_DEFAULT should map to a proper transfer function.
 * This depends on the colorspace.
 */
#define V4L2_MAP_XFER_FUNC_DEFAULT(colsp) \
        ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_OPRGB</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_OPRGB</span></code> : \
         ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE240M</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SMPTE240M</span></code> : \
          ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DCI_P3</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_DCI_P3</span></code> : \
           ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_RAW</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_NONE</span></code> : \
            ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code> || (colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_JPEG</span></code> ? \
             <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_SRGB</span></code> : <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_709</span></code>)))))

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ycbcr_encoding</span></code> {
        /*
         * Mapping of <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_DEFAULT</span></code> to actual encodings for the
         * various colorspaces:
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE170M</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_M</span></code>,
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_470_SYSTEM_BG</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SRGB</span></code>,
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_OPRGB</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_JPEG</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_601</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_REC709</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DCI_P3</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_709</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_BT2020</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_BT2020</span></code>
         *
         * <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE240M</span></code>: <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_SMPTE240M</span></code>
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_DEFAULT</span></code>        = 0,

        /* ITU-R 601 -- SDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_601</span></code>            = 1,

        /* Rec. 709 -- HDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_709</span></code>            = 2,

        /* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_XV601</span></code>          = 3,

        /* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_XV709</span></code>          = 4,

#ifndef __KERNEL__
        /*
         * sYCC (Y'CbCr encoding of sRGB), identical to ENC_601. It was added
         * originally due to a misunderstanding of the sYCC standard. It should
         * not be used, instead use V4L2_YCBCR_ENC_601.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_SYCC</span></code>           = 5,
#endif

        /* BT.2020 Non-constant Luminance Y'CbCr */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_BT2020</span></code>         = 6,

        /* BT.2020 Constant Luminance Y'CbcCrc */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_BT2020_CONST_LUM</span></code> = 7,

        /* SMPTE 240M -- Obsolete HDTV */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_SMPTE240M</span></code>      = 8,
#ifdef __KERNEL__
        /*
         * Largest supported encoding value, assigned by the compiler, used by
         * the framework to check for invalid values.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_LAST</span></code>,
#endif
};

/*
 * enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_hsv_encoding</span></code> values should not collide with the ones from
 * enum v4l2_ycbcr_encoding.
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_hsv_encoding</span></code> {

        /* Hue mapped to 0 - 179 */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_HSV_ENC_180</span></code>                = 128,

        /* Hue mapped to 0-255 */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_HSV_ENC_256</span></code>                = 129,
};

/*
 * Determine how YCBCR_ENC_DEFAULT should map to a proper Y'CbCr encoding.
 * This depends on the colorspace.
 */
#define V4L2_MAP_YCBCR_ENC_DEFAULT(colsp) \
        (((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_REC709</span></code> || \
          (colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_DCI_P3</span></code>) ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_709</span></code> : \
         ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_BT2020</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_BT2020</span></code> : \
          ((colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_SMPTE240M</span></code> ? <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_SMPTE240M</span></code> : \
           <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_YCBCR_ENC_601</span></code>)))

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_quantization</span></code> {
        /*
         * The default for R'G'B' quantization is always full range.
         * For Y'CbCr the quantization is always limited range, except
         * for COLORSPACE_JPEG: this is full range.
         */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_QUANTIZATION_DEFAULT</span></code>     = 0,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_QUANTIZATION_FULL_RANGE</span></code>  = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_QUANTIZATION_LIM_RANGE</span></code>   = 2,
};

/*
 * Determine how QUANTIZATION_DEFAULT should map to a proper quantization.
 * This depends on whether the image is RGB or not, the colorspace.
 * The Y'CbCr encoding is not used anymore, but is still there for backwards
 * compatibility.
 */
#define V4L2_MAP_QUANTIZATION_DEFAULT(is_rgb_or_hsv, colsp, ycbcr_enc) \
        (((is_rgb_or_hsv) || (colsp) == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_JPEG</span></code>) ? \
         <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_QUANTIZATION_FULL_RANGE</span></code> : <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_QUANTIZATION_LIM_RANGE</span></code>)

/*
 * Deprecated names for opRGB colorspace (IEC 61966-2-5)
 *
 * WARNING: Please don't use these deprecated defines in your code, as
 * there is a chance we have to remove them in the future.
 */
#ifndef __KERNEL__
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_ADOBERGB</span></code> <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_COLORSPACE_OPRGB</span></code>
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_ADOBERGB</span></code>  <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_XFER_FUNC_OPRGB</span></code>
#endif

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_UNSET</span></code>       = 0,  /* not initialized */
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_BACKGROUND</span></code>  = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_INTERACTIVE</span></code> = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_RECORD</span></code>      = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_DEFAULT</span></code>     = <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PRIORITY_INTERACTIVE</span></code>,
};

struct v4l2_rect {
        __s32   left;
        __s32   top;
        __u32   width;
        __u32   height;
};

struct v4l2_fract {
        __u32   numerator;
        __u32   denominator;
};

struct v4l2_area {
        __u32   width;
        __u32   height;
};

/**
  * struct v4l2_capability - Describes V4L2 device caps returned by <a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">VIDIOC_QUERYCAP</span></a>
  *
  * &#64;driver:       name of the driver module (e.g. &quot;bttv&quot;)
  * &#64;card:         name of the card (e.g. &quot;Hauppauge WinTV&quot;)
  * &#64;bus_info:     name of the bus (e.g. &quot;PCI:&quot; + pci_name(pci_dev) )
  * &#64;version:      KERNEL_VERSION
  * &#64;capabilities: capabilities of the physical device as a whole
  * &#64;device_caps:  capabilities accessed via this particular device (node)
  * &#64;reserved:     reserved fields for future extensions
  */
struct v4l2_capability {
        __u8    driver[16];
        __u8    card[32];
        __u8    bus_info[32];
        __u32   version;
        __u32   capabilities;
        __u32   device_caps;
        __u32   reserved[3];
};

/* Values for 'capabilities' field */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_CAPTURE</span></a>          0x00000001  /* Is a video capture device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_OUTPUT</span></a>           0x00000002  /* Is a video output device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_OVERLAY</span></a>          0x00000004  /* Can do video overlay */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VBI_CAPTURE</span></a>            0x00000010  /* Is a raw VBI capture device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VBI_OUTPUT</span></a>             0x00000020  /* Is a raw VBI output device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_SLICED_VBI_CAPTURE</span></a>     0x00000040  /* Is a sliced VBI capture device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_SLICED_VBI_OUTPUT</span></a>      0x00000080  /* Is a sliced VBI output device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_RDS_CAPTURE</span></a>            0x00000100  /* RDS data capture */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</span></a>   0x00000200  /* Can do video output overlay */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_HW_FREQ_SEEK</span></a>           0x00000400  /* Can do hardware frequency seek  */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_RDS_OUTPUT</span></a>             0x00000800  /* Is an RDS encoder */

/* Is a video capture device that supports multiplanar formats */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_CAPTURE_MPLANE</span></a>   0x00001000
/* Is a video output device that supports multiplanar formats */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_OUTPUT_MPLANE</span></a>    0x00002000
/* Is a video mem-to-mem device that supports multiplanar formats */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_M2M_MPLANE</span></a>       0x00004000
/* Is a video mem-to-mem device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_VIDEO_M2M</span></a>              0x00008000

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_TUNER</span></a>                  0x00010000  /* has a tuner */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_AUDIO</span></a>                  0x00020000  /* has audio support */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_RADIO</span></a>                  0x00040000  /* is a radio device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_MODULATOR</span></a>              0x00080000  /* has a modulator */

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_SDR_CAPTURE</span></a>            0x00100000  /* Is a SDR capture device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_EXT_PIX_FORMAT</span></a>         0x00200000  /* Supports the extended pixel format */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_SDR_OUTPUT</span></a>             0x00400000  /* Is a SDR output device */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_META_CAPTURE</span></a>           0x00800000  /* Is a metadata capture device */

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_READWRITE</span></a>              0x01000000  /* read/write systemcalls */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_STREAMING</span></a>              0x04000000  /* streaming I/O ioctls */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_META_OUTPUT</span></a>            0x08000000  /* Is a metadata output device */

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_TOUCH</span></a>                  0x10000000  /* Is a touch device */

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_IO_MC</span></a>                  0x20000000  /* Is input/output controlled by the media controller */

#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_DEVICE_CAPS</span></a>            0x80000000  /* sets device capabilities field */

/*
 *      V I D E O   I M A G E   F O R M A T
 */
struct v4l2_pix_format {
        __u32                   width;
        __u32                   height;
        __u32                   pixelformat;
        __u32                   field;          /* enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a> */
        __u32                   bytesperline;   /* for padding, zero if unused */
        __u32                   sizeimage;
        __u32                   colorspace;     /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_colorspace</span></code> */
        __u32                   priv;           /* private data, depends on pixelformat */
        __u32                   flags;          /* format flags (V4L2_PIX_FMT_FLAG_*) */
        union {
                /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ycbcr_encoding</span></code> */
                __u32                   ycbcr_enc;
                /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_hsv_encoding</span></code> */
                __u32                   hsv_enc;
        };
        __u32                   quantization;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_quantization</span></code> */
        __u32                   xfer_func;      /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_xfer_func</span></code> */
};

/*      Pixel format         FOURCC                          depth  Description  */

/* RGB formats (1 or 2 bytes per pixel) */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb332"><span class="std std-ref">V4L2_PIX_FMT_RGB332</span></a>  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb444"><span class="std std-ref">V4L2_PIX_FMT_RGB444</span></a>  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-argb444"><span class="std std-ref">V4L2_PIX_FMT_ARGB444</span></a> v4l2_fourcc('A', 'R', '1', '2') /* 16  aaaarrrr ggggbbbb */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xrgb444"><span class="std std-ref">V4L2_PIX_FMT_XRGB444</span></a> v4l2_fourcc('X', 'R', '1', '2') /* 16  xxxxrrrr ggggbbbb */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgba444"><span class="std std-ref">V4L2_PIX_FMT_RGBA444</span></a> v4l2_fourcc('R', 'A', '1', '2') /* 16  rrrrgggg bbbbaaaa */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgbx444"><span class="std std-ref">V4L2_PIX_FMT_RGBX444</span></a> v4l2_fourcc('R', 'X', '1', '2') /* 16  rrrrgggg bbbbxxxx */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-abgr444"><span class="std std-ref">V4L2_PIX_FMT_ABGR444</span></a> v4l2_fourcc('A', 'B', '1', '2') /* 16  aaaabbbb ggggrrrr */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xbgr444"><span class="std std-ref">V4L2_PIX_FMT_XBGR444</span></a> v4l2_fourcc('X', 'B', '1', '2') /* 16  xxxxbbbb ggggrrrr */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgra444"><span class="std std-ref">V4L2_PIX_FMT_BGRA444</span></a> v4l2_fourcc('G', 'A', '1', '2') /* 16  bbbbgggg rrrraaaa */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgrx444"><span class="std std-ref">V4L2_PIX_FMT_BGRX444</span></a> v4l2_fourcc('B', 'X', '1', '2') /* 16  bbbbgggg rrrrxxxx */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb555"><span class="std std-ref">V4L2_PIX_FMT_RGB555</span></a>  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-argb555"><span class="std std-ref">V4L2_PIX_FMT_ARGB555</span></a> v4l2_fourcc('A', 'R', '1', '5') /* 16  ARGB-1-5-5-5  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xrgb555"><span class="std std-ref">V4L2_PIX_FMT_XRGB555</span></a> v4l2_fourcc('X', 'R', '1', '5') /* 16  XRGB-1-5-5-5  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgba555"><span class="std std-ref">V4L2_PIX_FMT_RGBA555</span></a> v4l2_fourcc('R', 'A', '1', '5') /* 16  RGBA-5-5-5-1  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgbx555"><span class="std std-ref">V4L2_PIX_FMT_RGBX555</span></a> v4l2_fourcc('R', 'X', '1', '5') /* 16  RGBX-5-5-5-1  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-abgr555"><span class="std std-ref">V4L2_PIX_FMT_ABGR555</span></a> v4l2_fourcc('A', 'B', '1', '5') /* 16  ABGR-1-5-5-5  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xbgr555"><span class="std std-ref">V4L2_PIX_FMT_XBGR555</span></a> v4l2_fourcc('X', 'B', '1', '5') /* 16  XBGR-1-5-5-5  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgra555"><span class="std std-ref">V4L2_PIX_FMT_BGRA555</span></a> v4l2_fourcc('B', 'A', '1', '5') /* 16  BGRA-5-5-5-1  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgrx555"><span class="std std-ref">V4L2_PIX_FMT_BGRX555</span></a> v4l2_fourcc('B', 'X', '1', '5') /* 16  BGRX-5-5-5-1  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb565"><span class="std std-ref">V4L2_PIX_FMT_RGB565</span></a>  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb555x"><span class="std std-ref">V4L2_PIX_FMT_RGB555X</span></a> v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-argb555x"><span class="std std-ref">V4L2_PIX_FMT_ARGB555X</span></a> v4l2_fourcc_be('A', 'R', '1', '5') /* 16  ARGB-5-5-5 BE */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xrgb555x"><span class="std std-ref">V4L2_PIX_FMT_XRGB555X</span></a> v4l2_fourcc_be('X', 'R', '1', '5') /* 16  XRGB-5-5-5 BE */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb565x"><span class="std std-ref">V4L2_PIX_FMT_RGB565X</span></a> v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */

/* RGB formats (3 or 4 bytes per pixel) */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgr666"><span class="std std-ref">V4L2_PIX_FMT_BGR666</span></a>  v4l2_fourcc('B', 'G', 'R', 'H') /* 18  BGR-6-6-6     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgr24"><span class="std std-ref">V4L2_PIX_FMT_BGR24</span></a>   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb24"><span class="std std-ref">V4L2_PIX_FMT_RGB24</span></a>   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgr32"><span class="std std-ref">V4L2_PIX_FMT_BGR32</span></a>   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-abgr32"><span class="std std-ref">V4L2_PIX_FMT_ABGR32</span></a>  v4l2_fourcc('A', 'R', '2', '4') /* 32  BGRA-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xbgr32"><span class="std std-ref">V4L2_PIX_FMT_XBGR32</span></a>  v4l2_fourcc('X', 'R', '2', '4') /* 32  BGRX-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgra32"><span class="std std-ref">V4L2_PIX_FMT_BGRA32</span></a>  v4l2_fourcc('R', 'A', '2', '4') /* 32  ABGR-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-bgrx32"><span class="std std-ref">V4L2_PIX_FMT_BGRX32</span></a>  v4l2_fourcc('R', 'X', '2', '4') /* 32  XBGR-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgb32"><span class="std std-ref">V4L2_PIX_FMT_RGB32</span></a>   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgba32"><span class="std std-ref">V4L2_PIX_FMT_RGBA32</span></a>  v4l2_fourcc('A', 'B', '2', '4') /* 32  RGBA-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-rgbx32"><span class="std std-ref">V4L2_PIX_FMT_RGBX32</span></a>  v4l2_fourcc('X', 'B', '2', '4') /* 32  RGBX-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-argb32"><span class="std std-ref">V4L2_PIX_FMT_ARGB32</span></a>  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-rgb.html#v4l2-pix-fmt-xrgb32"><span class="std std-ref">V4L2_PIX_FMT_XRGB32</span></a>  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */

/* Grey formats */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-grey"><span class="std std-ref">V4L2_PIX_FMT_GREY</span></a>    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-y4"><span class="std std-ref">V4L2_PIX_FMT_Y4</span></a>      v4l2_fourcc('Y', '0', '4', ' ') /*  4  Greyscale     */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-y6"><span class="std std-ref">V4L2_PIX_FMT_Y6</span></a>      v4l2_fourcc('Y', '0', '6', ' ') /*  6  Greyscale     */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y10"><span class="std std-ref">V4L2_PIX_FMT_Y10</span></a>     v4l2_fourcc('Y', '1', '0', ' ') /* 10  Greyscale     */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y12"><span class="std std-ref">V4L2_PIX_FMT_Y12</span></a>     v4l2_fourcc('Y', '1', '2', ' ') /* 12  Greyscale     */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y14"><span class="std std-ref">V4L2_PIX_FMT_Y14</span></a>     v4l2_fourcc('Y', '1', '4', ' ') /* 14  Greyscale     */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y16"><span class="std std-ref">V4L2_PIX_FMT_Y16</span></a>     v4l2_fourcc('Y', '1', '6', ' ') /* 16  Greyscale     */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y16-be"><span class="std std-ref">V4L2_PIX_FMT_Y16_BE</span></a>  v4l2_fourcc_be('Y', '1', '6', ' ') /* 16  Greyscale BE  */

/* Grey bit-packed formats */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y10bpack"><span class="std std-ref">V4L2_PIX_FMT_Y10BPACK</span></a>    v4l2_fourcc('Y', '1', '0', 'B') /* 10  Greyscale bit-packed */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-y10p"><span class="std std-ref">V4L2_PIX_FMT_Y10P</span></a>    v4l2_fourcc('Y', '1', '0', 'P') /* 10  Greyscale, MIPI RAW10 packed */
#define <a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-ipu3-y10"><span class="std std-ref">V4L2_PIX_FMT_IPU3_Y10</span></a>           v4l2_fourcc('i', 'p', '3', 'y') /* IPU3 packed 10-bit greyscale */

/* Palette formats */
#define <a class="reference internal" href="pixfmt-indexed.html#v4l2-pix-fmt-pal8"><span class="std std-ref">V4L2_PIX_FMT_PAL8</span></a>    v4l2_fourcc('P', 'A', 'L', '8') /*  8  8-bit palette */

/* Chrominance formats */
#define <a class="reference internal" href="pixfmt-uv8.html#v4l2-pix-fmt-uv8"><span class="std std-ref">V4L2_PIX_FMT_UV8</span></a>     v4l2_fourcc('U', 'V', '8', ' ') /*  8  UV 4:4 */

/* Luminance+Chrominance formats */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuyv"><span class="std std-ref">V4L2_PIX_FMT_YUYV</span></a>    v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16  YUV 4:2:2     */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-yyuv"><span class="std std-ref">V4L2_PIX_FMT_YYUV</span></a>    v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16  YUV 4:2:2     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yvyu"><span class="std std-ref">V4L2_PIX_FMT_YVYU</span></a>    v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-uyvy"><span class="std std-ref">V4L2_PIX_FMT_UYVY</span></a>    v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16  YUV 4:2:2     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-vyuy"><span class="std std-ref">V4L2_PIX_FMT_VYUY</span></a>    v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16  YUV 4:2:2     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-y41p"><span class="std std-ref">V4L2_PIX_FMT_Y41P</span></a>    v4l2_fourcc('Y', '4', '1', 'P') /* 12  YUV 4:1:1     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuv444"><span class="std std-ref">V4L2_PIX_FMT_YUV444</span></a>  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuv555"><span class="std std-ref">V4L2_PIX_FMT_YUV555</span></a>  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuv565"><span class="std std-ref">V4L2_PIX_FMT_YUV565</span></a>  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuv24"><span class="std std-ref">V4L2_PIX_FMT_YUV24</span></a>   v4l2_fourcc('Y', 'U', 'V', '3') /* 24  YUV-8-8-8     */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuv32"><span class="std std-ref">V4L2_PIX_FMT_YUV32</span></a>   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-ayuv32"><span class="std std-ref">V4L2_PIX_FMT_AYUV32</span></a>  v4l2_fourcc('A', 'Y', 'U', 'V') /* 32  AYUV-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-xyuv32"><span class="std std-ref">V4L2_PIX_FMT_XYUV32</span></a>  v4l2_fourcc('X', 'Y', 'U', 'V') /* 32  XYUV-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-vuya32"><span class="std std-ref">V4L2_PIX_FMT_VUYA32</span></a>  v4l2_fourcc('V', 'U', 'Y', 'A') /* 32  VUYA-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-vuyx32"><span class="std std-ref">V4L2_PIX_FMT_VUYX32</span></a>  v4l2_fourcc('V', 'U', 'Y', 'X') /* 32  VUYX-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuva32"><span class="std std-ref">V4L2_PIX_FMT_YUVA32</span></a>  v4l2_fourcc('Y', 'U', 'V', 'A') /* 32  YUVA-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuvx32"><span class="std std-ref">V4L2_PIX_FMT_YUVX32</span></a>  v4l2_fourcc('Y', 'U', 'V', 'X') /* 32  YUVX-8-8-8-8  */
#define <a class="reference internal" href="pixfmt-m420.html#v4l2-pix-fmt-m420"><span class="std std-ref">V4L2_PIX_FMT_M420</span></a>    v4l2_fourcc('M', '4', '2', '0') /* 12  YUV 4:2:0 2 lines y, 1 line uv interleaved */

/* two planes -- one Y, one Cr + Cb interleaved  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12"><span class="std std-ref">V4L2_PIX_FMT_NV12</span></a>    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv21"><span class="std std-ref">V4L2_PIX_FMT_NV21</span></a>    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv16"><span class="std std-ref">V4L2_PIX_FMT_NV16</span></a>    v4l2_fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv61"><span class="std std-ref">V4L2_PIX_FMT_NV61</span></a>    v4l2_fourcc('N', 'V', '6', '1') /* 16  Y/CrCb 4:2:2  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv24"><span class="std std-ref">V4L2_PIX_FMT_NV24</span></a>    v4l2_fourcc('N', 'V', '2', '4') /* 24  Y/CbCr 4:4:4  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv42"><span class="std std-ref">V4L2_PIX_FMT_NV42</span></a>    v4l2_fourcc('N', 'V', '4', '2') /* 24  Y/CrCb 4:4:4  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-p010"><span class="std std-ref">V4L2_PIX_FMT_P010</span></a>    v4l2_fourcc('P', '0', '1', '0') /* 24  Y/CbCr 4:2:0 10-bit per component */

/* two non contiguous planes - one Y, one Cr + Cb interleaved  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12m"><span class="std std-ref">V4L2_PIX_FMT_NV12M</span></a>   v4l2_fourcc('N', 'M', '1', '2') /* 12  Y/CbCr 4:2:0  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv21m"><span class="std std-ref">V4L2_PIX_FMT_NV21M</span></a>   v4l2_fourcc('N', 'M', '2', '1') /* 21  Y/CrCb 4:2:0  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv16m"><span class="std std-ref">V4L2_PIX_FMT_NV16M</span></a>   v4l2_fourcc('N', 'M', '1', '6') /* 16  Y/CbCr 4:2:2  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv61m"><span class="std std-ref">V4L2_PIX_FMT_NV61M</span></a>   v4l2_fourcc('N', 'M', '6', '1') /* 16  Y/CrCb 4:2:2  */

/* three planes - Y Cb, Cr */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv410"><span class="std std-ref">V4L2_PIX_FMT_YUV410</span></a>  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu410"><span class="std std-ref">V4L2_PIX_FMT_YVU410</span></a>  v4l2_fourcc('Y', 'V', 'U', '9') /*  9  YVU 4:1:0     */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv411p"><span class="std std-ref">V4L2_PIX_FMT_YUV411P</span></a> v4l2_fourcc('4', '1', '1', 'P') /* 12  YVU411 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv420"><span class="std std-ref">V4L2_PIX_FMT_YUV420</span></a>  v4l2_fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu420"><span class="std std-ref">V4L2_PIX_FMT_YVU420</span></a>  v4l2_fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv422p"><span class="std std-ref">V4L2_PIX_FMT_YUV422P</span></a> v4l2_fourcc('4', '2', '2', 'P') /* 16  YVU422 planar */

/* three non contiguous planes - Y, Cb, Cr */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv420m"><span class="std std-ref">V4L2_PIX_FMT_YUV420M</span></a> v4l2_fourcc('Y', 'M', '1', '2') /* 12  YUV420 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu420m"><span class="std std-ref">V4L2_PIX_FMT_YVU420M</span></a> v4l2_fourcc('Y', 'M', '2', '1') /* 12  YVU420 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv422m"><span class="std std-ref">V4L2_PIX_FMT_YUV422M</span></a> v4l2_fourcc('Y', 'M', '1', '6') /* 16  YUV422 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu422m"><span class="std std-ref">V4L2_PIX_FMT_YVU422M</span></a> v4l2_fourcc('Y', 'M', '6', '1') /* 16  YVU422 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv444m"><span class="std std-ref">V4L2_PIX_FMT_YUV444M</span></a> v4l2_fourcc('Y', 'M', '2', '4') /* 24  YUV444 planar */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu444m"><span class="std std-ref">V4L2_PIX_FMT_YVU444M</span></a> v4l2_fourcc('Y', 'M', '4', '2') /* 24  YVU444 planar */

/* Tiled YUV formats */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-4l4"><span class="std std-ref">V4L2_PIX_FMT_NV12_4L4</span></a> v4l2_fourcc('V', 'T', '1', '2')   /* 12  Y/CbCr 4:2:0  4x4 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-16l16"><span class="std std-ref">V4L2_PIX_FMT_NV12_16L16</span></a> v4l2_fourcc('H', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 16x16 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-32l32"><span class="std std-ref">V4L2_PIX_FMT_NV12_32L32</span></a> v4l2_fourcc('S', 'T', '1', '2') /* 12  Y/CbCr 4:2:0 32x32 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-p010-4l4"><span class="std std-ref">V4L2_PIX_FMT_P010_4L4</span></a> v4l2_fourcc('T', '0', '1', '0') /* 12  Y/CbCr 4:2:0 10-bit 4x4 macroblocks */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-8l128"><span class="std std-ref">V4L2_PIX_FMT_NV12_8L128</span></a>       v4l2_fourcc('A', 'T', '1', '2') /* Y/CbCr 4:2:0 8x128 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-10be-8l128"><span class="std std-ref">V4L2_PIX_FMT_NV12_10BE_8L128</span></a>  v4l2_fourcc_be('A', 'X', '1', '2') /* Y/CbCr 4:2:0 10-bit 8x128 tiles */

/* Tiled YUV formats, non contiguous planes */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12mt"><span class="std std-ref">V4L2_PIX_FMT_NV12MT</span></a>  v4l2_fourcc('T', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 64x32 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12mt-16x16"><span class="std std-ref">V4L2_PIX_FMT_NV12MT_16X16</span></a> v4l2_fourcc('V', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 16x16 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12m-8l128"><span class="std std-ref">V4L2_PIX_FMT_NV12M_8L128</span></a>      v4l2_fourcc('N', 'A', '1', '2') /* Y/CbCr 4:2:0 8x128 tiles */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12m-10be-8l128"><span class="std std-ref">V4L2_PIX_FMT_NV12M_10BE_8L128</span></a> v4l2_fourcc_be('N', 'T', '1', '2') /* Y/CbCr 4:2:0 10-bit 8x128 tiles */

/* Bayer formats - see http://www.siliconimaging.com/RGB%20Bayer.htm */
#define <a class="reference internal" href="pixfmt-srggb8.html#v4l2-pix-fmt-sbggr8"><span class="std std-ref">V4L2_PIX_FMT_SBGGR8</span></a>  v4l2_fourcc('B', 'A', '8', '1') /*  8  BGBG.. GRGR.. */
#define <a class="reference internal" href="pixfmt-srggb8.html#v4l2-pix-fmt-sgbrg8"><span class="std std-ref">V4L2_PIX_FMT_SGBRG8</span></a>  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
#define <a class="reference internal" href="pixfmt-srggb8.html#v4l2-pix-fmt-sgrbg8"><span class="std std-ref">V4L2_PIX_FMT_SGRBG8</span></a>  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
#define <a class="reference internal" href="pixfmt-srggb8.html#v4l2-pix-fmt-srggb8"><span class="std std-ref">V4L2_PIX_FMT_SRGGB8</span></a>  v4l2_fourcc('R', 'G', 'G', 'B') /*  8  RGRG.. GBGB.. */
#define <a class="reference internal" href="pixfmt-srggb10.html#v4l2-pix-fmt-sbggr10"><span class="std std-ref">V4L2_PIX_FMT_SBGGR10</span></a> v4l2_fourcc('B', 'G', '1', '0') /* 10  BGBG.. GRGR.. */
#define <a class="reference internal" href="pixfmt-srggb10.html#v4l2-pix-fmt-sgbrg10"><span class="std std-ref">V4L2_PIX_FMT_SGBRG10</span></a> v4l2_fourcc('G', 'B', '1', '0') /* 10  GBGB.. RGRG.. */
#define <a class="reference internal" href="pixfmt-srggb10.html#v4l2-pix-fmt-sgrbg10"><span class="std std-ref">V4L2_PIX_FMT_SGRBG10</span></a> v4l2_fourcc('B', 'A', '1', '0') /* 10  GRGR.. BGBG.. */
#define <a class="reference internal" href="pixfmt-srggb10.html#v4l2-pix-fmt-srggb10"><span class="std std-ref">V4L2_PIX_FMT_SRGGB10</span></a> v4l2_fourcc('R', 'G', '1', '0') /* 10  RGRG.. GBGB.. */
        /* 10bit raw bayer packed, 5 bytes for every 4 pixels */
#define <a class="reference internal" href="pixfmt-srggb10p.html#v4l2-pix-fmt-sbggr10p"><span class="std std-ref">V4L2_PIX_FMT_SBGGR10P</span></a> v4l2_fourcc('p', 'B', 'A', 'A')
#define <a class="reference internal" href="pixfmt-srggb10p.html#v4l2-pix-fmt-sgbrg10p"><span class="std std-ref">V4L2_PIX_FMT_SGBRG10P</span></a> v4l2_fourcc('p', 'G', 'A', 'A')
#define <a class="reference internal" href="pixfmt-srggb10p.html#v4l2-pix-fmt-sgrbg10p"><span class="std std-ref">V4L2_PIX_FMT_SGRBG10P</span></a> v4l2_fourcc('p', 'g', 'A', 'A')
#define <a class="reference internal" href="pixfmt-srggb10p.html#v4l2-pix-fmt-srggb10p"><span class="std std-ref">V4L2_PIX_FMT_SRGGB10P</span></a> v4l2_fourcc('p', 'R', 'A', 'A')
        /* 10bit raw bayer a-law compressed to 8 bits */
#define <a class="reference internal" href="pixfmt-srggb10alaw8.html#v4l2-pix-fmt-sbggr10alaw8"><span class="std std-ref">V4L2_PIX_FMT_SBGGR10ALAW8</span></a> v4l2_fourcc('a', 'B', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb10alaw8.html#v4l2-pix-fmt-sgbrg10alaw8"><span class="std std-ref">V4L2_PIX_FMT_SGBRG10ALAW8</span></a> v4l2_fourcc('a', 'G', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb10alaw8.html#v4l2-pix-fmt-sgrbg10alaw8"><span class="std std-ref">V4L2_PIX_FMT_SGRBG10ALAW8</span></a> v4l2_fourcc('a', 'g', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb10alaw8.html#v4l2-pix-fmt-srggb10alaw8"><span class="std std-ref">V4L2_PIX_FMT_SRGGB10ALAW8</span></a> v4l2_fourcc('a', 'R', 'A', '8')
        /* 10bit raw bayer DPCM compressed to 8 bits */
#define <a class="reference internal" href="pixfmt-srggb10dpcm8.html#v4l2-pix-fmt-sbggr10dpcm8"><span class="std std-ref">V4L2_PIX_FMT_SBGGR10DPCM8</span></a> v4l2_fourcc('b', 'B', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb10dpcm8.html#v4l2-pix-fmt-sgbrg10dpcm8"><span class="std std-ref">V4L2_PIX_FMT_SGBRG10DPCM8</span></a> v4l2_fourcc('b', 'G', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb10dpcm8.html#v4l2-pix-fmt-sgrbg10dpcm8"><span class="std std-ref">V4L2_PIX_FMT_SGRBG10DPCM8</span></a> v4l2_fourcc('B', 'D', '1', '0')
#define <a class="reference internal" href="pixfmt-srggb10dpcm8.html#v4l2-pix-fmt-srggb10dpcm8"><span class="std std-ref">V4L2_PIX_FMT_SRGGB10DPCM8</span></a> v4l2_fourcc('b', 'R', 'A', '8')
#define <a class="reference internal" href="pixfmt-srggb12.html#v4l2-pix-fmt-sbggr12"><span class="std std-ref">V4L2_PIX_FMT_SBGGR12</span></a> v4l2_fourcc('B', 'G', '1', '2') /* 12  BGBG.. GRGR.. */
#define <a class="reference internal" href="pixfmt-srggb12.html#v4l2-pix-fmt-sgbrg12"><span class="std std-ref">V4L2_PIX_FMT_SGBRG12</span></a> v4l2_fourcc('G', 'B', '1', '2') /* 12  GBGB.. RGRG.. */
#define <a class="reference internal" href="pixfmt-srggb12.html#v4l2-pix-fmt-sgrbg12"><span class="std std-ref">V4L2_PIX_FMT_SGRBG12</span></a> v4l2_fourcc('B', 'A', '1', '2') /* 12  GRGR.. BGBG.. */
#define <a class="reference internal" href="pixfmt-srggb12.html#v4l2-pix-fmt-srggb12"><span class="std std-ref">V4L2_PIX_FMT_SRGGB12</span></a> v4l2_fourcc('R', 'G', '1', '2') /* 12  RGRG.. GBGB.. */
        /* 12bit raw bayer packed, 6 bytes for every 4 pixels */
#define <a class="reference internal" href="pixfmt-srggb12p.html#v4l2-pix-fmt-sbggr12p"><span class="std std-ref">V4L2_PIX_FMT_SBGGR12P</span></a> v4l2_fourcc('p', 'B', 'C', 'C')
#define <a class="reference internal" href="pixfmt-srggb12p.html#v4l2-pix-fmt-sgbrg12p"><span class="std std-ref">V4L2_PIX_FMT_SGBRG12P</span></a> v4l2_fourcc('p', 'G', 'C', 'C')
#define <a class="reference internal" href="pixfmt-srggb12p.html#v4l2-pix-fmt-sgrbg12p"><span class="std std-ref">V4L2_PIX_FMT_SGRBG12P</span></a> v4l2_fourcc('p', 'g', 'C', 'C')
#define <a class="reference internal" href="pixfmt-srggb12p.html#v4l2-pix-fmt-srggb12p"><span class="std std-ref">V4L2_PIX_FMT_SRGGB12P</span></a> v4l2_fourcc('p', 'R', 'C', 'C')
#define <a class="reference internal" href="pixfmt-srggb14.html#v4l2-pix-fmt-sbggr14"><span class="std std-ref">V4L2_PIX_FMT_SBGGR14</span></a> v4l2_fourcc('B', 'G', '1', '4') /* 14  BGBG.. GRGR.. */
#define <a class="reference internal" href="pixfmt-srggb14.html#v4l2-pix-fmt-sgbrg14"><span class="std std-ref">V4L2_PIX_FMT_SGBRG14</span></a> v4l2_fourcc('G', 'B', '1', '4') /* 14  GBGB.. RGRG.. */
#define <a class="reference internal" href="pixfmt-srggb14.html#v4l2-pix-fmt-sgrbg14"><span class="std std-ref">V4L2_PIX_FMT_SGRBG14</span></a> v4l2_fourcc('G', 'R', '1', '4') /* 14  GRGR.. BGBG.. */
#define <a class="reference internal" href="pixfmt-srggb14.html#v4l2-pix-fmt-srggb14"><span class="std std-ref">V4L2_PIX_FMT_SRGGB14</span></a> v4l2_fourcc('R', 'G', '1', '4') /* 14  RGRG.. GBGB.. */
        /* 14bit raw bayer packed, 7 bytes for every 4 pixels */
#define <a class="reference internal" href="pixfmt-srggb14p.html#v4l2-pix-fmt-sbggr14p"><span class="std std-ref">V4L2_PIX_FMT_SBGGR14P</span></a> v4l2_fourcc('p', 'B', 'E', 'E')
#define <a class="reference internal" href="pixfmt-srggb14p.html#v4l2-pix-fmt-sgbrg14p"><span class="std std-ref">V4L2_PIX_FMT_SGBRG14P</span></a> v4l2_fourcc('p', 'G', 'E', 'E')
#define <a class="reference internal" href="pixfmt-srggb14p.html#v4l2-pix-fmt-sgrbg14p"><span class="std std-ref">V4L2_PIX_FMT_SGRBG14P</span></a> v4l2_fourcc('p', 'g', 'E', 'E')
#define <a class="reference internal" href="pixfmt-srggb14p.html#v4l2-pix-fmt-srggb14p"><span class="std std-ref">V4L2_PIX_FMT_SRGGB14P</span></a> v4l2_fourcc('p', 'R', 'E', 'E')
#define <a class="reference internal" href="pixfmt-srggb16.html#v4l2-pix-fmt-sbggr16"><span class="std std-ref">V4L2_PIX_FMT_SBGGR16</span></a> v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */
#define <a class="reference internal" href="pixfmt-srggb16.html#v4l2-pix-fmt-sgbrg16"><span class="std std-ref">V4L2_PIX_FMT_SGBRG16</span></a> v4l2_fourcc('G', 'B', '1', '6') /* 16  GBGB.. RGRG.. */
#define <a class="reference internal" href="pixfmt-srggb16.html#v4l2-pix-fmt-sgrbg16"><span class="std std-ref">V4L2_PIX_FMT_SGRBG16</span></a> v4l2_fourcc('G', 'R', '1', '6') /* 16  GRGR.. BGBG.. */
#define <a class="reference internal" href="pixfmt-srggb16.html#v4l2-pix-fmt-srggb16"><span class="std std-ref">V4L2_PIX_FMT_SRGGB16</span></a> v4l2_fourcc('R', 'G', '1', '6') /* 16  RGRG.. GBGB.. */

/* HSV formats */
#define <a class="reference internal" href="pixfmt-packed-hsv.html#v4l2-pix-fmt-hsv24"><span class="std std-ref">V4L2_PIX_FMT_HSV24</span></a> v4l2_fourcc('H', 'S', 'V', '3')
#define <a class="reference internal" href="pixfmt-packed-hsv.html#v4l2-pix-fmt-hsv32"><span class="std std-ref">V4L2_PIX_FMT_HSV32</span></a> v4l2_fourcc('H', 'S', 'V', '4')

/* compressed formats */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-mjpeg"><span class="std std-ref">V4L2_PIX_FMT_MJPEG</span></a>    v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG   */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-jpeg"><span class="std std-ref">V4L2_PIX_FMT_JPEG</span></a>     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-dv"><span class="std std-ref">V4L2_PIX_FMT_DV</span></a>       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-mpeg"><span class="std std-ref">V4L2_PIX_FMT_MPEG</span></a>     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-h264"><span class="std std-ref">V4L2_PIX_FMT_H264</span></a>     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-h264-no-sc"><span class="std std-ref">V4L2_PIX_FMT_H264_NO_SC</span></a> v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-h264-mvc"><span class="std std-ref">V4L2_PIX_FMT_H264_MVC</span></a> v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-h263"><span class="std std-ref">V4L2_PIX_FMT_H263</span></a>     v4l2_fourcc('H', '2', '6', '3') /* H263          */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-mpeg1"><span class="std std-ref">V4L2_PIX_FMT_MPEG1</span></a>    v4l2_fourcc('M', 'P', 'G', '1') /* MPEG-1 ES     */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-mpeg2"><span class="std std-ref">V4L2_PIX_FMT_MPEG2</span></a>    v4l2_fourcc('M', 'P', 'G', '2') /* MPEG-2 ES     */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-mpeg2-slice"><span class="std std-ref">V4L2_PIX_FMT_MPEG2_SLICE</span></a> v4l2_fourcc('M', 'G', '2', 'S') /* MPEG-2 parsed slice data */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-mpeg4"><span class="std std-ref">V4L2_PIX_FMT_MPEG4</span></a>    v4l2_fourcc('M', 'P', 'G', '4') /* MPEG-4 part 2 ES */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-xvid"><span class="std std-ref">V4L2_PIX_FMT_XVID</span></a>     v4l2_fourcc('X', 'V', 'I', 'D') /* Xvid           */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vc1-annex-g"><span class="std std-ref">V4L2_PIX_FMT_VC1_ANNEX_G</span></a> v4l2_fourcc('V', 'C', '1', 'G') /* SMPTE 421M Annex G compliant stream */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vc1-annex-l"><span class="std std-ref">V4L2_PIX_FMT_VC1_ANNEX_L</span></a> v4l2_fourcc('V', 'C', '1', 'L') /* SMPTE 421M Annex L compliant stream */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vp8"><span class="std std-ref">V4L2_PIX_FMT_VP8</span></a>      v4l2_fourcc('V', 'P', '8', '0') /* VP8 */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vp8-frame"><span class="std std-ref">V4L2_PIX_FMT_VP8_FRAME</span></a> v4l2_fourcc('V', 'P', '8', 'F') /* VP8 parsed frame */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vp9"><span class="std std-ref">V4L2_PIX_FMT_VP9</span></a>      v4l2_fourcc('V', 'P', '9', '0') /* VP9 */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-vp9-frame"><span class="std std-ref">V4L2_PIX_FMT_VP9_FRAME</span></a> v4l2_fourcc('V', 'P', '9', 'F') /* VP9 parsed frame */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-hevc"><span class="std std-ref">V4L2_PIX_FMT_HEVC</span></a>     v4l2_fourcc('H', 'E', 'V', 'C') /* HEVC aka H.265 */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-fwht"><span class="std std-ref">V4L2_PIX_FMT_FWHT</span></a>     v4l2_fourcc('F', 'W', 'H', 'T') /* Fast Walsh Hadamard Transform (vicodec) */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-fwht-stateless"><span class="std std-ref">V4L2_PIX_FMT_FWHT_STATELESS</span></a>     v4l2_fourcc('S', 'F', 'W', 'H') /* Stateless FWHT (vicodec) */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-h264-slice"><span class="std std-ref">V4L2_PIX_FMT_H264_SLICE</span></a> v4l2_fourcc('S', '2', '6', '4') /* H264 parsed slices */
#define <a class="reference internal" href="pixfmt-compressed.html#v4l2-pix-fmt-hevc-slice"><span class="std std-ref">V4L2_PIX_FMT_HEVC_SLICE</span></a> v4l2_fourcc('S', '2', '6', '5') /* HEVC parsed slices */

/*  Vendor-specific formats   */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-cpia1"><span class="std std-ref">V4L2_PIX_FMT_CPIA1</span></a>    v4l2_fourcc('C', 'P', 'I', 'A') /* cpia1 YUV */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-wnva"><span class="std std-ref">V4L2_PIX_FMT_WNVA</span></a>     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-sn9c10x"><span class="std std-ref">V4L2_PIX_FMT_SN9C10X</span></a>  v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-sn9c20x-i420"><span class="std std-ref">V4L2_PIX_FMT_SN9C20X_I420</span></a> v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-pwc1"><span class="std std-ref">V4L2_PIX_FMT_PWC1</span></a>     v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-pwc2"><span class="std std-ref">V4L2_PIX_FMT_PWC2</span></a>     v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-et61x251"><span class="std std-ref">V4L2_PIX_FMT_ET61X251</span></a> v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-spca501"><span class="std std-ref">V4L2_PIX_FMT_SPCA501</span></a>  v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-spca505"><span class="std std-ref">V4L2_PIX_FMT_SPCA505</span></a>  v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-spca508"><span class="std std-ref">V4L2_PIX_FMT_SPCA508</span></a>  v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-spca561"><span class="std std-ref">V4L2_PIX_FMT_SPCA561</span></a>  v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-pac207"><span class="std std-ref">V4L2_PIX_FMT_PAC207</span></a>   v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-mr97310a"><span class="std std-ref">V4L2_PIX_FMT_MR97310A</span></a> v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-jl2005bcd"><span class="std std-ref">V4L2_PIX_FMT_JL2005BCD</span></a> v4l2_fourcc('J', 'L', '2', '0') /* compressed RGGB bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-sn9c2028"><span class="std std-ref">V4L2_PIX_FMT_SN9C2028</span></a> v4l2_fourcc('S', 'O', 'N', 'X') /* compressed GBRG bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-sq905c"><span class="std std-ref">V4L2_PIX_FMT_SQ905C</span></a>   v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-pjpg"><span class="std std-ref">V4L2_PIX_FMT_PJPG</span></a>     v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-ov511"><span class="std std-ref">V4L2_PIX_FMT_OV511</span></a>    v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-ov518"><span class="std std-ref">V4L2_PIX_FMT_OV518</span></a>    v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-stv0680"><span class="std std-ref">V4L2_PIX_FMT_STV0680</span></a>  v4l2_fourcc('S', '6', '8', '0') /* stv0680 bayer */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-tm6000"><span class="std std-ref">V4L2_PIX_FMT_TM6000</span></a>   v4l2_fourcc('T', 'M', '6', '0') /* tm5600/tm60x0 */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-cit-yyvyuy"><span class="std std-ref">V4L2_PIX_FMT_CIT_YYVYUY</span></a> v4l2_fourcc('C', 'I', 'T', 'V') /* one line of Y then 1 line of VYUY */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-konica420"><span class="std std-ref">V4L2_PIX_FMT_KONICA420</span></a>  v4l2_fourcc('K', 'O', 'N', 'I') /* YUV420 planar in blocks of 256 pixels */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-jpgl"><span class="std std-ref">V4L2_PIX_FMT_JPGL</span></a>       v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-se401"><span class="std std-ref">V4L2_PIX_FMT_SE401</span></a>      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-s5c-uyvy-jpg"><span class="std std-ref">V4L2_PIX_FMT_S5C_UYVY_JPG</span></a> v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
#define <a class="reference internal" href="pixfmt-y8i.html#v4l2-pix-fmt-y8i"><span class="std std-ref">V4L2_PIX_FMT_Y8I</span></a>      v4l2_fourcc('Y', '8', 'I', ' ') /* Greyscale 8-bit L/R interleaved */
#define <a class="reference internal" href="pixfmt-y12i.html#v4l2-pix-fmt-y12i"><span class="std std-ref">V4L2_PIX_FMT_Y12I</span></a>     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
#define <a class="reference internal" href="pixfmt-z16.html#v4l2-pix-fmt-z16"><span class="std std-ref">V4L2_PIX_FMT_Z16</span></a>      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-mt21c"><span class="std std-ref">V4L2_PIX_FMT_MT21C</span></a>    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
#define <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-mm21"><span class="std std-ref">V4L2_PIX_FMT_MM21</span></a>     v4l2_fourcc('M', 'M', '2', '1') /* Mediatek 8-bit block mode, two non-contiguous planes */
#define <a class="reference internal" href="pixfmt-inzi.html#v4l2-pix-fmt-inzi"><span class="std std-ref">V4L2_PIX_FMT_INZI</span></a>     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
#define <a class="reference internal" href="pixfmt-cnf4.html#v4l2-pix-fmt-cnf4"><span class="std std-ref">V4L2_PIX_FMT_CNF4</span></a>     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-hi240"><span class="std std-ref">V4L2_PIX_FMT_HI240</span></a>    v4l2_fourcc('H', 'I', '2', '4') /* BTTV 8-bit dithered RGB */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-qc08c"><span class="std std-ref">V4L2_PIX_FMT_QC08C</span></a>    v4l2_fourcc('Q', '0', '8', 'C') /* Qualcomm 8-bit compressed */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-qc10c"><span class="std std-ref">V4L2_PIX_FMT_QC10C</span></a>    v4l2_fourcc('Q', '1', '0', 'C') /* Qualcomm 10-bit compressed */
#define <a class="reference internal" href="pixfmt-reserved.html#v4l2-pix-fmt-ajpg"><span class="std std-ref">V4L2_PIX_FMT_AJPG</span></a>     v4l2_fourcc('A', 'J', 'P', 'G') /* Aspeed JPEG */

/* 10bit raw packed, 32 bytes for every 25 pixels, last LSB 6 bits unused */
#define <a class="reference internal" href="pixfmt-srggb10-ipu3.html#v4l2-pix-fmt-ipu3-sbggr10"><span class="std std-ref">V4L2_PIX_FMT_IPU3_SBGGR10</span></a>       v4l2_fourcc('i', 'p', '3', 'b') /* IPU3 packed 10-bit BGGR bayer */
#define <a class="reference internal" href="pixfmt-srggb10-ipu3.html#v4l2-pix-fmt-ipu3-sgbrg10"><span class="std std-ref">V4L2_PIX_FMT_IPU3_SGBRG10</span></a>       v4l2_fourcc('i', 'p', '3', 'g') /* IPU3 packed 10-bit GBRG bayer */
#define <a class="reference internal" href="pixfmt-srggb10-ipu3.html#v4l2-pix-fmt-ipu3-sgrbg10"><span class="std std-ref">V4L2_PIX_FMT_IPU3_SGRBG10</span></a>       v4l2_fourcc('i', 'p', '3', 'G') /* IPU3 packed 10-bit GRBG bayer */
#define <a class="reference internal" href="pixfmt-srggb10-ipu3.html#v4l2-pix-fmt-ipu3-srggb10"><span class="std std-ref">V4L2_PIX_FMT_IPU3_SRGGB10</span></a>       v4l2_fourcc('i', 'p', '3', 'r') /* IPU3 packed 10-bit RGGB bayer */

/* SDR formats - used only for Software Defined Radio devices */
#define <a class="reference internal" href="pixfmt-sdr-cu08.html#v4l2-sdr-fmt-cu8"><span class="std std-ref">V4L2_SDR_FMT_CU8</span></a>          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
#define <a class="reference internal" href="pixfmt-sdr-cu16le.html#v4l2-sdr-fmt-cu16le"><span class="std std-ref">V4L2_SDR_FMT_CU16LE</span></a>       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
#define <a class="reference internal" href="pixfmt-sdr-cs08.html#v4l2-sdr-fmt-cs8"><span class="std std-ref">V4L2_SDR_FMT_CS8</span></a>          v4l2_fourcc('C', 'S', '0', '8') /* complex s8 */
#define <a class="reference internal" href="pixfmt-sdr-cs14le.html#v4l2-sdr-fmt-cs14le"><span class="std std-ref">V4L2_SDR_FMT_CS14LE</span></a>       v4l2_fourcc('C', 'S', '1', '4') /* complex s14le */
#define <a class="reference internal" href="pixfmt-sdr-ru12le.html#v4l2-sdr-fmt-ru12le"><span class="std std-ref">V4L2_SDR_FMT_RU12LE</span></a>       v4l2_fourcc('R', 'U', '1', '2') /* real u12le */
#define <a class="reference internal" href="pixfmt-sdr-pcu16be.html#v4l2-sdr-fmt-pcu16be"><span class="std std-ref">V4L2_SDR_FMT_PCU16BE</span></a>      v4l2_fourcc('P', 'C', '1', '6') /* planar complex u16be */
#define <a class="reference internal" href="pixfmt-sdr-pcu18be.html#v4l2-sdr-fmt-pcu18be"><span class="std std-ref">V4L2_SDR_FMT_PCU18BE</span></a>      v4l2_fourcc('P', 'C', '1', '8') /* planar complex u18be */
#define <a class="reference internal" href="pixfmt-sdr-pcu20be.html#v4l2-sdr-fmt-pcu20be"><span class="std std-ref">V4L2_SDR_FMT_PCU20BE</span></a>      v4l2_fourcc('P', 'C', '2', '0') /* planar complex u20be */

/* Touch formats - used for Touch devices */
#define <a class="reference internal" href="pixfmt-tch-td16.html#v4l2-tch-fmt-delta-td16"><span class="std std-ref">V4L2_TCH_FMT_DELTA_TD16</span></a> v4l2_fourcc('T', 'D', '1', '6') /* 16-bit signed deltas */
#define <a class="reference internal" href="pixfmt-tch-td08.html#v4l2-tch-fmt-delta-td08"><span class="std std-ref">V4L2_TCH_FMT_DELTA_TD08</span></a> v4l2_fourcc('T', 'D', '0', '8') /* 8-bit signed deltas */
#define <a class="reference internal" href="pixfmt-tch-tu16.html#v4l2-tch-fmt-tu16"><span class="std std-ref">V4L2_TCH_FMT_TU16</span></a>       v4l2_fourcc('T', 'U', '1', '6') /* 16-bit unsigned touch data */
#define <a class="reference internal" href="pixfmt-tch-tu08.html#v4l2-tch-fmt-tu08"><span class="std std-ref">V4L2_TCH_FMT_TU08</span></a>       v4l2_fourcc('T', 'U', '0', '8') /* 8-bit unsigned touch data */

/* Meta-data formats */
#define <a class="reference internal" href="pixfmt-meta-vsp1-hgo.html#v4l2-meta-fmt-vsp1-hgo"><span class="std std-ref">V4L2_META_FMT_VSP1_HGO</span></a>    v4l2_fourcc('V', 'S', 'P', 'H') /* R-Car VSP1 1-D Histogram */
#define <a class="reference internal" href="pixfmt-meta-vsp1-hgt.html#v4l2-meta-fmt-vsp1-hgt"><span class="std std-ref">V4L2_META_FMT_VSP1_HGT</span></a>    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
#define <a class="reference internal" href="pixfmt-meta-uvc.html#v4l2-meta-fmt-uvc"><span class="std std-ref">V4L2_META_FMT_UVC</span></a>         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
#define <a class="reference internal" href="pixfmt-meta-d4xx.html#v4l2-meta-fmt-d4xx"><span class="std std-ref">V4L2_META_FMT_D4XX</span></a>        v4l2_fourcc('D', '4', 'X', 'X') /* D4XX Payload Header metadata */
#define <a class="reference internal" href="pixfmt-meta-vivid.html#v4l2-meta-fmt-vivid"><span class="std std-ref">V4L2_META_FMT_VIVID</span></a>       v4l2_fourcc('V', 'I', 'V', 'D') /* Vivid Metadata */

/* Vendor specific - used for RK_ISP1 camera sub-system */
#define <a class="reference internal" href="pixfmt-meta-rkisp1.html#v4l2-meta-fmt-rk-isp1-params"><span class="std std-ref">V4L2_META_FMT_RK_ISP1_PARAMS</span></a>    v4l2_fourcc('R', 'K', '1', 'P') /* Rockchip ISP1 3A Parameters */
#define <a class="reference internal" href="pixfmt-meta-rkisp1.html#v4l2-meta-fmt-rk-isp1-stat-3a"><span class="std std-ref">V4L2_META_FMT_RK_ISP1_STAT_3A</span></a>   v4l2_fourcc('R', 'K', '1', 'S') /* Rockchip ISP1 3A Statistics */

/* priv field value to indicates that subsequent fields are valid. */
#define <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_PRIV_MAGIC</span></code></a>         0xfeedcafe

/* Flags */
#define <a class="reference internal" href="pixfmt-v4l2.html#format-flags"><span class="std std-ref">V4L2_PIX_FMT_FLAG_PREMUL_ALPHA</span></a>  0x00000001
#define <a class="reference internal" href="pixfmt-v4l2.html#v4l2-pix-fmt-flag-set-csc"><span class="std std-ref">V4L2_PIX_FMT_FLAG_SET_CSC</span></a>       0x00000002

/*
 *      F O R M A T   E N U M E R A T I O N
 */
struct v4l2_fmtdesc {
        __u32               index;             /* Format number      */
        __u32               type;              /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        __u32               flags;
        __u8                description[32];   /* Description string */
        __u32               pixelformat;       /* Format fourcc      */
        __u32               mbus_code;          /* Media bus code    */
        __u32               reserved[3];
};

#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_COMPRESSED</span></a>                0x0001
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_EMULATED</span></a>                  0x0002
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM</span></a>     0x0004
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_DYN_RESOLUTION</span></a>            0x0008
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_ENC_CAP_FRAME_INTERVAL</span></a>    0x0010
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_COLORSPACE</span></a>            0x0020
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_XFER_FUNC</span></a>             0x0040
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_YCBCR_ENC</span></a>             0x0080
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_HSV_ENC</span></a>               <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_YCBCR_ENC</span></a>
#define <a class="reference internal" href="vidioc-enum-fmt.html#fmtdesc-flags"><span class="std std-ref">V4L2_FMT_FLAG_CSC_QUANTIZATION</span></a>          0x0100

        /* Frame Size and frame rate enumeration */
/*
 *      F R A M E   S I Z E   E N U M E R A T I O N
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_frmsizetypes</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMSIZE_TYPE_DISCRETE</span></code>      = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMSIZE_TYPE_CONTINUOUS</span></code>    = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMSIZE_TYPE_STEPWISE</span></code>      = 3,
};

struct v4l2_frmsize_discrete {
        __u32                   width;          /* Frame width [pixel] */
        __u32                   height;         /* Frame height [pixel] */
};

struct v4l2_frmsize_stepwise {
        __u32                   min_width;      /* Minimum frame width [pixel] */
        __u32                   max_width;      /* Maximum frame width [pixel] */
        __u32                   step_width;     /* Frame width step size [pixel] */
        __u32                   min_height;     /* Minimum frame height [pixel] */
        __u32                   max_height;     /* Maximum frame height [pixel] */
        __u32                   step_height;    /* Frame height step size [pixel] */
};

struct v4l2_frmsizeenum {
        __u32                   index;          /* Frame size number */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   type;           /* Frame size type the device supports. */

        union {                                 /* Frame size */
                struct v4l2_frmsize_discrete    discrete;
                struct v4l2_frmsize_stepwise    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};

/*
 *      F R A M E   R A T E   E N U M E R A T I O N
 */
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_frmivaltypes</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMIVAL_TYPE_DISCRETE</span></code>      = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMIVAL_TYPE_CONTINUOUS</span></code>    = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FRMIVAL_TYPE_STEPWISE</span></code>      = 3,
};

struct v4l2_frmival_stepwise {
        struct v4l2_fract       min;            /* Minimum frame interval [s] */
        struct v4l2_fract       max;            /* Maximum frame interval [s] */
        struct v4l2_fract       step;           /* Frame interval step size [s] */
};

struct v4l2_frmivalenum {
        __u32                   index;          /* Frame format index */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   width;          /* Frame width */
        __u32                   height;         /* Frame height */
        __u32                   type;           /* Frame interval type the device supports. */

        union {                                 /* Frame interval */
                struct v4l2_fract               discrete;
                struct v4l2_frmival_stepwise    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};

/*
 *      T I M E C O D E
 */
struct v4l2_timecode {
        __u32   type;
        __u32   flags;
        __u8    frames;
        __u8    seconds;
        __u8    minutes;
        __u8    hours;
        __u8    userbits[4];
};

/*  Type  */
#define <a class="reference internal" href="buffer.html#timecode-type"><span class="std std-ref">V4L2_TC_TYPE_24FPS</span></a>              1
#define <a class="reference internal" href="buffer.html#timecode-type"><span class="std std-ref">V4L2_TC_TYPE_25FPS</span></a>              2
#define <a class="reference internal" href="buffer.html#timecode-type"><span class="std std-ref">V4L2_TC_TYPE_30FPS</span></a>              3
#define <a class="reference internal" href="buffer.html#timecode-type"><span class="std std-ref">V4L2_TC_TYPE_50FPS</span></a>              4
#define <a class="reference internal" href="buffer.html#timecode-type"><span class="std std-ref">V4L2_TC_TYPE_60FPS</span></a>              5

/*  Flags  */
#define <a class="reference internal" href="buffer.html#timecode-flags"><span class="std std-ref">V4L2_TC_FLAG_DROPFRAME</span></a>          0x0001 /* &quot;drop-frame&quot; mode */
#define <a class="reference internal" href="buffer.html#timecode-flags"><span class="std std-ref">V4L2_TC_FLAG_COLORFRAME</span></a>         0x0002
#define <a class="reference internal" href="buffer.html#timecode-flags"><span class="std std-ref">V4L2_TC_USERBITS_field</span></a>          0x000C
#define <a class="reference internal" href="buffer.html#timecode-flags"><span class="std std-ref">V4L2_TC_USERBITS_USERDEFINED</span></a>    0x0000
#define <a class="reference internal" href="buffer.html#timecode-flags"><span class="std std-ref">V4L2_TC_USERBITS_8BITCHARS</span></a>      0x0008
/* The above is based on SMPTE timecodes */

struct v4l2_jpegcompression {
        int quality;

        int  APPn;              /* Number of APP segment to be written,
                                 * must be 0..15 */
        int  APP_len;           /* Length of data in JPEG APPn segment */
        char APP_data[60];      /* Data in the JPEG APPn segment. */

        int  COM_len;           /* Length of data in JPEG COM segment */
        char COM_data[60];      /* Data in JPEG COM segment */

        __u32 jpeg_markers;     /* Which markers should go into the JPEG
                                 * output. Unless you exactly know what
                                 * you do, leave them untouched.
                                 * Including less markers will make the
                                 * resulting code smaller, but there will
                                 * be fewer applications which can read it.
                                 * The presence of the APP and COM marker
                                 * is influenced by APP_len and COM_len
                                 * ONLY, not by this property! */

#define <a class="reference internal" href="vidioc-g-jpegcomp.html#jpeg-markers"><span class="std std-ref">V4L2_JPEG_MARKER_DHT</span></a> (1&lt;&lt;3)    /* Define Huffman Tables */
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#jpeg-markers"><span class="std std-ref">V4L2_JPEG_MARKER_DQT</span></a> (1&lt;&lt;4)    /* Define Quantization Tables */
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#jpeg-markers"><span class="std std-ref">V4L2_JPEG_MARKER_DRI</span></a> (1&lt;&lt;5)    /* Define Restart Interval */
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#jpeg-markers"><span class="std std-ref">V4L2_JPEG_MARKER_COM</span></a> (1&lt;&lt;6)    /* Comment segment */
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#jpeg-markers"><span class="std std-ref">V4L2_JPEG_MARKER_APP</span></a> (1&lt;&lt;7)    /* App segment, driver will
                                        * always use APP0 */
};

/*
 *      M E M O R Y - M A P P I N G   B U F F E R S
 */

#ifdef __KERNEL__
/*
 * This corresponds to the user space version of timeval
 * for 64-bit time_t. sparc64 is different from everyone
 * else, using the microseconds in the wrong half of the
 * second 64-bit word.
 */
struct __kernel_v4l2_timeval {
        long long       tv_sec;
#if defined(__sparc__) &amp;&amp; defined(__arch64__)
        int             tv_usec;
        int             __pad;
#else
        long long       tv_usec;
#endif
};
#endif

struct v4l2_requestbuffers {
        __u32                   count;
        __u32                   type;           /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        __u32                   memory;         /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_memory</span></code> */
        __u32                   capabilities;
        __u8                    flags;
        __u8                    reserved[3];
};

#define <a class="reference internal" href="buffer.html#v4l2-memory-flag-non-coherent"><span class="std std-ref">V4L2_MEMORY_FLAG_NON_COHERENT</span></a>                   (1 &lt;&lt; 0)

/* capabilities for struct v4l2_requestbuffers and v4l2_create_buffers */
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-mmap"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_MMAP</span></a>                      (1 &lt;&lt; 0)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-userptr"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_USERPTR</span></a>                   (1 &lt;&lt; 1)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-dmabuf"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_DMABUF</span></a>                    (1 &lt;&lt; 2)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-requests"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_REQUESTS</span></a>                  (1 &lt;&lt; 3)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-orphaned-bufs"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS</span></a>             (1 &lt;&lt; 4)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-m2m-hold-capture-buf"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF</span></a>      (1 &lt;&lt; 5)
#define <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-mmap-cache-hints"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS</span></a>          (1 &lt;&lt; 6)

/**
 * struct v4l2_plane - plane info for multi-planar buffers
 * &#64;bytesused:          number of bytes occupied by data in the plane (payload)
 * &#64;length:             size of this plane (NOT the payload) in bytes
 * &#64;mem_offset:         when memory in the associated struct v4l2_buffer is
 *                      <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_MMAP</span></code>, equals the offset from the start of
 *                      the device memory for this plane (or is a &quot;cookie&quot; that
 *                      should be passed to mmap() called on the video node)
 * &#64;userptr:            when memory is <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_USERPTR</span></code>, a userspace pointer
 *                      pointing to this plane
 * &#64;fd:                 when memory is <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_DMABUF</span></code>, a userspace file
 *                      descriptor associated with this plane
 * &#64;m:                  union of &#64;mem_offset, &#64;userptr and &#64;fd
 * &#64;data_offset:        offset in the plane to the start of data; usually 0,
 *                      unless there is a header in front of the data
 * &#64;reserved:           drivers and applications must zero this array
 *
 * Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer
 * with two planes can have one plane for Y, and another for interleaved CbCr
 * components. Each plane can reside in a separate memory buffer, or even in
 * a completely separate memory node (e.g. in embedded devices).
 */
struct v4l2_plane {
        __u32                   bytesused;
        __u32                   length;
        union {
                __u32           mem_offset;
                unsigned long   userptr;
                __s32           fd;
        } m;
        __u32                   data_offset;
        __u32                   reserved[11];
};

/**
 * struct v4l2_buffer - video buffer info
 * &#64;index:      id number of the buffer
 * &#64;type:       enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code>; buffer type (type == *_MPLANE for
 *              multiplanar buffers);
 * &#64;bytesused:  number of bytes occupied by data in the buffer (payload);
 *              unused (set to 0) for multiplanar buffers
 * &#64;flags:      buffer informational flags
 * &#64;field:      enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a>; field order of the image in the buffer
 * &#64;timestamp:  frame timestamp
 * &#64;timecode:   frame timecode
 * &#64;sequence:   sequence count of this frame
 * &#64;memory:     enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_memory</span></code>; the method, in which the actual video data is
 *              passed
 * &#64;offset:     for non-multiplanar buffers with memory == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_MMAP</span></code>;
 *              offset from the start of the device memory for this plane,
 *              (or a &quot;cookie&quot; that should be passed to mmap() as offset)
 * &#64;userptr:    for non-multiplanar buffers with memory == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_USERPTR</span></code>;
 *              a userspace pointer pointing to this buffer
 * &#64;fd:         for non-multiplanar buffers with memory == <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_MEMORY_DMABUF</span></code>;
 *              a userspace file descriptor associated with this buffer
 * &#64;planes:     for multiplanar buffers; userspace pointer to the array of plane
 *              info structs for this buffer
 * &#64;m:          union of &#64;offset, &#64;userptr, &#64;planes and &#64;fd
 * &#64;length:     size in bytes of the buffer (NOT its payload) for single-plane
 *              buffers (when type != *_MPLANE); number of elements in the
 *              planes array for multi-plane buffers
 * &#64;reserved2:  drivers and applications must zero this field
 * &#64;request_fd: fd of the request that this buffer should use
 * &#64;reserved:   for backwards compatibility with applications that do not know
 *              about &#64;request_fd
 *
 * Contains data exchanged by application and driver using one of the Streaming
 * I/O methods.
 */
struct v4l2_buffer {
        __u32                   index;
        __u32                   type;
        __u32                   bytesused;
        __u32                   flags;
        __u32                   field;
#ifdef __KERNEL__
        struct __kernel_v4l2_timeval timestamp;
#else
        struct timeval          timestamp;
#endif
        struct v4l2_timecode    timecode;
        __u32                   sequence;

        /* memory location */
        __u32                   memory;
        union {
                __u32           offset;
                unsigned long   userptr;
                struct v4l2_plane *planes;
                __s32           fd;
        } m;
        __u32                   length;
        __u32                   reserved2;
        union {
                __s32           request_fd;
                __u32           reserved;
        };
};

#ifndef __KERNEL__
/**
 * v4l2_timeval_to_ns - Convert timeval to nanoseconds
 * &#64;tv:         pointer to the timeval variable to be converted
 *
 * Returns the scalar nanosecond representation of the timeval
 * parameter.
 */
static inline __u64 v4l2_timeval_to_ns(const struct timeval *tv)
{
        return (__u64)tv-&gt;tv_sec * 1000000000ULL + tv-&gt;tv_usec * 1000;
}
#endif

/*  Flags for 'flags' field */
/* Buffer is mapped (flag) */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-mapped"><span class="std std-ref">V4L2_BUF_FLAG_MAPPED</span></a>                    0x00000001
/* Buffer is queued for processing */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-queued"><span class="std std-ref">V4L2_BUF_FLAG_QUEUED</span></a>                    0x00000002
/* Buffer is ready */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-done"><span class="std std-ref">V4L2_BUF_FLAG_DONE</span></a>                      0x00000004
/* Image is a keyframe (I-frame) */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-keyframe"><span class="std std-ref">V4L2_BUF_FLAG_KEYFRAME</span></a>                  0x00000008
/* Image is a P-frame */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-pframe"><span class="std std-ref">V4L2_BUF_FLAG_PFRAME</span></a>                    0x00000010
/* Image is a B-frame */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-bframe"><span class="std std-ref">V4L2_BUF_FLAG_BFRAME</span></a>                    0x00000020
/* Buffer is ready, but the data contained within is corrupted. */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-error"><span class="std std-ref">V4L2_BUF_FLAG_ERROR</span></a>                     0x00000040
/* Buffer is added to an unqueued request */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-in-request"><span class="std std-ref">V4L2_BUF_FLAG_IN_REQUEST</span></a>                0x00000080
/* timecode field is valid */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-timecode"><span class="std std-ref">V4L2_BUF_FLAG_TIMECODE</span></a>                  0x00000100
/* Don't return the capture buffer until OUTPUT timestamp changes */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-m2m-hold-capture-buf"><span class="std std-ref">V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF</span></a>      0x00000200
/* Buffer is prepared for queuing */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-prepared"><span class="std std-ref">V4L2_BUF_FLAG_PREPARED</span></a>                  0x00000400
/* Cache handling flags */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-no-cache-invalidate"><span class="std std-ref">V4L2_BUF_FLAG_NO_CACHE_INVALIDATE</span></a>       0x00000800
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-no-cache-clean"><span class="std std-ref">V4L2_BUF_FLAG_NO_CACHE_CLEAN</span></a>            0x00001000
/* Timestamp type */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-timestamp-mask"><span class="std std-ref">V4L2_BUF_FLAG_TIMESTAMP_MASK</span></a>            0x0000e000
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-timestamp-unknown"><span class="std std-ref">V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN</span></a>         0x00000000
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-timestamp-monotonic"><span class="std std-ref">V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC</span></a>       0x00002000
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-timestamp-copy"><span class="std std-ref">V4L2_BUF_FLAG_TIMESTAMP_COPY</span></a>            0x00004000
/* Timestamp sources. */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-tstamp-src-mask"><span class="std std-ref">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</span></a>           0x00070000
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-tstamp-src-eof"><span class="std std-ref">V4L2_BUF_FLAG_TSTAMP_SRC_EOF</span></a>            0x00000000
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-tstamp-src-soe"><span class="std std-ref">V4L2_BUF_FLAG_TSTAMP_SRC_SOE</span></a>            0x00010000
/* mem2mem encoder/decoder */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-last"><span class="std std-ref">V4L2_BUF_FLAG_LAST</span></a>                      0x00100000
/* request_fd is valid */
#define <a class="reference internal" href="buffer.html#v4l2-buf-flag-request-fd"><span class="std std-ref">V4L2_BUF_FLAG_REQUEST_FD</span></a>                0x00800000

/**
 * struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
 *
 * &#64;index:      id number of the buffer
 * &#64;type:       enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code>; buffer type (type == *_MPLANE for
 *              multiplanar buffers);
 * &#64;plane:      index of the plane to be exported, 0 for single plane queues
 * &#64;flags:      flags for newly created file, currently only O_CLOEXEC is
 *              supported, refer to manual of open syscall for more details
 * &#64;fd:         file descriptor associated with DMABUF (set by driver)
 * &#64;reserved:   drivers and applications must zero this array
 *
 * Contains data used for exporting a video buffer as DMABUF file descriptor.
 * The buffer is identified by a 'cookie' returned by <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">VIDIOC_QUERYBUF</span></a>
 * (identical to the cookie used to mmap() the buffer to userspace). All
 * reserved fields must be set to zero. The field reserved0 is expected to
 * become a structure 'type' allowing an alternative layout of the structure
 * content. Therefore this field should not be used for any other extensions.
 */
struct v4l2_exportbuffer {
        __u32           type; /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        __u32           index;
        __u32           plane;
        __u32           flags;
        __s32           fd;
        __u32           reserved[11];
};

/*
 *      O V E R L A Y   P R E V I E W
 */
struct v4l2_framebuffer {
        __u32                   capability;
        __u32                   flags;
/* FIXME: in theory we should pass something like PCI device + memory
 * region + offset instead of some physical address */
        void                    *base;
        struct {
                __u32           width;
                __u32           height;
                __u32           pixelformat;
                __u32           field;          /* enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a> */
                __u32           bytesperline;   /* for padding, zero if unused */
                __u32           sizeimage;
                __u32           colorspace;     /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_colorspace</span></code> */
                __u32           priv;           /* reserved field, set to 0 */
        } fmt;
};
/*  Flags for the 'capability' field. Read only */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_EXTERNOVERLAY</span></a>     0x0001
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_CHROMAKEY</span></a>         0x0002
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_LIST_CLIPPING</span></a>     0x0004
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_BITMAP_CLIPPING</span></a>   0x0008
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_LOCAL_ALPHA</span></a>       0x0010
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_GLOBAL_ALPHA</span></a>      0x0020
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_LOCAL_INV_ALPHA</span></a>   0x0040
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_FBUF_CAP_SRC_CHROMAKEY</span></a>     0x0080
/*  Flags for the 'flags' field. */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_PRIMARY</span></a>          0x0001
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_OVERLAY</span></a>          0x0002
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_CHROMAKEY</span></a>        0x0004
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_LOCAL_ALPHA</span></a>      0x0008
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_GLOBAL_ALPHA</span></a>     0x0010
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_LOCAL_INV_ALPHA</span></a>  0x0020
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-flags"><span class="std std-ref">V4L2_FBUF_FLAG_SRC_CHROMAKEY</span></a>    0x0040

struct v4l2_clip {
        struct v4l2_rect        c;
        struct v4l2_clip        __user *next;
};

struct v4l2_window {
        struct v4l2_rect        w;
        __u32                   field;   /* enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a> */
        __u32                   chromakey;
        struct v4l2_clip        *clips;
        __u32                   clipcount;
        void                    __user *bitmap;
        __u8                    global_alpha;
};

/*
 *      C A P T U R E   P A R A M E T E R S
 */
struct v4l2_captureparm {
        __u32              capability;    /*  Supported modes */
        __u32              capturemode;   /*  Current mode */
        struct v4l2_fract  timeperframe;  /*  Time per frame in seconds */
        __u32              extendedmode;  /*  Driver-specific extensions */
        __u32              readbuffers;   /*  # of buffers for read */
        __u32              reserved[4];
};

/*  Flags for 'capability' and 'capturemode' fields */
#define <a class="reference internal" href="vidioc-g-parm.html#parm-flags"><span class="std std-ref">V4L2_MODE_HIGHQUALITY</span></a>   0x0001  /*  High quality imaging mode */
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CAP_TIMEPERFRAME</span></code>   0x1000  /*  timeperframe field is supported */

struct v4l2_outputparm {
        __u32              capability;   /*  Supported modes */
        __u32              outputmode;   /*  Current mode */
        struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
        __u32              extendedmode; /*  Driver-specific extensions */
        __u32              writebuffers; /*  # of buffers for write */
        __u32              reserved[4];
};

/*
 *      I N P U T   I M A G E   C R O P P I N G
 */
struct v4l2_cropcap {
        __u32                   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        struct v4l2_rect        bounds;
        struct v4l2_rect        defrect;
        struct v4l2_fract       pixelaspect;
};

struct v4l2_crop {
        __u32                   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        struct v4l2_rect        c;
};

/**
 * struct v4l2_selection - selection info
 * &#64;type:       buffer type (do not use *_MPLANE types)
 * &#64;target:     Selection target, used to choose one of possible rectangles;
 *              defined in v4l2-common.h; V4L2_SEL_TGT_* .
 * &#64;flags:      constraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.
 * &#64;r:          coordinates of selection window
 * &#64;reserved:   for future use, rounds structure size to 64 bytes, set to zero
 *
 * Hardware may use multiple helper windows to process a video stream.
 * The structure is used to exchange this selection areas between
 * an application and a driver.
 */
struct v4l2_selection {
        __u32                   type;
        __u32                   target;
        __u32                   flags;
        struct v4l2_rect        r;
        __u32                   reserved[9];
};

/*
 *      A N A L O G   V I D E O   S T A N D A R D
 */

typedef __u64 v4l2_std_id;

/*
 * Attention: Keep the V4L2_STD_* bit definitions in sync with
 * include/dt-bindings/display/sdtv-standards.h SDTV_STD_* bit definitions.
 */
/* one bit for each */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B</span></a>          ((v4l2_std_id)0x00000001)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B1</span></a>         ((v4l2_std_id)0x00000002)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_G</span></a>          ((v4l2_std_id)0x00000004)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_H</span></a>          ((v4l2_std_id)0x00000008)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_I</span></a>          ((v4l2_std_id)0x00000010)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_D</span></a>          ((v4l2_std_id)0x00000020)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_D1</span></a>         ((v4l2_std_id)0x00000040)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_K</span></a>          ((v4l2_std_id)0x00000080)

#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_M</span></a>          ((v4l2_std_id)0x00000100)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_N</span></a>          ((v4l2_std_id)0x00000200)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_Nc</span></a>         ((v4l2_std_id)0x00000400)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_60</span></a>         ((v4l2_std_id)0x00000800)

#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M</span></a>         ((v4l2_std_id)0x00001000)       /* BTSC */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M_JP</span></a>      ((v4l2_std_id)0x00002000)       /* EIA-J */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_443</span></a>       ((v4l2_std_id)0x00004000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M_KR</span></a>      ((v4l2_std_id)0x00008000)       /* FM A2 */

#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_B</span></a>        ((v4l2_std_id)0x00010000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_D</span></a>        ((v4l2_std_id)0x00020000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_G</span></a>        ((v4l2_std_id)0x00040000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_H</span></a>        ((v4l2_std_id)0x00080000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_K</span></a>        ((v4l2_std_id)0x00100000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_K1</span></a>       ((v4l2_std_id)0x00200000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_L</span></a>        ((v4l2_std_id)0x00400000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_LC</span></a>       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC_8_VSB</span></a>     ((v4l2_std_id)0x01000000)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC_16_VSB</span></a>    ((v4l2_std_id)0x02000000)

/* FIXME:
   Although std_id is 64 bits, there is an issue on PPC32 architecture that
   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
   this value to 32 bits.
   As, currently, the max value is for <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC_16_VSB</span></a> (30 bits wide),
   it should work fine. However, if needed to add more than two standards,
   v4l2-common.c should be fixed.
 */

/*
 * Some macros to merge video standards in order to make live easier for the
 * drivers and V4L2 applications
 */

/*
 * &quot;Common&quot; NTSC/M - It should be noticed that <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_443</span></a> is
 * Missing here.
 */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC</span></a>           (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M_JP</span></a>     |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M_KR</span></a>)
/* Secam macros */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_DK</span></a>       (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_D</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_K</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_K1</span></a>)
/* All Secam Standards */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM</span></a>          (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_B</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_G</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_H</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_DK</span></a>      |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_L</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_LC</span></a>)
/* PAL macros */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_BG</span></a>         (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B1</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_G</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_DK</span></a>         (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_D</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_D1</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_K</span></a>)
/*
 * &quot;Common&quot; PAL - This macro is there to be compatible with the old
 * V4L1 concept of &quot;PAL&quot;: /BGDKHI.
 * Several PAL standards are missing here: /M, /N and /Nc
 */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL</span></a>            (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_BG</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_DK</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_H</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_I</span></a>)
/* Chroma &quot;agnostic&quot; standards */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_B</span></a>              (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_B1</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_B</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_G</span></a>              (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_G</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_G</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_H</span></a>              (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_H</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_H</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_L</span></a>              (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_L</span></a>       |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_LC</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_GH</span></a>             (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_G</span></a>             |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_H</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_DK</span></a>             (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_DK</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM_DK</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_BG</span></a>             (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_B</span></a>             |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_G</span></a>)
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_MN</span></a>             (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_M</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_N</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_Nc</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC</span></a>)

/* Standards where MTS/BTSC stereo could be found */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_MTS</span></a>            (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_M</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_M</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_N</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_Nc</span></a>)

/* Standards for Countries with 60Hz Line frequency */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_525_60</span></a>         (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_M</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_60</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC</span></a>          |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_NTSC_443</span></a>)
/* Standards for Countries with 50Hz Line frequency */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_625_50</span></a>         (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL</span></a>           |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_N</span></a>         |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_PAL_Nc</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_SECAM</span></a>)

#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC</span></a>           (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC_8_VSB</span></a>    |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ATSC_16_VSB</span></a>)
/* Macros with none and all analog standards */
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_UNKNOWN</span></a>        0
#define <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_ALL</span></a>            (<a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_525_60</span></a>        |\
                                 <a class="reference internal" href="vidioc-enumstd.html#v4l2-std-id"><span class="std std-ref">V4L2_STD_625_50</span></a>)

struct v4l2_standard {
        __u32                index;
        v4l2_std_id          id;
        __u8                 name[24];
        struct v4l2_fract    frameperiod; /* Frames, not fields */
        __u32                framelines;
        __u32                reserved[4];
};

/*
 *      D V     B T     T I M I N G S
 */

/** struct v4l2_bt_timings - BT.656/BT.1120 timing data
 * &#64;width:      total width of the active video in pixels
 * &#64;height:     total height of the active video in lines
 * &#64;interlaced: Interlaced or progressive
 * &#64;polarities: Positive or negative polarities
 * &#64;pixelclock: Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * &#64;hfrontporch:Horizontal front porch in pixels
 * &#64;hsync:      Horizontal Sync length in pixels
 * &#64;hbackporch: Horizontal back porch in pixels
 * &#64;vfrontporch:Vertical front porch in lines
 * &#64;vsync:      Vertical Sync length in lines
 * &#64;vbackporch: Vertical back porch in lines
 * &#64;il_vfrontporch:Vertical front porch for the even field
 *              (aka field 2) of interlaced field formats
 * &#64;il_vsync:   Vertical Sync length for the even field
 *              (aka field 2) of interlaced field formats
 * &#64;il_vbackporch:Vertical back porch for the even field
 *              (aka field 2) of interlaced field formats
 * &#64;standards:  Standards the timing belongs to
 * &#64;flags:      Flags
 * &#64;picture_aspect: The picture aspect ratio (hor/vert).
 * &#64;cea861_vic: VIC code as per the CEA-861 standard.
 * &#64;hdmi_vic:   VIC code as per the HDMI standard.
 * &#64;reserved:   Reserved fields, must be zeroed.
 *
 * A note regarding vertical interlaced timings: height refers to the total
 * height of the active video frame (= two fields). The blanking timings refer
 * to the blanking of each field. So the height of the total frame is
 * calculated as follows:
 *
 * tot_height = height + vfrontporch + vsync + vbackporch +
 *                       il_vfrontporch + il_vsync + il_vbackporch
 *
 * The active height of each field is height / 2.
 */
struct v4l2_bt_timings {
        __u32   width;
        __u32   height;
        __u32   interlaced;
        __u32   polarities;
        __u64   pixelclock;
        __u32   hfrontporch;
        __u32   hsync;
        __u32   hbackporch;
        __u32   vfrontporch;
        __u32   vsync;
        __u32   vbackporch;
        __u32   il_vfrontporch;
        __u32   il_vsync;
        __u32   il_vbackporch;
        __u32   standards;
        __u32   flags;
        struct v4l2_fract picture_aspect;
        __u8    cea861_vic;
        __u8    hdmi_vic;
        __u8    reserved[46];
} __attribute__ ((packed));

/* Interlaced or progressive format */
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_DV_PROGRESSIVE</span></code>     0
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_DV_INTERLACED</span></code>      1

/* Polarities. If bit is not set, it is assumed to be negative polarity */
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_DV_VSYNC_POS_POL</span></code>   0x00000001
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_DV_HSYNC_POS_POL</span></code>   0x00000002

/* Timings standards */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_BT_STD_CEA861</span></a>   (1 &lt;&lt; 0)  /* CEA-861 Digital TV Profile */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_BT_STD_DMT</span></a>      (1 &lt;&lt; 1)  /* VESA Discrete Monitor Timings */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_BT_STD_CVT</span></a>      (1 &lt;&lt; 2)  /* VESA Coordinated Video Timings */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_BT_STD_GTF</span></a>      (1 &lt;&lt; 3)  /* VESA Generalized Timings Formula */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_BT_STD_SDI</span></a>      (1 &lt;&lt; 4)  /* SDI Timings */

/* Flags */

/*
 * CVT/GTF specific: timing uses reduced blanking (CVT) or the 'Secondary
 * GTF' curve (GTF). In both cases the horizontal and/or vertical blanking
 * intervals are reduced, allowing a higher resolution over the same
 * bandwidth. This is a read-only flag.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_REDUCED_BLANKING</span></a>             (1 &lt;&lt; 0)
/*
 * CEA-861 specific: set for CEA-861 formats with a framerate of a multiple
 * of six. These formats can be optionally played at 1 / 1.001 speed.
 * This is a read-only flag.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_CAN_REDUCE_FPS</span></a>               (1 &lt;&lt; 1)
/*
 * CEA-861 specific: only valid for video transmitters, the flag is cleared
 * by receivers.
 * If the framerate of the format is a multiple of six, then the pixelclock
 * used to set up the transmitter is divided by 1.001 to make it compatible
 * with 60 Hz based standards such as NTSC and PAL-M that use a framerate of
 * 29.97 Hz. Otherwise this flag is cleared. If the transmitter can't generate
 * such frequencies, then the flag will also be cleared.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_REDUCED_FPS</span></a>                  (1 &lt;&lt; 2)
/*
 * Specific to interlaced formats: if set, then field 1 is really one half-line
 * longer and field 2 is really one half-line shorter, so each field has
 * exactly the same number of half-lines. Whether half-lines can be detected
 * or used depends on the hardware.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_HALF_LINE</span></a>                    (1 &lt;&lt; 3)
/*
 * If set, then this is a Consumer Electronics (CE) video format. Such formats
 * differ from other formats (commonly called IT formats) in that if RGB
 * encoding is used then by default the RGB values use limited range (i.e.
 * use the range 16-235) as opposed to 0-255. All formats defined in CEA-861
 * except for the 640x480 format are CE formats.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_IS_CE_VIDEO</span></a>                  (1 &lt;&lt; 4)
/* Some formats like SMPTE-125M have an interlaced signal with a odd
 * total height. For these formats, if this flag is set, the first
 * field has the extra line. If not, it is the second field.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE</span></a>       (1 &lt;&lt; 5)
/*
 * If set, then the picture_aspect field is valid. Otherwise assume that the
 * pixels are square, so the picture aspect ratio is the same as the width to
 * height ratio.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_HAS_PICTURE_ASPECT</span></a>           (1 &lt;&lt; 6)
/*
 * If set, then the cea861_vic field is valid and contains the Video
 * Identification Code as per the CEA-861 standard.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_HAS_CEA861_VIC</span></a>               (1 &lt;&lt; 7)
/*
 * If set, then the hdmi_vic field is valid and contains the Video
 * Identification Code as per the HDMI standard (HDMI Vendor Specific
 * InfoFrame).
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_HAS_HDMI_VIC</span></a>                 (1 &lt;&lt; 8)
/*
 * CEA-861 specific: only valid for video receivers.
 * If set, then HW can detect the difference between regular FPS and
 * 1000/1001 FPS. Note: This flag is only valid for HDMI VIC codes with
 * the <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_CAN_REDUCE_FPS</span></a> flag set.
 */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-bt-standards"><span class="std std-ref">V4L2_DV_FL_CAN_DETECT_REDUCED_FPS</span></a>       (1 &lt;&lt; 9)

/* A few useful defines to calculate the total blanking and frame sizes */
#define V4L2_DV_BT_BLANKING_WIDTH(bt) \
        ((bt)-&gt;hfrontporch + (bt)-&gt;hsync + (bt)-&gt;hbackporch)
#define V4L2_DV_BT_FRAME_WIDTH(bt) \
        ((bt)-&gt;width + V4L2_DV_BT_BLANKING_WIDTH(bt))
#define V4L2_DV_BT_BLANKING_HEIGHT(bt) \
        ((bt)-&gt;vfrontporch + (bt)-&gt;vsync + (bt)-&gt;vbackporch + \
         ((bt)-&gt;interlaced ? \
          ((bt)-&gt;il_vfrontporch + (bt)-&gt;il_vsync + (bt)-&gt;il_vbackporch) : 0))
#define V4L2_DV_BT_FRAME_HEIGHT(bt) \
        ((bt)-&gt;height + V4L2_DV_BT_BLANKING_HEIGHT(bt))

/** struct v4l2_dv_timings - DV timings
 * &#64;type:       the type of the timings
 * &#64;bt: BT656/1120 timings
 */
struct v4l2_dv_timings {
        __u32 type;
        union {
                struct v4l2_bt_timings  bt;
                __u32   reserved[32];
        };
} __attribute__ ((packed));

/* Values for the type field */
#define <a class="reference internal" href="vidioc-g-dv-timings.html#dv-timing-types"><span class="std std-ref">V4L2_DV_BT_656_1120</span></a>     0       /* BT.656/1120 timing type */

/** struct v4l2_enum_dv_timings - DV timings enumeration
 * &#64;index:      enumeration index
 * &#64;pad:        the pad number for which to enumerate timings (used with
 *              v4l-subdev nodes only)
 * &#64;reserved:   must be zeroed
 * &#64;timings:    the timings for the given index
 */
struct v4l2_enum_dv_timings {
        __u32 index;
        __u32 pad;
        __u32 reserved[2];
        struct v4l2_dv_timings timings;
};

/** struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities
 * &#64;min_width:          width in pixels
 * &#64;max_width:          width in pixels
 * &#64;min_height:         height in lines
 * &#64;max_height:         height in lines
 * &#64;min_pixelclock:     Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * &#64;max_pixelclock:     Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * &#64;standards:          Supported standards
 * &#64;capabilities:       Supported capabilities
 * &#64;reserved:           Must be zeroed
 */
struct v4l2_bt_timings_cap {
        __u32   min_width;
        __u32   max_width;
        __u32   min_height;
        __u32   max_height;
        __u64   min_pixelclock;
        __u64   max_pixelclock;
        __u32   standards;
        __u32   capabilities;
        __u32   reserved[16];
} __attribute__ ((packed));

/* Supports interlaced formats */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_DV_BT_CAP_INTERLACED</span></a>       (1 &lt;&lt; 0)
/* Supports progressive formats */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_DV_BT_CAP_PROGRESSIVE</span></a>      (1 &lt;&lt; 1)
/* Supports CVT/GTF reduced blanking */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_DV_BT_CAP_REDUCED_BLANKING</span></a> (1 &lt;&lt; 2)
/* Supports custom formats */
#define <a class="reference internal" href="vidioc-g-fbuf.html#framebuffer-cap"><span class="std std-ref">V4L2_DV_BT_CAP_CUSTOM</span></a>           (1 &lt;&lt; 3)

/** struct v4l2_dv_timings_cap - DV timings capabilities
 * &#64;type:       the type of the timings (same as in struct v4l2_dv_timings)
 * &#64;pad:        the pad number for which to query capabilities (used with
 *              v4l-subdev nodes only)
 * &#64;bt:         the BT656/1120 timings capabilities
 */
struct v4l2_dv_timings_cap {
        __u32 type;
        __u32 pad;
        __u32 reserved[2];
        union {
                struct v4l2_bt_timings_cap bt;
                __u32 raw_data[32];
        };
};

/*
 *      V I D E O   I N P U T S
 */
struct v4l2_input {
        __u32        index;             /*  Which input */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of input */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        tuner;             /*  enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        v4l2_std_id  std;
        __u32        status;
        __u32        capabilities;
        __u32        reserved[3];
};

/*  Values for the 'type' field */
#define <a class="reference internal" href="vidioc-enuminput.html#input-type"><span class="std std-ref">V4L2_INPUT_TYPE_TUNER</span></a>           1
#define <a class="reference internal" href="vidioc-enuminput.html#input-type"><span class="std std-ref">V4L2_INPUT_TYPE_CAMERA</span></a>          2
#define <a class="reference internal" href="vidioc-enuminput.html#input-type"><span class="std std-ref">V4L2_INPUT_TYPE_TOUCH</span></a>           3

/* field 'status' - general */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_POWER</span></a>    0x00000001  /* Attached device is off */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_SIGNAL</span></a>   0x00000002
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_COLOR</span></a>    0x00000004

/* field 'status' - sensor orientation */
/* If sensor is mounted upside down set both bits */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_HFLIP</span></a>       0x00000010 /* Frames are flipped horizontally */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_VFLIP</span></a>       0x00000020 /* Frames are flipped vertically */

/* field 'status' - analog */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_H_LOCK</span></a>   0x00000100  /* No horizontal sync lock */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_COLOR_KILL</span></a>  0x00000200  /* Color killer is active */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_V_LOCK</span></a>   0x00000400  /* No vertical sync lock */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_STD_LOCK</span></a> 0x00000800  /* No standard format lock */

/* field 'status' - digital */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_SYNC</span></a>     0x00010000  /* No synchronization lock */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_EQU</span></a>      0x00020000  /* No equalizer lock */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_CARRIER</span></a>  0x00040000  /* Carrier recovery failed */

/* field 'status' - VCR and set-top box */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_MACROVISION</span></a> 0x01000000  /* Macrovision detected */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_NO_ACCESS</span></a>   0x02000000  /* Conditional access denied */
#define <a class="reference internal" href="vidioc-enuminput.html#input-status"><span class="std std-ref">V4L2_IN_ST_VTR</span></a>         0x04000000  /* VTR time constant */

/* capabilities flags */
#define <a class="reference internal" href="vidioc-enuminput.html#input-capabilities"><span class="std std-ref">V4L2_IN_CAP_DV_TIMINGS</span></a>          0x00000002 /* Supports S_DV_TIMINGS */
#define V4L2_IN_CAP_CUSTOM_TIMINGS      <a class="reference internal" href="vidioc-enuminput.html#input-capabilities"><span class="std std-ref">V4L2_IN_CAP_DV_TIMINGS</span></a> /* For compatibility */
#define <a class="reference internal" href="vidioc-enuminput.html#input-capabilities"><span class="std std-ref">V4L2_IN_CAP_STD</span></a>                 0x00000004 /* Supports S_STD */
#define <a class="reference internal" href="vidioc-enuminput.html#input-capabilities"><span class="std std-ref">V4L2_IN_CAP_NATIVE_SIZE</span></a>         0x00000008 /* Supports setting native size */

/*
 *      V I D E O   O U T P U T S
 */
struct v4l2_output {
        __u32        index;             /*  Which output */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of output */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        modulator;         /*  Associated modulator */
        v4l2_std_id  std;
        __u32        capabilities;
        __u32        reserved[3];
};
/*  Values for the 'type' field */
#define <a class="reference internal" href="vidioc-enumoutput.html#output-type"><span class="std std-ref">V4L2_OUTPUT_TYPE_MODULATOR</span></a>              1
#define <a class="reference internal" href="vidioc-enumoutput.html#output-type"><span class="std std-ref">V4L2_OUTPUT_TYPE_ANALOG</span></a>                 2
#define <a class="reference internal" href="vidioc-enumoutput.html#output-type"><span class="std std-ref">V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY</span></a>       3

/* capabilities flags */
#define <a class="reference internal" href="vidioc-enumoutput.html#output-capabilities"><span class="std std-ref">V4L2_OUT_CAP_DV_TIMINGS</span></a>         0x00000002 /* Supports S_DV_TIMINGS */
#define V4L2_OUT_CAP_CUSTOM_TIMINGS     <a class="reference internal" href="vidioc-enumoutput.html#output-capabilities"><span class="std std-ref">V4L2_OUT_CAP_DV_TIMINGS</span></a> /* For compatibility */
#define <a class="reference internal" href="vidioc-enumoutput.html#output-capabilities"><span class="std std-ref">V4L2_OUT_CAP_STD</span></a>                0x00000004 /* Supports S_STD */
#define <a class="reference internal" href="vidioc-enumoutput.html#output-capabilities"><span class="std std-ref">V4L2_OUT_CAP_NATIVE_SIZE</span></a>        0x00000008 /* Supports setting native size */

/*
 *      C O N T R O L S
 */
struct v4l2_control {
        __u32                id;
        __s32                value;
};

struct v4l2_ext_control {
        __u32 id;
        __u32 size;
        __u32 reserved2[1];
        union {
                __s32 value;
                __s64 value64;
                char __user *string;
                __u8 __user *p_u8;
                __u16 __user *p_u16;
                __u32 __user *p_u32;
                __u32 __user *p_s32;
                __u32 __user *p_s64;
                struct v4l2_area __user *p_area;
                struct v4l2_ctrl_h264_sps __user *p_h264_sps;
                struct v4l2_ctrl_h264_pps *p_h264_pps;
                struct v4l2_ctrl_h264_scaling_matrix __user *p_h264_scaling_matrix;
                struct v4l2_ctrl_h264_pred_weights __user *p_h264_pred_weights;
                struct v4l2_ctrl_h264_slice_params __user *p_h264_slice_params;
                struct v4l2_ctrl_h264_decode_params __user *p_h264_decode_params;
                struct v4l2_ctrl_fwht_params __user *p_fwht_params;
                struct v4l2_ctrl_vp8_frame __user *p_vp8_frame;
                struct v4l2_ctrl_mpeg2_sequence __user *p_mpeg2_sequence;
                struct v4l2_ctrl_mpeg2_picture __user *p_mpeg2_picture;
                struct v4l2_ctrl_mpeg2_quantisation __user *p_mpeg2_quantisation;
                struct v4l2_ctrl_vp9_compressed_hdr __user *p_vp9_compressed_hdr_probs;
                struct v4l2_ctrl_vp9_frame __user *p_vp9_frame;
                struct v4l2_ctrl_hevc_sps __user *p_hevc_sps;
                struct v4l2_ctrl_hevc_pps __user *p_hevc_pps;
                struct v4l2_ctrl_hevc_slice_params __user *p_hevc_slice_params;
                struct v4l2_ctrl_hevc_scaling_matrix __user *p_hevc_scaling_matrix;
                struct v4l2_ctrl_hevc_decode_params __user *p_hevc_decode_params;
                void __user *ptr;
        };
} __attribute__ ((packed));

struct v4l2_ext_controls {
        union {
#ifndef __KERNEL__
                __u32 ctrl_class;
#endif
                __u32 which;
        };
        __u32 count;
        __u32 error_idx;
        __s32 request_fd;
        __u32 reserved[1];
        struct v4l2_ext_control *controls;
};

#define V4L2_CTRL_ID_MASK         (0x0fffffff)
#ifndef __KERNEL__
#define V4L2_CTRL_ID2CLASS(id)    ((id) &amp; 0x0fff0000UL)
#endif
#define V4L2_CTRL_ID2WHICH(id)    ((id) &amp; 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id) (((id) &amp; 0xffff) &gt;= 0x1000)
#define V4L2_CTRL_MAX_DIMS        (4)
#define V4L2_CTRL_WHICH_CUR_VAL   0
#define V4L2_CTRL_WHICH_DEF_VAL   0x0f000000
#define V4L2_CTRL_WHICH_REQUEST_VAL 0x0f010000

enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ctrl_type</span></code> {
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_INTEGER</span></code>       = 1,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_BOOLEAN</span></code>       = 2,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_MENU</span></code>          = 3,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_BUTTON</span></code>        = 4,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_INTEGER64</span></code>     = 5,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_CTRL_CLASS</span></code>    = 6,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_STRING</span></code>        = 7,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_BITMASK</span></code>       = 8,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_INTEGER_MENU</span></code>  = 9,

        /* Compound types are &gt;= 0x0100 */
        <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">V4L2_CTRL_COMPOUND_TYPES</span></a>     = 0x0100,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_U8</span></code>            = 0x0100,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_U16</span></code>           = 0x0101,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_U32</span></code>           = 0x0102,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_AREA</span></code>          = 0x0106,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HDR10_CLL_INFO</span></code>           = 0x0110,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY</span></code>  = 0x0111,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_SPS</span></code>             = 0x0200,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_PPS</span></code>             = 0x0201,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_SCALING_MATRIX</span></code>  = 0x0202,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_SLICE_PARAMS</span></code>    = 0x0203,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_DECODE_PARAMS</span></code>   = 0x0204,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_H264_PRED_WEIGHTS</span></code>    = 0x0205,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_FWHT_PARAMS</span></code>          = 0x0220,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_VP8_FRAME</span></code>            = 0x0240,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_MPEG2_QUANTISATION</span></code>   = 0x0250,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_MPEG2_SEQUENCE</span></code>       = 0x0251,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_MPEG2_PICTURE</span></code>        = 0x0252,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR</span></code>       = 0x0260,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_VP9_FRAME</span></code>                = 0x0261,

        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HEVC_SPS</span></code>                 = 0x0270,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HEVC_PPS</span></code>                 = 0x0271,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS</span></code>        = 0x0272,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX</span></code>      = 0x0273,
        <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS</span></code>       = 0x0274,
};

/*  Used in the <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERYCTRL</span></a> ioctl for querying controls */
struct v4l2_queryctrl {
        __u32                id;
        __u32                type;      /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ctrl_type</span></code> */
        __u8                 name[32];  /* Whatever */
        __s32                minimum;   /* Note signedness */
        __s32                maximum;
        __s32                step;
        __s32                default_value;
        __u32                flags;
        __u32                reserved[2];
};

/*  Used in the <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERY_EXT_CTRL</span></a> ioctl for querying extended controls */
struct v4l2_query_ext_ctrl {
        __u32                id;
        __u32                type;
        char                 name[32];
        __s64                minimum;
        __s64                maximum;
        __u64                step;
        __s64                default_value;
        __u32                flags;
        __u32                elem_size;
        __u32                elems;
        __u32                nr_of_dims;
        __u32                dims[V4L2_CTRL_MAX_DIMS];
        __u32                reserved[32];
};

/*  Used in the <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERYMENU</span></a> ioctl for querying menu items */
struct v4l2_querymenu {
        __u32           id;
        __u32           index;
        union {
                __u8    name[32];       /* Whatever */
                __s64   value;
        };
        __u32           reserved;
} __attribute__ ((packed));

/*  Control flags  */
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_DISABLED</span></a>         0x0001
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_GRABBED</span></a>          0x0002
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_READ_ONLY</span></a>        0x0004
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_UPDATE</span></a>           0x0008
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_INACTIVE</span></a>         0x0010
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_SLIDER</span></a>           0x0020
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_WRITE_ONLY</span></a>       0x0040
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_VOLATILE</span></a>         0x0080
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_HAS_PAYLOAD</span></a>      0x0100
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_EXECUTE_ON_WRITE</span></a> 0x0200
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_MODIFY_LAYOUT</span></a>    0x0400
#define <a class="reference internal" href="vidioc-queryctrl.html#control-flags"><span class="std std-ref">V4L2_CTRL_FLAG_DYNAMIC_ARRAY</span></a>    0x0800

/*  Query flags, to be ORed with the control ID */
#define <a class="reference internal" href="control.html#control"><span class="std std-ref">V4L2_CTRL_FLAG_NEXT_CTRL</span></a>        0x80000000
#define <a class="reference internal" href="control.html#control"><span class="std std-ref">V4L2_CTRL_FLAG_NEXT_COMPOUND</span></a>    0x40000000

/*  User-class control IDs defined by V4L2 */
#define V4L2_CID_MAX_CTRLS              1024
/*  IDs reserved for driver specific controls */
#define <a class="reference internal" href="control.html#control"><span class="std std-ref">V4L2_CID_PRIVATE_BASE</span></a>           0x08000000

/*
 *      T U N I N G
 */
struct v4l2_tuner {
        __u32                   index;
        __u8                    name[32];
        __u32                   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   rxsubchans;
        __u32                   audmode;
        __s32                   signal;
        __s32                   afc;
        __u32                   reserved[4];
};

struct v4l2_modulator {
        __u32                   index;
        __u8                    name[32];
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   txsubchans;
        __u32                   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        __u32                   reserved[3];
};

/*  Flags for the 'capability' field */
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_LOW</span></a>              0x0001
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_NORM</span></a>             0x0002
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_HWSEEK_BOUNDED</span></a>   0x0004
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_HWSEEK_WRAP</span></a>      0x0008
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_STEREO</span></a>           0x0010
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_LANG2</span></a>            0x0020
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_SAP</span></a>              0x0020
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_LANG1</span></a>            0x0040
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_RDS</span></a>              0x0080
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_RDS_BLOCK_IO</span></a>     0x0100
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_RDS_CONTROLS</span></a>     0x0200
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_FREQ_BANDS</span></a>       0x0400
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_HWSEEK_PROG_LIM</span></a>  0x0800
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-capability"><span class="std std-ref">V4L2_TUNER_CAP_1HZ</span></a>              0x1000

/*  Flags for the 'rxsubchans' field */
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_MONO</span></a>             0x0001
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_STEREO</span></a>           0x0002
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_LANG2</span></a>            0x0004
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_SAP</span></a>              0x0004
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_LANG1</span></a>            0x0008
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-rxsubchans"><span class="std std-ref">V4L2_TUNER_SUB_RDS</span></a>              0x0010

/*  Values for the 'audmode' field */
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_MONO</span></a>            0x0000
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_STEREO</span></a>          0x0001
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_LANG2</span></a>           0x0002
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_SAP</span></a>             0x0002
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_LANG1</span></a>           0x0003
#define <a class="reference internal" href="vidioc-g-tuner.html#tuner-audmode"><span class="std std-ref">V4L2_TUNER_MODE_LANG1_LANG2</span></a>     0x0004

struct v4l2_frequency {
        __u32   tuner;
        __u32   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        __u32   frequency;
        __u32   reserved[8];
};

#define <a class="reference internal" href="vidioc-enum-freq-bands.html#band-modulation"><span class="std std-ref">V4L2_BAND_MODULATION_VSB</span></a>        (1 &lt;&lt; 1)
#define <a class="reference internal" href="vidioc-enum-freq-bands.html#band-modulation"><span class="std std-ref">V4L2_BAND_MODULATION_FM</span></a>         (1 &lt;&lt; 2)
#define <a class="reference internal" href="vidioc-enum-freq-bands.html#band-modulation"><span class="std std-ref">V4L2_BAND_MODULATION_AM</span></a>         (1 &lt;&lt; 3)

struct v4l2_frequency_band {
        __u32   tuner;
        __u32   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        __u32   index;
        __u32   capability;
        __u32   rangelow;
        __u32   rangehigh;
        __u32   modulation;
        __u32   reserved[9];
};

struct v4l2_hw_freq_seek {
        __u32   tuner;
        __u32   type;   /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner_type</span></code> */
        __u32   seek_upward;
        __u32   wrap_around;
        __u32   spacing;
        __u32   rangelow;
        __u32   rangehigh;
        __u32   reserved[5];
};

/*
 *      R D S
 */

struct v4l2_rds_data {
        __u8    lsb;
        __u8    msb;
        __u8    block;
} __attribute__ ((packed));

#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_MSK</span></a>       0x7
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_A</span></a>         0
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_B</span></a>         1
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_C</span></a>         2
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_D</span></a>         3
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_C_ALT</span></a>     4
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_INVALID</span></a>   7

#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_CORRECTED</span></a> 0x40
#define <a class="reference internal" href="dev-rds.html#v4l2-rds-block"><span class="std std-ref">V4L2_RDS_BLOCK_ERROR</span></a>     0x80

/*
 *      A U D I O
 */
struct v4l2_audio {
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*  Flags for the 'capability' field */
#define <a class="reference internal" href="vidioc-g-audio.html#audio-capability"><span class="std std-ref">V4L2_AUDCAP_STEREO</span></a>              0x00001
#define <a class="reference internal" href="vidioc-g-audio.html#audio-capability"><span class="std std-ref">V4L2_AUDCAP_AVL</span></a>                 0x00002

/*  Flags for the 'mode' field */
#define <a class="reference internal" href="vidioc-g-audio.html#audio-mode"><span class="std std-ref">V4L2_AUDMODE_AVL</span></a>                0x00001

struct v4l2_audioout {
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*
 *      M P E G   S E R V I C E S
 */
#if 1
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_ENC_IDX_FRAME_I</span></code>    (0)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_ENC_IDX_FRAME_P</span></code>    (1)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_ENC_IDX_FRAME_B</span></code>    (2)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_ENC_IDX_FRAME_MASK</span></code> (0xf)

struct v4l2_enc_idx_entry {
        __u64 offset;
        __u64 pts;
        __u32 length;
        __u32 flags;
        __u32 reserved[2];
};

#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_ENC_IDX_ENTRIES</span></code> (64)
struct v4l2_enc_idx {
        __u32 entries;
        __u32 entries_cap;
        __u32 reserved[4];
        struct v4l2_enc_idx_entry entry[V4L2_ENC_IDX_ENTRIES];
};

#define <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-cmds"><span class="std std-ref">V4L2_ENC_CMD_START</span></a>      (0)
#define <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-cmds"><span class="std std-ref">V4L2_ENC_CMD_STOP</span></a>       (1)
#define <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-cmds"><span class="std std-ref">V4L2_ENC_CMD_PAUSE</span></a>      (2)
#define <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-cmds"><span class="std std-ref">V4L2_ENC_CMD_RESUME</span></a>     (3)

/* Flags for <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-cmds"><span class="std std-ref">V4L2_ENC_CMD_STOP</span></a> */
#define <a class="reference internal" href="vidioc-encoder-cmd.html#encoder-flags"><span class="std std-ref">V4L2_ENC_CMD_STOP_AT_GOP_END</span></a>    (1 &lt;&lt; 0)

struct v4l2_encoder_cmd {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u32 data[8];
                } raw;
        };
};

/* Decoder commands */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_START</span></a>       (0)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_STOP</span></a>        (1)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_PAUSE</span></a>       (2)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_RESUME</span></a>      (3)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_FLUSH</span></a>       (4)

/* Flags for <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_START</span></a> */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_START_MUTE_AUDIO</span></a>   (1 &lt;&lt; 0)

/* Flags for <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_PAUSE</span></a> */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_PAUSE_TO_BLACK</span></a>     (1 &lt;&lt; 0)

/* Flags for <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_STOP</span></a> */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_STOP_TO_BLACK</span></a>      (1 &lt;&lt; 0)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_CMD_STOP_IMMEDIATELY</span></a>   (1 &lt;&lt; 1)

/* Play format requirements (returned by the driver): */

/* The decoder has no special format requirements */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_START_FMT_NONE</span></a>         (0)
/* The decoder requires full GOPs */
#define <a class="reference internal" href="vidioc-decoder-cmd.html#decoder-cmds"><span class="std std-ref">V4L2_DEC_START_FMT_GOP</span></a>          (1)

/* The structure must be zeroed before use by the application
   This ensures it can be extended safely in the future. */
struct v4l2_decoder_cmd {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u64 pts;
                } stop;

                struct {
                        /* 0 or 1000 specifies normal speed,
                           1 specifies forward single stepping,
                           -1 specifies backward single stepping,
                           &gt;1: playback at speed/1000 of the normal speed,
                           &lt;-1: reverse playback at (-speed/1000) of the normal speed. */
                        __s32 speed;
                        __u32 format;
                } start;

                struct {
                        __u32 data[16];
                } raw;
        };
};
#endif

/*
 *      D A T A   S E R V I C E S   ( V B I )
 *
 *      Data services API by Michael Schimek
 */

/* Raw VBI */
struct v4l2_vbi_format {
        __u32   sampling_rate;          /* in 1 Hz */
        __u32   offset;
        __u32   samples_per_line;
        __u32   sample_format;          /* V4L2_PIX_FMT_* */
        __s32   start[2];
        __u32   count[2];
        __u32   flags;                  /* V4L2_VBI_* */
        __u32   reserved[2];            /* must be zero */
};

/*  VBI flags  */
#define <a class="reference internal" href="dev-raw-vbi.html#vbifmt-flags"><span class="std std-ref">V4L2_VBI_UNSYNC</span></a>         (1 &lt;&lt; 0)
#define <a class="reference internal" href="dev-raw-vbi.html#vbifmt-flags"><span class="std std-ref">V4L2_VBI_INTERLACED</span></a>     (1 &lt;&lt; 1)

/* ITU-R start lines for each field */
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_VBI_ITU_525_F1_START</span></code> (1)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_VBI_ITU_525_F2_START</span></code> (264)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_VBI_ITU_625_F1_START</span></code> (1)
#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_VBI_ITU_625_F2_START</span></code> (314)

/* Sliced VBI
 *
 *    This implements is a proposal V4L2 API to allow SLICED VBI
 * required for some hardware encoders. It should change without
 * notice in the definitive implementation.
 */

struct v4l2_sliced_vbi_format {
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   io_size;
        __u32   reserved[2];            /* must be zero */
};

/* Teletext World System Teletext
   (WST), defined on ITU-R BT.653-2 */
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_TELETEXT_B</span></a>          (0x0001)
/* Video Program System, defined on ETS 300 231*/
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_VPS</span></a>                 (0x0400)
/* Closed Caption, defined on EIA-608 */
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_CAPTION_525</span></a>         (0x1000)
/* Wide Screen System, defined on ITU-R BT1119.1 */
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_WSS_625</span></a>             (0x4000)

#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_VBI_525</span></a>             (<a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_CAPTION_525</span></a>)
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_VBI_625</span></a>             (<a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_TELETEXT_B</span></a> | <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_VPS</span></a> | <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vbi-services"><span class="std std-ref">V4L2_SLICED_WSS_625</span></a>)

struct v4l2_sliced_vbi_cap {
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   type;           /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        __u32   reserved[3];    /* must be 0 */
};

struct v4l2_sliced_vbi_data {
        __u32   id;
        __u32   field;          /* 0: first field, 1: second field */
        __u32   line;           /* 1-23 */
        __u32   reserved;       /* must be 0 */
        __u8    data[48];
};

/*
 * Sliced VBI data inserted into MPEG Streams
 */

/*
 * V4L2_MPEG_STREAM_VBI_FMT_IVTV:
 *
 * Structure of payload contained in an MPEG 2 Private Stream 1 PES Packet in an
 * MPEG-2 Program Pack that contains V4L2_MPEG_STREAM_VBI_FMT_IVTV Sliced VBI
 * data
 *
 * Note, the MPEG-2 Program Pack and Private Stream 1 PES packet header
 * definitions are not included here.  See the MPEG-2 specifications for details
 * on these headers.
 */

/* Line type IDs */
#define <a class="reference internal" href="dev-sliced-vbi.html#itv0-line-identifier-constants"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_TELETEXT_B</span></a>     (1)
#define <a class="reference internal" href="dev-sliced-vbi.html#itv0-line-identifier-constants"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_CAPTION_525</span></a>    (4)
#define <a class="reference internal" href="dev-sliced-vbi.html#itv0-line-identifier-constants"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_WSS_625</span></a>        (5)
#define <a class="reference internal" href="dev-sliced-vbi.html#itv0-line-identifier-constants"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_VPS</span></a>            (7)

struct v4l2_mpeg_vbi_itv0_line {
        __u8 id;        /* One of V4L2_MPEG_VBI_IVTV_* above */
        __u8 data[42];  /* Sliced VBI data for the line */
} __attribute__ ((packed));

struct v4l2_mpeg_vbi_itv0 {
        __le32 linemask[2]; /* Bitmasks of VBI service lines present */
        struct v4l2_mpeg_vbi_itv0_line line[35];
} __attribute__ ((packed));

struct v4l2_mpeg_vbi_ITV0 {
        struct v4l2_mpeg_vbi_itv0_line line[36];
} __attribute__ ((packed));

#define <a class="reference internal" href="dev-sliced-vbi.html#v4l2-mpeg-vbi-fmt-ivtv-magic"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_MAGIC0</span></a>       &quot;itv0&quot;
#define <a class="reference internal" href="dev-sliced-vbi.html#v4l2-mpeg-vbi-fmt-ivtv-magic"><span class="std std-ref">V4L2_MPEG_VBI_IVTV_MAGIC1</span></a>       &quot;ITV0&quot;

struct v4l2_mpeg_vbi_fmt_ivtv {
        __u8 magic[4];
        union {
                struct v4l2_mpeg_vbi_itv0 itv0;
                struct v4l2_mpeg_vbi_ITV0 ITV0;
        };
} __attribute__ ((packed));

/*
 *      A G G R E G A T E   S T R U C T U R E S
 */

/**
 * struct v4l2_plane_pix_format - additional, per-plane format definition
 * &#64;sizeimage:          maximum size in bytes required for data, for which
 *                      this plane will be used
 * &#64;bytesperline:       distance in bytes between the leftmost pixels in two
 *                      adjacent lines
 * &#64;reserved:           drivers and applications must zero this array
 */
struct v4l2_plane_pix_format {
        __u32           sizeimage;
        __u32           bytesperline;
        __u16           reserved[6];
} __attribute__ ((packed));

/**
 * struct v4l2_pix_format_mplane - multiplanar format definition
 * &#64;width:              image width in pixels
 * &#64;height:             image height in pixels
 * &#64;pixelformat:        little endian four character code (fourcc)
 * &#64;field:              enum <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_field</span></code></a>; field order (for interlaced video)
 * &#64;colorspace:         enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_colorspace</span></code>; supplemental to pixelformat
 * &#64;plane_fmt:          per-plane information
 * &#64;num_planes:         number of planes for this format
 * &#64;flags:              format flags (V4L2_PIX_FMT_FLAG_*)
 * &#64;ycbcr_enc:          enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ycbcr_encoding</span></code>, Y'CbCr encoding
 * &#64;hsv_enc:            enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_hsv_encoding</span></code>, HSV encoding
 * &#64;quantization:       enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_quantization</span></code>, colorspace quantization
 * &#64;xfer_func:          enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_xfer_func</span></code>, colorspace transfer function
 * &#64;reserved:           drivers and applications must zero this array
 */
struct v4l2_pix_format_mplane {
        __u32                           width;
        __u32                           height;
        __u32                           pixelformat;
        __u32                           field;
        __u32                           colorspace;

        struct v4l2_plane_pix_format    plane_fmt[VIDEO_MAX_PLANES];
        __u8                            num_planes;
        __u8                            flags;
         union {
                __u8                            ycbcr_enc;
                __u8                            hsv_enc;
        };
        __u8                            quantization;
        __u8                            xfer_func;
        __u8                            reserved[7];
} __attribute__ ((packed));

/**
 * struct v4l2_sdr_format - SDR format definition
 * &#64;pixelformat:        little endian four character code (fourcc)
 * &#64;buffersize:         maximum size in bytes required for data
 * &#64;reserved:           drivers and applications must zero this array
 */
struct v4l2_sdr_format {
        __u32                           pixelformat;
        __u32                           buffersize;
        __u8                            reserved[24];
} __attribute__ ((packed));

/**
 * struct v4l2_meta_format - metadata format definition
 * &#64;dataformat:         little endian four character code (fourcc)
 * &#64;buffersize:         maximum size in bytes required for data
 */
struct v4l2_meta_format {
        __u32                           dataformat;
        __u32                           buffersize;
} __attribute__ ((packed));

/**
 * struct v4l2_format - stream data format
 * &#64;type:       enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code>; type of the data stream
 * &#64;pix:        definition of an image format
 * &#64;pix_mp:     definition of a multiplanar image format
 * &#64;win:        definition of an overlaid image
 * &#64;vbi:        raw VBI capture or output parameters
 * &#64;sliced:     sliced VBI capture or output parameters
 * &#64;raw_data:   placeholder for future extensions and custom formats
 * &#64;fmt:        union of &#64;pix, &#64;pix_mp, &#64;win, &#64;vbi, &#64;sliced, &#64;sdr, &#64;meta
 *              and &#64;raw_data
 */
struct v4l2_format {
        __u32    type;
        union {
                struct v4l2_pix_format          pix;     /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code> */
                struct v4l2_pix_format_mplane   pix_mp;  /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span></code> */
                struct v4l2_window              win;     /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OVERLAY</span></code> */
                struct v4l2_vbi_format          vbi;     /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VBI_CAPTURE</span></code> */
                struct v4l2_sliced_vbi_format   sliced;  /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</span></code> */
                struct v4l2_sdr_format          sdr;     /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_SDR_CAPTURE</span></code> */
                struct v4l2_meta_format         meta;    /* <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_META_CAPTURE</span></code> */
                __u8    raw_data[200];                   /* user-defined */
        } fmt;
};

/*      Stream type-dependent parameters
 */
struct v4l2_streamparm {
        __u32    type;                  /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code> */
        union {
                struct v4l2_captureparm capture;
                struct v4l2_outputparm  output;
                __u8    raw_data[200];  /* user-defined */
        } parm;
};

/*
 *      E V E N T S
 */

#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_ALL</span></a>                          0
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_VSYNC</span></a>                        1
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_EOS</span></a>                          2
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_CTRL</span></a>                         3
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_FRAME_SYNC</span></a>                   4
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_SOURCE_CHANGE</span></a>                5
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_MOTION_DET</span></a>                   6
#define <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_PRIVATE_START</span></a>                0x08000000

/* Payload for <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_VSYNC</span></a> */
struct v4l2_event_vsync {
        /* Can be <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_FIELD_ANY</span></code></a>, _NONE, _TOP or _BOTTOM */
        __u8 field;
} __attribute__ ((packed));

/* Payload for <a class="reference internal" href="vidioc-dqevent.html#event-type"><span class="std std-ref">V4L2_EVENT_CTRL</span></a> */
#define <a class="reference internal" href="vidioc-dqevent.html#ctrl-changes-flags"><span class="std std-ref">V4L2_EVENT_CTRL_CH_VALUE</span></a>                (1 &lt;&lt; 0)
#define <a class="reference internal" href="vidioc-dqevent.html#ctrl-changes-flags"><span class="std std-ref">V4L2_EVENT_CTRL_CH_FLAGS</span></a>                (1 &lt;&lt; 1)
#define <a class="reference internal" href="vidioc-dqevent.html#ctrl-changes-flags"><span class="std std-ref">V4L2_EVENT_CTRL_CH_RANGE</span></a>                (1 &lt;&lt; 2)
#define <a class="reference internal" href="vidioc-dqevent.html#ctrl-changes-flags"><span class="std std-ref">V4L2_EVENT_CTRL_CH_DIMENSIONS</span></a>           (1 &lt;&lt; 3)

struct v4l2_event_ctrl {
        __u32 changes;
        __u32 type;
        union {
                __s32 value;
                __s64 value64;
        };
        __u32 flags;
        __s32 minimum;
        __s32 maximum;
        __s32 step;
        __s32 default_value;
};

struct v4l2_event_frame_sync {
        __u32 frame_sequence;
};

#define <a class="reference internal" href="vidioc-dqevent.html#src-changes-flags"><span class="std std-ref">V4L2_EVENT_SRC_CH_RESOLUTION</span></a>            (1 &lt;&lt; 0)

struct v4l2_event_src_change {
        __u32 changes;
};

#define <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ</span></code> (1 &lt;&lt; 0)

/**
 * struct v4l2_event_motion_det - motion detection event
 * &#64;flags:             if <code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ</span></code> is set, then the
 *                     frame_sequence field is valid.
 * &#64;frame_sequence:    the frame sequence number associated with this event.
 * &#64;region_mask:       which regions detected motion.
 */
struct v4l2_event_motion_det {
        __u32 flags;
        __u32 frame_sequence;
        __u32 region_mask;
};

struct v4l2_event {
        __u32                           type;
        union {
                struct v4l2_event_vsync         vsync;
                struct v4l2_event_ctrl          ctrl;
                struct v4l2_event_frame_sync    frame_sync;
                struct v4l2_event_src_change    src_change;
                struct v4l2_event_motion_det    motion_det;
                __u8                            data[64];
        } u;
        __u32                           pending;
        __u32                           sequence;
#ifdef __KERNEL__
        struct __kernel_timespec        timestamp;
#else
        struct timespec                 timestamp;
#endif
        __u32                           id;
        __u32                           reserved[8];
};

#define <a class="reference internal" href="vidioc-subscribe-event.html#event-flags"><span class="std std-ref">V4L2_EVENT_SUB_FL_SEND_INITIAL</span></a>          (1 &lt;&lt; 0)
#define <a class="reference internal" href="vidioc-subscribe-event.html#event-flags"><span class="std std-ref">V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK</span></a>        (1 &lt;&lt; 1)

struct v4l2_event_subscription {
        __u32                           type;
        __u32                           id;
        __u32                           flags;
        __u32                           reserved[5];
};

/*
 *      A D V A N C E D   D E B U G G I N G
 *
 *      NOTE: EXPERIMENTAL API, NEVER RELY ON THIS IN APPLICATIONS!
 *      FOR DEBUGGING, TESTING AND INTERNAL USE ONLY!
 */

/* <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">VIDIOC_DBG_G_REGISTER</span></a> and <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">VIDIOC_DBG_S_REGISTER</span></a> */

#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_BRIDGE</span></a>      0  /* Match against chip ID on the bridge (0 for the bridge) */
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_SUBDEV</span></a>      4  /* Match against subdev index */

/* The following four defines are no longer in use */
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_HOST</span></a> <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_BRIDGE</span></a>
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_I2C_DRIVER</span></a>  1  /* Match against I2C driver name */
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_I2C_ADDR</span></a>    2  /* Match against I2C 7-bit address */
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_MATCH_AC97</span></a>        3  /* Match against ancillary AC97 chip */

struct v4l2_dbg_match {
        __u32 type; /* Match type */
        union {     /* Match this chip, meaning determined by type */
                __u32 addr;
                char name[32];
        };
} __attribute__ ((packed));

struct v4l2_dbg_register {
        struct v4l2_dbg_match match;
        __u32 size;     /* register size in bytes */
        __u64 reg;
        __u64 val;
} __attribute__ ((packed));

#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_FL_READABLE</span></a> (1 &lt;&lt; 0)
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">V4L2_CHIP_FL_WRITABLE</span></a> (1 &lt;&lt; 1)

/* <a class="reference internal" href="vidioc-dbg-g-chip-info.html#vidioc-dbg-g-chip-info"><span class="std std-ref">VIDIOC_DBG_G_CHIP_INFO</span></a> */
struct v4l2_dbg_chip_info {
        struct v4l2_dbg_match match;
        char name[32];
        __u32 flags;
        __u32 reserved[32];
} __attribute__ ((packed));

/**
 * struct v4l2_create_buffers - <a class="reference internal" href="vidioc-create-bufs.html#vidioc-create-bufs"><span class="std std-ref">VIDIOC_CREATE_BUFS</span></a> argument
 * &#64;index:      on return, index of the first created buffer
 * &#64;count:      entry: number of requested buffers,
 *              return: number of created buffers
 * &#64;memory:     enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_memory</span></code>; buffer memory type
 * &#64;format:     frame format, for which buffers are requested
 * &#64;capabilities: capabilities of this buffer type.
 * &#64;flags:      additional buffer management attributes (ignored unless the
 *              queue has <a class="reference internal" href="vidioc-reqbufs.html#v4l2-buf-cap-supports-mmap-cache-hints"><span class="std std-ref">V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS</span></a> capability
 *              and configured for MMAP streaming I/O).
 * &#64;reserved:   future extensions
 */
struct v4l2_create_buffers {
        __u32                   index;
        __u32                   count;
        __u32                   memory;
        struct v4l2_format      format;
        __u32                   capabilities;
        __u32                   flags;
        __u32                   reserved[6];
};

/*
 *      I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
 *
 */
#define <a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">VIDIOC_QUERYCAP</span></a>          _IOR('V',  0, struct v4l2_capability)
#define <a class="reference internal" href="vidioc-enum-fmt.html#vidioc-enum-fmt"><span class="std std-ref">VIDIOC_ENUM_FMT</span></a>         _IOWR('V',  2, struct v4l2_fmtdesc)
#define <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_G_FMT</span></a>            _IOWR('V',  4, struct v4l2_format)
#define <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a>            _IOWR('V',  5, struct v4l2_format)
#define <a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">VIDIOC_REQBUFS</span></a>          _IOWR('V',  8, struct v4l2_requestbuffers)
#define <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">VIDIOC_QUERYBUF</span></a>         _IOWR('V',  9, struct v4l2_buffer)
#define <a class="reference internal" href="vidioc-g-fbuf.html#vidioc-g-fbuf"><span class="std std-ref">VIDIOC_G_FBUF</span></a>            _IOR('V', 10, struct v4l2_framebuffer)
#define <a class="reference internal" href="vidioc-g-fbuf.html#vidioc-g-fbuf"><span class="std std-ref">VIDIOC_S_FBUF</span></a>            _IOW('V', 11, struct v4l2_framebuffer)
#define <a class="reference internal" href="vidioc-overlay.html#vidioc-overlay"><span class="std std-ref">VIDIOC_OVERLAY</span></a>           _IOW('V', 14, int)
#define <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_QBUF</span></a>             _IOWR('V', 15, struct v4l2_buffer)
#define <a class="reference internal" href="vidioc-expbuf.html#vidioc-expbuf"><span class="std std-ref">VIDIOC_EXPBUF</span></a>           _IOWR('V', 16, struct v4l2_exportbuffer)
#define <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>            _IOWR('V', 17, struct v4l2_buffer)
#define <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a>          _IOW('V', 18, int)
#define <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a>         _IOW('V', 19, int)
#define <a class="reference internal" href="vidioc-g-parm.html#vidioc-g-parm"><span class="std std-ref">VIDIOC_G_PARM</span></a>           _IOWR('V', 21, struct v4l2_streamparm)
#define <a class="reference internal" href="vidioc-g-parm.html#vidioc-g-parm"><span class="std std-ref">VIDIOC_S_PARM</span></a>           _IOWR('V', 22, struct v4l2_streamparm)
#define <a class="reference internal" href="vidioc-g-std.html#vidioc-g-std"><span class="std std-ref">VIDIOC_G_STD</span></a>             _IOR('V', 23, v4l2_std_id)
#define <a class="reference internal" href="vidioc-g-std.html#vidioc-g-std"><span class="std std-ref">VIDIOC_S_STD</span></a>             _IOW('V', 24, v4l2_std_id)
#define <a class="reference internal" href="vidioc-enumstd.html#vidioc-enumstd"><span class="std std-ref">VIDIOC_ENUMSTD</span></a>          _IOWR('V', 25, struct v4l2_standard)
#define <a class="reference internal" href="vidioc-enuminput.html#vidioc-enuminput"><span class="std std-ref">VIDIOC_ENUMINPUT</span></a>        _IOWR('V', 26, struct v4l2_input)
#define <a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_G_CTRL</span></a>           _IOWR('V', 27, struct v4l2_control)
#define <a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_S_CTRL</span></a>           _IOWR('V', 28, struct v4l2_control)
#define <a class="reference internal" href="vidioc-g-tuner.html#vidioc-g-tuner"><span class="std std-ref">VIDIOC_G_TUNER</span></a>          _IOWR('V', 29, struct v4l2_tuner)
#define <a class="reference internal" href="vidioc-g-tuner.html#vidioc-g-tuner"><span class="std std-ref">VIDIOC_S_TUNER</span></a>           _IOW('V', 30, struct v4l2_tuner)
#define <a class="reference internal" href="vidioc-g-audio.html#vidioc-g-audio"><span class="std std-ref">VIDIOC_G_AUDIO</span></a>           _IOR('V', 33, struct v4l2_audio)
#define <a class="reference internal" href="vidioc-g-audio.html#vidioc-g-audio"><span class="std std-ref">VIDIOC_S_AUDIO</span></a>           _IOW('V', 34, struct v4l2_audio)
#define <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERYCTRL</span></a>        _IOWR('V', 36, struct v4l2_queryctrl)
#define <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERYMENU</span></a>        _IOWR('V', 37, struct v4l2_querymenu)
#define <a class="reference internal" href="vidioc-g-input.html#vidioc-g-input"><span class="std std-ref">VIDIOC_G_INPUT</span></a>           _IOR('V', 38, int)
#define <a class="reference internal" href="vidioc-g-input.html#vidioc-g-input"><span class="std std-ref">VIDIOC_S_INPUT</span></a>          _IOWR('V', 39, int)
#define <a class="reference internal" href="vidioc-g-edid.html#vidioc-g-edid"><span class="std std-ref">VIDIOC_G_EDID</span></a>           _IOWR('V', 40, struct v4l2_edid)
#define <a class="reference internal" href="vidioc-g-edid.html#vidioc-g-edid"><span class="std std-ref">VIDIOC_S_EDID</span></a>           _IOWR('V', 41, struct v4l2_edid)
#define <a class="reference internal" href="vidioc-g-output.html#vidioc-g-output"><span class="std std-ref">VIDIOC_G_OUTPUT</span></a>          _IOR('V', 46, int)
#define <a class="reference internal" href="vidioc-g-output.html#vidioc-g-output"><span class="std std-ref">VIDIOC_S_OUTPUT</span></a>         _IOWR('V', 47, int)
#define <a class="reference internal" href="vidioc-enumoutput.html#vidioc-enumoutput"><span class="std std-ref">VIDIOC_ENUMOUTPUT</span></a>       _IOWR('V', 48, struct v4l2_output)
#define <a class="reference internal" href="vidioc-g-audioout.html#vidioc-g-audout"><span class="std std-ref">VIDIOC_G_AUDOUT</span></a>          _IOR('V', 49, struct v4l2_audioout)
#define <a class="reference internal" href="vidioc-g-audioout.html#vidioc-g-audout"><span class="std std-ref">VIDIOC_S_AUDOUT</span></a>          _IOW('V', 50, struct v4l2_audioout)
#define <a class="reference internal" href="vidioc-g-modulator.html#vidioc-g-modulator"><span class="std std-ref">VIDIOC_G_MODULATOR</span></a>      _IOWR('V', 54, struct v4l2_modulator)
#define <a class="reference internal" href="vidioc-g-modulator.html#vidioc-g-modulator"><span class="std std-ref">VIDIOC_S_MODULATOR</span></a>       _IOW('V', 55, struct v4l2_modulator)
#define <a class="reference internal" href="vidioc-g-frequency.html#vidioc-g-frequency"><span class="std std-ref">VIDIOC_G_FREQUENCY</span></a>      _IOWR('V', 56, struct v4l2_frequency)
#define <a class="reference internal" href="vidioc-g-frequency.html#vidioc-g-frequency"><span class="std std-ref">VIDIOC_S_FREQUENCY</span></a>       _IOW('V', 57, struct v4l2_frequency)
#define <a class="reference internal" href="vidioc-cropcap.html#vidioc-cropcap"><span class="std std-ref">VIDIOC_CROPCAP</span></a>          _IOWR('V', 58, struct v4l2_cropcap)
#define <a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_G_CROP</span></a>           _IOWR('V', 59, struct v4l2_crop)
#define <a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_S_CROP</span></a>            _IOW('V', 60, struct v4l2_crop)
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#vidioc-g-jpegcomp"><span class="std std-ref">VIDIOC_G_JPEGCOMP</span></a>        _IOR('V', 61, struct v4l2_jpegcompression)
#define <a class="reference internal" href="vidioc-g-jpegcomp.html#vidioc-g-jpegcomp"><span class="std std-ref">VIDIOC_S_JPEGCOMP</span></a>        _IOW('V', 62, struct v4l2_jpegcompression)
#define <a class="reference internal" href="vidioc-querystd.html#vidioc-querystd"><span class="std std-ref">VIDIOC_QUERYSTD</span></a>          _IOR('V', 63, v4l2_std_id)
#define <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_TRY_FMT</span></a>          _IOWR('V', 64, struct v4l2_format)
#define <a class="reference internal" href="vidioc-enumaudio.html#vidioc-enumaudio"><span class="std std-ref">VIDIOC_ENUMAUDIO</span></a>        _IOWR('V', 65, struct v4l2_audio)
#define <a class="reference internal" href="vidioc-enumaudioout.html#vidioc-enumaudout"><span class="std std-ref">VIDIOC_ENUMAUDOUT</span></a>       _IOWR('V', 66, struct v4l2_audioout)
#define <a class="reference internal" href="vidioc-g-priority.html#vidioc-g-priority"><span class="std std-ref">VIDIOC_G_PRIORITY</span></a>        _IOR('V', 67, __u32) /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code> */
#define <a class="reference internal" href="vidioc-g-priority.html#vidioc-g-priority"><span class="std std-ref">VIDIOC_S_PRIORITY</span></a>        _IOW('V', 68, __u32) /* enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code> */
#define <a class="reference internal" href="vidioc-g-sliced-vbi-cap.html#vidioc-g-sliced-vbi-cap"><span class="std std-ref">VIDIOC_G_SLICED_VBI_CAP</span></a> _IOWR('V', 69, struct v4l2_sliced_vbi_cap)
#define <a class="reference internal" href="vidioc-log-status.html#vidioc-log-status"><span class="std std-ref">VIDIOC_LOG_STATUS</span></a>         _IO('V', 70)
#define <a class="reference internal" href="vidioc-g-ext-ctrls.html#vidioc-g-ext-ctrls"><span class="std std-ref">VIDIOC_G_EXT_CTRLS</span></a>      _IOWR('V', 71, struct v4l2_ext_controls)
#define <a class="reference internal" href="vidioc-g-ext-ctrls.html#vidioc-g-ext-ctrls"><span class="std std-ref">VIDIOC_S_EXT_CTRLS</span></a>      _IOWR('V', 72, struct v4l2_ext_controls)
#define <a class="reference internal" href="vidioc-g-ext-ctrls.html#vidioc-g-ext-ctrls"><span class="std std-ref">VIDIOC_TRY_EXT_CTRLS</span></a>    _IOWR('V', 73, struct v4l2_ext_controls)
#define <a class="reference internal" href="vidioc-enum-framesizes.html#vidioc-enum-framesizes"><span class="std std-ref">VIDIOC_ENUM_FRAMESIZES</span></a>  _IOWR('V', 74, struct v4l2_frmsizeenum)
#define <a class="reference internal" href="vidioc-enum-frameintervals.html#vidioc-enum-frameintervals"><span class="std std-ref">VIDIOC_ENUM_FRAMEINTERVALS</span></a> _IOWR('V', 75, struct v4l2_frmivalenum)
#define <a class="reference internal" href="vidioc-g-enc-index.html#vidioc-g-enc-index"><span class="std std-ref">VIDIOC_G_ENC_INDEX</span></a>       _IOR('V', 76, struct v4l2_enc_idx)
#define <a class="reference internal" href="vidioc-encoder-cmd.html#vidioc-encoder-cmd"><span class="std std-ref">VIDIOC_ENCODER_CMD</span></a>      _IOWR('V', 77, struct v4l2_encoder_cmd)
#define <a class="reference internal" href="vidioc-encoder-cmd.html#vidioc-encoder-cmd"><span class="std std-ref">VIDIOC_TRY_ENCODER_CMD</span></a>  _IOWR('V', 78, struct v4l2_encoder_cmd)

/*
 * Experimental, meant for debugging, testing and internal use.
 * Only implemented if CONFIG_VIDEO_ADV_DEBUG is defined.
 * You must be root to use these ioctls. Never use these in applications!
 */
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">VIDIOC_DBG_S_REGISTER</span></a>    _IOW('V', 79, struct v4l2_dbg_register)
#define <a class="reference internal" href="vidioc-dbg-g-register.html#vidioc-dbg-g-register"><span class="std std-ref">VIDIOC_DBG_G_REGISTER</span></a>   _IOWR('V', 80, struct v4l2_dbg_register)

#define <a class="reference internal" href="vidioc-s-hw-freq-seek.html#vidioc-s-hw-freq-seek"><span class="std std-ref">VIDIOC_S_HW_FREQ_SEEK</span></a>    _IOW('V', 82, struct v4l2_hw_freq_seek)
#define <a class="reference internal" href="vidioc-g-dv-timings.html#vidioc-g-dv-timings"><span class="std std-ref">VIDIOC_S_DV_TIMINGS</span></a>     _IOWR('V', 87, struct v4l2_dv_timings)
#define <a class="reference internal" href="vidioc-g-dv-timings.html#vidioc-g-dv-timings"><span class="std std-ref">VIDIOC_G_DV_TIMINGS</span></a>     _IOWR('V', 88, struct v4l2_dv_timings)
#define <a class="reference internal" href="vidioc-dqevent.html#vidioc-dqevent"><span class="std std-ref">VIDIOC_DQEVENT</span></a>           _IOR('V', 89, struct v4l2_event)
#define <a class="reference internal" href="vidioc-subscribe-event.html#vidioc-subscribe-event"><span class="std std-ref">VIDIOC_SUBSCRIBE_EVENT</span></a>   _IOW('V', 90, struct v4l2_event_subscription)
#define <a class="reference internal" href="vidioc-subscribe-event.html#vidioc-unsubscribe-event"><span class="std std-ref">VIDIOC_UNSUBSCRIBE_EVENT</span></a> _IOW('V', 91, struct v4l2_event_subscription)
#define <a class="reference internal" href="vidioc-create-bufs.html#vidioc-create-bufs"><span class="std std-ref">VIDIOC_CREATE_BUFS</span></a>      _IOWR('V', 92, struct v4l2_create_buffers)
#define <a class="reference internal" href="vidioc-prepare-buf.html#vidioc-prepare-buf"><span class="std std-ref">VIDIOC_PREPARE_BUF</span></a>      _IOWR('V', 93, struct v4l2_buffer)
#define <a class="reference internal" href="vidioc-g-selection.html#vidioc-g-selection"><span class="std std-ref">VIDIOC_G_SELECTION</span></a>      _IOWR('V', 94, struct v4l2_selection)
#define <a class="reference internal" href="vidioc-g-selection.html#vidioc-g-selection"><span class="std std-ref">VIDIOC_S_SELECTION</span></a>      _IOWR('V', 95, struct v4l2_selection)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#vidioc-decoder-cmd"><span class="std std-ref">VIDIOC_DECODER_CMD</span></a>      _IOWR('V', 96, struct v4l2_decoder_cmd)
#define <a class="reference internal" href="vidioc-decoder-cmd.html#vidioc-decoder-cmd"><span class="std std-ref">VIDIOC_TRY_DECODER_CMD</span></a>  _IOWR('V', 97, struct v4l2_decoder_cmd)
#define <a class="reference internal" href="vidioc-enum-dv-timings.html#vidioc-enum-dv-timings"><span class="std std-ref">VIDIOC_ENUM_DV_TIMINGS</span></a>  _IOWR('V', 98, struct v4l2_enum_dv_timings)
#define <a class="reference internal" href="vidioc-query-dv-timings.html#vidioc-query-dv-timings"><span class="std std-ref">VIDIOC_QUERY_DV_TIMINGS</span></a>  _IOR('V', 99, struct v4l2_dv_timings)
#define <a class="reference internal" href="vidioc-dv-timings-cap.html#vidioc-dv-timings-cap"><span class="std std-ref">VIDIOC_DV_TIMINGS_CAP</span></a>   _IOWR('V', 100, struct v4l2_dv_timings_cap)
#define <a class="reference internal" href="vidioc-enum-freq-bands.html#vidioc-enum-freq-bands"><span class="std std-ref">VIDIOC_ENUM_FREQ_BANDS</span></a>  _IOWR('V', 101, struct v4l2_frequency_band)

/*
 * Experimental, meant for debugging, testing and internal use.
 * Never use this in applications!
 */
#define <a class="reference internal" href="vidioc-dbg-g-chip-info.html#vidioc-dbg-g-chip-info"><span class="std std-ref">VIDIOC_DBG_G_CHIP_INFO</span></a>  _IOWR('V', 102, struct v4l2_dbg_chip_info)

#define <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">VIDIOC_QUERY_EXT_CTRL</span></a>   _IOWR('V', 103, struct v4l2_query_ext_ctrl)

/* Reminder: when adding new ioctls please add support for them to
   drivers/media/v4l2-core/v4l2-compat-ioctl32.c as well! */

#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

/* Deprecated definitions kept for backwards compatibility */
#ifndef __KERNEL__
#define <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_HM12</span></code></a> <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-16l16"><span class="std std-ref">V4L2_PIX_FMT_NV12_16L16</span></a>
#define <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_SUNXI_TILED_NV12</span></code></a> <a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-nv12-32l32"><span class="std std-ref">V4L2_PIX_FMT_NV12_32L32</span></a>
/*
 * This capability was never implemented, anyone using this cap should drop it
 * from their code.
 */
#define <a class="reference internal" href="vidioc-querycap.html#device-capabilities"><span class="std std-ref">V4L2_CAP_ASYNCIO</span></a> 0x02000000
#endif

#endif /* _UAPI__LINUX_VIDEODEV2_H */</pre>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. Video For Linux Two Header File</a><ul>
<li><a class="reference internal" href="#videodev2-h">9.1. videodev2.h</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/v4l/videodev.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/v4l/videodev.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>