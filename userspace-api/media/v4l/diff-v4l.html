
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>6.1. Differences between V4L and V4L2 &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="6.2. Changes of the V4L2 API" href="hist-v4l2.html" />
    <link rel="prev" title="6. Changes" href="compat.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="differences-between-v4l-and-v4l2">
<span id="diff-v4l"></span><h1><span class="section-number">6.1. </span>Differences between V4L and V4L2<a class="headerlink" href="#differences-between-v4l-and-v4l2" title="Permalink to this headline">¶</a></h1>
<p>The Video For Linux API was first introduced in Linux 2.1 to unify and
replace various TV and radio device related interfaces, developed
independently by driver writers in prior years. Starting with Linux 2.5
the much improved V4L2 API replaces the V4L API. The support for the old
V4L calls were removed from Kernel, but the library <a class="reference internal" href="libv4l.html#libv4l"><span class="std std-ref">Libv4l Userspace Library</span></a>
supports the conversion of a V4L API system call into a V4L2 one.</p>
<section id="opening-and-closing-devices">
<h2><span class="section-number">6.1.1. </span>Opening and Closing Devices<a class="headerlink" href="#opening-and-closing-devices" title="Permalink to this headline">¶</a></h2>
<p>For compatibility reasons the character device file names recommended
for V4L2 video capture, overlay, radio and raw vbi capture devices did
not change from those used by V4L. They are listed in <a class="reference internal" href="devices.html#devices"><span class="std std-ref">Interfaces</span></a>
and below in <a class="reference internal" href="#v4l-dev"><span class="std std-ref">V4L Device Types, Names and Numbers</span></a>.</p>
<p>The teletext devices (minor range 192-223) have been removed in V4L2 and
no longer exist. There is no hardware available anymore for handling
pure teletext. Instead raw or sliced VBI is used.</p>
<p>The V4L <code class="docutils literal notranslate"><span class="pre">videodev</span></code> module automatically assigns minor numbers to
drivers in load order, depending on the registered device type. We
recommend that V4L2 drivers by default register devices with the same
numbers, but the system administrator can assign arbitrary minor numbers
using driver module options. The major device number remains 81.</p>
<span id="v4l-dev"></span><table class="docutils align-default" id="id10">
<caption><span class="caption-text">V4L Device Types, Names and Numbers</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Device Type</p></th>
<th class="head"><p>File Name</p></th>
<th class="head"><p>Minor Numbers</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Video capture and overlay</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/video</span></code> and <code class="docutils literal notranslate"><span class="pre">/dev/bttv0</span></code> <a class="footnote-reference brackets" href="#f1" id="id1">1</a>, <code class="docutils literal notranslate"><span class="pre">/dev/video0</span></code> to
<code class="docutils literal notranslate"><span class="pre">/dev/video63</span></code></p></td>
<td><p>0-63</p></td>
</tr>
<tr class="row-odd"><td><p>Radio receiver</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/radio</span></code> <a class="footnote-reference brackets" href="#f2" id="id2">2</a>, <code class="docutils literal notranslate"><span class="pre">/dev/radio0</span></code> to <code class="docutils literal notranslate"><span class="pre">/dev/radio63</span></code></p></td>
<td><p>64-127</p></td>
</tr>
<tr class="row-even"><td><p>Raw VBI capture</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/vbi</span></code>, <code class="docutils literal notranslate"><span class="pre">/dev/vbi0</span></code> to <code class="docutils literal notranslate"><span class="pre">/dev/vbi31</span></code></p></td>
<td><p>224-255</p></td>
</tr>
</tbody>
</table>
<p>V4L prohibits (or used to prohibit) multiple opens of a device file.
V4L2 drivers <em>may</em> support multiple opens, see <a class="reference internal" href="open.html#open"><span class="std std-ref">Opening and Closing Devices</span></a> for details
and consequences.</p>
<p>V4L drivers respond to V4L2 ioctls with an <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> error code.</p>
</section>
<section id="querying-capabilities">
<h2><span class="section-number">6.1.2. </span>Querying Capabilities<a class="headerlink" href="#querying-capabilities" title="Permalink to this headline">¶</a></h2>
<p>The V4L <code class="docutils literal notranslate"><span class="pre">VIDIOCGCAP</span></code> ioctl is equivalent to V4L2’s
<a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">ioctl VIDIOC_QUERYCAP</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> field in struct <code class="docutils literal notranslate"><span class="pre">video_capability</span></code> became
<code class="docutils literal notranslate"><span class="pre">card</span></code> in struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_capability</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>
was replaced by <code class="docutils literal notranslate"><span class="pre">capabilities</span></code>. Note V4L2 does not distinguish between
device types like this, better think of basic video input, video output
and radio devices supporting a set of related functions like video
capturing, video overlay and VBI capturing. See <a class="reference internal" href="open.html#open"><span class="std std-ref">Opening and Closing Devices</span></a> for an
introduction.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_capability</span></code> <code class="docutils literal notranslate"><span class="pre">type</span></code></p></th>
<th class="head"><p>struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_capability</span></code>
<code class="docutils literal notranslate"><span class="pre">capabilities</span></code> flags</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_CAPTURE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CAP_VIDEO_CAPTURE</span></code></p></td>
<td><p>The <a class="reference internal" href="dev-capture.html#capture"><span class="std std-ref">video capture</span></a> interface is supported.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_TUNER</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CAP_TUNER</span></code></p></td>
<td><p>The device has a <a class="reference internal" href="tuner.html#tuner"><span class="std std-ref">tuner or modulator</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_TELETEXT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CAP_VBI_CAPTURE</span></code></p></td>
<td><p>The <a class="reference internal" href="dev-raw-vbi.html#raw-vbi"><span class="std std-ref">raw VBI capture</span></a> interface is supported.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_OVERLAY</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CAP_VIDEO_OVERLAY</span></code></p></td>
<td><p>The <a class="reference internal" href="dev-overlay.html#overlay"><span class="std std-ref">video overlay</span></a> interface is supported.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_CHROMAKEY</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_FBUF_CAP_CHROMAKEY</span></code> in field <code class="docutils literal notranslate"><span class="pre">capability</span></code> of struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_framebuffer</span></code></p></td>
<td><p>Whether chromakey overlay is supported. For more information on
overlay see <a class="reference internal" href="dev-overlay.html#overlay"><span class="std std-ref">Video Overlay Interface</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_CLIPPING</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_FBUF_CAP_LIST_CLIPPING</span></code> and
<code class="docutils literal notranslate"><span class="pre">V4L2_FBUF_CAP_BITMAP_CLIPPING</span></code> in field <code class="docutils literal notranslate"><span class="pre">capability</span></code> of
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_framebuffer</span></code></p></td>
<td><p>Whether clipping the overlaid image is supported, see
<a class="reference internal" href="dev-overlay.html#overlay"><span class="std std-ref">Video Overlay Interface</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_FRAMERAM</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_FBUF_CAP_EXTERNOVERLAY</span></code> <em>not set</em> in field <code class="docutils literal notranslate"><span class="pre">capability</span></code>
of struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_framebuffer</span></code></p></td>
<td><p>Whether overlay overwrites frame buffer memory, see
<a class="reference internal" href="dev-overlay.html#overlay"><span class="std std-ref">Video Overlay Interface</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_SCALES</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>This flag indicates if the hardware can scale images. The V4L2 API
implies the scale factor by setting the cropping dimensions and
image size with the <a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_S_CROP</span></a> and
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a> ioctl, respectively. The
driver returns the closest sizes possible. For more information on
cropping and scaling see <a class="reference internal" href="crop.html#crop"><span class="std std-ref">Image Cropping, Insertion and Scaling – the CROP API</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_MONOCHROME</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Applications can enumerate the supported image formats with the
<a class="reference internal" href="vidioc-enum-fmt.html#vidioc-enum-fmt"><span class="std std-ref">ioctl VIDIOC_ENUM_FMT</span></a> ioctl to determine if
the device supports grey scale capturing only. For more
information on image formats see <a class="reference internal" href="pixfmt.html#pixfmt"><span class="std std-ref">Image Formats</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_SUBCAPTURE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Applications can call the <a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_G_CROP</span></a>
ioctl to determine if the device supports capturing a subsection
of the full picture (“cropping” in V4L2). If not, the ioctl
returns the <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> error code. For more information on cropping
and scaling see <a class="reference internal" href="crop.html#crop"><span class="std std-ref">Image Cropping, Insertion and Scaling – the CROP API</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_MPEG_DECODER</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Applications can enumerate the supported image formats with the
<a class="reference internal" href="vidioc-enum-fmt.html#vidioc-enum-fmt"><span class="std std-ref">ioctl VIDIOC_ENUM_FMT</span></a> ioctl to determine if
the device supports MPEG streams.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_MPEG_ENCODER</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>See above.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_MJPEG_DECODER</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>See above.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VID_TYPE_MJPEG_ENCODER</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>See above.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">audios</span></code> field was replaced by <code class="docutils literal notranslate"><span class="pre">capabilities</span></code> flag
<code class="docutils literal notranslate"><span class="pre">V4L2_CAP_AUDIO</span></code>, indicating <em>if</em> the device has any audio inputs or
outputs. To determine their number applications can enumerate audio
inputs with the <a class="reference internal" href="vidioc-g-audio.html#vidioc-g-audio"><span class="std std-ref">VIDIOC_G_AUDIO</span></a> ioctl. The
audio ioctls are described in <a class="reference internal" href="audio.html#audio"><span class="std std-ref">Audio Inputs and Outputs</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">maxwidth</span></code>, <code class="docutils literal notranslate"><span class="pre">maxheight</span></code>, <code class="docutils literal notranslate"><span class="pre">minwidth</span></code> and <code class="docutils literal notranslate"><span class="pre">minheight</span></code> fields
were removed. Calling the <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a> or
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_TRY_FMT</span></a> ioctl with the desired
dimensions returns the closest size possible, taking into account the
current video standard, cropping and scaling limitations.</p>
</section>
<section id="video-sources">
<h2><span class="section-number">6.1.3. </span>Video Sources<a class="headerlink" href="#video-sources" title="Permalink to this headline">¶</a></h2>
<p>V4L provides the <code class="docutils literal notranslate"><span class="pre">VIDIOCGCHAN</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSCHAN</span></code> ioctl using struct
<code class="docutils literal notranslate"><span class="pre">video_channel</span></code> to enumerate the video inputs of a V4L
device. The equivalent V4L2 ioctls are
<a class="reference internal" href="vidioc-enuminput.html#vidioc-enuminput"><span class="std std-ref">ioctl VIDIOC_ENUMINPUT</span></a>,
<a class="reference internal" href="vidioc-g-input.html#vidioc-g-input"><span class="std std-ref">VIDIOC_G_INPUT</span></a> and
<a class="reference internal" href="vidioc-g-input.html#vidioc-g-input"><span class="std std-ref">VIDIOC_S_INPUT</span></a> using struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_input</span></code> as discussed in <a class="reference internal" href="video.html#video"><span class="std std-ref">Video Inputs and Outputs</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">channel</span></code> field counting inputs was renamed to <code class="docutils literal notranslate"><span class="pre">index</span></code>, the
video input types were renamed as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>struct <code class="docutils literal notranslate"><span class="pre">video_channel</span></code> <code class="docutils literal notranslate"><span class="pre">type</span></code></p></th>
<th class="head"><p>struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_input</span></code> <code class="docutils literal notranslate"><span class="pre">type</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_TYPE_TV</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_INPUT_TYPE_TUNER</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_TYPE_CAMERA</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_INPUT_TYPE_CAMERA</span></code></p></td>
</tr>
</tbody>
</table>
<p>Unlike the <code class="docutils literal notranslate"><span class="pre">tuners</span></code> field expressing the number of tuners of this
input, V4L2 assumes each video input is connected to at most one tuner.
However a tuner can have more than one input, i. e. RF connectors, and a
device can have multiple tuners. The index number of the tuner
associated with the input, if any, is stored in field <code class="docutils literal notranslate"><span class="pre">tuner</span></code> of
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_input</span></code>. Enumeration of tuners is
discussed in <a class="reference internal" href="tuner.html#tuner"><span class="std std-ref">Tuners and Modulators</span></a>.</p>
<p>The redundant <code class="docutils literal notranslate"><span class="pre">VIDEO_VC_TUNER</span></code> flag was dropped. Video inputs
associated with a tuner are of type <code class="docutils literal notranslate"><span class="pre">V4L2_INPUT_TYPE_TUNER</span></code>. The
<code class="docutils literal notranslate"><span class="pre">VIDEO_VC_AUDIO</span></code> flag was replaced by the <code class="docutils literal notranslate"><span class="pre">audioset</span></code> field. V4L2
considers devices with up to 32 audio inputs. Each set bit in the
<code class="docutils literal notranslate"><span class="pre">audioset</span></code> field represents one audio input this video input combines
with. For information about audio inputs and how to switch between them
see <a class="reference internal" href="audio.html#audio"><span class="std std-ref">Audio Inputs and Outputs</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">norm</span></code> field describing the supported video standards was replaced
by <code class="docutils literal notranslate"><span class="pre">std</span></code>. The V4L specification mentions a flag <code class="docutils literal notranslate"><span class="pre">VIDEO_VC_NORM</span></code>
indicating whether the standard can be changed. This flag was a later
addition together with the <code class="docutils literal notranslate"><span class="pre">norm</span></code> field and has been removed in the
meantime. V4L2 has a similar, albeit more comprehensive approach to
video standards, see <a class="reference internal" href="standard.html#standard"><span class="std std-ref">Video Standards</span></a> for more information.</p>
</section>
<section id="tuning">
<h2><span class="section-number">6.1.4. </span>Tuning<a class="headerlink" href="#tuning" title="Permalink to this headline">¶</a></h2>
<p>The V4L <code class="docutils literal notranslate"><span class="pre">VIDIOCGTUNER</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSTUNER</span></code> ioctl and struct
<code class="docutils literal notranslate"><span class="pre">video_tuner</span></code> can be used to enumerate the tuners of a
V4L TV or radio device. The equivalent V4L2 ioctls are
<a class="reference internal" href="vidioc-g-tuner.html#vidioc-g-tuner"><span class="std std-ref">VIDIOC_G_TUNER</span></a> and
<a class="reference internal" href="vidioc-g-tuner.html#vidioc-g-tuner"><span class="std std-ref">VIDIOC_S_TUNER</span></a> using struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner</span></code>. Tuners are covered in <a class="reference internal" href="tuner.html#tuner"><span class="std std-ref">Tuners and Modulators</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tuner</span></code> field counting tuners was renamed to <code class="docutils literal notranslate"><span class="pre">index</span></code>. The fields
<code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">rangelow</span></code> and <code class="docutils literal notranslate"><span class="pre">rangehigh</span></code> remained unchanged.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_PAL</span></code>, <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_NTSC</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_SECAM</span></code>
flags indicating the supported video standards were dropped. This
information is now contained in the associated struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_input</span></code>. No replacement exists for the
<code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_NORM</span></code> flag indicating whether the video standard can be
switched. The <code class="docutils literal notranslate"><span class="pre">mode</span></code> field to select a different video standard was
replaced by a whole new set of ioctls and structures described in
<a class="reference internal" href="standard.html#standard"><span class="std std-ref">Video Standards</span></a>. Due to its ubiquity it should be mentioned the BTTV
driver supports several standards in addition to the regular
<code class="docutils literal notranslate"><span class="pre">VIDEO_MODE_PAL</span></code> (0), <code class="docutils literal notranslate"><span class="pre">VIDEO_MODE_NTSC</span></code>, <code class="docutils literal notranslate"><span class="pre">VIDEO_MODE_SECAM</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDEO_MODE_AUTO</span></code> (3). Namely N/PAL Argentina, M/PAL, N/PAL, and NTSC
Japan with numbers 3-6 (sic).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_STEREO_ON</span></code> flag indicating stereo reception became
<code class="docutils literal notranslate"><span class="pre">V4L2_TUNER_SUB_STEREO</span></code> in field <code class="docutils literal notranslate"><span class="pre">rxsubchans</span></code>. This field also
permits the detection of monaural and bilingual audio, see the
definition of struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner</span></code> for details.
Presently no replacement exists for the <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_RDS_ON</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_MBS_ON</span></code> flags.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDEO_TUNER_LOW</span></code> flag was renamed to <code class="docutils literal notranslate"><span class="pre">V4L2_TUNER_CAP_LOW</span></code> in
the struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner</span></code> <code class="docutils literal notranslate"><span class="pre">capability</span></code> field.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDIOCGFREQ</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSFREQ</span></code> ioctl to change the tuner
frequency where renamed to
<a class="reference internal" href="vidioc-g-frequency.html#vidioc-g-frequency"><span class="std std-ref">VIDIOC_G_FREQUENCY</span></a> and
<a class="reference internal" href="vidioc-g-frequency.html#vidioc-g-frequency"><span class="std std-ref">VIDIOC_S_FREQUENCY</span></a>. They take a pointer
to a struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_frequency</span></code> instead of an
unsigned long integer.</p>
</section>
<section id="image-properties">
<span id="v4l-image-properties"></span><h2><span class="section-number">6.1.5. </span>Image Properties<a class="headerlink" href="#image-properties" title="Permalink to this headline">¶</a></h2>
<p>V4L2 has no equivalent of the <code class="docutils literal notranslate"><span class="pre">VIDIOCGPICT</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSPICT</span></code> ioctl
and struct <code class="docutils literal notranslate"><span class="pre">video_picture</span></code>. The following fields where
replaced by V4L2 controls accessible with the
<a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">ioctls VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL and VIDIOC_QUERYMENU</span></a>,
<a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_G_CTRL</span></a> and
<a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_S_CTRL</span></a> ioctls:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>struct <code class="docutils literal notranslate"><span class="pre">video_picture</span></code></p></th>
<th class="head"><p>V4L2 Control ID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">brightness</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_BRIGHTNESS</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hue</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_HUE</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">colour</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_SATURATION</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">contrast</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_CONTRAST</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">whiteness</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_WHITENESS</span></code></p></td>
</tr>
</tbody>
</table>
<p>The V4L picture controls are assumed to range from 0 to 65535 with no
particular reset value. The V4L2 API permits arbitrary limits and
defaults which can be queried with the
<a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">ioctls VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL and VIDIOC_QUERYMENU</span></a> ioctl. For general
information about controls see <a class="reference internal" href="control.html#control"><span class="std std-ref">User Controls</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">depth</span></code> (average number of bits per pixel) of a video image is
implied by the selected image format. V4L2 does not explicitly provide
such information assuming applications recognizing the format are aware
of the image depth and others need not know. The <code class="docutils literal notranslate"><span class="pre">palette</span></code> field moved
into the struct <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_pix_format</span></code></a>:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>struct <code class="docutils literal notranslate"><span class="pre">video_picture</span></code> <code class="docutils literal notranslate"><span class="pre">palette</span></code></p></th>
<th class="head"><p>struct <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_pix_format</span></code></a> <code class="docutils literal notranslate"><span class="pre">pixfmt</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_GREY</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-yuv-luma.html#v4l2-pix-fmt-grey"><span class="std std-ref">V4L2_PIX_FMT_GREY</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_HI240</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-reserved.html#pixfmt-reserved"><span class="std std-ref">V4L2_PIX_FMT_HI240</span></a> <a class="footnote-reference brackets" href="#f3" id="id3">3</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RGB565</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">V4L2_PIX_FMT_RGB565</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RGB555</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">V4L2_PIX_FMT_RGB555</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RGB24</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">V4L2_PIX_FMT_BGR24</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RGB32</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">V4L2_PIX_FMT_BGR32</span></a> <a class="footnote-reference brackets" href="#f4" id="id4">4</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV422</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuyv"><span class="std std-ref">V4L2_PIX_FMT_YUYV</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUYV</span></code> <a class="footnote-reference brackets" href="#f5" id="id5">5</a></p></td>
<td><p><a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-yuyv"><span class="std std-ref">V4L2_PIX_FMT_YUYV</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_UYVY</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-uyvy"><span class="std std-ref">V4L2_PIX_FMT_UYVY</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV420</span></code></p></td>
<td><p>None</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV411</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-packed-yuv.html#v4l2-pix-fmt-y41p"><span class="std std-ref">V4L2_PIX_FMT_Y41P</span></a> <a class="footnote-reference brackets" href="#f6" id="id6">6</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RAW</span></code></p></td>
<td><p>None <a class="footnote-reference brackets" href="#f7" id="id7">7</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV422P</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv422p"><span class="std std-ref">V4L2_PIX_FMT_YUV422P</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV411P</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yuv411p"><span class="std std-ref">V4L2_PIX_FMT_YUV411P</span></a> <a class="footnote-reference brackets" href="#f8" id="id8">8</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV420P</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu420"><span class="std std-ref">V4L2_PIX_FMT_YVU420</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV410P</span></code></p></td>
<td><p><a class="reference internal" href="pixfmt-yuv-planar.html#v4l2-pix-fmt-yvu410"><span class="std std-ref">V4L2_PIX_FMT_YVU410</span></a></p></td>
</tr>
</tbody>
</table>
<p>V4L2 image formats are defined in <a class="reference internal" href="pixfmt.html#pixfmt"><span class="std std-ref">Image Formats</span></a>. The image format can
be selected with the <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a> ioctl.</p>
</section>
<section id="audio">
<h2><span class="section-number">6.1.6. </span>Audio<a class="headerlink" href="#audio" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDIOCGAUDIO</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSAUDIO</span></code> ioctl and struct
<code class="docutils literal notranslate"><span class="pre">video_audio</span></code> are used to enumerate the audio inputs
of a V4L device. The equivalent V4L2 ioctls are
<a class="reference internal" href="vidioc-g-audio.html#vidioc-g-audio"><span class="std std-ref">VIDIOC_G_AUDIO</span></a> and
<a class="reference internal" href="vidioc-g-audio.html#vidioc-g-audio"><span class="std std-ref">VIDIOC_S_AUDIO</span></a> using struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_audio</span></code> as discussed in <a class="reference internal" href="audio.html#audio"><span class="std std-ref">Audio Inputs and Outputs</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">audio</span></code> “channel number” field counting audio inputs was renamed
to <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<p>On <code class="docutils literal notranslate"><span class="pre">VIDIOCSAUDIO</span></code> the <code class="docutils literal notranslate"><span class="pre">mode</span></code> field selects <em>one</em> of the
<code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_MONO</span></code>, <code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_STEREO</span></code>, <code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_LANG1</span></code> or
<code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_LANG2</span></code> audio demodulation modes. When the current audio
standard is BTSC <code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_LANG2</span></code> refers to SAP and
<code class="docutils literal notranslate"><span class="pre">VIDEO_SOUND_LANG1</span></code> is meaningless. Also undocumented in the V4L
specification, there is no way to query the selected mode. On
<code class="docutils literal notranslate"><span class="pre">VIDIOCGAUDIO</span></code> the driver returns the <em>actually received</em> audio
programmes in this field. In the V4L2 API this information is stored in
the struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_tuner</span></code> <code class="docutils literal notranslate"><span class="pre">rxsubchans</span></code> and
<code class="docutils literal notranslate"><span class="pre">audmode</span></code> fields, respectively. See <a class="reference internal" href="tuner.html#tuner"><span class="std std-ref">Tuners and Modulators</span></a> for more
information on tuners. Related to audio modes struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_audio</span></code> also reports if this is a mono or
stereo input, regardless if the source is a tuner.</p>
<p>The following fields where replaced by V4L2 controls accessible with the
<a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">ioctls VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL and VIDIOC_QUERYMENU</span></a>,
<a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_G_CTRL</span></a> and
<a class="reference internal" href="vidioc-g-ctrl.html#vidioc-g-ctrl"><span class="std std-ref">VIDIOC_S_CTRL</span></a> ioctls:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>struct <code class="docutils literal notranslate"><span class="pre">video_audio</span></code></p></th>
<th class="head"><p>V4L2 Control ID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">volume</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_AUDIO_VOLUME</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bass</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_AUDIO_BASS</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">treble</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_AUDIO_TREBLE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">balance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">V4L2_CID_AUDIO_BALANCE</span></code></p></td>
</tr>
</tbody>
</table>
<p>To determine which of these controls are supported by a driver V4L
provides the <code class="docutils literal notranslate"><span class="pre">flags</span></code> <code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_VOLUME</span></code>, <code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_BASS</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_TREBLE</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_BALANCE</span></code>. In the V4L2 API the
<a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">ioctls VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL and VIDIOC_QUERYMENU</span></a> ioctl reports if the
respective control is supported. Accordingly the <code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_MUTABLE</span></code>
and <code class="docutils literal notranslate"><span class="pre">VIDEO_AUDIO_MUTE</span></code> flags where replaced by the boolean
<code class="docutils literal notranslate"><span class="pre">V4L2_CID_AUDIO_MUTE</span></code> control.</p>
<p>All V4L2 controls have a <code class="docutils literal notranslate"><span class="pre">step</span></code> attribute replacing the struct
<code class="docutils literal notranslate"><span class="pre">video_audio</span></code> <code class="docutils literal notranslate"><span class="pre">step</span></code> field. The V4L audio controls
are assumed to range from 0 to 65535 with no particular reset value. The
V4L2 API permits arbitrary limits and defaults which can be queried with
the <a class="reference internal" href="vidioc-queryctrl.html#vidioc-queryctrl"><span class="std std-ref">ioctls VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL and VIDIOC_QUERYMENU</span></a> ioctl. For general
information about controls see <a class="reference internal" href="control.html#control"><span class="std std-ref">User Controls</span></a>.</p>
</section>
<section id="frame-buffer-overlay">
<h2><span class="section-number">6.1.7. </span>Frame Buffer Overlay<a class="headerlink" href="#frame-buffer-overlay" title="Permalink to this headline">¶</a></h2>
<p>The V4L2 ioctls equivalent to <code class="docutils literal notranslate"><span class="pre">VIDIOCGFBUF</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSFBUF</span></code> are
<a class="reference internal" href="vidioc-g-fbuf.html#vidioc-g-fbuf"><span class="std std-ref">VIDIOC_G_FBUF</span></a> and
<a class="reference internal" href="vidioc-g-fbuf.html#vidioc-g-fbuf"><span class="std std-ref">VIDIOC_S_FBUF</span></a>. The <code class="docutils literal notranslate"><span class="pre">base</span></code> field of struct
<code class="docutils literal notranslate"><span class="pre">video_buffer</span></code> remained unchanged, except V4L2 defines
a flag to indicate non-destructive overlays instead of a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
pointer. All other fields moved into the struct
<a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_pix_format</span></code></a> <code class="docutils literal notranslate"><span class="pre">fmt</span></code> substructure of
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_framebuffer</span></code>. The <code class="docutils literal notranslate"><span class="pre">depth</span></code>
field was replaced by <code class="docutils literal notranslate"><span class="pre">pixelformat</span></code>. See <a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">RGB Formats</span></a> for a
list of RGB formats and their respective color depths.</p>
<p>Instead of the special ioctls <code class="docutils literal notranslate"><span class="pre">VIDIOCGWIN</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSWIN</span></code> V4L2
uses the general-purpose data format negotiation ioctls
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_G_FMT</span></a> and
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a>. They take a pointer to a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_format</span></code> as argument. Here the <code class="docutils literal notranslate"><span class="pre">win</span></code> member
of the <code class="docutils literal notranslate"><span class="pre">fmt</span></code> union is used, a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_window</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> fields of struct
<code class="docutils literal notranslate"><span class="pre">video_window</span></code> moved into struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_rect</span></code> substructure <code class="docutils literal notranslate"><span class="pre">w</span></code> of struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_window</span></code>. The <code class="docutils literal notranslate"><span class="pre">chromakey</span></code>, <code class="docutils literal notranslate"><span class="pre">clips</span></code>, and
<code class="docutils literal notranslate"><span class="pre">clipcount</span></code> fields remained unchanged. Struct
<code class="docutils literal notranslate"><span class="pre">video_clip</span></code> was renamed to struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_clip</span></code>, also containing a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_rect</span></code>, but the semantics are still the same.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDEO_WINDOW_INTERLACE</span></code> flag was dropped. Instead applications
must set the <code class="docutils literal notranslate"><span class="pre">field</span></code> field to <code class="docutils literal notranslate"><span class="pre">V4L2_FIELD_ANY</span></code> or
<code class="docutils literal notranslate"><span class="pre">V4L2_FIELD_INTERLACED</span></code>. The <code class="docutils literal notranslate"><span class="pre">VIDEO_WINDOW_CHROMAKEY</span></code> flag moved
into struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_framebuffer</span></code>, under the new
name <code class="docutils literal notranslate"><span class="pre">V4L2_FBUF_FLAG_CHROMAKEY</span></code>.</p>
<p>In V4L, storing a bitmap pointer in <code class="docutils literal notranslate"><span class="pre">clips</span></code> and setting <code class="docutils literal notranslate"><span class="pre">clipcount</span></code>
to <code class="docutils literal notranslate"><span class="pre">VIDEO_CLIP_BITMAP</span></code> (-1) requests bitmap clipping, using a fixed
size bitmap of 1024 × 625 bits. Struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_window</span></code>
has a separate <code class="docutils literal notranslate"><span class="pre">bitmap</span></code> pointer field for this purpose and the bitmap
size is determined by <code class="docutils literal notranslate"><span class="pre">w.width</span></code> and <code class="docutils literal notranslate"><span class="pre">w.height</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDIOCCAPTURE</span></code> ioctl to enable or disable overlay was renamed to
<a class="reference internal" href="vidioc-overlay.html#vidioc-overlay"><span class="std std-ref">ioctl VIDIOC_OVERLAY</span></a>.</p>
</section>
<section id="cropping">
<h2><span class="section-number">6.1.8. </span>Cropping<a class="headerlink" href="#cropping" title="Permalink to this headline">¶</a></h2>
<p>To capture only a subsection of the full picture V4L defines the
<code class="docutils literal notranslate"><span class="pre">VIDIOCGCAPTURE</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSCAPTURE</span></code> ioctls using struct
<code class="docutils literal notranslate"><span class="pre">video_capture</span></code>. The equivalent V4L2 ioctls are
<a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_G_CROP</span></a> and
<a class="reference internal" href="vidioc-g-crop.html#vidioc-g-crop"><span class="std std-ref">VIDIOC_S_CROP</span></a> using struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_crop</span></code>, and the related
<a class="reference internal" href="vidioc-cropcap.html#vidioc-cropcap"><span class="std std-ref">ioctl VIDIOC_CROPCAP</span></a> ioctl. This is a rather
complex matter, see <a class="reference internal" href="crop.html#crop"><span class="std std-ref">Image Cropping, Insertion and Scaling – the CROP API</span></a> for details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> fields moved into struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_rect</span></code> substructure <code class="docutils literal notranslate"><span class="pre">c</span></code> of struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_crop</span></code>. The <code class="docutils literal notranslate"><span class="pre">decimation</span></code> field was dropped. In
the V4L2 API the scaling factor is implied by the size of the cropping
rectangle and the size of the captured or overlaid image.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDEO_CAPTURE_ODD</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDEO_CAPTURE_EVEN</span></code> flags to capture
only the odd or even field, respectively, were replaced by
<code class="docutils literal notranslate"><span class="pre">V4L2_FIELD_TOP</span></code> and <code class="docutils literal notranslate"><span class="pre">V4L2_FIELD_BOTTOM</span></code> in the field named
<code class="docutils literal notranslate"><span class="pre">field</span></code> of struct <a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_pix_format</span></code></a> and
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_window</span></code>. These structures are used to
select a capture or overlay format with the
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a> ioctl.</p>
</section>
<section id="reading-images-memory-mapping">
<h2><span class="section-number">6.1.9. </span>Reading Images, Memory Mapping<a class="headerlink" href="#reading-images-memory-mapping" title="Permalink to this headline">¶</a></h2>
<section id="capturing-using-the-read-method">
<h3><span class="section-number">6.1.9.1. </span>Capturing using the read method<a class="headerlink" href="#capturing-using-the-read-method" title="Permalink to this headline">¶</a></h3>
<p>There is no essential difference between reading images from a V4L or
V4L2 device using the <code class="xref c c-func docutils literal notranslate"><span class="pre">read()</span></code> function, however V4L2
drivers are not required to support this I/O method. Applications can
determine if the function is available with the
<a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">ioctl VIDIOC_QUERYCAP</span></a> ioctl. All V4L2 devices
exchanging data with applications must support the
<code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code>
functions.</p>
<p>To select an image format and size, V4L provides the <code class="docutils literal notranslate"><span class="pre">VIDIOCSPICT</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDIOCSWIN</span></code> ioctls. V4L2 uses the general-purpose data format
negotiation ioctls <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_G_FMT</span></a> and
<a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a>. They take a pointer to a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_format</span></code> as argument, here the struct
<a class="reference internal" href="pixfmt-v4l2.html#c.v4l2_pix_format" title="v4l2_pix_format"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_pix_format</span></code></a> named <code class="docutils literal notranslate"><span class="pre">pix</span></code> of its
<code class="docutils literal notranslate"><span class="pre">fmt</span></code> union is used.</p>
<p>For more information about the V4L2 read interface see <a class="reference internal" href="rw.html#rw"><span class="std std-ref">Read/Write</span></a>.</p>
</section>
<section id="capturing-using-memory-mapping">
<h3><span class="section-number">6.1.9.2. </span>Capturing using memory mapping<a class="headerlink" href="#capturing-using-memory-mapping" title="Permalink to this headline">¶</a></h3>
<p>Applications can read from V4L devices by mapping buffers in device
memory, or more often just buffers allocated in DMA-able system memory,
into their address space. This avoids the data copying overhead of the
read method. V4L2 supports memory mapping as well, with a few
differences.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>V4L</p></th>
<th class="head"><p>V4L2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
<td><p>The image format must be selected before buffers are allocated,
with the <a class="reference internal" href="vidioc-g-fmt.html#vidioc-g-fmt"><span class="std std-ref">VIDIOC_S_FMT</span></a> ioctl. When no
format is selected the driver may use the last, possibly by
another application requested format.</p></td>
</tr>
<tr class="row-odd"><td><p>Applications cannot change the number of buffers. The it is built
into the driver, unless it has a module option to change the
number when the driver module is loaded.</p></td>
<td><p>The <a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">ioctl VIDIOC_REQBUFS</span></a> ioctl allocates the
desired number of buffers, this is a required step in the
initialization sequence.</p></td>
</tr>
<tr class="row-even"><td><p>Drivers map all buffers as one contiguous range of memory. The
<code class="docutils literal notranslate"><span class="pre">VIDIOCGMBUF</span></code> ioctl is available to query the number of buffers,
the offset of each buffer from the start of the virtual file, and
the overall amount of memory used, which can be used as arguments
for the <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> function.</p></td>
<td><p>Buffers are individually mapped. The offset and size of each
buffer can be determined with the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">ioctl VIDIOC_QUERYBUF</span></a> ioctl.</p></td>
</tr>
<tr class="row-odd"><td><p>The <code class="docutils literal notranslate"><span class="pre">VIDIOCMCAPTURE</span></code> ioctl prepares a buffer for capturing. It
also determines the image format for this buffer. The ioctl
returns immediately, eventually with an <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> error code if no
video signal had been detected. When the driver supports more than
one buffer applications can call the ioctl multiple times and thus
have multiple outstanding capture requests.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDIOCSYNC</span></code> ioctl suspends execution until a particular
buffer has been filled.</p>
</td>
<td><p>Drivers maintain an incoming and outgoing queue.
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a> enqueues any empty buffer into
the incoming queue. Filled buffers are dequeued from the outgoing
queue with the <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a> ioctl. To wait
until filled buffers become available this function,
<code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code> can
be used. The <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</span></a> ioctl
must be called once after enqueuing one or more buffers to start
capturing. Its counterpart
<a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a> stops capturing and
dequeues all buffers from both queues. Applications can query the
signal status, if known, with the
<a class="reference internal" href="vidioc-enuminput.html#vidioc-enuminput"><span class="std std-ref">ioctl VIDIOC_ENUMINPUT</span></a> ioctl.</p></td>
</tr>
</tbody>
</table>
<p>For a more in-depth discussion of memory mapping and examples, see
<a class="reference internal" href="mmap.html#mmap"><span class="std std-ref">Streaming I/O (Memory Mapping)</span></a>.</p>
</section>
</section>
<section id="reading-raw-vbi-data">
<h2><span class="section-number">6.1.10. </span>Reading Raw VBI Data<a class="headerlink" href="#reading-raw-vbi-data" title="Permalink to this headline">¶</a></h2>
<p>Originally the V4L API did not specify a raw VBI capture interface, only
the device file <code class="docutils literal notranslate"><span class="pre">/dev/vbi</span></code> was reserved for this purpose. The only
driver supporting this interface was the BTTV driver, de-facto defining
the V4L VBI interface. Reading from the device yields a raw VBI image
with the following parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_vbi_format</span></code></p></th>
<th class="head"><p>V4L, BTTV driver</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sampling_rate</p></td>
<td><p>28636363 Hz NTSC (or any other 525-line standard); 35468950 Hz PAL
and SECAM (625-line standards)</p></td>
</tr>
<tr class="row-odd"><td><p>offset</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p>samples_per_line</p></td>
<td><p>2048</p></td>
</tr>
<tr class="row-odd"><td><p>sample_format</p></td>
<td><p>V4L2_PIX_FMT_GREY. The last four bytes (a machine endianness
integer) contain a frame counter.</p></td>
</tr>
<tr class="row-even"><td><p>start[]</p></td>
<td><p>10, 273 NTSC; 22, 335 PAL and SECAM</p></td>
</tr>
<tr class="row-odd"><td><p>count[]</p></td>
<td><p>16, 16 <a class="footnote-reference brackets" href="#f9" id="id9">9</a></p></td>
</tr>
<tr class="row-even"><td><p>flags</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>Undocumented in the V4L specification, in Linux 2.3 the
<code class="docutils literal notranslate"><span class="pre">VIDIOCGVBIFMT</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOCSVBIFMT</span></code> ioctls using struct
<code class="docutils literal notranslate"><span class="pre">vbi_format</span></code> were added to determine the VBI image
parameters. These ioctls are only partially compatible with the V4L2 VBI
interface specified in <a class="reference internal" href="dev-raw-vbi.html#raw-vbi"><span class="std std-ref">Raw VBI Data Interface</span></a>.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">offset</span></code> field does not exist, <code class="docutils literal notranslate"><span class="pre">sample_format</span></code> is supposed to be
<code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_RAW</span></code>, equivalent to <code class="docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_GREY</span></code>. The
remaining fields are probably equivalent to struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_vbi_format</span></code>.</p>
<p>Apparently only the Zoran (ZR 36120) driver implements these ioctls. The
semantics differ from those specified for V4L2 in two ways. The
parameters are reset on <code class="xref c c-func docutils literal notranslate"><span class="pre">open()</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDIOCSVBIFMT</span></code> always returns an <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> error code if the parameters
are invalid.</p>
</section>
<section id="miscellaneous">
<h2><span class="section-number">6.1.11. </span>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>V4L2 has no equivalent of the <code class="docutils literal notranslate"><span class="pre">VIDIOCGUNIT</span></code> ioctl. Applications can
find the VBI device associated with a video capture device (or vice
versa) by reopening the device and requesting VBI data. For details see
<a class="reference internal" href="open.html#open"><span class="std std-ref">Opening and Closing Devices</span></a>.</p>
<p>No replacement exists for <code class="docutils literal notranslate"><span class="pre">VIDIOCKEY</span></code>, and the V4L functions for
microcode programming. A new interface for MPEG compression and playback
devices is documented in <a class="reference internal" href="extended-controls.html#extended-controls"><span class="std std-ref">Extended Controls API</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>According to <a class="reference internal" href="../../../admin-guide/devices.html"><span class="doc">Linux allocated devices (4.x+ version)</span></a> these should be symbolic links
to <code class="docutils literal notranslate"><span class="pre">/dev/video0</span></code>. Note the original bttv interface is not
compatible with V4L or V4L2.</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>According to <code class="docutils literal notranslate"><span class="pre">Documentation/admin-guide/devices.rst</span></code> a symbolic link to
<code class="docutils literal notranslate"><span class="pre">/dev/radio0</span></code>.</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>This is a custom format used by the BTTV driver, not one of the V4L2
standard formats.</p>
</dd>
<dt class="label" id="f4"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Presumably all V4L RGB formats are little-endian, although some
drivers might interpret them according to machine endianness. V4L2
defines little-endian, big-endian and red/blue swapped variants. For
details see <a class="reference internal" href="pixfmt-rgb.html#pixfmt-rgb"><span class="std std-ref">RGB Formats</span></a>.</p>
</dd>
<dt class="label" id="f5"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUV422</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDEO_PALETTE_YUYV</span></code> are the same
formats. Some V4L drivers respond to one, some to the other.</p>
</dd>
<dt class="label" id="f6"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Not to be confused with <code class="docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_YUV411P</span></code>, which is a planar
format.</p>
</dd>
<dt class="label" id="f7"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>V4L explains this as: “RAW capture (BT848)”</p>
</dd>
<dt class="label" id="f8"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>Not to be confused with <code class="docutils literal notranslate"><span class="pre">V4L2_PIX_FMT_Y41P</span></code>, which is a packed
format.</p>
</dd>
<dt class="label" id="f9"><span class="brackets"><a class="fn-backref" href="#id9">9</a></span></dt>
<dd><p>Old driver versions used different values, eventually the custom
<code class="docutils literal notranslate"><span class="pre">BTTV_VBISIZE</span></code> ioctl was added to query the correct values.</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.1. Differences between V4L and V4L2</a><ul>
<li><a class="reference internal" href="#opening-and-closing-devices">6.1.1. Opening and Closing Devices</a></li>
<li><a class="reference internal" href="#querying-capabilities">6.1.2. Querying Capabilities</a></li>
<li><a class="reference internal" href="#video-sources">6.1.3. Video Sources</a></li>
<li><a class="reference internal" href="#tuning">6.1.4. Tuning</a></li>
<li><a class="reference internal" href="#image-properties">6.1.5. Image Properties</a></li>
<li><a class="reference internal" href="#audio">6.1.6. Audio</a></li>
<li><a class="reference internal" href="#frame-buffer-overlay">6.1.7. Frame Buffer Overlay</a></li>
<li><a class="reference internal" href="#cropping">6.1.8. Cropping</a></li>
<li><a class="reference internal" href="#reading-images-memory-mapping">6.1.9. Reading Images, Memory Mapping</a><ul>
<li><a class="reference internal" href="#capturing-using-the-read-method">6.1.9.1. Capturing using the read method</a></li>
<li><a class="reference internal" href="#capturing-using-memory-mapping">6.1.9.2. Capturing using memory mapping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reading-raw-vbi-data">6.1.10. Reading Raw VBI Data</a></li>
<li><a class="reference internal" href="#miscellaneous">6.1.11. Miscellaneous</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/v4l/diff-v4l.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/v4l/diff-v4l.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>