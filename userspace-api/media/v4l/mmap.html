
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3.2. Streaming I/O (Memory Mapping) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="3.3. Streaming I/O (User Pointers)" href="userp.html" />
    <link rel="prev" title="3.1. Read/Write" href="rw.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="streaming-i-o-memory-mapping">
<span id="mmap"></span><h1><span class="section-number">3.2. </span>Streaming I/O (Memory Mapping)<a class="headerlink" href="#streaming-i-o-memory-mapping" title="Permalink to this headline">¶</a></h1>
<p>Input and output devices support this I/O method when the
<code class="docutils literal notranslate"><span class="pre">V4L2_CAP_STREAMING</span></code> flag in the <code class="docutils literal notranslate"><span class="pre">capabilities</span></code> field of struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_capability</span></code> returned by the
<a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">ioctl VIDIOC_QUERYCAP</span></a> ioctl is set. There are two
streaming methods, to determine if the memory mapping flavor is
supported applications must call the <a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">ioctl VIDIOC_REQBUFS</span></a> ioctl
with the memory type set to <code class="docutils literal notranslate"><span class="pre">V4L2_MEMORY_MMAP</span></code>.</p>
<p>Streaming is an I/O method where only pointers to buffers are exchanged
between application and driver, the data itself is not copied. Memory
mapping is primarily intended to map buffers in device memory into the
application’s address space. Device memory can be for example the video
memory on a graphics card with a video capture add-on. However, being
the most efficient I/O method available for a long time, many other
drivers support streaming as well, allocating buffers in DMA-able main
memory.</p>
<p>A driver can support many sets of buffers. Each set is identified by a
unique buffer type value. The sets are independent and each set can hold
a different type of data. To access different sets at the same time
different file descriptors must be used. <a class="footnote-reference brackets" href="#f1" id="id1">1</a></p>
<p>To allocate device buffers applications call the
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">ioctl VIDIOC_REQBUFS</span></a> ioctl with the desired number
of buffers and buffer type, for example <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code>.
This ioctl can also be used to change the number of buffers or to free
the allocated memory, provided none of the buffers are still mapped.</p>
<p>Before applications can access the buffers they must map them into their
address space with the <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> function. The
location of the buffers in device memory can be determined with the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">ioctl VIDIOC_QUERYBUF</span></a> ioctl. In the single-planar
API case, the <code class="docutils literal notranslate"><span class="pre">m.offset</span></code> and <code class="docutils literal notranslate"><span class="pre">length</span></code> returned in a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code> are passed as sixth and second
parameter to the <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> function. When using the
multi-planar API, struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code> contains an
array of struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_plane</span></code> structures, each
containing its own <code class="docutils literal notranslate"><span class="pre">m.offset</span></code> and <code class="docutils literal notranslate"><span class="pre">length</span></code>. When using the
multi-planar API, every plane of every buffer has to be mapped
separately, so the number of calls to <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> should
be equal to number of buffers times number of planes in each buffer. The
offset and length values must not be modified. Remember, the buffers are
allocated in physical memory, as opposed to virtual memory, which can be
swapped out to disk. Applications should free the buffers as soon as
possible with the <code class="xref c c-func docutils literal notranslate"><span class="pre">munmap()</span></code> function.</p>
<section id="example-mapping-buffers-in-the-single-planar-api">
<h2><span class="section-number">3.2.1. </span>Example: Mapping buffers in the single-planar API<a class="headerlink" href="#example-mapping-buffers-in-the-single-planar-api" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_requestbuffers</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">buffers</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">));</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">;</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ioctl</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_REQBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EINVAL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Video capturing or mmap-streaming is not supported</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_REQBUFS&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* We want at least five buffers. */</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* You may need to free the buffers here. */</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Not enough buffer memory</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">buffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffers</span><span class="p">));</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">buffers</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">v4l2_buffer</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ioctl</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_QUERYBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_QUERYBUF&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="cm">/* remember for munmap() */</span><span class="w"></span>

<span class="w">    </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="cm">/* recommended */</span><span class="w"></span>
<span class="w">                </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w">             </span><span class="cm">/* recommended */</span><span class="w"></span>
<span class="w">                </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MAP_FAILED</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* If you do not exit here you should unmap() and free()</span>
<span class="cm">           the buffers mapped so far. */</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Cleanup. */</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">munmap</span><span class="p">(</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="example-mapping-buffers-in-the-multi-planar-api">
<h2><span class="section-number">3.2.2. </span>Example: Mapping buffers in the multi-planar API<a class="headerlink" href="#example-mapping-buffers-in-the-multi-planar-api" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_requestbuffers</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* Our current format uses 3 planes per buffer */</span><span class="w"></span>
<span class="cp">#define FMT_NUM_PLANES = 3</span>

<span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">buffers</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">));</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span><span class="p">;</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span><span class="w"></span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_REQBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EINVAL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Video capturing or mmap-streaming is not supported</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_REQBUFS&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* We want at least five buffers. */</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* You may need to free the buffers here. */</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Not enough buffer memory</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">buffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffers</span><span class="p">));</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">buffers</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">v4l2_buffer</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">v4l2_plane</span><span class="w"> </span><span class="n">planes</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* length in struct v4l2_buffer in multi-planar API stores the size</span>
<span class="cm">     * of planes array. */</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FMT_NUM_PLANES</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">planes</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_QUERYBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_QUERYBUF&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* Every plane has to be mapped separately */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FMT_NUM_PLANES</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="cm">/* remember for munmap() */</span><span class="w"></span>

<span class="w">        </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="cm">/* recommended */</span><span class="w"></span>
<span class="w">                 </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w">             </span><span class="cm">/* recommended */</span><span class="w"></span>
<span class="w">                 </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MAP_FAILED</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cm">/* If you do not exit here you should unmap() and free()</span>
<span class="cm">               the buffers and planes mapped so far. */</span><span class="w"></span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Cleanup. */</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FMT_NUM_PLANES</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">munmap</span><span class="p">(</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<p>Conceptually streaming drivers maintain two buffer queues, an incoming
and an outgoing queue. They separate the synchronous capture or output
operation locked to a video clock from the application which is subject
to random disk or network delays and preemption by other processes,
thereby reducing the probability of data loss. The queues are organized
as FIFOs, buffers will be output in the order enqueued in the incoming
FIFO, and were captured in the order dequeued from the outgoing FIFO.</p>
<p>The driver may require a minimum number of buffers enqueued at all times
to function, apart of this no limit exists on the number of buffers
applications can enqueue in advance, or dequeue and process. They can
also enqueue in a different order than buffers have been dequeued, and
the driver can <em>fill</em> enqueued <em>empty</em> buffers in any order.  <a class="footnote-reference brackets" href="#f2" id="id2">2</a> The
index number of a buffer (struct <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code>
<code class="docutils literal notranslate"><span class="pre">index</span></code>) plays no role here, it only identifies the buffer.</p>
<p>Initially all mapped buffers are in dequeued state, inaccessible by the
driver. For capturing applications it is customary to first enqueue all
mapped buffers, then to start capturing and enter the read loop. Here
the application waits until a filled buffer can be dequeued, and
re-enqueues the buffer when the data is no longer needed. Output
applications fill and enqueue buffers, when enough buffers are stacked
up the output is started with <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a>.
In the write loop, when the application runs out of free buffers, it
must wait until an empty buffer can be dequeued and reused.</p>
<p>To enqueue and dequeue a buffer applications use the
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_QBUF</span></a> and <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>
ioctl. The status of a buffer being mapped, enqueued, full or empty can
be determined at any time using the <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">ioctl VIDIOC_QUERYBUF</span></a> ioctl. Two
methods exist to suspend execution of the application until one or more
buffers can be dequeued.  By default <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>
blocks when no buffer is in the outgoing queue. When the <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code>
flag was given to the <code class="xref c c-func docutils literal notranslate"><span class="pre">open()</span></code> function,
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a> returns immediately with an <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code>
error code when no buffer is available. The <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code>
or <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code> functions are always available.</p>
<p>To start and stop capturing or output applications call the
<a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a> and <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a> ioctl.</p>
<p>Drivers implementing memory mapping I/O must support the
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">VIDIOC_REQBUFS</span></a>, <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">VIDIOC_QUERYBUF</span></a>, <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_QBUF</span></a>, <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>, <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a>
and <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a> ioctls, the <a class="reference internal" href="func-mmap.html#func-mmap"><span class="std std-ref">mmap()</span></a>, <code class="xref c c-func docutils literal notranslate"><span class="pre">munmap()</span></code>, <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> and <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code> function. <a class="footnote-reference brackets" href="#f3" id="id3">3</a></p>
<p>[capture example]</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>One could use one file descriptor and set the buffer type field
accordingly when calling <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a> etc.,
but it makes the <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> function ambiguous. We also
like the clean approach of one file descriptor per logical stream.
Video overlay for example is also a logical stream, although the CPU
is not needed for continuous operation.</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Random enqueue order permits applications processing images out of
order (such as video codecs) to return buffers earlier, reducing the
probability of data loss. Random fill order allows drivers to reuse
buffers on a LIFO-basis, taking advantage of caches holding
scatter-gather lists and the like.</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>At the driver level <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code> are
the same, and <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> is too important to be optional.
The rest should be evident.</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2. Streaming I/O (Memory Mapping)</a><ul>
<li><a class="reference internal" href="#example-mapping-buffers-in-the-single-planar-api">3.2.1. Example: Mapping buffers in the single-planar API</a></li>
<li><a class="reference internal" href="#example-mapping-buffers-in-the-multi-planar-api">3.2.2. Example: Mapping buffers in the multi-planar API</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/userspace-api/media/v4l/mmap.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/userspace-api/media/v4l/mmap.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>