
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Summary of CDROM ioctl calls &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Summary of HDIO_ ioctl calls" href="hdio.html" />
    <link rel="prev" title="Decoding an IOCTL Magic Number" href="ioctl-decoding.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="summary-of-cdrom-ioctl-calls">
<h1>Summary of CDROM ioctl calls<a class="headerlink" href="#summary-of-cdrom-ioctl-calls" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Edward A. Falk &lt;<a class="reference external" href="mailto:efalk&#37;&#52;&#48;google&#46;com">efalk<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</p></li>
</ul>
<p>November, 2004</p>
<p>This document attempts to describe the ioctl(2) calls supported by
the CDROM layer.  These are by-and-large implemented (as of Linux 2.6)
in drivers/cdrom/cdrom.c and drivers/block/scsi_ioctl.c</p>
<p>ioctl values are listed in &lt;linux/cdrom.h&gt;.  As of this writing, they
are as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDROMPAUSE</p></td>
<td><p>Pause Audio Operation</p></td>
</tr>
<tr class="row-even"><td><p>CDROMRESUME</p></td>
<td><p>Resume paused Audio Operation</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMPLAYMSF</p></td>
<td><p>Play Audio MSF (struct cdrom_msf)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMPLAYTRKIND</p></td>
<td><p>Play Audio Track/index (struct cdrom_ti)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADTOCHDR</p></td>
<td><p>Read TOC header (struct cdrom_tochdr)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADTOCENTRY</p></td>
<td><p>Read TOC entry (struct cdrom_tocentry)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSTOP</p></td>
<td><p>Stop the cdrom drive</p></td>
</tr>
<tr class="row-even"><td><p>CDROMSTART</p></td>
<td><p>Start the cdrom drive</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMEJECT</p></td>
<td><p>Ejects the cdrom media</p></td>
</tr>
<tr class="row-even"><td><p>CDROMVOLCTRL</p></td>
<td><p>Control output volume (struct cdrom_volctrl)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSUBCHNL</p></td>
<td><p>Read subchannel data (struct cdrom_subchnl)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADMODE2</p></td>
<td><p>Read CDROM mode 2 data (2336 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADMODE1</p></td>
<td><p>Read CDROM mode 1 data (2048 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADAUDIO</p></td>
<td><p>(struct cdrom_read_audio)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMEJECT_SW</p></td>
<td><p>enable(1)/disable(0) auto-ejecting</p></td>
</tr>
<tr class="row-even"><td><p>CDROMMULTISESSION</p></td>
<td><p>Obtain the start-of-last-session
address of multi session disks
(struct cdrom_multisession)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_GET_MCN</p></td>
<td><p>Obtain the “Universal Product Code”
if available (struct cdrom_mcn)</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_GET_UPC</p></td>
<td><p>Deprecated, use CDROM_GET_MCN instead.</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMRESET</p></td>
<td><p>hard-reset the drive</p></td>
</tr>
<tr class="row-even"><td><p>CDROMVOLREAD</p></td>
<td><p>Get the drive’s volume setting
(struct cdrom_volctrl)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADRAW</p></td>
<td><p>read data in raw mode (2352 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADCOOKED</p></td>
<td><p>read data in cooked mode</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSEEK</p></td>
<td><p>seek msf address</p></td>
</tr>
<tr class="row-even"><td><p>CDROMPLAYBLK</p></td>
<td><p>scsi-cd only, (struct cdrom_blk)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADALL</p></td>
<td><p>read all 2646 bytes</p></td>
</tr>
<tr class="row-even"><td><p>CDROMGETSPINDOWN</p></td>
<td><p>return 4-bit spindown value</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSETSPINDOWN</p></td>
<td><p>set 4-bit spindown value</p></td>
</tr>
<tr class="row-even"><td><p>CDROMCLOSETRAY</p></td>
<td><p>pendant of CDROMEJECT</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_SET_OPTIONS</p></td>
<td><p>Set behavior options</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_CLEAR_OPTIONS</p></td>
<td><p>Clear behavior options</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_SELECT_SPEED</p></td>
<td><p>Set the CD-ROM speed</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_SELECT_DISC</p></td>
<td><p>Select disc (for juke-boxes)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_MEDIA_CHANGED</p></td>
<td><p>Check is media changed</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_TIMED_MEDIA_CHANGE</p></td>
<td><p>Check if media changed
since given time
(struct cdrom_timed_media_change_info)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_DRIVE_STATUS</p></td>
<td><p>Get tray position, etc.</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_DISC_STATUS</p></td>
<td><p>Get disc type, etc.</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_CHANGER_NSLOTS</p></td>
<td><p>Get number of slots</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_LOCKDOOR</p></td>
<td><p>lock or unlock door</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_DEBUG</p></td>
<td><p>Turn debug messages on/off</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_GET_CAPABILITY</p></td>
<td><p>get capabilities</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMAUDIOBUFSIZ</p></td>
<td><p>set the audio buffer size</p></td>
</tr>
<tr class="row-even"><td><p>DVD_READ_STRUCT</p></td>
<td><p>Read structure</p></td>
</tr>
<tr class="row-odd"><td><p>DVD_WRITE_STRUCT</p></td>
<td><p>Write structure</p></td>
</tr>
<tr class="row-even"><td><p>DVD_AUTH</p></td>
<td><p>Authentication</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_SEND_PACKET</p></td>
<td><p>send a packet to the drive</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_NEXT_WRITABLE</p></td>
<td><p>get next writable block</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_LAST_WRITTEN</p></td>
<td><p>get last block written on disc</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The information that follows was determined from reading kernel source
code.  It is likely that some corrections will be made over time.</p>
<hr class="docutils" />
<p>General:</p>
<blockquote>
<div><p>Unless otherwise specified, all ioctl calls return 0 on success
and -1 with errno set to an appropriate value on error.  (Some
ioctls return non-negative data values.)</p>
<p>Unless otherwise specified, all ioctl calls return -1 and set
errno to EFAULT on a failed attempt to copy data to or from user
address space.</p>
<p>Individual drivers may return error codes not listed here.</p>
<p>Unless otherwise specified, all data structures and constants
are defined in &lt;linux/cdrom.h&gt;</p>
</div></blockquote>
<hr class="docutils" />
<dl>
<dt>CDROMPAUSE</dt><dd><p>Pause Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMPAUSE, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMRESUME</dt><dd><p>Resume paused Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESUME, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYMSF</dt><dd><p>Play Audio MSF</p>
<p>(struct cdrom_msf)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMPLAYMSF, &amp;msf);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_msf structure, describing a segment of music to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>MSF stands for minutes-seconds-frames</p></li>
<li><p>LBA stands for logical block address</p></li>
<li><p>Segment is described as start and end times, where each time
is described as minutes:seconds:frames.
A frame is 1/75 of a second.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYTRKIND</dt><dd><p>Play Audio Track/index</p>
<p>(struct cdrom_ti)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_ti ti;

ioctl(fd, CDROMPLAYTRKIND, &amp;ti);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_ti structure, describing a segment of music to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Segment is described as start and end times, where each time
is described as a track and an index.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCHDR</dt><dd><p>Read TOC header</p>
<p>(struct cdrom_tochdr)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cdrom_tochdr header;

ioctl(fd, CDROMREADTOCHDR, &amp;header);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_tochdr structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_tochdr structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCENTRY</dt><dd><p>Read TOC entry</p>
<p>(struct cdrom_tocentry)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_tocentry entry;

ioctl(fd, CDROMREADTOCENTRY, &amp;entry);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_tocentry structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_tocentry structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
<li><p>EINVAL      entry.cdte_format not CDROM_MSF or CDROM_LBA</p></li>
<li><p>EINVAL      requested track out of bounds</p></li>
<li><p>EIO         I/O error reading TOC</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>TOC stands for Table Of Contents</p></li>
<li><p>MSF stands for minutes-seconds-frames</p></li>
<li><p>LBA stands for logical block address</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTOP</dt><dd><p>Stop the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTOP, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive down.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTART</dt><dd><p>Start the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTART, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive up and/or close the tray.
Other devices ignore the ioctl completely.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT</dt><dd><ul class="simple">
<li><p>Ejects the cdrom media</p></li>
</ul>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMEJECT, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not capable of ejecting</p></li>
<li><p>EBUSY       other processes are accessing drive, or door is locked</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>See CDROM_LOCKDOOR, below.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMCLOSETRAY</dt><dd><p>pendant of CDROMEJECT</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMCLOSETRAY, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not capable of closing the tray</p></li>
<li><p>EBUSY       other processes are accessing drive, or door is locked</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>See CDROM_LOCKDOOR, below.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLCTRL</dt><dd><p>Control output volume (struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLCTRL, &amp;volume);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_volctrl structure containing volumes for up to 4
channels.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLREAD</dt><dd><p>Get the drive’s volume setting</p>
<p>(struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLREAD, &amp;volume);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The current volume settings.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSUBCHNL</dt><dd><p>Read subchannel data</p>
<p>(struct cdrom_subchnl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_subchnl q;

ioctl(fd, CDROMSUBCHNL, &amp;q);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_subchnl structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_subchnl structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Format is converted to CDROM_MSF or CDROM_LBA
as per user request on return</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADRAW</dt><dd><p>read data in raw mode (2352 Bytes)</p>
<p>(struct cdrom_read)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union {

  struct cdrom_msf msf;               /* input */
  char buffer[CD_FRAMESIZE_RAW];      /* return */
} arg;
ioctl(fd, CDROMREADRAW, &amp;arg);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>cdrom_msf structure indicating an address to read.</p>
<p>Only the start values are significant.</p>
</dd>
<dt>outputs:</dt><dd><p>Data written to address provided by user.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      address less than 0, or msf less than 0:2:0</p></li>
<li><p>ENOMEM      out of memory</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>As of 2.6.8.1, comments in &lt;linux/cdrom.h&gt; indicate that this
ioctl accepts a cdrom_read structure, but actual source code
reads a cdrom_msf structure and writes a buffer of data to
the same address.</p></li>
<li><p>MSF values are converted to LBA values via this formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lba = (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADMODE1</dt><dd><p>Read CDROM mode 1 data (2048 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="simple">
<dt>notes:</dt><dd><p>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE (2048) bytes</p>
</dd>
</dl>
</dd>
<dt>CDROMREADMODE2</dt><dd><p>Read CDROM mode 2 data (2336 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="simple">
<dt>notes:</dt><dd><p>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE_RAW0 (2336) bytes</p>
</dd>
</dl>
</dd>
<dt>CDROMREADAUDIO</dt><dd><p>(struct cdrom_read_audio)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_read_audio ra;

ioctl(fd, CDROMREADAUDIO, &amp;ra);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_read_audio structure containing read start
point and length</p>
</dd>
<dt>outputs:</dt><dd><p>audio data, returned to buffer indicated by ra</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
<li><p>EINVAL      nframes not in range [1 75]</p></li>
<li><p>ENXIO       drive has no queue (probably means invalid fd)</p></li>
<li><p>ENOMEM      out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT_SW</dt><dd><p>enable(1)/disable(0) auto-ejecting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, CDROMEJECT_SW, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Flag specifying auto-eject flag.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive is not capable of ejecting.</p></li>
<li><p>EBUSY       Door is locked</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMMULTISESSION</dt><dd><p>Obtain the start-of-last-session address of multi session disks</p>
<p>(struct cdrom_multisession)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_multisession ms_info;

ioctl(fd, CDROMMULTISESSION, &amp;ms_info);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>cdrom_multisession structure containing desired</p>
</div></blockquote>
<p>format.</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_multisession structure is filled with last_session
information.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_MCN</dt><dd><p>Obtain the “Universal Product Code”
if available</p>
<p>(struct cdrom_mcn)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_mcn mcn;

ioctl(fd, CDROM_GET_MCN, &amp;mcn);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>Universal Product Code</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive is not capable of reading MCN data.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The following function is implemented, although very few
audio discs give Universal Product Code information, which
should just be the Medium Catalog Number on the box.  Note,
that the way the code is written on the CD is /not/ uniform
across all discs!
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_UPC</dt><dd><p>CDROM_GET_MCN  (deprecated)</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>CDROMRESET</dt><dd><p>hard-reset the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESET, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>ENOSYS      Drive is not capable of resetting.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADCOOKED</dt><dd><p>read data in cooked mode</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 buffer[CD_FRAMESIZE]

ioctl(fd, CDROMREADCOOKED, buffer);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>2048 bytes of data, “cooked” mode.</p>
</dd>
<dt>notes:</dt><dd><p>Not implemented on all drives.</p>
</dd>
</dl>
</dd>
<dt>CDROMREADALL</dt><dd><p>read all 2646 bytes</p>
<p>Same as CDROMREADCOOKED, but reads 2646 bytes.</p>
</dd>
<dt>CDROMSEEK</dt><dd><p>seek msf address</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMSEEK, &amp;msf);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>MSF address to seek to.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROMPLAYBLK</dt><dd><p>scsi-cd only</p>
<p>(struct cdrom_blk)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_blk blk;

ioctl(fd, CDROMPLAYBLK, &amp;blk);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Region to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROMGETSPINDOWN</dt><dd><p>Obsolete, was ide-cd only</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown;

ioctl(fd, CDROMGETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current 4-bit spindown value.</p>
</dd>
</dl>
</dd>
<dt>CDROMSETSPINDOWN</dt><dd><p>Obsolete, was ide-cd only</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown

ioctl(fd, CDROMSETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>4-bit value used to control spindown (TODO: more detail here)</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROM_SET_OPTIONS</dt><dd><p>Set behavior options</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int options;

ioctl(fd, CDROM_SET_OPTIONS, options);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>New values for drive options.  The logical ‘or’ of:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDO_AUTO_CLOSE</p></td>
<td><p>close tray on first open(2)</p></td>
</tr>
<tr class="row-even"><td><p>CDO_AUTO_EJECT</p></td>
<td><p>open tray on last release</p></td>
</tr>
<tr class="row-odd"><td><p>CDO_USE_FFLAGS</p></td>
<td><p>use O_NONBLOCK information on open</p></td>
</tr>
<tr class="row-even"><td><p>CDO_LOCK</p></td>
<td><p>lock tray on open files</p></td>
</tr>
<tr class="row-odd"><td><p>CDO_CHECK_TYPE</p></td>
<td><p>check type on open for data</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><p>Returns the resulting options settings in the
ioctl return value.  Returns -1 on error.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      selected option(s) not supported by drive.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CLEAR_OPTIONS</dt><dd><p>Clear behavior options</p>
<p>Same as CDROM_SET_OPTIONS, except that selected options are
turned off.</p>
</dd>
<dt>CDROM_SELECT_SPEED</dt><dd><p>Set the CD-ROM speed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int speed;

ioctl(fd, CDROM_SELECT_SPEED, speed);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New drive speed.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      speed selection not supported by drive.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_SELECT_DISC</dt><dd><p>Select disc (for juke-boxes)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int disk;

ioctl(fd, CDROM_SELECT_DISC, disk);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Disk to load into drive.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Disk number beyond capacity of drive</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_MEDIA_CHANGED</dt><dd><p>Check is media changed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_MEDIA_CHANGED, slot);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Slot number to be tested, always zero except for jukeboxes.</p>
<p>May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value is 0 or 1 depending on whether the media</p>
</div></blockquote>
<p>has been changed, or -1 on error.</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive can’t detect media change</p></li>
<li><p>EINVAL      Slot number beyond capacity of drive</p></li>
<li><p>ENOMEM      Out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DRIVE_STATUS</dt><dd><p>Get tray position, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_DRIVE_STATUS, slot);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Slot number to be tested, always zero except for jukeboxes.</p>
<p>May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value will be one of the following values</p>
</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDS_NO_INFO</p></td>
<td><p>Information not available.</p></td>
</tr>
<tr class="row-even"><td><p>CDS_NO_DISC</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CDS_TRAY_OPEN</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>CDS_DRIVE_NOT_READY</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CDS_DISC_OK</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive can’t detect drive status</p></li>
<li><p>EINVAL      Slot number beyond capacity of drive</p></li>
<li><p>ENOMEM      Out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DISC_STATUS</dt><dd><p>Get disc type, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_DISC_STATUS, 0);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value will be one of the following values</p>
</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote>
<div><ul class="simple">
<li><p>CDS_NO_INFO</p></li>
<li><p>CDS_AUDIO</p></li>
<li><p>CDS_MIXED</p></li>
<li><p>CDS_XA_2_2</p></li>
<li><p>CDS_XA_2_1</p></li>
<li><p>CDS_DATA_1</p></li>
</ul>
</div></blockquote>
</dd>
<dt>error returns:</dt><dd><p>none at present</p>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ok, this is where problems start.  The current interface for
the CDROM_DISC_STATUS ioctl is flawed.  It makes the false
assumption that CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.
Unfortunately, while this is often the case, it is also
very common for CDs to have some tracks with data, and some
tracks with audio.      Just because I feel like it, I declare
the following to be the best way to cope.  If the CD has
ANY data tracks on it, it will be returned as a data CD.
If it has any XA tracks, I will return it as that.      Now I
could simplify this interface by combining these returns with
the above, but this more clearly demonstrates the problem
with the current interface.  Too bad this wasn&#39;t designed
to use bitmasks...             -Erik

Well, now we have the option CDS_MIXED: a mixed-type CD.
User level programmers might feel the ioctl is not very
useful.
                ---david
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CHANGER_NSLOTS</dt><dd><p>Get number of slots</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_CHANGER_NSLOTS, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value will be the number of slots in a
CD changer.  Typically 1 for non-multi-disk devices.</p>
</dd>
<dt>error returns:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROM_LOCKDOOR</dt><dd><p>lock or unlock door</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lock;

ioctl(fd, CDROM_LOCKDOOR, lock);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Door lock flag, 1=lock, 0=unlock</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul>
<li><p>EDRIVE_CANT_DO_THIS</p>
<blockquote>
<div><p>Door lock function not supported.</p>
</div></blockquote>
</li>
<li><p>EBUSY</p>
<blockquote>
<div><p>Attempt to unlock when multiple users
have the drive open and not CAP_SYS_ADMIN</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt>notes:</dt><dd><p>As of 2.6.8.1, the lock flag is a global lock, meaning that
all CD drives will be locked or unlocked together.  This is
probably a bug.</p>
<p>The EDRIVE_CANT_DO_THIS value is defined in &lt;linux/cdrom.h&gt;
and is currently (2.6.8.1) the same as EOPNOTSUPP</p>
</dd>
</dl>
</dd>
<dt>CDROM_DEBUG</dt><dd><p>Turn debug messages on/off</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int debug;

ioctl(fd, CDROM_DEBUG, debug);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Cdrom debug flag, 0=disable, 1=enable</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value will be the new debug flag.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_CAPABILITY</dt><dd><p>get capabilities</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_GET_CAPABILITY, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value is the current device capability
flags.  See CDC_CLOSE_TRAY, CDC_OPEN_TRAY, etc.</p>
</dd>
</dl>
</dd>
<dt>CDROMAUDIOBUFSIZ</dt><dd><p>set the audio buffer size</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int arg;

ioctl(fd, CDROMAUDIOBUFSIZ, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New audio buffer size</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value is the new audio buffer size, or -1
on error.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Not supported by this driver.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>Not supported by all drivers.</p>
</dd>
</dl>
</dd>
</dl>
<p>DVD_READ_STRUCT                 Read structure</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_struct s;

ioctl(fd, DVD_READ_STRUCT, &amp;s);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>dvd_struct structure, containing:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>type</p></td>
<td><p>specifies the information desired, one of
DVD_STRUCT_PHYSICAL, DVD_STRUCT_COPYRIGHT,
DVD_STRUCT_DISCKEY, DVD_STRUCT_BCA,
DVD_STRUCT_MANUFACT</p></td>
</tr>
<tr class="row-even"><td><p>physical.layer_num</p></td>
<td><p>desired layer, indexed from 0</p></td>
</tr>
<tr class="row-odd"><td><p>copyright.layer_num</p></td>
<td><p>desired layer, indexed from 0</p></td>
</tr>
<tr class="row-even"><td><p>disckey.agid</p></td>
<td></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>dvd_struct structure, containing:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>physical</p></td>
<td><p>for type == DVD_STRUCT_PHYSICAL</p></td>
</tr>
<tr class="row-even"><td><p>copyright</p></td>
<td><p>for type == DVD_STRUCT_COPYRIGHT</p></td>
</tr>
<tr class="row-odd"><td><p>disckey.value</p></td>
<td><p>for type == DVD_STRUCT_DISCKEY</p></td>
</tr>
<tr class="row-even"><td><p>bca.{len,value}</p></td>
<td><p>for type == DVD_STRUCT_BCA</p></td>
</tr>
<tr class="row-odd"><td><p>manufact.{len,valu}</p></td>
<td><p>for type == DVD_STRUCT_MANUFACT</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EINVAL      physical.layer_num exceeds number of layers</p></li>
<li><p>EIO         Received invalid response from drive</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>DVD_WRITE_STRUCT                Write structure</p>
<blockquote>
<div><p>Not implemented, as of 2.6.8.1</p>
</div></blockquote>
<p>DVD_AUTH                        Authentication</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_authinfo ai;

ioctl(fd, DVD_AUTH, &amp;ai);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>dvd_authinfo structure.  See &lt;linux/cdrom.h&gt;</p>
</dd>
<dt>outputs:</dt><dd><p>dvd_authinfo structure.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOTTY      ai.type not recognized.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>CDROM_SEND_PACKET</dt><dd><p>send a packet to the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_generic_command cgc;

ioctl(fd, CDROM_SEND_PACKET, &amp;cgc);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>cdrom_generic_command structure containing the packet to send.</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>none</p>
</div></blockquote>
<p>cdrom_generic_command structure containing results.</p>
</dd>
<dt>error return:</dt><dd><ul>
<li><p>EIO</p>
<blockquote>
<div><p>command failed.</p>
</div></blockquote>
</li>
<li><p>EPERM</p>
<blockquote>
<div><p>Operation not permitted, either because a
write command was attempted on a drive which
is opened read-only, or because the command
requires CAP_SYS_RAWIO</p>
</div></blockquote>
</li>
<li><p>EINVAL</p>
<blockquote>
<div><p>cgc.data_direction not set</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_NEXT_WRITABLE</dt><dd><p>get next writable block</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long next;

ioctl(fd, CDROM_NEXT_WRITABLE, &amp;next);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The next writable block.</p>
</dd>
<dt>notes:</dt><dd><blockquote>
<div><p>If the device does not support this ioctl directly, the</p>
</div></blockquote>
<p>ioctl will return CDROM_LAST_WRITTEN + 7.</p>
</dd>
</dl>
</dd>
<dt>CDROM_LAST_WRITTEN</dt><dd><p>get last block written on disc</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long last;

ioctl(fd, CDROM_LAST_WRITTEN, &amp;last);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The last block written on disc</p>
</dd>
<dt>notes:</dt><dd><p>If the device does not support this ioctl directly, the
result is derived from the disc’s table of contents.  If the
table of contents can’t be read, this ioctl returns an
error.</p>
</dd>
</dl>
</dd>
</dl>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/userspace-api/ioctl/cdrom.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/userspace-api/ioctl/cdrom.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>