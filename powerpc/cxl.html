
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Coherent Accelerator Interface (CXL) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Coherent Accelerator (CXL) Flash" href="cxlflash.html" />
    <link rel="prev" title="CPU Features" href="cpu_features.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="coherent-accelerator-interface-cxl">
<h1>Coherent Accelerator Interface (CXL)<a class="headerlink" href="#coherent-accelerator-interface-cxl" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The coherent accelerator interface is designed to allow the
coherent connection of accelerators (FPGAs and other devices) to a
POWER system. These devices need to adhere to the Coherent
Accelerator Interface Architecture (CAIA).</p>
<p>IBM refers to this as the Coherent Accelerator Processor Interface
or CAPI. In the kernel it’s referred to by the name CXL to avoid
confusion with the ISDN CAPI subsystem.</p>
<p>Coherent in this context means that the accelerator and CPUs can
both access system memory directly and with the same effective
addresses.</p>
</div></blockquote>
</section>
<section id="hardware-overview">
<h2>Hardware overview<a class="headerlink" href="#hardware-overview" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  POWER8/9             FPGA
+----------+        +---------+
|          |        |         |
|   CPU    |        |   AFU   |
|          |        |         |
|          |        |         |
|          |        |         |
+----------+        +---------+
|   PHB    |        |         |
|   +------+        |   PSL   |
|   | CAPP |&lt;------&gt;|         |
+---+------+  PCIE  +---------+
</pre></div>
</div>
<p>The POWER8/9 chip has a Coherently Attached Processor Proxy (CAPP)
unit which is part of the PCIe Host Bridge (PHB). This is managed
by Linux by calls into OPAL. Linux doesn’t directly program the
CAPP.</p>
<p>The FPGA (or coherently attached device) consists of two parts.
The POWER Service Layer (PSL) and the Accelerator Function Unit
(AFU). The AFU is used to implement specific functionality behind
the PSL. The PSL, among other things, provides memory address
translation services to allow each AFU direct access to userspace
memory.</p>
<p>The AFU is the core part of the accelerator (eg. the compression,
crypto etc function). The kernel has no knowledge of the function
of the AFU. Only userspace interacts directly with the AFU.</p>
<p>The PSL provides the translation and interrupt services that the
AFU needs. This is what the kernel interacts with. For example, if
the AFU needs to read a particular effective address, it sends
that address to the PSL, the PSL then translates it, fetches the
data from memory and returns it to the AFU. If the PSL has a
translation miss, it interrupts the kernel and the kernel services
the fault. The context to which this fault is serviced is based on
who owns that acceleration function.</p>
<ul class="simple">
<li><p>POWER8 and PSL Version 8 are compliant to the CAIA Version 1.0.</p></li>
<li><p>POWER9 and PSL Version 9 are compliant to the CAIA Version 2.0.</p></li>
</ul>
<p>This PSL Version 9 provides new features such as:</p>
<ul class="simple">
<li><p>Interaction with the nest MMU on the P9 chip.</p></li>
<li><p>Native DMA support.</p></li>
<li><p>Supports sending ASB_Notify messages for host thread wakeup.</p></li>
<li><p>Supports Atomic operations.</p></li>
<li><p>etc.</p></li>
</ul>
<p>Cards with a PSL9 won’t work on a POWER8 system and cards with a
PSL8 won’t work on a POWER9 system.</p>
</div></blockquote>
</section>
<section id="afu-modes">
<h2>AFU Modes<a class="headerlink" href="#afu-modes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are two programming modes supported by the AFU. Dedicated
and AFU directed. AFU may support one or both modes.</p>
<p>When using dedicated mode only one MMU context is supported. In
this mode, only one userspace process can use the accelerator at
time.</p>
<p>When using AFU directed mode, up to 16K simultaneous contexts can
be supported. This means up to 16K simultaneous userspace
applications may use the accelerator (although specific AFUs may
support fewer). In this mode, the AFU sends a 16 bit context ID
with each of its requests. This tells the PSL which context is
associated with each operation. If the PSL can’t translate an
operation, the ID can also be accessed by the kernel so it can
determine the userspace context associated with an operation.</p>
</div></blockquote>
</section>
<section id="mmio-space">
<h2>MMIO space<a class="headerlink" href="#mmio-space" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A portion of the accelerator MMIO space can be directly mapped
from the AFU to userspace. Either the whole space can be mapped or
just a per context portion. The hardware is self describing, hence
the kernel can determine the offset and size of the per context
portion.</p>
</div></blockquote>
</section>
<section id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>AFUs may generate interrupts that are destined for userspace. These
are received by the kernel as hardware interrupts and passed onto
userspace by a read syscall documented below.</p>
<p>Data storage faults and error interrupts are handled by the kernel
driver.</p>
</div></blockquote>
</section>
<section id="work-element-descriptor-wed">
<h2>Work Element Descriptor (WED)<a class="headerlink" href="#work-element-descriptor-wed" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The WED is a 64-bit parameter passed to the AFU when a context is
started. Its format is up to the AFU hence the kernel has no
knowledge of what it represents. Typically it will be the
effective address of a work queue or status block where the AFU
and userspace can share control and status information.</p>
</div></blockquote>
</section>
<section id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<section id="afu-character-devices">
<h3>1. AFU character devices<a class="headerlink" href="#afu-character-devices" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For AFUs operating in AFU directed mode, two character device
files will be created. /dev/cxl/afu0.0m will correspond to a
master context and /dev/cxl/afu0.0s will correspond to a slave
context. Master contexts have access to the full MMIO space an
AFU provides. Slave contexts have access to only the per process
MMIO space an AFU provides.</p>
<p>For AFUs operating in dedicated process mode, the driver will
only create a single character device per AFU called
/dev/cxl/afu0.0d. This will have access to the entire MMIO space
that the AFU provides (like master contexts in AFU directed).</p>
<p>The types described below are defined in include/uapi/misc/cxl.h</p>
<p>The following file operations are supported on both slave and
master devices.</p>
<p>A userspace library libcxl is available here:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/ibm-capi/libcxl">https://github.com/ibm-capi/libcxl</a></p>
</div></blockquote>
<p>This provides a C interface to this kernel API.</p>
</div></blockquote>
<section id="open">
<h4>open<a class="headerlink" href="#open" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Opens the device and allocates a file descriptor to be used with
the rest of the API.</p>
<p>A dedicated mode AFU only has one context and only allows the
device to be opened once.</p>
<p>An AFU directed mode AFU can have many contexts, the device can be
opened once for each context that is available.</p>
<p>When all available contexts are allocated the open call will fail
and return -ENOSPC.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>IRQs need to be allocated for each context, which may limit
the number of contexts that can be created, and therefore
how many times the device can be opened. The POWER8 CAPP
supports 2040 IRQs and 3 are used by the kernel, so 2037 are
left. If 1 IRQ is needed per context, then only 2037
contexts can be allocated. If 4 IRQs are needed per context,
then only 2037/4 = 509 contexts can be allocated.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="ioctl">
<h4>ioctl<a class="headerlink" href="#ioctl" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl>
<dt>CXL_IOCTL_START_WORK:</dt><dd><p>Starts the AFU context and associates it with the current
process. Once this ioctl is successfully executed, all memory
mapped into this process is accessible to this AFU context
using the same effective addresses. No additional calls are
required to map/unmap memory. The AFU memory context will be
updated as userspace allocates and frees memory. This ioctl
returns once the AFU context is started.</p>
<p>Takes a pointer to a struct cxl_ioctl_start_work</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_ioctl_start_work {
        __u64 flags;
        __u64 work_element_descriptor;
        __u64 amr;
        __s16 num_interrupts;
        __s16 reserved1;
        __s32 reserved2;
        __u64 reserved3;
        __u64 reserved4;
        __u64 reserved5;
        __u64 reserved6;
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>Indicates which optional fields in the structure are
valid.</p>
</dd>
<dt>work_element_descriptor:</dt><dd><p>The Work Element Descriptor (WED) is a 64-bit argument
defined by the AFU. Typically this is an effective
address pointing to an AFU specific structure
describing what work to perform.</p>
</dd>
<dt>amr:</dt><dd><p>Authority Mask Register (AMR), same as the powerpc
AMR. This field is only used by the kernel when the
corresponding CXL_START_WORK_AMR value is specified in
flags. If not specified the kernel will use a default
value of 0.</p>
</dd>
<dt>num_interrupts:</dt><dd><p>Number of userspace interrupts to request. This field
is only used by the kernel when the corresponding
CXL_START_WORK_NUM_IRQS value is specified in flags.
If not specified the minimum number required by the
AFU will be allocated. The min and max number can be
obtained from sysfs.</p>
</dd>
<dt>reserved fields:</dt><dd><p>For ABI padding and future extensions</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>CXL_IOCTL_GET_PROCESS_ELEMENT:</dt><dd><p>Get the current context id, also known as the process element.
The value is returned from the kernel as a __u32.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="mmap">
<h4>mmap<a class="headerlink" href="#mmap" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>An AFU may have an MMIO space to facilitate communication with the
AFU. If it does, the MMIO space can be accessed via mmap. The size
and contents of this area are specific to the particular AFU. The
size can be discovered via sysfs.</p>
<p>In AFU directed mode, master contexts are allowed to map all of
the MMIO space and slave contexts are allowed to only map the per
process MMIO space associated with the context. In dedicated
process mode the entire MMIO space can always be mapped.</p>
<p>This mmap call must be done after the START_WORK ioctl.</p>
<p>Care should be taken when accessing MMIO space. Only 32 and 64-bit
accesses are supported by POWER8. Also, the AFU will be designed
with a specific endianness, so all MMIO accesses should consider
endianness (recommend endian(3) variants like: le64toh(),
be64toh() etc). These endian issues equally apply to shared memory
queues the WED may describe.</p>
</div></blockquote>
</section>
<section id="read">
<h4>read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Reads events from the AFU. Blocks if no events are pending
(unless O_NONBLOCK is supplied). Returns -EIO in the case of an
unrecoverable error or if the card is removed.</p>
<p>read() will always return an integral number of events.</p>
<p>The buffer passed to read() must be at least 4K bytes.</p>
<p>The result of the read will be a buffer of one or more events,
each event is of type struct cxl_event, of varying size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_event {
        struct cxl_event_header header;
        union {
                struct cxl_event_afu_interrupt irq;
                struct cxl_event_data_storage fault;
                struct cxl_event_afu_error afu_error;
        };
};
</pre></div>
</div>
<p>The struct cxl_event_header is defined as</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_event_header {
        __u16 type;
        __u16 size;
        __u16 process_element;
        __u16 reserved1;
};
</pre></div>
</div>
<dl class="simple">
<dt>type:</dt><dd><p>This defines the type of event. The type determines how
the rest of the event is structured. These types are
described below and defined by enum cxl_event_type.</p>
</dd>
<dt>size:</dt><dd><p>This is the size of the event in bytes including the
struct cxl_event_header. The start of the next event can
be found at this offset from the start of the current
event.</p>
</dd>
<dt>process_element:</dt><dd><p>Context ID of the event.</p>
</dd>
<dt>reserved field:</dt><dd><p>For future extensions and padding.</p>
</dd>
</dl>
</div></blockquote>
<p>If the event type is CXL_EVENT_AFU_INTERRUPT then the event
structure is defined as</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_event_afu_interrupt {
        __u16 flags;
        __u16 irq; /* Raised AFU interrupt number */
        __u32 reserved1;
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>These flags indicate which optional fields are present
in this struct. Currently all fields are mandatory.</p>
</dd>
<dt>irq:</dt><dd><p>The IRQ number sent by the AFU.</p>
</dd>
<dt>reserved field:</dt><dd><p>For future extensions and padding.</p>
</dd>
</dl>
</div></blockquote>
<p>If the event type is CXL_EVENT_DATA_STORAGE then the event
structure is defined as</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_event_data_storage {
        __u16 flags;
        __u16 reserved1;
        __u32 reserved2;
        __u64 addr;
        __u64 dsisr;
        __u64 reserved3;
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>These flags indicate which optional fields are present in
this struct. Currently all fields are mandatory.</p>
</dd>
<dt>address:</dt><dd><p>The address that the AFU unsuccessfully attempted to
access. Valid accesses will be handled transparently by the
kernel but invalid accesses will generate this event.</p>
</dd>
<dt>dsisr:</dt><dd><p>This field gives information on the type of fault. It is a
copy of the DSISR from the PSL hardware when the address
fault occurred. The form of the DSISR is as defined in the
CAIA.</p>
</dd>
<dt>reserved fields:</dt><dd><p>For future extensions</p>
</dd>
</dl>
</div></blockquote>
<p>If the event type is CXL_EVENT_AFU_ERROR then the event structure
is defined as</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_event_afu_error {
        __u16 flags;
        __u16 reserved1;
        __u32 reserved2;
        __u64 error;
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>These flags indicate which optional fields are present in
this struct. Currently all fields are Mandatory.</p>
</dd>
<dt>error:</dt><dd><p>Error status from the AFU. Defined by the AFU.</p>
</dd>
<dt>reserved fields:</dt><dd><p>For future extensions and padding</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="card-character-device-powervm-guest-only">
<h3>2. Card character device (powerVM guest only)<a class="headerlink" href="#card-character-device-powervm-guest-only" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In a powerVM guest, an extra character device is created for the
card. The device is only used to write (flash) a new image on the
FPGA accelerator. Once the image is written and verified, the
device tree is updated and the card is reset to reload the updated
image.</p>
</div></blockquote>
<section id="id1">
<h4>open<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Opens the device and allocates a file descriptor to be used with
the rest of the API. The device can only be opened once.</p>
</div></blockquote>
</section>
<section id="id2">
<h4>ioctl<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<dl>
<dt>CXL_IOCTL_DOWNLOAD_IMAGE / CXL_IOCTL_VALIDATE_IMAGE:</dt><dd><p>Starts and controls flashing a new FPGA image. Partial
reconfiguration is not supported (yet), so the image must contain
a copy of the PSL and AFU(s). Since an image can be quite large,
the caller may have to iterate, splitting the image in smaller
chunks.</p>
<p>Takes a pointer to a struct cxl_adapter_image:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cxl_adapter_image {
    __u64 flags;
    __u64 data;
    __u64 len_data;
    __u64 len_image;
    __u64 reserved1;
    __u64 reserved2;
    __u64 reserved3;
    __u64 reserved4;
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>These flags indicate which optional fields are present in
this struct. Currently all fields are mandatory.</p>
</dd>
<dt>data:</dt><dd><p>Pointer to a buffer with part of the image to write to the
card.</p>
</dd>
<dt>len_data:</dt><dd><p>Size of the buffer pointed to by data.</p>
</dd>
<dt>len_image:</dt><dd><p>Full size of the image.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</section>
</section>
<section id="sysfs-class">
<h2>Sysfs Class<a class="headerlink" href="#sysfs-class" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A cxl sysfs class is added under /sys/class/cxl to facilitate
enumeration and tuning of the accelerators. Its layout is
described in Documentation/ABI/testing/sysfs-class-cxl</p>
</div></blockquote>
</section>
<section id="udev-rules">
<h2>Udev rules<a class="headerlink" href="#udev-rules" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The following udev rules could be used to create a symlink to the
most logical chardev to use in any programming mode (afuX.Yd for
dedicated, afuX.Ys for afu directed), since the API is virtually
identical for each:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SUBSYSTEM==&quot;cxl&quot;, ATTRS{mode}==&quot;dedicated_process&quot;, SYMLINK=&quot;cxl/%b&quot;
SUBSYSTEM==&quot;cxl&quot;, ATTRS{mode}==&quot;afu_directed&quot;, \
                  KERNEL==&quot;afu[0-9]*.[0-9]*s&quot;, SYMLINK=&quot;cxl/%b&quot;
</pre></div>
</div>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Coherent Accelerator Interface (CXL)</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#hardware-overview">Hardware overview</a></li>
<li><a class="reference internal" href="#afu-modes">AFU Modes</a></li>
<li><a class="reference internal" href="#mmio-space">MMIO space</a></li>
<li><a class="reference internal" href="#interrupts">Interrupts</a></li>
<li><a class="reference internal" href="#work-element-descriptor-wed">Work Element Descriptor (WED)</a></li>
<li><a class="reference internal" href="#user-api">User API</a><ul>
<li><a class="reference internal" href="#afu-character-devices">1. AFU character devices</a><ul>
<li><a class="reference internal" href="#open">open</a></li>
<li><a class="reference internal" href="#ioctl">ioctl</a></li>
<li><a class="reference internal" href="#mmap">mmap</a></li>
<li><a class="reference internal" href="#read">read</a></li>
</ul>
</li>
<li><a class="reference internal" href="#card-character-device-powervm-guest-only">2. Card character device (powerVM guest only)</a><ul>
<li><a class="reference internal" href="#id1">open</a></li>
<li><a class="reference internal" href="#id2">ioctl</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sysfs-class">Sysfs Class</a></li>
<li><a class="reference internal" href="#udev-rules">Udev rules</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/powerpc/cxl.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/powerpc/cxl.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>