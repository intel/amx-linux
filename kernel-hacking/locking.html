
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Unreliable Guide To Locking &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Tracing Technologies" href="../trace/index.html" />
    <link rel="prev" title="Unreliable Guide To Hacking The Linux Kernel" href="hacking.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="unreliable-guide-to-locking">
<span id="kernel-hacking-lock"></span><h1>Unreliable Guide To Locking<a class="headerlink" href="#unreliable-guide-to-locking" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Rusty Russell</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome, to Rusty’s Remarkably Unreliable Guide to Kernel Locking
issues. This document describes the locking systems in the Linux Kernel
in 2.6.</p>
<p>With the wide availability of HyperThreading, and preemption in the
Linux Kernel, everyone hacking on the kernel needs to know the
fundamentals of concurrency and locking for SMP.</p>
</section>
<section id="the-problem-with-concurrency">
<h2>The Problem With Concurrency<a class="headerlink" href="#the-problem-with-concurrency" title="Permalink to this headline">¶</a></h2>
<p>(Skip this if you know what a Race Condition is).</p>
<p>In a normal program, you can increment a counter like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>very_important_count++;
</pre></div>
</div>
<p>This is what they would expect to happen:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Expected Results</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Instance 1</p></th>
<th class="head"><p>Instance 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>read very_important_count (5)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>add 1 (6)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>write very_important_count (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>read very_important_count (6)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>add 1 (7)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>write very_important_count (7)</p></td>
</tr>
</tbody>
</table>
<p>This is what might happen:</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Possible Results</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Instance 1</p></th>
<th class="head"><p>Instance 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>read very_important_count (5)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>read very_important_count (5)</p></td>
</tr>
<tr class="row-even"><td><p>add 1 (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>add 1 (6)</p></td>
</tr>
<tr class="row-even"><td><p>write very_important_count (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>write very_important_count (6)</p></td>
</tr>
</tbody>
</table>
<section id="race-conditions-and-critical-regions">
<h3>Race Conditions and Critical Regions<a class="headerlink" href="#race-conditions-and-critical-regions" title="Permalink to this headline">¶</a></h3>
<p>This overlap, where the result depends on the relative timing of
multiple tasks, is called a race condition. The piece of code containing
the concurrency issue is called a critical region. And especially since
Linux starting running on SMP machines, they became one of the major
issues in kernel design and implementation.</p>
<p>Preemption can have the same effect, even if there is only one CPU: by
preempting one task during the critical region, we have exactly the same
race condition. In this case the thread which preempts might run the
critical region itself.</p>
<p>The solution is to recognize when these simultaneous accesses occur, and
use locks to make sure that only one instance can enter the critical
region at any time. There are many friendly primitives in the Linux
kernel to help you do this. And then there are the unfriendly
primitives, but I’ll pretend they don’t exist.</p>
</section>
</section>
<section id="locking-in-the-linux-kernel">
<h2>Locking in the Linux Kernel<a class="headerlink" href="#locking-in-the-linux-kernel" title="Permalink to this headline">¶</a></h2>
<p>If I could give you one piece of advice on locking: <strong>keep it simple</strong>.</p>
<p>Be reluctant to introduce new locks.</p>
<section id="two-main-types-of-kernel-locks-spinlocks-and-mutexes">
<h3>Two Main Types of Kernel Locks: Spinlocks and Mutexes<a class="headerlink" href="#two-main-types-of-kernel-locks-spinlocks-and-mutexes" title="Permalink to this headline">¶</a></h3>
<p>There are two main types of kernel locks. The fundamental type is the
spinlock (<code class="docutils literal notranslate"><span class="pre">include/asm/spinlock.h</span></code>), which is a very simple
single-holder lock: if you can’t get the spinlock, you keep trying
(spinning) until you can. Spinlocks are very small and fast, and can be
used anywhere.</p>
<p>The second type is a mutex (<code class="docutils literal notranslate"><span class="pre">include/linux/mutex.h</span></code>): it is like a
spinlock, but you may block holding a mutex. If you can’t lock a mutex,
your task will suspend itself, and be woken up when the mutex is
released. This means the CPU can do something else while you are
waiting. There are many cases when you simply can’t sleep (see
<a class="reference internal" href="#what-functions-are-safe-to-call-from-interrupts">What Functions Are Safe To Call From Interrupts?</a>),
and so have to use a spinlock instead.</p>
<p>Neither type of lock is recursive: see
<a class="reference internal" href="#deadlock-simple-and-advanced">Deadlock: Simple and Advanced</a>.</p>
</section>
<section id="locks-and-uniprocessor-kernels">
<h3>Locks and Uniprocessor Kernels<a class="headerlink" href="#locks-and-uniprocessor-kernels" title="Permalink to this headline">¶</a></h3>
<p>For kernels compiled without <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code>, and without
<code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> spinlocks do not exist at all. This is an excellent
design decision: when no-one else can run at the same time, there is no
reason to have a lock.</p>
<p>If the kernel is compiled without <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code>, but <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code>
is set, then spinlocks simply disable preemption, which is sufficient to
prevent any races. For most purposes, we can think of preemption as
equivalent to SMP, and not worry about it separately.</p>
<p>You should always test your locking code with <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code> and
<code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> enabled, even if you don’t have an SMP test box,
because it will still catch some kinds of locking bugs.</p>
<p>Mutexes still exist, because they are required for synchronization
between user contexts, as we will see below.</p>
</section>
<section id="locking-only-in-user-context">
<h3>Locking Only In User Context<a class="headerlink" href="#locking-only-in-user-context" title="Permalink to this headline">¶</a></h3>
<p>If you have a data structure which is only ever accessed from user
context, then you can use a simple mutex (<code class="docutils literal notranslate"><span class="pre">include/linux/mutex.h</span></code>) to
protect it. This is the most trivial case: you initialize the mutex.
Then you can call <a class="reference internal" href="#c.mutex_lock_interruptible" title="mutex_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock_interruptible()</span></code></a> to grab the
mutex, and <a class="reference internal" href="#c.mutex_unlock" title="mutex_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_unlock()</span></code></a> to release it. There is also a
<a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>, which should be avoided, because it will
not return if a signal is received.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">net/netfilter/nf_sockopt.c</span></code> allows registration of new
setsockopt() and getsockopt() calls, with
nf_register_sockopt(). Registration and de-registration
are only done on module load and unload (and boot time, where there is
no concurrency), and the list of registrations is only consulted for an
unknown setsockopt() or getsockopt() system
call. The <code class="docutils literal notranslate"><span class="pre">nf_sockopt_mutex</span></code> is perfect to protect this, especially
since the setsockopt and getsockopt calls may well sleep.</p>
</section>
<section id="locking-between-user-context-and-softirqs">
<h3>Locking Between User Context and Softirqs<a class="headerlink" href="#locking-between-user-context-and-softirqs" title="Permalink to this headline">¶</a></h3>
<p>If a softirq shares data with user context, you have two problems.
Firstly, the current user context can be interrupted by a softirq, and
secondly, the critical region could be entered from another CPU. This is
where spin_lock_bh() (<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) is
used. It disables softirqs on that CPU, then grabs the lock.
spin_unlock_bh() does the reverse. (The ‘_bh’ suffix is
a historical reference to “Bottom Halves”, the old name for software
interrupts. It should really be called spin_lock_softirq()’ in a
perfect world).</p>
<p>Note that you can also use spin_lock_irq() or
spin_lock_irqsave() here, which stop hardware interrupts
as well: see <a class="reference internal" href="#hard-irq-context">Hard IRQ Context</a>.</p>
<p>This works perfectly for UP as well: the spin lock vanishes, and this
macro simply becomes local_bh_disable()
(<code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code>), which protects you from the softirq
being run.</p>
</section>
<section id="locking-between-user-context-and-tasklets">
<h3>Locking Between User Context and Tasklets<a class="headerlink" href="#locking-between-user-context-and-tasklets" title="Permalink to this headline">¶</a></h3>
<p>This is exactly the same as above, because tasklets are actually run
from a softirq.</p>
</section>
<section id="locking-between-user-context-and-timers">
<h3>Locking Between User Context and Timers<a class="headerlink" href="#locking-between-user-context-and-timers" title="Permalink to this headline">¶</a></h3>
<p>This, too, is exactly the same as above, because timers are actually run
from a softirq. From a locking point of view, tasklets and timers are
identical.</p>
</section>
<section id="locking-between-tasklets-timers">
<h3>Locking Between Tasklets/Timers<a class="headerlink" href="#locking-between-tasklets-timers" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a tasklet or timer might want to share data with another
tasklet or timer.</p>
<section id="the-same-tasklet-timer">
<h4>The Same Tasklet/Timer<a class="headerlink" href="#the-same-tasklet-timer" title="Permalink to this headline">¶</a></h4>
<p>Since a tasklet is never run on two CPUs at once, you don’t need to
worry about your tasklet being reentrant (running twice at once), even
on SMP.</p>
</section>
<section id="different-tasklets-timers">
<h4>Different Tasklets/Timers<a class="headerlink" href="#different-tasklets-timers" title="Permalink to this headline">¶</a></h4>
<p>If another tasklet/timer wants to share data with your tasklet or timer
, you will both need to use spin_lock() and
spin_unlock() calls. spin_lock_bh() is
unnecessary here, as you are already in a tasklet, and none will be run
on the same CPU.</p>
</section>
</section>
<section id="locking-between-softirqs">
<h3>Locking Between Softirqs<a class="headerlink" href="#locking-between-softirqs" title="Permalink to this headline">¶</a></h3>
<p>Often a softirq might want to share data with itself or a tasklet/timer.</p>
<section id="the-same-softirq">
<h4>The Same Softirq<a class="headerlink" href="#the-same-softirq" title="Permalink to this headline">¶</a></h4>
<p>The same softirq can run on the other CPUs: you can use a per-CPU array
(see <a class="reference internal" href="#per-cpu-data">Per-CPU Data</a>) for better performance. If you’re
going so far as to use a softirq, you probably care about scalable
performance enough to justify the extra complexity.</p>
<p>You’ll need to use spin_lock() and
spin_unlock() for shared data.</p>
</section>
<section id="different-softirqs">
<h4>Different Softirqs<a class="headerlink" href="#different-softirqs" title="Permalink to this headline">¶</a></h4>
<p>You’ll need to use spin_lock() and
spin_unlock() for shared data, whether it be a timer,
tasklet, different softirq or the same or another softirq: any of them
could be running on a different CPU.</p>
</section>
</section>
</section>
<section id="hard-irq-context">
<h2>Hard IRQ Context<a class="headerlink" href="#hard-irq-context" title="Permalink to this headline">¶</a></h2>
<p>Hardware interrupts usually communicate with a tasklet or softirq.
Frequently this involves putting work in a queue, which the softirq will
take out.</p>
<section id="locking-between-hard-irq-and-softirqs-tasklets">
<h3>Locking Between Hard IRQ and Softirqs/Tasklets<a class="headerlink" href="#locking-between-hard-irq-and-softirqs-tasklets" title="Permalink to this headline">¶</a></h3>
<p>If a hardware irq handler shares data with a softirq, you have two
concerns. Firstly, the softirq processing can be interrupted by a
hardware interrupt, and secondly, the critical region could be entered
by a hardware interrupt on another CPU. This is where
spin_lock_irq() is used. It is defined to disable
interrupts on that cpu, then grab the lock.
spin_unlock_irq() does the reverse.</p>
<p>The irq handler does not need to use spin_lock_irq(), because
the softirq cannot run while the irq handler is running: it can use
spin_lock(), which is slightly faster. The only exception
would be if a different hardware irq handler uses the same lock:
spin_lock_irq() will stop that from interrupting us.</p>
<p>This works perfectly for UP as well: the spin lock vanishes, and this
macro simply becomes local_irq_disable()
(<code class="docutils literal notranslate"><span class="pre">include/asm/smp.h</span></code>), which protects you from the softirq/tasklet/BH
being run.</p>
<p>spin_lock_irqsave() (<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) is a
variant which saves whether interrupts were on or off in a flags word,
which is passed to spin_unlock_irqrestore(). This means
that the same code can be used inside an hard irq handler (where
interrupts are already off) and in softirqs (where the irq disabling is
required).</p>
<p>Note that softirqs (and hence tasklets and timers) are run on return
from hardware interrupts, so spin_lock_irq() also stops
these. In that sense, spin_lock_irqsave() is the most
general and powerful locking function.</p>
</section>
<section id="locking-between-two-hard-irq-handlers">
<h3>Locking Between Two Hard IRQ Handlers<a class="headerlink" href="#locking-between-two-hard-irq-handlers" title="Permalink to this headline">¶</a></h3>
<p>It is rare to have to share data between two IRQ handlers, but if you
do, spin_lock_irqsave() should be used: it is
architecture-specific whether all interrupts are disabled inside irq
handlers themselves.</p>
</section>
</section>
<section id="cheat-sheet-for-locking">
<h2>Cheat Sheet For Locking<a class="headerlink" href="#cheat-sheet-for-locking" title="Permalink to this headline">¶</a></h2>
<p>Pete Zaitcev gives the following summary:</p>
<ul class="simple">
<li><p>If you are in a process context (any syscall) and want to lock other
process out, use a mutex. You can take a mutex and sleep
(<code class="docutils literal notranslate"><span class="pre">copy_from_user()</span></code> or <code class="docutils literal notranslate"><span class="pre">kmalloc(x,GFP_KERNEL)</span></code>).</p></li>
<li><p>Otherwise (== data can be touched in an interrupt), use
spin_lock_irqsave() and
spin_unlock_irqrestore().</p></li>
<li><p>Avoid holding spinlock for more than 5 lines of code and across any
function call (except accessors like readb()).</p></li>
</ul>
<section id="table-of-minimum-requirements">
<h3>Table of Minimum Requirements<a class="headerlink" href="#table-of-minimum-requirements" title="Permalink to this headline">¶</a></h3>
<p>The following table lists the <strong>minimum</strong> locking requirements between
various contexts. In some cases, the same context can only be running on
one CPU at a time, so no locking is required for that context (eg. a
particular thread can only run on one CPU at a time, but if it needs
shares data with another thread, locking is required).</p>
<p>Remember the advice above: you can always use
spin_lock_irqsave(), which is a superset of all other
spinlock primitives.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>.</p></th>
<th class="head"><p>IRQ Handler A</p></th>
<th class="head"><p>IRQ Handler B</p></th>
<th class="head"><p>Softirq A</p></th>
<th class="head"><p>Softirq B</p></th>
<th class="head"><p>Tasklet A</p></th>
<th class="head"><p>Tasklet B</p></th>
<th class="head"><p>Timer A</p></th>
<th class="head"><p>Timer B</p></th>
<th class="head"><p>User Context A</p></th>
<th class="head"><p>User Context B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IRQ Handler A</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>IRQ Handler B</p></td>
<td><p>SLIS</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Softirq A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Softirq B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Tasklet A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Tasklet B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Timer A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Timer B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>User Context A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>None</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>User Context B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>MLI</p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<p>Table: Table of Locking Requirements</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>SLIS</p></td>
<td><p>spin_lock_irqsave</p></td>
</tr>
<tr class="row-even"><td><p>SLI</p></td>
<td><p>spin_lock_irq</p></td>
</tr>
<tr class="row-odd"><td><p>SL</p></td>
<td><p>spin_lock</p></td>
</tr>
<tr class="row-even"><td><p>SLBH</p></td>
<td><p>spin_lock_bh</p></td>
</tr>
<tr class="row-odd"><td><p>MLI</p></td>
<td><p>mutex_lock_interruptible</p></td>
</tr>
</tbody>
</table>
<p>Table: Legend for Locking Requirements Table</p>
</section>
</section>
<section id="the-trylock-functions">
<h2>The trylock Functions<a class="headerlink" href="#the-trylock-functions" title="Permalink to this headline">¶</a></h2>
<p>There are functions that try to acquire a lock only once and immediately
return a value telling about success or failure to acquire the lock.
They can be used if you need no access to the data protected with the
lock when some other thread is holding the lock. You should acquire the
lock later if you then need access to the data protected with the lock.</p>
<p>spin_trylock() does not spin but returns non-zero if it
acquires the spinlock on the first try or 0 if not. This function can be
used in all contexts like spin_lock(): you must have
disabled the contexts that might interrupt you and acquire the spin
lock.</p>
<p><a class="reference internal" href="#c.mutex_trylock" title="mutex_trylock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_trylock()</span></code></a> does not suspend your task but returns
non-zero if it could lock the mutex on the first try or 0 if not. This
function cannot be safely used in hardware or software interrupt
contexts despite not sleeping.</p>
</section>
<section id="common-examples">
<h2>Common Examples<a class="headerlink" href="#common-examples" title="Permalink to this headline">¶</a></h2>
<p>Let’s step through a simple example: a cache of number to name mappings.
The cache keeps a count of how often each of the objects is used, and
when it gets full, throws out the least used one.</p>
<section id="all-in-user-context">
<h3>All In User Context<a class="headerlink" href="#all-in-user-context" title="Permalink to this headline">¶</a></h3>
<p>For our first example, we assume that all operations are in user context
(ie. from system calls), so we can sleep. This means we can use a mutex
to protect the cache and all the objects within it. Here’s the code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/list.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;asm/errno.h&gt;

struct object
{
        struct list_head list;
        int id;
        char name[32];
        int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DEFINE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
        struct object *i;

        list_for_each_entry(i, &amp;cache, list)
                if (i-&gt;id == id) {
                        i-&gt;popularity++;
                        return i;
                }
        return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
        BUG_ON(!obj);
        list_del(&amp;obj-&gt;list);
        kfree(obj);
        cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
        list_add(&amp;obj-&gt;list, &amp;cache);
        if (++cache_num &gt; MAX_CACHE_SIZE) {
                struct object *i, *outcast = NULL;
                list_for_each_entry(i, &amp;cache, list) {
                        if (!outcast || i-&gt;popularity &lt; outcast-&gt;popularity)
                                outcast = i;
                }
                __cache_delete(outcast);
        }
}

int cache_add(int id, const char *name)
{
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                return -ENOMEM;

        strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
        obj-&gt;id = id;
        obj-&gt;popularity = 0;

        mutex_lock(&amp;cache_lock);
        __cache_add(obj);
        mutex_unlock(&amp;cache_lock);
        return 0;
}

void cache_delete(int id)
{
        mutex_lock(&amp;cache_lock);
        __cache_delete(__cache_find(id));
        mutex_unlock(&amp;cache_lock);
}

int cache_find(int id, char *name)
{
        struct object *obj;
        int ret = -ENOENT;

        mutex_lock(&amp;cache_lock);
        obj = __cache_find(id);
        if (obj) {
                ret = 0;
                strcpy(name, obj-&gt;name);
        }
        mutex_unlock(&amp;cache_lock);
        return ret;
}
</pre></div>
</div>
<p>Note that we always make sure we have the cache_lock when we add,
delete, or look up the cache: both the cache infrastructure itself and
the contents of the objects are protected by the lock. In this case it’s
easy, since we copy the data for the user, and never let them access the
objects directly.</p>
<p>There is a slight (and common) optimization here: in
cache_add() we set up the fields of the object before
grabbing the lock. This is safe, as no-one else can access it until we
put it in cache.</p>
</section>
<section id="accessing-from-interrupt-context">
<h3>Accessing From Interrupt Context<a class="headerlink" href="#accessing-from-interrupt-context" title="Permalink to this headline">¶</a></h3>
<p>Now consider the case where cache_find() can be called
from interrupt context: either a hardware interrupt or a softirq. An
example would be a timer which deletes object from the cache.</p>
<p>The change is shown below, in standard patch format: the <code class="docutils literal notranslate"><span class="pre">-</span></code> are lines
which are taken away, and the <code class="docutils literal notranslate"><span class="pre">+</span></code> are lines which are added.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.usercontext 2003-12-09 13:58:54.000000000 +1100
+++ cache.c.interrupt   2003-12-09 14:07:49.000000000 +1100
@@ -12,7 +12,7 @@
         int popularity;
 };

-static DEFINE_MUTEX(cache_lock);
+static DEFINE_SPINLOCK(cache_lock);
 static LIST_HEAD(cache);
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10
@@ -55,6 +55,7 @@
 int cache_add(int id, const char *name)
 {
         struct object *obj;
+        unsigned long flags;

         if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                 return -ENOMEM;
@@ -63,30 +64,33 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return 0;
 }

 void cache_delete(int id)
 {
-        mutex_lock(&amp;cache_lock);
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_delete(__cache_find(id));
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

 int cache_find(int id, char *name)
 {
         struct object *obj;
         int ret = -ENOENT;
+        unsigned long flags;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj) {
                 ret = 0;
                 strcpy(name, obj-&gt;name);
         }
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return ret;
 }
</pre></div>
</div>
<p>Note that the spin_lock_irqsave() will turn off
interrupts if they are on, otherwise does nothing (if we are already in
an interrupt handler), hence these functions are safe to call from any
context.</p>
<p>Unfortunately, cache_add() calls <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>
with the <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code> flag, which is only legal in user context. I
have assumed that cache_add() is still only called in
user context, otherwise this should become a parameter to
cache_add().</p>
</section>
<section id="exposing-objects-outside-this-file">
<h3>Exposing Objects Outside This File<a class="headerlink" href="#exposing-objects-outside-this-file" title="Permalink to this headline">¶</a></h3>
<p>If our objects contained more information, it might not be sufficient to
copy the information in and out: other parts of the code might want to
keep pointers to these objects, for example, rather than looking up the
id every time. This produces two problems.</p>
<p>The first problem is that we use the <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> to protect objects:
we’d need to make this non-static so the rest of the code can use it.
This makes locking trickier, as it is no longer all in one place.</p>
<p>The second problem is the lifetime problem: if another structure keeps a
pointer to an object, it presumably expects that pointer to remain
valid. Unfortunately, this is only guaranteed while you hold the lock,
otherwise someone might call cache_delete() and even
worse, add another object, re-using the same address.</p>
<p>As there is only one lock, you can’t hold it forever: no-one else would
get any work done.</p>
<p>The solution to this problem is to use a reference count: everyone who
has a pointer to the object increases it when they first get the object,
and drops the reference count when they’re finished with it. Whoever
drops it to zero knows it is unused, and can actually delete it.</p>
<p>Here is the code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.interrupt   2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt  2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
 struct object
 {
         struct list_head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ -17,6 +18,35 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&gt;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&gt;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
 /* Must be holding cache_lock */
 static struct object *__cache_find(int id)
 {
@@ -35,6 +65,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
+        __object_put(obj);
         cache_num--;
 }

@@ -63,6 +94,7 @@
         strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
+        obj-&gt;refcnt = 1; /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -79,18 +111,15 @@
         spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
 {
         struct object *obj;
-        int ret = -ENOENT;
         unsigned long flags;

         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&gt;name);
-        }
+        if (obj)
+                __object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
-        return ret;
+        return obj;
 }
</pre></div>
</div>
<p>We encapsulate the reference counting in the standard ‘get’ and ‘put’
functions. Now we can return the object itself from
cache_find() which has the advantage that the user can
now sleep holding the object (eg. to copy_to_user() to
name to userspace).</p>
<p>The other point to note is that I said a reference should be held for
every pointer to the object: thus the reference count is 1 when first
inserted into the cache. In some versions the framework does not hold a
reference count, but they are more complicated.</p>
<section id="using-atomic-operations-for-the-reference-count">
<h4>Using Atomic Operations For The Reference Count<a class="headerlink" href="#using-atomic-operations-for-the-reference-count" title="Permalink to this headline">¶</a></h4>
<p>In practice, <code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code> would usually be used for refcnt. There are a
number of atomic operations defined in <code class="docutils literal notranslate"><span class="pre">include/asm/atomic.h</span></code>: these
are guaranteed to be seen atomically from all CPUs in the system, so no
lock is required. In this case, it is simpler than using spinlocks,
although for anything non-trivial using spinlocks is clearer. The
atomic_inc() and atomic_dec_and_test()
are used instead of the standard increment and decrement operators, and
the lock is no longer used to protect the reference count itself.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.refcnt  2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic   2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
 struct object
 {
         struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
         int id;
         char name[32];
         int popularity;
@@ -18,33 +18,15 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&gt;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&gt;refcnt++;
-}
-
 void object_put(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
+                kfree(obj);
 }

 void object_get(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        atomic_inc(&amp;obj-&gt;refcnt);
 }

 /* Must be holding cache_lock */
@@ -65,7 +47,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
-        __object_put(obj);
+        object_put(obj);
         cache_num--;
 }

@@ -94,7 +76,7 @@
         strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
-        obj-&gt;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -119,7 +101,7 @@
         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj)
-                __object_get(obj);
+                object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
         return obj;
 }
</pre></div>
</div>
</section>
</section>
<section id="protecting-the-objects-themselves">
<h3>Protecting The Objects Themselves<a class="headerlink" href="#protecting-the-objects-themselves" title="Permalink to this headline">¶</a></h3>
<p>In these examples, we assumed that the objects (except the reference
counts) never changed once they are created. If we wanted to allow the
name to change, there are three possibilities:</p>
<ul class="simple">
<li><p>You can make <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> non-static, and tell people to grab that
lock before changing the name in any object.</p></li>
<li><p>You can provide a cache_obj_rename() which grabs this
lock and changes the name for the caller, and tell everyone to use
that function.</p></li>
<li><p>You can make the <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> protect only the cache itself, and
use another lock to protect the name.</p></li>
</ul>
<p>Theoretically, you can make the locks as fine-grained as one lock for
every field, for every object. In practice, the most common variants
are:</p>
<ul class="simple">
<li><p>One lock which protects the infrastructure (the <code class="docutils literal notranslate"><span class="pre">cache</span></code> list in
this example) and all the objects. This is what we have done so far.</p></li>
<li><p>One lock which protects the infrastructure (including the list
pointers inside the objects), and one lock inside the object which
protects the rest of that object.</p></li>
<li><p>Multiple locks to protect the infrastructure (eg. one lock per hash
chain), possibly with a separate per-object lock.</p></li>
</ul>
<p>Here is the “lock-per-object” implementation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.refcnt-atomic   2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

 struct object
 {
+        /* These two protected by cache_lock. */
         struct list_head list;
+        int popularity;
+
         atomic_t refcnt;
+
+        /* Doesn&#39;t change once created. */
         int id;
+
+        spinlock_t lock; /* Protects the name */
         char name[32];
-        int popularity;
 };

 static DEFINE_SPINLOCK(cache_lock);
@@ -77,6 +84,7 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
         atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&amp;obj-&gt;lock);

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
</pre></div>
</div>
<p>Note that I decide that the popularity count should be protected by the
<code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> rather than the per-object lock: this is because it (like
the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> inside the object)
is logically part of the infrastructure. This way, I don’t need to grab
the lock of every object in __cache_add() when seeking
the least popular.</p>
<p>I also decided that the id member is unchangeable, so I don’t need to
grab each object lock in __cache_find() to examine the
id: the object lock is only used by a caller who wants to read or write
the name field.</p>
<p>Note also that I added a comment describing what data was protected by
which locks. This is extremely important, as it describes the runtime
behavior of the code, and can be hard to gain from just reading. And as
Alan Cox says, “Lock data, not code”.</p>
</section>
</section>
<section id="common-problems">
<h2>Common Problems<a class="headerlink" href="#common-problems" title="Permalink to this headline">¶</a></h2>
<section id="deadlock-simple-and-advanced">
<h3>Deadlock: Simple and Advanced<a class="headerlink" href="#deadlock-simple-and-advanced" title="Permalink to this headline">¶</a></h3>
<p>There is a coding bug where a piece of code tries to grab a spinlock
twice: it will spin forever, waiting for the lock to be released
(spinlocks, rwlocks and mutexes are not recursive in Linux). This is
trivial to diagnose: not a
stay-up-five-nights-talk-to-fluffy-code-bunnies kind of problem.</p>
<p>For a slightly more complex case, imagine you have a region shared by a
softirq and user context. If you use a spin_lock() call
to protect it, it is possible that the user context will be interrupted
by the softirq while it holds the lock, and the softirq will then spin
forever trying to get the same lock.</p>
<p>Both of these are called deadlock, and as shown above, it can occur even
with a single CPU (although not on UP compiles, since spinlocks vanish
on kernel compiles with <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code>=n. You’ll still get data
corruption in the second example).</p>
<p>This complete lockup is easy to diagnose: on SMP boxes the watchdog
timer or compiling with <code class="docutils literal notranslate"><span class="pre">DEBUG_SPINLOCK</span></code> set
(<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) will show this up immediately when it
happens.</p>
<p>A more complex problem is the so-called ‘deadly embrace’, involving two
or more locks. Say you have a hash table: each entry in the table is a
spinlock, and a chain of hashed objects. Inside a softirq handler, you
sometimes want to alter an object from one place in the hash to another:
you grab the spinlock of the old hash chain and the spinlock of the new
hash chain, and delete the object from the old one, and insert it in the
new one.</p>
<p>There are two problems here. First, if your code ever tries to move the
object to the same chain, it will deadlock with itself as it tries to
lock it twice. Secondly, if the same softirq on another CPU is trying to
move another object in the reverse direction, the following could
happen:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>CPU 1</p></th>
<th class="head"><p>CPU 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Grab lock A -&gt; OK</p></td>
<td><p>Grab lock B -&gt; OK</p></td>
</tr>
<tr class="row-odd"><td><p>Grab lock B -&gt; spin</p></td>
<td><p>Grab lock A -&gt; spin</p></td>
</tr>
</tbody>
</table>
<p>Table: Consequences</p>
<p>The two CPUs will spin forever, waiting for the other to give up their
lock. It will look, smell, and feel like a crash.</p>
</section>
<section id="preventing-deadlock">
<h3>Preventing Deadlock<a class="headerlink" href="#preventing-deadlock" title="Permalink to this headline">¶</a></h3>
<p>Textbooks will tell you that if you always lock in the same order, you
will never get this kind of deadlock. Practice will tell you that this
approach doesn’t scale: when I create a new lock, I don’t understand
enough of the kernel to figure out where in the 5000 lock hierarchy it
will fit.</p>
<p>The best locks are encapsulated: they never get exposed in headers, and
are never held around calls to non-trivial functions outside the same
file. You can read through this code and see that it will never
deadlock, because it never tries to grab another lock while it has that
one. People using your code don’t even need to know you are using a
lock.</p>
<p>A classic problem here is when you provide callbacks or hooks: if you
call these with the lock held, you risk simple deadlock, or a deadly
embrace (who knows what the callback will do?).</p>
<section id="overzealous-prevention-of-deadlocks">
<h4>Overzealous Prevention Of Deadlocks<a class="headerlink" href="#overzealous-prevention-of-deadlocks" title="Permalink to this headline">¶</a></h4>
<p>Deadlocks are problematic, but not as bad as data corruption. Code which
grabs a read lock, searches a list, fails to find what it wants, drops
the read lock, grabs a write lock and inserts the object has a race
condition.</p>
</section>
</section>
<section id="racing-timers-a-kernel-pastime">
<h3>Racing Timers: A Kernel Pastime<a class="headerlink" href="#racing-timers-a-kernel-pastime" title="Permalink to this headline">¶</a></h3>
<p>Timers can produce their own special problems with races. Consider a
collection of objects (list, hash, etc) where each object has a timer
which is due to destroy it.</p>
<p>If you want to destroy the entire collection (say on module removal),
you might do the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
   HUNGARIAN NOTATION */
spin_lock_bh(&amp;list_lock);

while (list) {
        struct foo *next = list-&gt;next;
        timer_delete(&amp;list-&gt;timer);
        kfree(list);
        list = next;
}

spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Sooner or later, this will crash on SMP, because a timer can have just
gone off before the spin_lock_bh(), and it will only get
the lock after we spin_unlock_bh(), and then try to free
the element (which has already been freed!).</p>
<p>This can be avoided by checking the result of
<a class="reference internal" href="../driver-api/basics.html#c.timer_delete" title="timer_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete()</span></code></a>: if it returns 1, the timer has been deleted.
If 0, it means (in this case) that it is currently running, so we can
do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>retry:
        spin_lock_bh(&amp;list_lock);

        while (list) {
                struct foo *next = list-&gt;next;
                if (!timer_delete(&amp;list-&gt;timer)) {
                        /* Give timer a chance to delete this */
                        spin_unlock_bh(&amp;list_lock);
                        goto retry;
                }
                kfree(list);
                list = next;
        }

        spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Another common problem is deleting timers which restart themselves (by
calling <a class="reference internal" href="../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> at the end of their timer function).
Because this is a fairly common case which is prone to races, you should
use <a class="reference internal" href="../driver-api/basics.html#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/timer.h</span></code>) to handle this case.</p>
<p>Before freeing a timer, <a class="reference internal" href="../driver-api/basics.html#c.timer_shutdown" title="timer_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown()</span></code></a> or <a class="reference internal" href="../driver-api/basics.html#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> should be
called which will keep it from being rearmed. Any subsequent attempt to
rearm the timer will be silently ignored by the core code.</p>
</section>
</section>
<section id="locking-speed">
<h2>Locking Speed<a class="headerlink" href="#locking-speed" title="Permalink to this headline">¶</a></h2>
<p>There are three main things to worry about when considering speed of
some code which does locking. First is concurrency: how many things are
going to be waiting while someone else is holding a lock. Second is the
time taken to actually acquire and release an uncontended lock. Third is
using fewer, or smarter locks. I’m assuming that the lock is used fairly
often: otherwise, you wouldn’t be concerned about efficiency.</p>
<p>Concurrency depends on how long the lock is usually held: you should
hold the lock for as long as needed, but no longer. In the cache
example, we always create the object without the lock held, and then
grab the lock only when we are ready to insert it in the list.</p>
<p>Acquisition times depend on how much damage the lock operations do to
the pipeline (pipeline stalls) and how likely it is that this CPU was
the last one to grab the lock (ie. is the lock cache-hot for this CPU):
on a machine with more CPUs, this likelihood drops fast. Consider a
700MHz Intel Pentium III: an instruction takes about 0.7ns, an atomic
increment takes about 58ns, a lock which is cache-hot on this CPU takes
160ns, and a cacheline transfer from another CPU takes an additional 170
to 360ns. (These figures from Paul McKenney’s <a class="reference external" href="http://www.linuxjournal.com/article.php?sid=6993">Linux Journal RCU
article</a>).</p>
<p>These two aims conflict: holding a lock for a short time might be done
by splitting locks into parts (such as in our final per-object-lock
example), but this increases the number of lock acquisitions, and the
results are often slower than having a single lock. This is another
reason to advocate locking simplicity.</p>
<p>The third concern is addressed below: there are some methods to reduce
the amount of locking which needs to be done.</p>
<section id="read-write-lock-variants">
<h3>Read/Write Lock Variants<a class="headerlink" href="#read-write-lock-variants" title="Permalink to this headline">¶</a></h3>
<p>Both spinlocks and mutexes have read/write variants: <code class="docutils literal notranslate"><span class="pre">rwlock_t</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rw_semaphore</span></code>. These divide
users into two classes: the readers and the writers. If you are only
reading the data, you can get a read lock, but to write to the data you
need the write lock. Many people can hold a read lock, but a writer must
be sole holder.</p>
<p>If your code divides neatly along reader/writer lines (as our cache code
does), and the lock is held by readers for significant lengths of time,
using these locks can help. They are slightly slower than the normal
locks though, so in practice <code class="docutils literal notranslate"><span class="pre">rwlock_t</span></code> is not usually worthwhile.</p>
</section>
<section id="avoiding-locks-read-copy-update">
<h3>Avoiding Locks: Read Copy Update<a class="headerlink" href="#avoiding-locks-read-copy-update" title="Permalink to this headline">¶</a></h3>
<p>There is a special method of read/write locking called Read Copy Update.
Using RCU, the readers can avoid taking a lock altogether: as we expect
our cache to be read more often than updated (otherwise the cache is a
waste of time), it is a candidate for this optimization.</p>
<p>How do we get rid of read locks? Getting rid of read locks means that
writers may be changing the list underneath the readers. That is
actually quite simple: we can read a linked list while an element is
being added if the writer adds the element very carefully. For example,
adding <code class="docutils literal notranslate"><span class="pre">new</span></code> to a single linked list called <code class="docutils literal notranslate"><span class="pre">list</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>new-&gt;next = list-&gt;next;
wmb();
list-&gt;next = new;
</pre></div>
</div>
<p>The wmb() is a write memory barrier. It ensures that the
first operation (setting the new element’s <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer) is complete
and will be seen by all CPUs, before the second operation is (putting
the new element into the list). This is important, since modern
compilers and modern CPUs can both reorder instructions unless told
otherwise: we want a reader to either not see the new element at all, or
see the new element with the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer correctly pointing at the
rest of the list.</p>
<p>Fortunately, there is a function to do this for standard
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> lists:
<a class="reference internal" href="../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>).</p>
<p>Removing an element from the list is even simpler: we replace the
pointer to the old element with a pointer to its successor, and readers
will either see it, or skip over it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list-&gt;next = old-&gt;next;
</pre></div>
</div>
<p>There is <a class="reference internal" href="../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>) which
does this (the normal version poisons the old object, which we don’t
want).</p>
<p>The reader must also be careful: some CPUs can look through the <code class="docutils literal notranslate"><span class="pre">next</span></code>
pointer to start reading the contents of the next element early, but
don’t realize that the pre-fetched contents is wrong when the <code class="docutils literal notranslate"><span class="pre">next</span></code>
pointer changes underneath them. Once again, there is a
<a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>)
to help you. Of course, writers can just use
<a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a>, since there cannot be two
simultaneous writers.</p>
<p>Our final dilemma is this: when can we actually destroy the removed
element? Remember, a reader might be stepping through this element in
the list right now: if we free this element and the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer
changes, the reader will jump off into garbage and crash. We need to
wait until we know that all the readers who were traversing the list
when we deleted the element are finished. We use
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> to register a callback which will actually
destroy the object once all pre-existing readers are finished.
Alternatively, <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> may be used to block
until all pre-existing are finished.</p>
<p>But how does Read Copy Update know when the readers are finished? The
method is this: firstly, the readers always traverse the list inside
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>/<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> pairs:
these simply disable preemption so the reader won’t go to sleep while
reading the list.</p>
<p>RCU then waits until every other CPU has slept at least once: since
readers cannot sleep, we know that any readers which were traversing the
list during the deletion are finished, and the callback is triggered.
The real Read Copy Update code is a little more optimized than this, but
this is the fundamental idea.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
+++ cache.c.rcupdate    2003-12-11 17:55:14.000000000 +1100
@@ -1,15 +1,18 @@
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
+#include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;asm/errno.h&gt;

 struct object
 {
-        /* These two protected by cache_lock. */
+        /* This is protected by RCU */
         struct list_head list;
         int popularity;

+        struct rcu_head rcu;
+
         atomic_t refcnt;

         /* Doesn&#39;t change once created. */
@@ -40,7 +43,7 @@
 {
         struct object *i;

-        list_for_each_entry(i, &amp;cache, list) {
+        list_for_each_entry_rcu(i, &amp;cache, list) {
                 if (i-&gt;id == id) {
                         i-&gt;popularity++;
                         return i;
@@ -49,19 +52,25 @@
         return NULL;
 }

+/* Final discard done once we know no readers are looking. */
+static void cache_delete_rcu(void *arg)
+{
+        object_put(arg);
+}
+
 /* Must be holding cache_lock */
 static void __cache_delete(struct object *obj)
 {
         BUG_ON(!obj);
-        list_del(&amp;obj-&gt;list);
-        object_put(obj);
+        list_del_rcu(&amp;obj-&gt;list);
         cache_num--;
+        call_rcu(&amp;obj-&gt;rcu, cache_delete_rcu);
 }

 /* Must be holding cache_lock */
 static void __cache_add(struct object *obj)
 {
-        list_add(&amp;obj-&gt;list, &amp;cache);
+        list_add_rcu(&amp;obj-&gt;list, &amp;cache);
         if (++cache_num &gt; MAX_CACHE_SIZE) {
                 struct object *i, *outcast = NULL;
                 list_for_each_entry(i, &amp;cache, list) {
@@ -104,12 +114,11 @@
 struct object *cache_find(int id)
 {
         struct object *obj;
-        unsigned long flags;

-        spin_lock_irqsave(&amp;cache_lock, flags);
+        rcu_read_lock();
         obj = __cache_find(id);
         if (obj)
                 object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        rcu_read_unlock();
         return obj;
 }
</pre></div>
</div>
<p>Note that the reader will alter the popularity member in
__cache_find(), and now it doesn’t hold a lock. One
solution would be to make it an <code class="docutils literal notranslate"><span class="pre">atomic_t</span></code>, but for this usage, we
don’t really care about races: an approximate result is good enough, so
I didn’t change it.</p>
<p>The result is that cache_find() requires no
synchronization with any other functions, so is almost as fast on SMP as
it would be on UP.</p>
<p>There is a further optimization possible here: remember our original
cache code, where there were no reference counts and the caller simply
held the lock whenever using the object? This is still possible: if you
hold the lock, no one can delete the object, so you don’t need to get
and put the reference count.</p>
<p>Now, because the ‘read lock’ in RCU is simply disabling preemption, a
caller which always has preemption disabled between calling
cache_find() and object_put() does not
need to actually get and put the reference count: we could expose
__cache_find() by making it non-static, and such
callers could simply call that.</p>
<p>The benefit here is that the reference count is not written to: the
object is not altered in any way, which is much faster on SMP machines
due to caching.</p>
</section>
<section id="per-cpu-data">
<h3>Per-CPU Data<a class="headerlink" href="#per-cpu-data" title="Permalink to this headline">¶</a></h3>
<p>Another technique for avoiding locking which is used fairly widely is to
duplicate information for each CPU. For example, if you wanted to keep a
count of a common condition, you could use a spin lock and a single
counter. Nice and simple.</p>
<p>If that was too slow (it’s usually not, but if you’ve got a really big
machine to test on and can show that it is), you could instead use a
counter for each CPU, then none of them need an exclusive lock. See
DEFINE_PER_CPU(), get_cpu_var() and
put_cpu_var() (<code class="docutils literal notranslate"><span class="pre">include/linux/percpu.h</span></code>).</p>
<p>Of particular use for simple per-cpu counters is the <code class="docutils literal notranslate"><span class="pre">local_t</span></code> type,
and the cpu_local_inc() and related functions, which are
more efficient than simple code on some architectures
(<code class="docutils literal notranslate"><span class="pre">include/asm/local.h</span></code>).</p>
<p>Note that there is no simple, reliable way of getting an exact value of
such a counter, without introducing more locks. This is not a problem
for some uses.</p>
</section>
<section id="data-which-mostly-used-by-an-irq-handler">
<h3>Data Which Mostly Used By An IRQ Handler<a class="headerlink" href="#data-which-mostly-used-by-an-irq-handler" title="Permalink to this headline">¶</a></h3>
<p>If data is always accessed from within the same IRQ handler, you don’t
need a lock at all: the kernel already guarantees that the irq handler
will not run simultaneously on multiple CPUs.</p>
<p>Manfred Spraul points out that you can still do this, even if the data
is very occasionally accessed in user context or softirqs/tasklets. The
irq handler doesn’t use a lock, and all other accesses are done as so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex_lock(&amp;lock);
disable_irq(irq);
...
enable_irq(irq);
mutex_unlock(&amp;lock);
</pre></div>
</div>
<p>The <a class="reference internal" href="../core-api/genericirq.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> prevents the irq handler from running
(and waits for it to finish if it’s currently running on other CPUs).
The spinlock prevents any other accesses happening at the same time.
Naturally, this is slower than just a spin_lock_irq()
call, so it only makes sense if this type of access happens extremely
rarely.</p>
</section>
</section>
<section id="what-functions-are-safe-to-call-from-interrupts">
<h2>What Functions Are Safe To Call From Interrupts?<a class="headerlink" href="#what-functions-are-safe-to-call-from-interrupts" title="Permalink to this headline">¶</a></h2>
<p>Many functions in the kernel sleep (ie. call schedule()) directly or
indirectly: you can never call them while holding a spinlock, or with
preemption disabled. This also means you need to be in user context:
calling them from an interrupt is illegal.</p>
<section id="some-functions-which-sleep">
<h3>Some Functions Which Sleep<a class="headerlink" href="#some-functions-which-sleep" title="Permalink to this headline">¶</a></h3>
<p>The most common ones are listed below, but you usually have to read the
code to find out if other calls are safe. If everyone else who calls it
can sleep, you probably need to be able to sleep, too. In particular,
registration and deregistration functions usually expect to be called
from user context, and can sleep.</p>
<ul>
<li><p>Accesses to userspace:</p>
<ul class="simple">
<li><p>copy_from_user()</p></li>
<li><p>copy_to_user()</p></li>
<li><p><a class="reference internal" href="../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a></p></li>
<li><p><a class="reference internal" href="../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a></p></li>
</ul>
</li>
<li><p>kmalloc(GP_KERNEL) &lt;kmalloc&gt;`</p></li>
<li><p><a class="reference internal" href="#c.mutex_lock_interruptible" title="mutex_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock_interruptible()</span></code></a> and
<a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a></p>
<p>There is a <a class="reference internal" href="#c.mutex_trylock" title="mutex_trylock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_trylock()</span></code></a> which does not sleep.
Still, it must not be used inside interrupt context since its
implementation is not safe for that. <a class="reference internal" href="#c.mutex_unlock" title="mutex_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_unlock()</span></code></a>
will also never sleep. It cannot be used in interrupt context either
since a mutex must be released by the same task that acquired it.</p>
</li>
</ul>
</section>
<section id="some-functions-which-don-t-sleep">
<h3>Some Functions Which Don’t Sleep<a class="headerlink" href="#some-functions-which-don-t-sleep" title="Permalink to this headline">¶</a></h3>
<p>Some functions are safe to call from any context, or holding almost any
lock.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a></p></li>
<li><p><a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a></p></li>
<li><p><a class="reference internal" href="../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> and <a class="reference internal" href="../driver-api/basics.html#c.timer_delete" title="timer_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete()</span></code></a></p></li>
</ul>
</section>
</section>
<section id="mutex-api-reference">
<h2>Mutex API reference<a class="headerlink" href="#mutex-api-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.mutex_init">
<code class="sig-name descname">mutex_init</code><span class="sig-paren">(</span><em>mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>the mutex to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the mutex to unlocked state.</p>
<p>It is not allowed to initialize an already locked mutex.</p>
</div>
<dl class="function">
<dt id="c.mutex_is_locked">
bool <code class="sig-name descname">mutex_is_locked</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>is the mutex locked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be queried</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the mutex is locked, false if unlocked.</p>
</div>
<dl class="function">
<dt id="c.mutex_lock">
void <code class="sig-name descname">mutex_lock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex exclusively for this task. If the mutex is not
available right now, it will sleep until it can get it.</p>
<p>The mutex must later on be released by the same task that
acquired it. Recursive locking is not allowed. The task
may not exit without first unlocking the mutex. Also, kernel
memory where the mutex resides must not be freed with
the mutex still locked. The mutex must first be initialized
(or statically defined) before it can be locked. <a class="reference internal" href="../core-api/kernel-api.html#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a>-ing
the mutex to 0 is not allowed.</p>
<p>(The CONFIG_DEBUG_MUTEXES .config option turns on debugging
checks that will enforce the restrictions and will also do
deadlock debugging)</p>
<p>This function is similar to (but not equivalent to) down().</p>
</div>
<dl class="function">
<dt id="c.mutex_unlock">
void <code class="sig-name descname">mutex_unlock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously.</p>
<p>This function must not be used in interrupt context. Unlocking
of a not locked mutex is not allowed.</p>
<p>This function is similar to (but not equivalent to) up().</p>
</div>
<dl class="function">
<dt id="c.ww_mutex_unlock">
void <code class="sig-name descname">ww_mutex_unlock</code><span class="sig-paren">(</span>struct ww_mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ww_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the w/w mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously with any of the
ww_mutex_lock* functions (with or without an acquire context). It is
forbidden to release the locks after releasing the acquire context.</p>
<p>This function must not be used in interrupt context. Unlocking
of a unlocked mutex is not allowed.</p>
</div>
<dl class="function">
<dt id="c.ww_mutex_trylock">
int <code class="sig-name descname">ww_mutex_trylock</code><span class="sig-paren">(</span>struct ww_mutex<em> *ww</em>, struct ww_acquire_ctx<em> *ww_ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ww_mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>tries to acquire the w/w mutex with optional acquire context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_mutex</span> <span class="pre">*ww</span></code></dt><dd><p>mutex to lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ww_ctx</span></code></dt><dd><p>optional w/w acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trylocks a mutex with the optional acquire context; no deadlock detection is
possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.</p>
<p>Unlike ww_mutex_lock, no deadlock handling is performed. However, if a <strong>ctx</strong> is
specified, -EALREADY handling may happen in calls to ww_mutex_trylock.</p>
<p>A mutex acquired with this function must be released with ww_mutex_unlock.</p>
</div>
<dl class="function">
<dt id="c.mutex_lock_interruptible">
int <code class="sig-name descname">mutex_lock_interruptible</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by signals.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  If a signal is delivered while the
process is sleeping, this function will return without acquiring the
mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if a
signal arrived.</p>
</div>
<dl class="function">
<dt id="c.mutex_lock_killable">
int <code class="sig-name descname">mutex_lock_killable</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by fatal signals.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  If a signal which will be fatal to
the current process is delivered while the process is sleeping, this
function will return without acquiring the mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if a
fatal signal arrived.</p>
</div>
<dl class="function">
<dt id="c.mutex_lock_io">
void <code class="sig-name descname">mutex_lock_io</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex and mark the process as waiting for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  While the task is waiting for this
mutex, it will be accounted as being in the IO wait state by the
scheduler.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
</div>
<dl class="function">
<dt id="c.mutex_trylock">
int <code class="sig-name descname">mutex_trylock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to acquire the mutex, without waiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire the mutex atomically. Returns 1 if the mutex
has been acquired successfully, and 0 on contention.</p>
<p>This function must not be used in interrupt context. The
mutex must be released by the same task that acquired it.</p>
<p><strong>NOTE</strong></p>
<p>this function follows the spin_trylock() convention, so
it is negated from the down_trylock() return values! Be careful
about this when converting semaphore users to mutexes.</p>
</div>
<dl class="function">
<dt id="c.atomic_dec_and_mutex_lock">
int <code class="sig-name descname">atomic_dec_and_mutex_lock</code><span class="sig-paren">(</span>atomic_t<em> *cnt</em>, struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_and_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding mutex if we dec to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*cnt</span></code></dt><dd><p>the atomic which we are to dec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to return holding if we dec to 0</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>return true and hold lock if we dec to 0, return false otherwise</p>
</div>
</section>
<section id="futex-api-reference">
<h2>Futex API reference<a class="headerlink" href="#futex-api-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.futex_hash">
struct futex_hash_bucket * <code class="sig-name descname">futex_hash</code><span class="sig-paren">(</span>union futex_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the hash bucket in the global hash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>Pointer to the futex key for which the hash is calculated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We hash on the keys returned from get_futex_key (see below) and return the
corresponding hash bucket in the global hash.</p>
</div>
<dl class="function">
<dt id="c.futex_setup_timer">
struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> * <code class="sig-name descname">futex_setup_timer</code><span class="sig-paren">(</span>ktime_t<em> *time</em>, struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em>, int<em> flags</em>, u64<em> range_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_setup_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the sleeping hrtimer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*time</span></code></dt><dd><p>ptr to the given timeout value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the hrtimer_sleeper structure to be set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range_ns</span></code></dt><dd><p>optional range in ns</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Initialized hrtimer_sleeper structure or NULL if no timeout</dt><dd><p>value given</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.get_futex_key">
int <code class="sig-name descname">get_futex_key</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, bool<em> fshared</em>, union futex_key<em> *key</em>, enum futex_access<em> rw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_futex_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters which are the keys for a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>virtual address of the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fshared</span></code></dt><dd><p>false for a PROCESS_PRIVATE futex, true for PROCESS_SHARED</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>address where result is stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">futex_access</span> <span class="pre">rw</span></code></dt><dd><p>mapping needs to be read/write (values: FUTEX_READ,
FUTEX_WRITE)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a negative error code or 0</p>
<p><strong>Description</strong></p>
<p>The key words are stored in <strong>key</strong> on success.</p>
<p>For shared mappings (when <strong>fshared</strong>), the key is:</p>
<blockquote>
<div><p>( inode-&gt;i_sequence, page-&gt;index, offset_within_page )</p>
</div></blockquote>
<p>[ also see get_inode_sequence_number() ]</p>
<p>For private mappings (or when <strong>!fshared</strong>), the key is:</p>
<blockquote>
<div><p>( current-&gt;mm, address, 0 )</p>
</div></blockquote>
<p>This allows (cross process, where applicable) identification of the futex
without keeping the page pinned for the duration of the FUTEX_WAIT.</p>
<p><a class="reference internal" href="../core-api/mm-api.html#c.lock_page" title="lock_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">lock_page()</span></code></a> might sleep, the caller should not hold a spinlock.</p>
</div>
<dl class="function">
<dt id="c.fault_in_user_writeable">
int <code class="sig-name descname">fault_in_user_writeable</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fault_in_user_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Fault in user address and verify RW access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>pointer to faulting user space address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Slow path to fixup the fault we just took in the atomic write
access to <strong>uaddr</strong>.</p>
<p>We have no generic implementation of a non-destructive write to the
user address. We know that we faulted in the atomic pagefault
disabled section so we can as well avoid the #PF overhead by
calling get_user_pages() right away.</p>
</div>
<dl class="function">
<dt id="c.futex_top_waiter">
struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> * <code class="sig-name descname">futex_top_waiter</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, union futex_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_top_waiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest priority waiter on a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash bucket the futex_q’s reside in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the futex key (to distinguish it from other futex futex_q’s)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the hb lock held.</p>
</div>
<dl class="function">
<dt id="c.wait_for_owner_exiting">
void <code class="sig-name descname">wait_for_owner_exiting</code><span class="sig-paren">(</span>int<em> ret</em>, struct task_struct<em> *exiting</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_owner_exiting" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until the owner has exited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ret</span></code></dt><dd><p>owner’s current futex lock status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*exiting</span></code></dt><dd><p>Pointer to the exiting task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold a refcount on <strong>exiting</strong>.</p>
</div>
<dl class="function">
<dt id="c.__futex_unqueue">
void <code class="sig-name descname">__futex_unqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__futex_unqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to unqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be NULL and must be held by the caller.</p>
</div>
<dl class="function">
<dt id="c.futex_unqueue">
int <code class="sig-name descname">futex_unqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_unqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to unqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be held by the caller. A call to <a class="reference internal" href="#c.futex_unqueue" title="futex_unqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_unqueue()</span></code></a> must
be paired with exactly one earlier call to <a class="reference internal" href="#c.futex_queue" title="futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - if the futex_q was still queued (and we removed unqueued it);</p></li>
<li><p>0 - if the futex_q was already removed by the waking thread</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_exit_recursive">
void <code class="sig-name descname">futex_exit_recursive</code><span class="sig-paren">(</span>struct task_struct<em> *tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_exit_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the tasks futex state to FUTEX_STATE_DEAD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task to set the state on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the futex exit state of the task lockless. The futex waiter code
observes that state when a task is exiting and loops until the task has
actually finished the futex cleanup. The worst case for this is that the
waiter runs through the wait loop until the state becomes visible.</p>
<p>This is called from the recursive fault handling path in make_task_dead().</p>
<p>This is best effort. Either the futex exit code has run already or
not. If the OWNER_DIED bit has been set on the futex then the waiter can
take it over. If not, the problem is pushed back to user space. If the
futex exit code did not run yet, then an already queued waiter might
block forever, but there is nothing which can be done about that.</p>
</div>
<dl class="type">
<dt id="c.futex_q">
struct <code class="sig-name descname">futex_q</code><a class="headerlink" href="#c.futex_q" title="Permalink to this definition">¶</a></dt>
<dd><p>The hashed futex queue entry, one per waiting task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct futex_q {
    struct plist_node list;
    struct task_struct *task;
    spinlock_t *lock_ptr;
    union futex_key key;
    struct futex_pi_state *pi_state;
    struct rt_mutex_waiter *rt_waiter;
    union futex_key *requeue_pi_key;
    u32 bitset;
    atomic_t requeue_state;
#ifdef CONFIG_PREEMPT_RT;
    struct rcuwait requeue_wait;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>priority-sorted list of tasks waiting on this futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task</span></code></dt><dd><p>the task waiting on the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_ptr</span></code></dt><dd><p>the hash bucket lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>the key the futex is hashed on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pi_state</span></code></dt><dd><p>optional priority inheritance state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt_waiter</span></code></dt><dd><p>rt_waiter storage for use with requeue_pi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_pi_key</span></code></dt><dd><p>the requeue_pi target futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitset</span></code></dt><dd><p>bitset for the optional bitmasked wakeup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_state</span></code></dt><dd><p>State field for futex_requeue_pi()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_wait</span></code></dt><dd><p>RCU wait for futex_requeue_pi() (RT only)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>We use this hashed waitqueue, instead of a normal wait_queue_entry_t, so
we can wake only the relevant ones (hashed queues may be shared).</p>
<p>A futex_q has a woken state, just like tasks have TASK_RUNNING.
It is considered woken when plist_node_empty(<code class="xref c c-type docutils literal notranslate"><span class="pre">q-&gt;list</span></code>) || q-&gt;lock_ptr == 0.
The order of wakeup is always to make the first condition true, then
the second.</p>
<p>PI futexes are typically woken before they are removed from the hash list via
the rt_mutex code. See futex_unqueue_pi().</p>
<dl class="function">
<dt id="c.futex_match">
int <code class="sig-name descname">futex_match</code><span class="sig-paren">(</span>union futex_key<em> *key1</em>, union futex_key<em> *key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two futex keys are equal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key1</span></code></dt><dd><p>Pointer to key1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>Pointer to key2</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 1 if two futex_keys are equal, 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.futex_queue">
void <code class="sig-name descname">futex_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> *hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Enqueue the futex_q on the futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to enqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>The destination hash bucket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hb-&gt;lock must be held by the caller, and is released here. A call to
<a class="reference internal" href="#c.futex_queue" title="futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a> is typically paired with exactly one call to <a class="reference internal" href="#c.futex_unqueue" title="futex_unqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_unqueue()</span></code></a>.  The
exceptions involve the PI related operations, which may use futex_unqueue_pi()
or nothing if the unqueue is done as part of the wake process and the unqueue
state is implicit in the state of woken task (see <a class="reference internal" href="#c.futex_wait_requeue_pi" title="futex_wait_requeue_pi"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_wait_requeue_pi()</span></code></a> for
an example).</p>
</div>
<dl class="type">
<dt id="c.futex_vector">
struct <code class="sig-name descname">futex_vector</code><a class="headerlink" href="#c.futex_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary struct for futex_waitv()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct futex_vector {
    struct futex_waitv w;
    struct futex_q q;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code></dt><dd><p>Userspace provided data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">q</span></code></dt><dd><p>Kernel side data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Struct used to build an array with all data need for futex_waitv()</p>
<dl class="function">
<dt id="c.futex_lock_pi_atomic">
int <code class="sig-name descname">futex_lock_pi_atomic</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, struct futex_hash_bucket<em> *hb</em>, union futex_key<em> *key</em>, struct futex_pi_state<em> **ps</em>, struct task_struct<em> *task</em>, struct task_struct<em> **exiting</em>, int<em> set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_lock_pi_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic work required to acquire a pi aware futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the pi futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the pi futex hash bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the futex key associated with uaddr and hb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**ps</span></code></dt><dd><p>the pi_state pointer where we store the result of the
lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>the task to perform the atomic lock work for.  This will
be “current” except in the case of requeue pi.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">**exiting</span></code></dt><dd><p>Pointer to store the task pointer of the owner task
which is in the middle of exiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt><dd><p>force setting the FUTEX_WAITERS bit (1) or not (0)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - ready to wait;</p></li>
<li><p>1 - acquired the lock;</p></li>
<li><p>&lt;0 - error</p></li>
</ul>
</div></blockquote>
<p><strong>Description</strong></p>
<p>The hb-&gt;lock must be held by the caller.</p>
<p><strong>exiting</strong> is only set when the return value is -EBUSY. If so, this holds
a refcount on the exiting task on return and the caller needs to drop it
after waiting for the exit to complete.</p>
</div>
<dl class="function">
<dt id="c.fixup_pi_owner">
int <code class="sig-name descname">fixup_pi_owner</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, int<em> locked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fixup_pi_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Post lock pi_state and corner case management</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>user address of the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>futex_q (contains pi_state and access to the rt_mutex)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">locked</span></code></dt><dd><p>if the attempt to take the rt_mutex succeeded (1) or not (0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After attempting to lock an rt_mutex, this function is called to cleanup
the pi_state owner as well as handle race conditions that may allow us to
acquire the lock. Must be called with the hb lock held.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - success, lock taken;</p></li>
<li><p>0 - success, lock not taken;</p></li>
<li><p>&lt;0 - on error (-EFAULT)</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.requeue_futex">
void <code class="sig-name descname">requeue_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> *hb1</em>, struct futex_hash_bucket<em> *hb2</em>, union futex_key<em> *key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.requeue_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue a futex_q from one hb to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q to requeue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb1</span></code></dt><dd><p>the source hash_bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb2</span></code></dt><dd><p>the target hash_bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>the new key for the requeued futex_q</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.requeue_pi_wake_futex">
void <code class="sig-name descname">requeue_pi_wake_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, union futex_key<em> *key</em>, struct futex_hash_bucket<em> *hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.requeue_pi_wake_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake a task that acquired the lock during requeue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the key of the requeue target futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash_bucket of the requeue target futex</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During futex_requeue, with requeue_pi=1, it is possible to acquire the
target futex if it is uncontended or via a lock steal.</p>
<ol class="arabic simple">
<li><p>Set <strong>q</strong>::key to the requeue target futex key so the waiter can detect
the wakeup on the right futex.</p></li>
<li><p>Dequeue <strong>q</strong> from the hash bucket.</p></li>
<li><p>Set <strong>q</strong>::rt_waiter to NULL so the woken up task can detect atomic lock
acquisition.</p></li>
<li><p>Set the q-&gt;lock_ptr to the requeue target hb-&gt;lock for the case that
the waiter has to fixup the pi state.</p></li>
<li><p>Complete the requeue state so the waiter can make progress. After
this point the waiter task can return from the syscall immediately in
case that the pi state does not have to be fixed up.</p></li>
<li><p>Wake the waiter task.</p></li>
</ol>
<p>Must be called with both q-&gt;lock_ptr and hb-&gt;lock held.</p>
</div>
<dl class="function">
<dt id="c.futex_proxy_trylock_atomic">
int <code class="sig-name descname">futex_proxy_trylock_atomic</code><span class="sig-paren">(</span>u32 __user<em> *pifutex</em>, struct futex_hash_bucket<em> *hb1</em>, struct futex_hash_bucket<em> *hb2</em>, union futex_key<em> *key1</em>, union futex_key<em> *key2</em>, struct futex_pi_state<em> **ps</em>, struct task_struct<em> **exiting</em>, int<em> set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_proxy_trylock_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt an atomic lock for the top waiter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*pifutex</span></code></dt><dd><p>the user address of the to futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb1</span></code></dt><dd><p>the from futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb2</span></code></dt><dd><p>the to futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key1</span></code></dt><dd><p>the from futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>the to futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**ps</span></code></dt><dd><p>address to store the pi_state pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">**exiting</span></code></dt><dd><p>Pointer to store the task pointer of the owner task
which is in the middle of exiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt><dd><p>force setting the FUTEX_WAITERS bit (1) or not (0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try and get the lock on behalf of the top waiter if we can do it atomically.
Wake the top waiter if we succeed.  If the caller specified set_waiters,
then direct <a class="reference internal" href="#c.futex_lock_pi_atomic" title="futex_lock_pi_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_lock_pi_atomic()</span></code></a> to force setting the FUTEX_WAITERS bit.
hb1 and hb2 must be held by the caller.</p>
<p><strong>exiting</strong> is only set when the return value is -EBUSY. If so, this holds
a refcount on the exiting task on return and the caller needs to drop it
after waiting for the exit to complete.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - failed to acquire the lock atomically;</p></li>
<li><p>&gt;0 - acquired the lock, return value is vpid of the top_waiter</p></li>
<li><p>&lt;0 - error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_requeue">
int <code class="sig-name descname">futex_requeue</code><span class="sig-paren">(</span>u32 __user<em> *uaddr1</em>, unsigned int<em> flags</em>, u32 __user<em> *uaddr2</em>, int<em> nr_wake</em>, int<em> nr_requeue</em>, u32<em> *cmpval</em>, int<em> requeue_pi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_requeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue waiters from uaddr1 to uaddr2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr1</span></code></dt><dd><p>source futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr2</span></code></dt><dd><p>target futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_wake</span></code></dt><dd><p>number of waiters to wake (must be 1 for requeue_pi)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_requeue</span></code></dt><dd><p>number of waiters to requeue (0-INT_MAX)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*cmpval</span></code></dt><dd><p><strong>uaddr1</strong> expected value (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">requeue_pi</span></code></dt><dd><p>if we are attempting to requeue from a non-pi futex to a
pi futex (pi to pi requeue is not supported)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requeue waiters on uaddr1 to uaddr2. In the requeue_pi case, try to acquire
uaddr2 atomically on behalf of the top waiter.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>&gt;=0 - on success, the number of tasks requeued or woken;</p></li>
<li><p>&lt;0 - on error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.handle_early_requeue_pi_wakeup">
int <code class="sig-name descname">handle_early_requeue_pi_wakeup</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_early_requeue_pi_wakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle early wakeup on the initial futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash_bucket futex_q was original enqueued on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q woken while waiting to be requeued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the timeout associated with the wait (NULL if none)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the cause for the early wakeup.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>-EWOULDBLOCK or -ETIMEDOUT or -ERESTARTNOINTR</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_wait_requeue_pi">
int <code class="sig-name descname">futex_wait_requeue_pi</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, unsigned int<em> flags</em>, u32<em> val</em>, ktime_t<em> *abs_time</em>, u32<em> bitset</em>, u32 __user<em> *uaddr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_requeue_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on uaddr and take uaddr2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the futex we initially wait on (non-pi)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, FLAGS_CLOCKRT, etc.), they must be
the same type, no requeueing from private to shared, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>the expected value of uaddr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*abs_time</span></code></dt><dd><p>absolute timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">bitset</span></code></dt><dd><p>32 bit wakeup bitset set by userspace, defaults to all</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr2</span></code></dt><dd><p>the pi futex we will take prior to returning to user-space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller will wait on uaddr and will be requeued by <a class="reference internal" href="#c.futex_requeue" title="futex_requeue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_requeue()</span></code></a> to
uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
without one, the pi logic would not know which task to boost/deboost, if
there was a need to.</p>
<p>We call schedule in <a class="reference internal" href="#c.futex_wait_queue" title="futex_wait_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_wait_queue()</span></code></a> when we enqueue and return there
via the following–
1) wakeup on uaddr2 after an atomic lock acquisition by <a class="reference internal" href="#c.futex_requeue" title="futex_requeue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_requeue()</span></code></a>
2) wakeup on uaddr2 after a requeue
3) signal
4) timeout</p>
<p>If 3, cleanup and return -ERESTARTNOINTR.</p>
<p>If 2, we may then block on trying to take the rt_mutex and return via:
5) successful lock
6) signal
7) timeout
8) other lock acquisition failure</p>
<p>If 6, return -EWOULDBLOCK (restarting the syscall would do the same).</p>
<p>If 4 or 7, we cleanup and return with -ETIMEDOUT.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - On success;</p></li>
<li><p>&lt;0 - On error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_wait_queue">
void <code class="sig-name descname">futex_wait_queue</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.futex_queue" title="futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a> and wait for wakeup, timeout, or signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q to queue up on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the prepared hrtimer_sleeper, or null for no timeout</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unqueue_multiple">
int <code class="sig-name descname">unqueue_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_vector" title="futex_vector">futex_vector</a><em> *v</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unqueue_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove various futexes from their hash bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*v</span></code></dt><dd><p>The list of futexes to unqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of futexes in the list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to unqueue a list of futexes. This can’t fail.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul>
<li><p>&gt;=0 - Index of the last futex that was awoken;</p></li>
<li><dl class="option-list">
<dt><kbd><span class="option">-1</span></kbd></dt>
<dd><ul class="simple">
<li><p>No futex was awoken</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_wait_multiple_setup">
int <code class="sig-name descname">futex_wait_multiple_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, int<em> count</em>, int<em> *woken</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_multiple_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait and enqueue multiple futexes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>The futex list to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The size of the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*woken</span></code></dt><dd><p>Index of the last woken futex, if any. Used to notify the
caller that it can return this index to userspace (return parameter)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare multiple futexes in a single step and enqueue them. This may fail if
the futex list is invalid or if any futex was already awoken. On success the
task is ready to interruptible sleep.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - One of the futexes was woken by another thread</p></li>
<li><p>0 - Success</p></li>
<li><p>&lt;0 - -EFAULT, -EWOULDBLOCK or -EINVAL</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_sleep_multiple">
void <code class="sig-name descname">futex_sleep_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, unsigned int<em> count</em>, struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_sleep_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Check sleeping conditions and sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>List of futexes to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Length of vs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*to</span></code></dt><dd><p>Timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sleep if and only if the timeout hasn’t expired and no futex on the list has
been woken up.</p>
</div>
<dl class="function">
<dt id="c.futex_wait_multiple">
int <code class="sig-name descname">futex_wait_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, unsigned int<em> count</em>, struct <a class="reference internal" href="../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait on and enqueue several futexes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>The list of futexes to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The number of objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*to</span></code></dt><dd><p>Timeout before giving up and returning to userspace</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Entry point for the FUTEX_WAIT_MULTIPLE futex operation, this function
sleeps on a group of futexes and returns on the first futex that is
wake, or after the timeout has elapsed.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>&gt;=0 - Hint to the futex that was awoken</p></li>
<li><p>&lt;0  - On error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.futex_wait_setup">
int <code class="sig-name descname">futex_wait_setup</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, u32<em> val</em>, unsigned int<em> flags</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> **hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait on a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the futex userspace address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>the expected value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the associated futex_q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">**hb</span></code></dt><dd><p>storage for hash_bucket pointer to be returned to caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the futex_q and locate the hash_bucket.  Get the futex value and
compare it with the expected value.  Handle atomic faults internally.
Return with the hb lock held on success, and unlocked on failure.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - uaddr contains val and hb has been locked;</p></li>
<li><p>&lt;1 - -EFAULT or -EWOULDBLOCK (uaddr does not contain val) and hb is unlocked</p></li>
</ul>
</div></blockquote>
</div>
</section>
<section id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Documentation/locking/spinlocks.rst</span></code>: Linus Torvalds’ spinlocking
tutorial in the kernel sources.</p></li>
<li><p>Unix Systems for Modern Architectures: Symmetric Multiprocessing and
Caching for Kernel Programmers:</p>
<p>Curt Schimmel’s very good introduction to kernel level locking (not
written for Linux, but nearly everything applies). The book is
expensive, but really worth every penny to understand SMP locking.
[ISBN: 0201633388]</p>
</li>
</ul>
</section>
<section id="thanks">
<h2>Thanks<a class="headerlink" href="#thanks" title="Permalink to this headline">¶</a></h2>
<p>Thanks to Telsa Gwynne for DocBooking, neatening and adding style.</p>
<p>Thanks to Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul Mackerras,
Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim Waugh, Pete Zaitcev,
James Morris, Robert Love, Paul McKenney, John Ashby for proofreading,
correcting, flaming, commenting.</p>
<p>Thanks to the cabal for having no influence on this document.</p>
</section>
<section id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>preemption</dt><dd><p>Prior to 2.5, or when <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> is unset, processes in user
context inside the kernel would not preempt each other (ie. you had that
CPU until you gave it up, except for interrupts). With the addition of
<code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> in 2.5.4, this changed: when in user context, higher
priority tasks can “cut in”: spinlocks were changed to disable
preemption, even on UP.</p>
</dd>
<dt>bh</dt><dd><p>Bottom Half: for historical reasons, functions with ‘_bh’ in them often
now refer to any software interrupt, e.g. spin_lock_bh()
blocks any software interrupt on the current CPU. Bottom halves are
deprecated, and will eventually be replaced by tasklets. Only one bottom
half will be running at any time.</p>
</dd>
<dt>Hardware Interrupt / Hardware IRQ</dt><dd><p>Hardware interrupt request. in_hardirq() returns true in a
hardware interrupt handler.</p>
</dd>
<dt>Interrupt Context</dt><dd><p>Not user context: processing a hardware irq or software irq. Indicated
by the in_interrupt() macro returning true.</p>
</dd>
<dt>SMP</dt><dd><p>Symmetric Multi-Processor: kernels compiled for multiple-CPU machines.
(<code class="docutils literal notranslate"><span class="pre">CONFIG_SMP=y</span></code>).</p>
</dd>
<dt>Software Interrupt / softirq</dt><dd><p>Software interrupt handler. in_hardirq() returns false;
in_softirq() returns true. Tasklets and softirqs both
fall into the category of ‘software interrupts’.</p>
<p>Strictly speaking a softirq is one of up to 32 enumerated software
interrupts which can run on multiple CPUs at once. Sometimes used to
refer to tasklets as well (ie. all software interrupts).</p>
</dd>
<dt>tasklet</dt><dd><p>A dynamically-registrable software interrupt, which is guaranteed to
only run on one CPU at a time.</p>
</dd>
<dt>timer</dt><dd><p>A dynamically-registrable software interrupt, which is run at (or close
to) a given time. When running, it is just like a tasklet (in fact, they
are called from the <code class="docutils literal notranslate"><span class="pre">TIMER_SOFTIRQ</span></code>).</p>
</dd>
<dt>UP</dt><dd><p>Uni-Processor: Non-SMP. (<code class="docutils literal notranslate"><span class="pre">CONFIG_SMP=n</span></code>).</p>
</dd>
<dt>User Context</dt><dd><p>The kernel executing on behalf of a particular process (ie. a system
call or trap) or kernel thread. You can tell which process with the
<code class="docutils literal notranslate"><span class="pre">current</span></code> macro.) Not to be confused with userspace. Can be
interrupted by software or hardware interrupts.</p>
</dd>
<dt>Userspace</dt><dd><p>A process executing its own code outside the kernel.</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unreliable Guide To Locking</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#the-problem-with-concurrency">The Problem With Concurrency</a><ul>
<li><a class="reference internal" href="#race-conditions-and-critical-regions">Race Conditions and Critical Regions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locking-in-the-linux-kernel">Locking in the Linux Kernel</a><ul>
<li><a class="reference internal" href="#two-main-types-of-kernel-locks-spinlocks-and-mutexes">Two Main Types of Kernel Locks: Spinlocks and Mutexes</a></li>
<li><a class="reference internal" href="#locks-and-uniprocessor-kernels">Locks and Uniprocessor Kernels</a></li>
<li><a class="reference internal" href="#locking-only-in-user-context">Locking Only In User Context</a></li>
<li><a class="reference internal" href="#locking-between-user-context-and-softirqs">Locking Between User Context and Softirqs</a></li>
<li><a class="reference internal" href="#locking-between-user-context-and-tasklets">Locking Between User Context and Tasklets</a></li>
<li><a class="reference internal" href="#locking-between-user-context-and-timers">Locking Between User Context and Timers</a></li>
<li><a class="reference internal" href="#locking-between-tasklets-timers">Locking Between Tasklets/Timers</a><ul>
<li><a class="reference internal" href="#the-same-tasklet-timer">The Same Tasklet/Timer</a></li>
<li><a class="reference internal" href="#different-tasklets-timers">Different Tasklets/Timers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locking-between-softirqs">Locking Between Softirqs</a><ul>
<li><a class="reference internal" href="#the-same-softirq">The Same Softirq</a></li>
<li><a class="reference internal" href="#different-softirqs">Different Softirqs</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#hard-irq-context">Hard IRQ Context</a><ul>
<li><a class="reference internal" href="#locking-between-hard-irq-and-softirqs-tasklets">Locking Between Hard IRQ and Softirqs/Tasklets</a></li>
<li><a class="reference internal" href="#locking-between-two-hard-irq-handlers">Locking Between Two Hard IRQ Handlers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cheat-sheet-for-locking">Cheat Sheet For Locking</a><ul>
<li><a class="reference internal" href="#table-of-minimum-requirements">Table of Minimum Requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-trylock-functions">The trylock Functions</a></li>
<li><a class="reference internal" href="#common-examples">Common Examples</a><ul>
<li><a class="reference internal" href="#all-in-user-context">All In User Context</a></li>
<li><a class="reference internal" href="#accessing-from-interrupt-context">Accessing From Interrupt Context</a></li>
<li><a class="reference internal" href="#exposing-objects-outside-this-file">Exposing Objects Outside This File</a><ul>
<li><a class="reference internal" href="#using-atomic-operations-for-the-reference-count">Using Atomic Operations For The Reference Count</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protecting-the-objects-themselves">Protecting The Objects Themselves</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-problems">Common Problems</a><ul>
<li><a class="reference internal" href="#deadlock-simple-and-advanced">Deadlock: Simple and Advanced</a></li>
<li><a class="reference internal" href="#preventing-deadlock">Preventing Deadlock</a><ul>
<li><a class="reference internal" href="#overzealous-prevention-of-deadlocks">Overzealous Prevention Of Deadlocks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#racing-timers-a-kernel-pastime">Racing Timers: A Kernel Pastime</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locking-speed">Locking Speed</a><ul>
<li><a class="reference internal" href="#read-write-lock-variants">Read/Write Lock Variants</a></li>
<li><a class="reference internal" href="#avoiding-locks-read-copy-update">Avoiding Locks: Read Copy Update</a></li>
<li><a class="reference internal" href="#per-cpu-data">Per-CPU Data</a></li>
<li><a class="reference internal" href="#data-which-mostly-used-by-an-irq-handler">Data Which Mostly Used By An IRQ Handler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#what-functions-are-safe-to-call-from-interrupts">What Functions Are Safe To Call From Interrupts?</a><ul>
<li><a class="reference internal" href="#some-functions-which-sleep">Some Functions Which Sleep</a></li>
<li><a class="reference internal" href="#some-functions-which-don-t-sleep">Some Functions Which Don’t Sleep</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mutex-api-reference">Mutex API reference</a></li>
<li><a class="reference internal" href="#futex-api-reference">Futex API reference</a></li>
<li><a class="reference internal" href="#further-reading">Further reading</a></li>
<li><a class="reference internal" href="#thanks">Thanks</a></li>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/kernel-hacking/locking.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/kernel-hacking/locking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>