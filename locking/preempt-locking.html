
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Proper Locking Under a Preemptible Kernel: Keeping Kernel Code Preempt-Safe &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Lightweight PI-futexes" href="pi-futex.html" />
    <link rel="prev" title="Wound/Wait Deadlock-Proof Mutex Design" href="ww-mutex-design.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="proper-locking-under-a-preemptible-kernel-keeping-kernel-code-preempt-safe">
<h1>Proper Locking Under a Preemptible Kernel: Keeping Kernel Code Preempt-Safe<a class="headerlink" href="#proper-locking-under-a-preemptible-kernel-keeping-kernel-code-preempt-safe" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Robert Love &lt;<a class="reference external" href="mailto:rml&#37;&#52;&#48;tech9&#46;net">rml<span>&#64;</span>tech9<span>&#46;</span>net</a>&gt;</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>A preemptible kernel creates new locking issues.  The issues are the same as
those under SMP: concurrency and reentrancy.  Thankfully, the Linux preemptible
kernel model leverages existing SMP locking mechanisms.  Thus, the kernel
requires explicit additional locking for very few additional situations.</p>
<p>This document is for all kernel hackers.  Developing code in the kernel
requires protecting these situations.</p>
<section id="rule-1-per-cpu-data-structures-need-explicit-protection">
<h3>RULE #1: Per-CPU data structures need explicit protection<a class="headerlink" href="#rule-1-per-cpu-data-structures-need-explicit-protection" title="Permalink to this headline">¶</a></h3>
<p>Two similar problems arise. An example code snippet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct this_needs_locking tux[NR_CPUS];
tux[smp_processor_id()] = some_value;
/* task is preempted here... */
something = tux[smp_processor_id()];
</pre></div>
</div>
<p>First, since the data is per-CPU, it may not have explicit SMP locking, but
require it otherwise.  Second, when a preempted task is finally rescheduled,
the previous value of smp_processor_id may not equal the current.  You must
protect these situations by disabling preemption around them.</p>
<p>You can also use put_cpu() and get_cpu(), which will disable preemption.</p>
</section>
<section id="rule-2-cpu-state-must-be-protected">
<h3>RULE #2: CPU state must be protected.<a class="headerlink" href="#rule-2-cpu-state-must-be-protected" title="Permalink to this headline">¶</a></h3>
<p>Under preemption, the state of the CPU must be protected.  This is arch-
dependent, but includes CPU structures and state not preserved over a context
switch.  For example, on x86, entering and exiting FPU mode is now a critical
section that must occur while preemption is disabled.  Think what would happen
if the kernel is executing a floating-point instruction and is then preempted.
Remember, the kernel does not save FPU state except for user tasks.  Therefore,
upon preemption, the FPU registers will be sold to the lowest bidder.  Thus,
preemption must be disabled around such regions.</p>
<p>Note, some FPU functions are already explicitly preempt safe.  For example,
kernel_fpu_begin and kernel_fpu_end will disable and enable preemption.</p>
</section>
<section id="rule-3-lock-acquire-and-release-must-be-performed-by-same-task">
<h3>RULE #3: Lock acquire and release must be performed by same task<a class="headerlink" href="#rule-3-lock-acquire-and-release-must-be-performed-by-same-task" title="Permalink to this headline">¶</a></h3>
<p>A lock acquired in one task must be released by the same task.  This
means you can’t do oddball things like acquire a lock and go off to
play while another task releases it.  If you want to do something
like this, acquire and release the task in the same code path and
have the caller wait on an event by the other task.</p>
</section>
</section>
<section id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Permalink to this headline">¶</a></h2>
<p>Data protection under preemption is achieved by disabling preemption for the
duration of the critical region.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>preempt_enable()              decrement the preempt counter
preempt_disable()             increment the preempt counter
preempt_enable_no_resched()   decrement, but do not immediately preempt
preempt_check_resched()       if needed, reschedule
preempt_count()               return the preempt counter
</pre></div>
</div>
<p>The functions are nestable.  In other words, you can call preempt_disable
n-times in a code path, and preemption will not be reenabled until the n-th
call to preempt_enable.  The preempt statements define to nothing if
preemption is not enabled.</p>
<p>Note that you do not need to explicitly prevent preemption if you are holding
any locks or interrupts are disabled, since preemption is implicitly disabled
in those cases.</p>
<p>But keep in mind that ‘irqs disabled’ is a fundamentally unsafe way of
disabling preemption - any cond_resched() or cond_resched_lock() might trigger
a reschedule if the preempt count is 0. A simple <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> might trigger a
reschedule. So use this implicit preemption-disabling property only if you
know that the affected codepath does not do any of this. Best policy is to use
this only for small, atomic code that you wrote and which calls no complex
functions.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cpucache_t *cc; /* this is per-CPU */
preempt_disable();
cc = cc_data(searchp);
if (cc &amp;&amp; cc-&gt;avail) {
        __free_block(searchp, cc_entry(cc), cc-&gt;avail);
        cc-&gt;avail = 0;
}
preempt_enable();
return 0;
</pre></div>
</div>
<p>Notice how the preemption statements must encompass every reference of the
critical variables.  Another example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int buf[NR_CPUS];
set_cpu_val(buf);
if (buf[smp_processor_id()] == -1) printf(KERN_INFO &quot;wee!\n&quot;);
spin_lock(&amp;buf_lock);
/* ... */
</pre></div>
</div>
<p>This code is not preempt-safe, but see how easily we can fix it by simply
moving the spin_lock up two lines.</p>
</section>
<section id="preventing-preemption-using-interrupt-disabling">
<h2>Preventing preemption using interrupt disabling<a class="headerlink" href="#preventing-preemption-using-interrupt-disabling" title="Permalink to this headline">¶</a></h2>
<p>It is possible to prevent a preemption event using local_irq_disable and
local_irq_save.  Note, when doing so, you must be very careful to not cause
an event that would set need_resched and result in a preemption check.  When
in doubt, rely on locking or explicit preemption disabling.</p>
<p>Note in 2.5 interrupt disabling is now only per-CPU (e.g. local).</p>
<p>An additional concern is proper usage of local_irq_disable and local_irq_save.
These may be used to protect from preemption, however, on exit, if preemption
may be enabled, a test to see if preemption is required should be done.  If
these are called from the spin_lock and read/write lock macros, the right thing
is done.  They may also be called within a spin-lock protected region, however,
if they are ever called outside of this context, a test for preemption should
be made. Do note that calls from interrupt context or bottom half/ tasklets
are also protected by preemption locks and so may use the versions which do
not check preemption.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Proper Locking Under a Preemptible Kernel: Keeping Kernel Code Preempt-Safe</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#rule-1-per-cpu-data-structures-need-explicit-protection">RULE #1: Per-CPU data structures need explicit protection</a></li>
<li><a class="reference internal" href="#rule-2-cpu-state-must-be-protected">RULE #2: CPU state must be protected.</a></li>
<li><a class="reference internal" href="#rule-3-lock-acquire-and-release-must-be-performed-by-same-task">RULE #3: Lock acquire and release must be performed by same task</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solution">Solution</a></li>
<li><a class="reference internal" href="#preventing-preemption-using-interrupt-disabling">Preventing preemption using interrupt disabling</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/locking/preempt-locking.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/locking/preempt-locking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>