
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Runtime locking correctness validator &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Lock Statistics" href="lockstat.html" />
    <link rel="prev" title="Lock types and their rules" href="locktypes.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="runtime-locking-correctness-validator">
<h1>Runtime locking correctness validator<a class="headerlink" href="#runtime-locking-correctness-validator" title="Permalink to this headline">¶</a></h1>
<p>started by Ingo Molnar &lt;<a class="reference external" href="mailto:mingo&#37;&#52;&#48;redhat&#46;com">mingo<span>&#64;</span>redhat<span>&#46;</span>com</a>&gt;</p>
<p>additions by Arjan van de Ven &lt;<a class="reference external" href="mailto:arjan&#37;&#52;&#48;linux&#46;intel&#46;com">arjan<span>&#64;</span>linux<span>&#46;</span>intel<span>&#46;</span>com</a>&gt;</p>
<section id="lock-class">
<h2>Lock-class<a class="headerlink" href="#lock-class" title="Permalink to this headline">¶</a></h2>
<p>The basic object the validator operates upon is a ‘class’ of locks.</p>
<p>A class of locks is a group of locks that are logically the same with
respect to locking rules, even if the locks may have multiple (possibly
tens of thousands of) instantiations. For example a lock in the inode
struct is one class, while each inode has its own instantiation of that
lock class.</p>
<p>The validator tracks the ‘usage state’ of lock-classes, and it tracks
the dependencies between different lock-classes. Lock usage indicates
how a lock is used with regard to its IRQ contexts, while lock
dependency can be understood as lock order, where L1 -&gt; L2 suggests that
a task is attempting to acquire L2 while holding L1. From lockdep’s
perspective, the two locks (L1 and L2) are not necessarily related; that
dependency just means the order ever happened. The validator maintains a
continuing effort to prove lock usages and dependencies are correct or
the validator will shoot a splat if incorrect.</p>
<p>A lock-class’s behavior is constructed by its instances collectively:
when the first instance of a lock-class is used after bootup the class
gets registered, then all (subsequent) instances will be mapped to the
class and hence their usages and dependecies will contribute to those of
the class. A lock-class does not go away when a lock instance does, but
it can be removed if the memory space of the lock class (static or
dynamic) is reclaimed, this happens for example when a module is
unloaded or a workqueue is destroyed.</p>
</section>
<section id="state">
<h2>State<a class="headerlink" href="#state" title="Permalink to this headline">¶</a></h2>
<p>The validator tracks lock-class usage history and divides the usage into
(4 usages * n STATEs + 1) categories:</p>
<p>where the 4 usages can be:</p>
<ul class="simple">
<li><p>‘ever held in STATE context’</p></li>
<li><p>‘ever held as readlock in STATE context’</p></li>
<li><p>‘ever held with STATE enabled’</p></li>
<li><p>‘ever held as readlock with STATE enabled’</p></li>
</ul>
<p>where the n STATEs are coded in kernel/locking/lockdep_states.h and as of
now they include:</p>
<ul class="simple">
<li><p>hardirq</p></li>
<li><p>softirq</p></li>
</ul>
<p>where the last 1 category is:</p>
<ul class="simple">
<li><p>‘ever used’                                       [ == !unused        ]</p></li>
</ul>
<p>When locking rules are violated, these usage bits are presented in the
locking error messages, inside curlies, with a total of 2 * n STATEs bits.
A contrived example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>modprobe/2287 is trying to acquire lock:
 (&amp;sio_locks[i].lock){-.-.}, at: [&lt;c02867fd&gt;] mutex_lock+0x21/0x24

but task is already holding lock:
 (&amp;sio_locks[i].lock){-.-.}, at: [&lt;c02867fd&gt;] mutex_lock+0x21/0x24
</pre></div>
</div>
<p>For a given lock, the bit positions from left to right indicate the usage
of the lock and readlock (if exists), for each of the n STATEs listed
above respectively, and the character displayed at each bit position
indicates:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 94%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘.’</p></td>
<td><p>acquired while irqs disabled and not in irq context</p></td>
</tr>
<tr class="row-even"><td><p>‘-’</p></td>
<td><p>acquired in irq context</p></td>
</tr>
<tr class="row-odd"><td><p>‘+’</p></td>
<td><p>acquired with irqs enabled</p></td>
</tr>
<tr class="row-even"><td><p>‘?’</p></td>
<td><p>acquired in irq context with irqs enabled.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The bits are illustrated with an example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(&amp;sio_locks[i].lock){-.-.}, at: [&lt;c02867fd&gt;] mutex_lock+0x21/0x24
                     ||||
                     ||| \-&gt; softirq disabled and not in softirq context
                     || \--&gt; acquired in softirq context
                     | \---&gt; hardirq disabled and not in hardirq context
                      \----&gt; acquired in hardirq context
</pre></div>
</div>
<p>For a given STATE, whether the lock is ever acquired in that STATE
context and whether that STATE is enabled yields four possible cases as
shown in the table below. The bit character is able to indicate which
exact case is for the lock as of the reporting time.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 32%" />
<col style="width: 34%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>irq enabled</p></td>
<td><p>irq disabled</p></td>
</tr>
<tr class="row-even"><td><p>ever in irq</p></td>
<td><p>‘?’</p></td>
<td><p>‘-’</p></td>
</tr>
<tr class="row-odd"><td><p>never in irq</p></td>
<td><p>‘+’</p></td>
<td><p>‘.’</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The character ‘-’ suggests irq is disabled because if otherwise the
charactor ‘?’ would have been shown instead. Similar deduction can be
applied for ‘+’ too.</p>
<p>Unused locks (e.g., mutexes) cannot be part of the cause of an error.</p>
</section>
<section id="single-lock-state-rules">
<h2>Single-lock state rules:<a class="headerlink" href="#single-lock-state-rules" title="Permalink to this headline">¶</a></h2>
<p>A lock is irq-safe means it was ever used in an irq context, while a lock
is irq-unsafe means it was ever acquired with irq enabled.</p>
<p>A softirq-unsafe lock-class is automatically hardirq-unsafe as well. The
following states must be exclusive: only one of them is allowed to be set
for any lock-class based on its usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;hardirq-safe&gt; or &lt;hardirq-unsafe&gt;
&lt;softirq-safe&gt; or &lt;softirq-unsafe&gt;
</pre></div>
</div>
<p>This is because if a lock can be used in irq context (irq-safe) then it
cannot be ever acquired with irq enabled (irq-unsafe). Otherwise, a
deadlock may happen. For example, in the scenario that after this lock
was acquired but before released, if the context is interrupted this
lock will be attempted to acquire twice, which creates a deadlock,
referred to as lock recursion deadlock.</p>
<p>The validator detects and reports lock usage that violates these
single-lock state rules.</p>
</section>
<section id="multi-lock-dependency-rules">
<h2>Multi-lock dependency rules:<a class="headerlink" href="#multi-lock-dependency-rules" title="Permalink to this headline">¶</a></h2>
<p>The same lock-class must not be acquired twice, because this could lead
to lock recursion deadlocks.</p>
<p>Furthermore, two locks can not be taken in inverse order:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;L1&gt; -&gt; &lt;L2&gt;
&lt;L2&gt; -&gt; &lt;L1&gt;
</pre></div>
</div>
<p>because this could lead to a deadlock - referred to as lock inversion
deadlock - as attempts to acquire the two locks form a circle which
could lead to the two contexts waiting for each other permanently. The
validator will find such dependency circle in arbitrary complexity,
i.e., there can be any other locking sequence between the acquire-lock
operations; the validator will still find whether these locks can be
acquired in a circular fashion.</p>
<p>Furthermore, the following usage based lock dependencies are not allowed
between any two lock-classes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;hardirq-safe&gt;   -&gt;  &lt;hardirq-unsafe&gt;
&lt;softirq-safe&gt;   -&gt;  &lt;softirq-unsafe&gt;
</pre></div>
</div>
<p>The first rule comes from the fact that a hardirq-safe lock could be
taken by a hardirq context, interrupting a hardirq-unsafe lock - and
thus could result in a lock inversion deadlock. Likewise, a softirq-safe
lock could be taken by an softirq context, interrupting a softirq-unsafe
lock.</p>
<p>The above rules are enforced for any locking sequence that occurs in the
kernel: when acquiring a new lock, the validator checks whether there is
any rule violation between the new lock and any of the held locks.</p>
<p>When a lock-class changes its state, the following aspects of the above
dependency rules are enforced:</p>
<ul class="simple">
<li><p>if a new hardirq-safe lock is discovered, we check whether it
took any hardirq-unsafe lock in the past.</p></li>
<li><p>if a new softirq-safe lock is discovered, we check whether it took
any softirq-unsafe lock in the past.</p></li>
<li><p>if a new hardirq-unsafe lock is discovered, we check whether any
hardirq-safe lock took it in the past.</p></li>
<li><p>if a new softirq-unsafe lock is discovered, we check whether any
softirq-safe lock took it in the past.</p></li>
</ul>
<p>(Again, we do these checks too on the basis that an interrupt context
could interrupt _any_ of the irq-unsafe or hardirq-unsafe locks, which
could lead to a lock inversion deadlock - even if that lock scenario did
not trigger in practice yet.)</p>
</section>
<section id="exception-nested-data-dependencies-leading-to-nested-locking">
<h2>Exception: Nested data dependencies leading to nested locking<a class="headerlink" href="#exception-nested-data-dependencies-leading-to-nested-locking" title="Permalink to this headline">¶</a></h2>
<p>There are a few cases where the Linux kernel acquires more than one
instance of the same lock-class. Such cases typically happen when there
is some sort of hierarchy within objects of the same type. In these
cases there is an inherent “natural” ordering between the two objects
(defined by the properties of the hierarchy), and the kernel grabs the
locks in this fixed order on each of the objects.</p>
<p>An example of such an object hierarchy that results in “nested locking”
is that of a “whole disk” block-dev object and a “partition” block-dev
object; the partition is “part of” the whole device and as long as one
always takes the whole disk lock as a higher lock than the partition
lock, the lock ordering is fully correct. The validator does not
automatically detect this natural ordering, as the locking rule behind
the ordering is not static.</p>
<p>In order to teach the validator about this correct usage model, new
versions of the various locking primitives were added that allow you to
specify a “nesting level”. An example call, for the block device mutex,
looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum bdev_bd_mutex_lock_class
{
     BD_MUTEX_NORMAL,
     BD_MUTEX_WHOLE,
     BD_MUTEX_PARTITION
};

mutex_lock_nested(&amp;bdev-&gt;bd_contains-&gt;bd_mutex, BD_MUTEX_PARTITION);
</pre></div>
</div>
<p>In this case the locking is done on a bdev object that is known to be a
partition.</p>
<p>The validator treats a lock that is taken in such a nested fashion as a
separate (sub)class for the purposes of validation.</p>
<p>Note: When changing code to use the _nested() primitives, be careful and
check really thoroughly that the hierarchy is correctly mapped; otherwise
you can get false positives or false negatives.</p>
</section>
<section id="annotations">
<h2>Annotations<a class="headerlink" href="#annotations" title="Permalink to this headline">¶</a></h2>
<p>Two constructs can be used to annotate and check where and if certain locks
must be held: lockdep_assert_held*(&amp;lock) and lockdep_*pin_lock(&amp;lock).</p>
<p>As the name suggests, lockdep_assert_held* family of macros assert that a
particular lock is held at a certain time (and generate a WARN() otherwise).
This annotation is largely used all over the kernel, e.g. kernel/sched/
core.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void update_rq_clock(struct rq *rq)
{
      s64 delta;

      lockdep_assert_held(&amp;rq-&gt;lock);
      [...]
}
</pre></div>
</div>
<p>where holding rq-&gt;lock is required to safely update a rq’s clock.</p>
<p>The other family of macros is lockdep_*pin_lock(), which is admittedly only
used for rq-&gt;lock ATM. Despite their limited adoption these annotations
generate a WARN() if the lock of interest is “accidentally” unlocked. This turns
out to be especially helpful to debug code with callbacks, where an upper
layer assumes a lock remains taken, but a lower layer thinks it can maybe drop
and reacquire the lock (“unwittingly” introducing races). lockdep_pin_lock()
returns a ‘struct pin_cookie’ that is then used by lockdep_unpin_lock() to check
that nobody tampered with the lock, e.g. kernel/sched/sched.h:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)
{
      rf-&gt;cookie = lockdep_pin_lock(&amp;rq-&gt;lock);
      [...]
}

static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)
{
      [...]
      lockdep_unpin_lock(&amp;rq-&gt;lock, rf-&gt;cookie);
}
</pre></div>
</div>
<p>While comments about locking requirements might provide useful information,
the runtime checks performed by annotations are invaluable when debugging
locking problems and they carry the same level of details when inspecting
code.  Always prefer annotations when in doubt!</p>
</section>
<section id="proof-of-100-correctness">
<h2>Proof of 100% correctness:<a class="headerlink" href="#proof-of-100-correctness" title="Permalink to this headline">¶</a></h2>
<p>The validator achieves perfect, mathematical ‘closure’ (proof of locking
correctness) in the sense that for every simple, standalone single-task
locking sequence that occurred at least once during the lifetime of the
kernel, the validator proves it with a 100% certainty that no
combination and timing of these locking sequences can cause any class of
lock related deadlock. <a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
<p>I.e. complex multi-CPU and multi-task locking scenarios do not have to
occur in practice to prove a deadlock: only the simple ‘component’
locking chains have to occur at least once (anytime, in any
task/context) for the validator to be able to prove correctness. (For
example, complex deadlocks that would normally need more than 3 CPUs and
a very unlikely constellation of tasks, irq-contexts and timings to
occur, can be detected on a plain, lightly loaded single-CPU system as
well!)</p>
<p>This radically decreases the complexity of locking related QA of the
kernel: what has to be done during QA is to trigger as many “simple”
single-task locking dependencies in the kernel as possible, at least
once, to prove locking correctness - instead of having to trigger every
possible combination of locking interaction between CPUs, combined with
every possible hardirq and softirq nesting scenario (which is impossible
to do in practice).</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>assuming that the validator itself is 100% correct, and no other
part of the system corrupts the state of the validator in any way.
We also assume that all NMI/SMM paths [which could interrupt
even hardirq-disabled codepaths] are correct and do not interfere
with the validator. We also assume that the 64-bit ‘chain hash’
value is unique for every lock-chain in the system. Also, lock
recursion must not be higher than 20.</p>
</dd>
</dl>
</section>
<section id="performance">
<h2>Performance:<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<p>The above rules require <strong>massive</strong> amounts of runtime checking. If we did
that for every lock taken and for every irqs-enable event, it would
render the system practically unusably slow. The complexity of checking
is O(N^2), so even with just a few hundred lock-classes we’d have to do
tens of thousands of checks for every event.</p>
<p>This problem is solved by checking any given ‘locking scenario’ (unique
sequence of locks taken after each other) only once. A simple stack of
held locks is maintained, and a lightweight 64-bit hash value is
calculated, which hash is unique for every lock chain. The hash value,
when the chain is validated for the first time, is then put into a hash
table, which hash-table can be checked in a lockfree manner. If the
locking chain occurs again later on, the hash table tells us that we
don’t have to validate the chain again.</p>
</section>
<section id="troubleshooting">
<h2>Troubleshooting:<a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h2>
<p>The validator tracks a maximum of MAX_LOCKDEP_KEYS number of lock classes.
Exceeding this number will trigger the following lockdep warning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(DEBUG_LOCKS_WARN_ON(id &gt;= MAX_LOCKDEP_KEYS))
</pre></div>
</div>
<p>By default, MAX_LOCKDEP_KEYS is currently set to 8191, and typical
desktop systems have less than 1,000 lock classes, so this warning
normally results from lock-class leakage or failure to properly
initialize locks.  These two problems are illustrated below:</p>
<ol class="arabic">
<li><p>Repeated module loading and unloading while running the validator
will result in lock-class leakage.  The issue here is that each
load of the module will create a new set of lock classes for
that module’s locks, but module unloading does not remove old
classes (see below discussion of reuse of lock classes for why).
Therefore, if that module is loaded and unloaded repeatedly,
the number of lock classes will eventually reach the maximum.</p></li>
<li><p>Using structures such as arrays that have large numbers of
locks that are not explicitly initialized.  For example,
a hash table with 8192 buckets where each bucket has its own
spinlock_t will consume 8192 lock classes -unless- each spinlock
is explicitly initialized at runtime, for example, using the
run-time spin_lock_init() as opposed to compile-time initializers
such as __SPIN_LOCK_UNLOCKED().  Failure to properly initialize
the per-bucket spinlocks would guarantee lock-class overflow.
In contrast, a loop that called spin_lock_init() on each lock
would place all 8192 locks into a single lock class.</p>
<p>The moral of this story is that you should always explicitly
initialize your locks.</p>
</li>
</ol>
<p>One might argue that the validator should be modified to allow
lock classes to be reused.  However, if you are tempted to make this
argument, first review the code and think through the changes that would
be required, keeping in mind that the lock classes to be removed are
likely to be linked into the lock-dependency graph.  This turns out to
be harder to do than to say.</p>
<p>Of course, if you do run out of lock classes, the next thing to do is
to find the offending lock classes.  First, the following command gives
you the number of lock classes currently in use along with the maximum:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>grep &quot;lock-classes&quot; /proc/lockdep_stats
</pre></div>
</div>
<p>This command produces the following output on a modest system:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock-classes:                          748 [max: 8191]
</pre></div>
</div>
<p>If the number allocated (748 above) increases continually over time,
then there is likely a leak.  The following command can be used to
identify the leaking lock classes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>grep &quot;BD&quot; /proc/lockdep
</pre></div>
</div>
<p>Run the command and save the output, then compare against the output from
a later run of this command to identify the leakers.  This same output
can also help you find situations where runtime lock initialization has
been omitted.</p>
</section>
<section id="recursive-read-locks">
<h2>Recursive read locks:<a class="headerlink" href="#recursive-read-locks" title="Permalink to this headline">¶</a></h2>
<p>The whole of the rest document tries to prove a certain type of cycle is equivalent
to deadlock possibility.</p>
<p>There are three types of lockers: writers (i.e. exclusive lockers, like
spin_lock() or write_lock()), non-recursive readers (i.e. shared lockers, like
down_read()) and recursive readers (recursive shared lockers, like <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>).
And we use the following notations of those lockers in the rest of the document:</p>
<blockquote>
<div><p>W or E: stands for writers (exclusive lockers).
r:      stands for non-recursive readers.
R:      stands for recursive readers.
S:      stands for all readers (non-recursive + recursive), as both are shared lockers.
N:      stands for writers and non-recursive readers, as both are not recursive.</p>
</div></blockquote>
<p>Obviously, N is “r or W” and S is “r or R”.</p>
<p>Recursive readers, as their name indicates, are the lockers allowed to acquire
even inside the critical section of another reader of the same lock instance,
in other words, allowing nested read-side critical sections of one lock instance.</p>
<p>While non-recursive readers will cause a self deadlock if trying to acquire inside
the critical section of another reader of the same lock instance.</p>
<p>The difference between recursive readers and non-recursive readers is because:
recursive readers get blocked only by a write lock <em>holder</em>, while non-recursive
readers could get blocked by a write lock <em>waiter</em>. Considering the follow
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TASK A:                 TASK B:

read_lock(X);
                        write_lock(X);
read_lock_2(X);
</pre></div>
</div>
<p>Task A gets the reader (no matter whether recursive or non-recursive) on X via
read_lock() first. And when task B tries to acquire writer on X, it will block
and become a waiter for writer on X. Now if read_lock_2() is recursive readers,
task A will make progress, because writer waiters don’t block recursive readers,
and there is no deadlock. However, if read_lock_2() is non-recursive readers,
it will get blocked by writer waiter B, and cause a self deadlock.</p>
</section>
<section id="block-conditions-on-readers-writers-of-the-same-lock-instance">
<h2>Block conditions on readers/writers of the same lock instance:<a class="headerlink" href="#block-conditions-on-readers-writers-of-the-same-lock-instance" title="Permalink to this headline">¶</a></h2>
<p>There are simply four block conditions:</p>
<ol class="arabic simple">
<li><p>Writers block other writers.</p></li>
<li><p>Readers block writers.</p></li>
<li><p>Writers block both recursive readers and non-recursive readers.</p></li>
<li><p>And readers (recursive or not) don’t block other recursive readers but
may block non-recursive readers (because of the potential co-existing
writer waiters)</p></li>
</ol>
<p>Block condition matrix, Y means the row blocks the column, and N means otherwise.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>W</p></td>
<td><p>r</p></td>
<td><p>R</p></td>
</tr>
<tr class="row-even"><td><p>W</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>r</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>R</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
</tbody>
</table>
<p>(W: writers, r: non-recursive readers, R: recursive readers)</p>
</div></blockquote>
<p>acquired recursively. Unlike non-recursive read locks, recursive read locks
only get blocked by current write lock <em>holders</em> other than write lock
<em>waiters</em>, for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TASK A:                 TASK B:

read_lock(X);

                        write_lock(X);

read_lock(X);
</pre></div>
</div>
<p>is not a deadlock for recursive read locks, as while the task B is waiting for
the lock X, the second read_lock() doesn’t need to wait because it’s a recursive
read lock. However if the read_lock() is non-recursive read lock, then the above
case is a deadlock, because even if the write_lock() in TASK B cannot get the
lock, but it can block the second read_lock() in TASK A.</p>
<p>Note that a lock can be a write lock (exclusive lock), a non-recursive read
lock (non-recursive shared lock) or a recursive read lock (recursive shared
lock), depending on the lock operations used to acquire it (more specifically,
the value of the ‘read’ parameter for lock_acquire()). In other words, a single
lock instance has three types of acquisition depending on the acquisition
functions: exclusive, non-recursive read, and recursive read.</p>
<p>To be concise, we call that write locks and non-recursive read locks as
“non-recursive” locks and recursive read locks as “recursive” locks.</p>
<p>Recursive locks don’t block each other, while non-recursive locks do (this is
even true for two non-recursive read locks). A non-recursive lock can block the
corresponding recursive lock, and vice versa.</p>
<p>A deadlock case with recursive locks involved is as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TASK A:                 TASK B:

read_lock(X);
                        read_lock(Y);
write_lock(Y);
                        write_lock(X);
</pre></div>
</div>
<p>Task A is waiting for task B to read_unlock() Y and task B is waiting for task
A to read_unlock() X.</p>
</section>
<section id="dependency-types-and-strong-dependency-paths">
<h2>Dependency types and strong dependency paths:<a class="headerlink" href="#dependency-types-and-strong-dependency-paths" title="Permalink to this headline">¶</a></h2>
<p>Lock dependencies record the orders of the acquisitions of a pair of locks, and
because there are 3 types for lockers, there are, in theory, 9 types of lock
dependencies, but we can show that 4 types of lock dependencies are enough for
deadlock detection.</p>
<p>For each lock dependency:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L1 -&gt; L2
</pre></div>
</div>
<p>, which means lockdep has seen L1 held before L2 held in the same context at runtime.
And in deadlock detection, we care whether we could get blocked on L2 with L1 held,
IOW, whether there is a locker L3 that L1 blocks L3 and L2 gets blocked by L3. So
we only care about 1) what L1 blocks and 2) what blocks L2. As a result, we can combine
recursive readers and non-recursive readers for L1 (as they block the same types) and
we can combine writers and non-recursive readers for L2 (as they get blocked by the
same types).</p>
<p>With the above combination for simplification, there are 4 types of dependency edges
in the lockdep graph:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>-(ER)-&gt;:</dt><dd><p>exclusive writer to recursive reader dependency, “X -(ER)-&gt; Y” means
X -&gt; Y and X is a writer and Y is a recursive reader.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>-(EN)-&gt;:</dt><dd><p>exclusive writer to non-recursive locker dependency, “X -(EN)-&gt; Y” means
X -&gt; Y and X is a writer and Y is either a writer or non-recursive reader.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>-(SR)-&gt;:</dt><dd><p>shared reader to recursive reader dependency, “X -(SR)-&gt; Y” means
X -&gt; Y and X is a reader (recursive or not) and Y is a recursive reader.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>-(SN)-&gt;:</dt><dd><p>shared reader to non-recursive locker dependency, “X -(SN)-&gt; Y” means
X -&gt; Y and X is a reader (recursive or not) and Y is either a writer or
non-recursive reader.</p>
</dd>
</dl>
</li>
</ol>
<p>Note that given two locks, they may have multiple dependencies between them,
for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TASK A:

read_lock(X);
write_lock(Y);
...

TASK B:

write_lock(X);
write_lock(Y);
</pre></div>
</div>
<p>, we have both X -(SN)-&gt; Y and X -(EN)-&gt; Y in the dependency graph.</p>
<p>We use -(xN)-&gt; to represent edges that are either -(EN)-&gt; or -(SN)-&gt;, the
similar for -(Ex)-&gt;, -(xR)-&gt; and -(Sx)-&gt;</p>
<p>A “path” is a series of conjunct dependency edges in the graph. And we define a
“strong” path, which indicates the strong dependency throughout each dependency
in the path, as the path that doesn’t have two conjunct edges (dependencies) as
-(xR)-&gt; and -(Sx)-&gt;. In other words, a “strong” path is a path from a lock
walking to another through the lock dependencies, and if X -&gt; Y -&gt; Z is in the
path (where X, Y, Z are locks), and the walk from X to Y is through a -(SR)-&gt; or
-(ER)-&gt; dependency, the walk from Y to Z must not be through a -(SN)-&gt; or
-(SR)-&gt; dependency.</p>
<p>We will see why the path is called “strong” in next section.</p>
</section>
<section id="recursive-read-deadlock-detection">
<h2>Recursive Read Deadlock Detection:<a class="headerlink" href="#recursive-read-deadlock-detection" title="Permalink to this headline">¶</a></h2>
<p>We now prove two things:</p>
<p>Lemma 1:</p>
<p>If there is a closed strong path (i.e. a strong circle), then there is a
combination of locking sequences that causes deadlock. I.e. a strong circle is
sufficient for deadlock detection.</p>
<p>Lemma 2:</p>
<p>If there is no closed strong path (i.e. strong circle), then there is no
combination of locking sequences that could cause deadlock. I.e.  strong
circles are necessary for deadlock detection.</p>
<p>With these two Lemmas, we can easily say a closed strong path is both sufficient
and necessary for deadlocks, therefore a closed strong path is equivalent to
deadlock possibility. As a closed strong path stands for a dependency chain that
could cause deadlocks, so we call it “strong”, considering there are dependency
circles that won’t cause deadlocks.</p>
<p>Proof for sufficiency (Lemma 1):</p>
<p>Let’s say we have a strong circle:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L1 -&gt; L2 ... -&gt; Ln -&gt; L1
</pre></div>
</div>
<p>, which means we have dependencies:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L1 -&gt; L2
L2 -&gt; L3
...
Ln-1 -&gt; Ln
Ln -&gt; L1
</pre></div>
</div>
<p>We now can construct a combination of locking sequences that cause deadlock:</p>
<p>Firstly let’s make one CPU/task get the L1 in L1 -&gt; L2, and then another get
the L2 in L2 -&gt; L3, and so on. After this, all of the Lx in Lx -&gt; Lx+1 are
held by different CPU/tasks.</p>
<p>And then because we have L1 -&gt; L2, so the holder of L1 is going to acquire L2
in L1 -&gt; L2, however since L2 is already held by another CPU/task, plus L1 -&gt;
L2 and L2 -&gt; L3 are not -(xR)-&gt; and -(Sx)-&gt; (the definition of strong), which
means either L2 in L1 -&gt; L2 is a non-recursive locker (blocked by anyone) or
the L2 in L2 -&gt; L3, is writer (blocking anyone), therefore the holder of L1
cannot get L2, it has to wait L2’s holder to release.</p>
<p>Moreover, we can have a similar conclusion for L2’s holder: it has to wait L3’s
holder to release, and so on. We now can prove that Lx’s holder has to wait for
Lx+1’s holder to release, and note that Ln+1 is L1, so we have a circular
waiting scenario and nobody can get progress, therefore a deadlock.</p>
<p>Proof for necessary (Lemma 2):</p>
<p>Lemma 2 is equivalent to: If there is a deadlock scenario, then there must be a
strong circle in the dependency graph.</p>
<p>According to Wikipedia[1], if there is a deadlock, then there must be a circular
waiting scenario, means there are N CPU/tasks, where CPU/task P1 is waiting for
a lock held by P2, and P2 is waiting for a lock held by P3, … and Pn is waiting
for a lock held by P1. Let’s name the lock Px is waiting as Lx, so since P1 is waiting
for L1 and holding Ln, so we will have Ln -&gt; L1 in the dependency graph. Similarly,
we have L1 -&gt; L2, L2 -&gt; L3, …, Ln-1 -&gt; Ln in the dependency graph, which means we
have a circle:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ln -&gt; L1 -&gt; L2 -&gt; ... -&gt; Ln
</pre></div>
</div>
<p>, and now let’s prove the circle is strong:</p>
<p>For a lock Lx, Px contributes the dependency Lx-1 -&gt; Lx and Px+1 contributes
the dependency Lx -&gt; Lx+1, and since Px is waiting for Px+1 to release Lx,
so it’s impossible that Lx on Px+1 is a reader and Lx on Px is a recursive
reader, because readers (no matter recursive or not) don’t block recursive
readers, therefore Lx-1 -&gt; Lx and Lx -&gt; Lx+1 cannot be a -(xR)-&gt; -(Sx)-&gt; pair,
and this is true for any lock in the circle, therefore, the circle is strong.</p>
</section>
<section id="references">
<h2>References:<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[1]: <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">https://en.wikipedia.org/wiki/Deadlock</a>
[2]: Shibu, K. (2009). Intro To Embedded Systems (1st ed.). Tata McGraw-Hill</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Runtime locking correctness validator</a><ul>
<li><a class="reference internal" href="#lock-class">Lock-class</a></li>
<li><a class="reference internal" href="#state">State</a></li>
<li><a class="reference internal" href="#single-lock-state-rules">Single-lock state rules:</a></li>
<li><a class="reference internal" href="#multi-lock-dependency-rules">Multi-lock dependency rules:</a></li>
<li><a class="reference internal" href="#exception-nested-data-dependencies-leading-to-nested-locking">Exception: Nested data dependencies leading to nested locking</a></li>
<li><a class="reference internal" href="#annotations">Annotations</a></li>
<li><a class="reference internal" href="#proof-of-100-correctness">Proof of 100% correctness:</a></li>
<li><a class="reference internal" href="#performance">Performance:</a></li>
<li><a class="reference internal" href="#troubleshooting">Troubleshooting:</a></li>
<li><a class="reference internal" href="#recursive-read-locks">Recursive read locks:</a></li>
<li><a class="reference internal" href="#block-conditions-on-readers-writers-of-the-same-lock-instance">Block conditions on readers/writers of the same lock instance:</a></li>
<li><a class="reference internal" href="#dependency-types-and-strong-dependency-paths">Dependency types and strong dependency paths:</a></li>
<li><a class="reference internal" href="#recursive-read-deadlock-detection">Recursive Read Deadlock Detection:</a></li>
<li><a class="reference internal" href="#references">References:</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/locking/lockdep-design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/locking/lockdep-design.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>