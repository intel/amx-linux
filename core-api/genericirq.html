
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Linux generic IRQ handling &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory Protection Keys" href="protection-keys.html" />
    <link rel="prev" title="Memory hotplug" href="memory-hotplug.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linux-generic-irq-handling">
<h1>Linux generic IRQ handling<a class="headerlink" href="#linux-generic-irq-handling" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2005-2010: Thomas Gleixner</p>
</dd>
<dt class="field-even">Copyright</dt>
<dd class="field-even"><p>© 2005-2006:  Ingo Molnar</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The generic interrupt handling layer is designed to provide a complete
abstraction of interrupt handling for device drivers. It is able to
handle all the different types of interrupt controller hardware. Device
drivers use generic API functions to request, enable, disable and free
interrupts. The drivers do not have to know anything about interrupt
hardware details, so they can be used on different platforms without
code changes.</p>
<p>This documentation is provided to developers who want to implement an
interrupt subsystem based for their architecture, with the help of the
generic IRQ handling layer.</p>
</section>
<section id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<p>The original implementation of interrupt handling in Linux uses the
__do_IRQ() super-handler, which is able to deal with every type of
interrupt logic.</p>
<p>Originally, Russell King identified different types of handlers to build
a quite universal set for the ARM interrupt handler implementation in
Linux 2.5/2.6. He distinguished between:</p>
<ul class="simple">
<li><p>Level type</p></li>
<li><p>Edge type</p></li>
<li><p>Simple type</p></li>
</ul>
<p>During the implementation we identified another type:</p>
<ul class="simple">
<li><p>Fast EOI type</p></li>
</ul>
<p>In the SMP world of the __do_IRQ() super-handler another type was
identified:</p>
<ul class="simple">
<li><p>Per CPU type</p></li>
</ul>
<p>This split implementation of high-level IRQ handlers allows us to
optimize the flow of the interrupt handling for each specific interrupt
type. This reduces complexity in that particular code path and allows
the optimized handling of a given type.</p>
<p>The original general IRQ implementation used hw_interrupt_type
structures and their <code class="docutils literal notranslate"><span class="pre">-&gt;ack</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;end</span></code> [etc.] callbacks to differentiate
the flow control in the super-handler. This leads to a mix of flow logic
and low-level hardware logic, and it also leads to unnecessary code
duplication: for example in i386, there is an <code class="docutils literal notranslate"><span class="pre">ioapic_level_irq</span></code> and an
<code class="docutils literal notranslate"><span class="pre">ioapic_edge_irq</span></code> IRQ-type which share many of the low-level details but
have different flow handling.</p>
<p>A more natural abstraction is the clean separation of the ‘irq flow’ and
the ‘chip details’.</p>
<p>Analysing a couple of architecture’s IRQ subsystem implementations
reveals that most of them can use a generic set of ‘irq flow’ methods
and only need to add the chip-level specific code. The separation is
also valuable for (sub)architectures which need specific quirks in the
IRQ flow itself but not in the chip details - and thus provides a more
transparent IRQ subsystem design.</p>
<p>Each interrupt descriptor is assigned its own high-level flow handler,
which is normally one of the generic implementations. (This high-level
flow handler implementation also makes it simple to provide
demultiplexing handlers which can be found in embedded platforms on
various architectures.)</p>
<p>The separation makes the generic interrupt handling layer more flexible
and extensible. For example, an (sub)architecture can use a generic
IRQ-flow implementation for ‘level type’ interrupts and add a
(sub)architecture specific ‘edge type’ implementation.</p>
<p>To make the transition to the new model easier and prevent the breakage
of existing implementations, the __do_IRQ() super-handler is still
available. This leads to a kind of duality for the time being. Over time
the new model should be used in more and more architectures, as it
enables smaller and cleaner IRQ subsystems. It’s deprecated for three
years now and about to be removed.</p>
</section>
<section id="known-bugs-and-assumptions">
<h2>Known Bugs And Assumptions<a class="headerlink" href="#known-bugs-and-assumptions" title="Permalink to this headline">¶</a></h2>
<p>None (knock on wood).</p>
</section>
<section id="abstraction-layers">
<h2>Abstraction layers<a class="headerlink" href="#abstraction-layers" title="Permalink to this headline">¶</a></h2>
<p>There are three main levels of abstraction in the interrupt code:</p>
<ol class="arabic simple">
<li><p>High-level driver API</p></li>
<li><p>High-level IRQ flow handlers</p></li>
<li><p>Chip-level hardware encapsulation</p></li>
</ol>
<section id="interrupt-control-flow">
<h3>Interrupt control flow<a class="headerlink" href="#interrupt-control-flow" title="Permalink to this headline">¶</a></h3>
<p>Each interrupt is described by an interrupt descriptor structure
irq_desc. The interrupt is referenced by an ‘unsigned int’ numeric
value which selects the corresponding interrupt description structure in
the descriptor structures array. The descriptor structure contains
status information and pointers to the interrupt flow method and the
interrupt chip structure which are assigned to this interrupt.</p>
<p>Whenever an interrupt triggers, the low-level architecture code calls
into the generic interrupt code by calling desc-&gt;handle_irq(). This
high-level IRQ handling function only uses desc-&gt;irq_data.chip
primitives referenced by the assigned chip descriptor structure.</p>
</section>
<section id="high-level-driver-api">
<h3>High-level Driver API<a class="headerlink" href="#high-level-driver-api" title="Permalink to this headline">¶</a></h3>
<p>The high-level Driver API consists of following functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.request_threaded_irq" title="request_threaded_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_threaded_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.enable_irq" title="enable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.disable_irq_nosync" title="disable_irq_nosync"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq_nosync()</span></code></a> (SMP only)</p></li>
<li><p><a class="reference internal" href="#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> (SMP only)</p></li>
<li><p><a class="reference internal" href="#c.irq_set_irq_type" title="irq_set_irq_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_irq_type()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.irq_set_irq_wake" title="irq_set_irq_wake"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_irq_wake()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.irq_set_handler_data" title="irq_set_handler_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_handler_data()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.irq_set_chip" title="irq_set_chip"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_chip()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.irq_set_chip_data" title="irq_set_chip_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_chip_data()</span></code></a></p></li>
</ul>
<p>See the autogenerated function documentation for details.</p>
</section>
<section id="high-level-irq-flow-handlers">
<h3>High-level IRQ flow handlers<a class="headerlink" href="#high-level-irq-flow-handlers" title="Permalink to this headline">¶</a></h3>
<p>The generic layer provides a set of pre-defined irq-flow methods:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.handle_level_irq" title="handle_level_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_level_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_edge_irq" title="handle_edge_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_edge_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_fasteoi_irq" title="handle_fasteoi_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_fasteoi_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_simple_irq" title="handle_simple_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_simple_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_percpu_irq" title="handle_percpu_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_percpu_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_edge_eoi_irq" title="handle_edge_eoi_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_edge_eoi_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.handle_bad_irq" title="handle_bad_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_bad_irq()</span></code></a></p></li>
</ul>
<p>The interrupt flow handlers (either pre-defined or architecture
specific) are assigned to specific interrupts by the architecture either
during bootup or during device initialization.</p>
<section id="default-flow-implementations">
<h4>Default flow implementations<a class="headerlink" href="#default-flow-implementations" title="Permalink to this headline">¶</a></h4>
<section id="helper-functions">
<h5>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h5>
<p>The helper functions call the chip primitives and are used by the
default flow implementations. The following helper functions are
implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default_enable(struct irq_data *data)
{
    desc-&gt;irq_data.chip-&gt;irq_unmask(data);
}

default_disable(struct irq_data *data)
{
    if (!delay_disable(data))
        desc-&gt;irq_data.chip-&gt;irq_mask(data);
}

default_ack(struct irq_data *data)
{
    chip-&gt;irq_ack(data);
}

default_mask_ack(struct irq_data *data)
{
    if (chip-&gt;irq_mask_ack) {
        chip-&gt;irq_mask_ack(data);
    } else {
        chip-&gt;irq_mask(data);
        chip-&gt;irq_ack(data);
    }
}

noop(struct irq_data *data))
{
}
</pre></div>
</div>
</section>
</section>
<section id="default-flow-handler-implementations">
<h4>Default flow handler implementations<a class="headerlink" href="#default-flow-handler-implementations" title="Permalink to this headline">¶</a></h4>
<section id="default-level-irq-flow-handler">
<h5>Default Level IRQ flow handler<a class="headerlink" href="#default-level-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_level_irq provides a generic implementation for level-triggered
interrupts.</p>
<p>The following control flow is implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>desc-&gt;irq_data.chip-&gt;irq_mask_ack();
handle_irq_event(desc-&gt;action);
desc-&gt;irq_data.chip-&gt;irq_unmask();
</pre></div>
</div>
</section>
<section id="default-fast-eoi-irq-flow-handler">
<h5>Default Fast EOI IRQ flow handler<a class="headerlink" href="#default-fast-eoi-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_fasteoi_irq provides a generic implementation for interrupts,
which only need an EOI at the end of the handler.</p>
<p>The following control flow is implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>handle_irq_event(desc-&gt;action);
desc-&gt;irq_data.chip-&gt;irq_eoi();
</pre></div>
</div>
</section>
<section id="default-edge-irq-flow-handler">
<h5>Default Edge IRQ flow handler<a class="headerlink" href="#default-edge-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_edge_irq provides a generic implementation for edge-triggered
interrupts.</p>
<p>The following control flow is implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (desc-&gt;status &amp; running) {
    desc-&gt;irq_data.chip-&gt;irq_mask_ack();
    desc-&gt;status |= pending | masked;
    return;
}
desc-&gt;irq_data.chip-&gt;irq_ack();
desc-&gt;status |= running;
do {
    if (desc-&gt;status &amp; masked)
        desc-&gt;irq_data.chip-&gt;irq_unmask();
    desc-&gt;status &amp;= ~pending;
    handle_irq_event(desc-&gt;action);
} while (status &amp; pending);
desc-&gt;status &amp;= ~running;
</pre></div>
</div>
</section>
<section id="default-simple-irq-flow-handler">
<h5>Default simple IRQ flow handler<a class="headerlink" href="#default-simple-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_simple_irq provides a generic implementation for simple
interrupts.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The simple flow handler does not call any handler/chip primitives.</p>
</div>
<p>The following control flow is implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>handle_irq_event(desc-&gt;action);
</pre></div>
</div>
</section>
<section id="default-per-cpu-flow-handler">
<h5>Default per CPU flow handler<a class="headerlink" href="#default-per-cpu-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_percpu_irq provides a generic implementation for per CPU
interrupts.</p>
<p>Per CPU interrupts are only available on SMP and the handler provides a
simplified version without locking.</p>
<p>The following control flow is implemented (simplified excerpt):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (desc-&gt;irq_data.chip-&gt;irq_ack)
    desc-&gt;irq_data.chip-&gt;irq_ack();
handle_irq_event(desc-&gt;action);
if (desc-&gt;irq_data.chip-&gt;irq_eoi)
    desc-&gt;irq_data.chip-&gt;irq_eoi();
</pre></div>
</div>
</section>
<section id="eoi-edge-irq-flow-handler">
<h5>EOI Edge IRQ flow handler<a class="headerlink" href="#eoi-edge-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_edge_eoi_irq provides an abnomination of the edge handler
which is solely used to tame a badly wreckaged irq controller on
powerpc/cell.</p>
</section>
<section id="bad-irq-flow-handler">
<h5>Bad IRQ flow handler<a class="headerlink" href="#bad-irq-flow-handler" title="Permalink to this headline">¶</a></h5>
<p>handle_bad_irq is used for spurious interrupts which have no real
handler assigned..</p>
</section>
</section>
<section id="quirks-and-optimizations">
<h4>Quirks and optimizations<a class="headerlink" href="#quirks-and-optimizations" title="Permalink to this headline">¶</a></h4>
<p>The generic functions are intended for ‘clean’ architectures and chips,
which have no platform-specific IRQ handling quirks. If an architecture
needs to implement quirks on the ‘flow’ level then it can do so by
overriding the high-level irq-flow handler.</p>
</section>
<section id="delayed-interrupt-disable">
<h4>Delayed interrupt disable<a class="headerlink" href="#delayed-interrupt-disable" title="Permalink to this headline">¶</a></h4>
<p>This per interrupt selectable feature, which was introduced by Russell
King in the ARM interrupt implementation, does not mask an interrupt at
the hardware level when <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> is called. The interrupt is kept
enabled and is masked in the flow handler when an interrupt event
happens. This prevents losing edge interrupts on hardware which does not
store an edge interrupt event while the interrupt is disabled at the
hardware level. When an interrupt arrives while the IRQ_DISABLED flag
is set, then the interrupt is masked at the hardware level and the
IRQ_PENDING bit is set. When the interrupt is re-enabled by
<a class="reference internal" href="#c.enable_irq" title="enable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_irq()</span></code></a> the pending bit is checked and if it is set, the interrupt
is resent either via hardware or by a software resend mechanism. (It’s
necessary to enable CONFIG_HARDIRQS_SW_RESEND when you want to use
the delayed interrupt disable feature and your hardware is not capable
of retriggering an interrupt.) The delayed interrupt disable is not
configurable.</p>
</section>
</section>
<section id="chip-level-hardware-encapsulation">
<h3>Chip-level hardware encapsulation<a class="headerlink" href="#chip-level-hardware-encapsulation" title="Permalink to this headline">¶</a></h3>
<p>The chip-level hardware descriptor structure <a class="reference internal" href="#c.irq_chip" title="irq_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">irq_chip</span></code></a> contains all
the direct chip relevant functions, which can be utilized by the irq flow
implementations.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">irq_ack</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_mask_ack</span></code> - Optional, recommended for performance</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_mask</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_unmask</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_eoi</span></code> - Optional, required for EOI flow handlers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_retrigger</span></code> - Optional</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_set_type</span></code> - Optional</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">irq_set_wake</span></code> - Optional</p></li>
</ul>
<p>These primitives are strictly intended to mean what they say: ack means
ACK, masking means masking of an IRQ line, etc. It is up to the flow
handler(s) to use these basic units of low-level functionality.</p>
</section>
</section>
<section id="do-irq-entry-point">
<h2>__do_IRQ entry point<a class="headerlink" href="#do-irq-entry-point" title="Permalink to this headline">¶</a></h2>
<p>The original implementation __do_IRQ() was an alternative entry point
for all types of interrupts. It no longer exists.</p>
<p>This handler turned out to be not suitable for all interrupt hardware
and was therefore reimplemented with split functionality for
edge/level/simple/percpu interrupts. This is not only a functional
optimization. It also shortens code paths for interrupts.</p>
</section>
<section id="locking-on-smp">
<h2>Locking on SMP<a class="headerlink" href="#locking-on-smp" title="Permalink to this headline">¶</a></h2>
<p>The locking of chip registers is up to the architecture that defines the
chip primitives. The per-irq structure is protected via desc-&gt;lock, by
the generic layer.</p>
</section>
<section id="generic-interrupt-chip">
<h2>Generic interrupt chip<a class="headerlink" href="#generic-interrupt-chip" title="Permalink to this headline">¶</a></h2>
<p>To avoid copies of identical implementations of IRQ chips the core
provides a configurable generic interrupt chip implementation.
Developers should check carefully whether the generic chip fits their
needs before implementing the same functionality slightly differently
themselves.</p>
<dl class="function">
<dt id="c.irq_gc_noop">
void <code class="sig-name descname">irq_gc_noop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_noop" title="Permalink to this definition">¶</a></dt>
<dd><p>NOOP function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_gc_mask_disable_reg">
void <code class="sig-name descname">irq_gc_mask_disable_reg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_mask_disable_reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask chip via disable register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Chip has separate enable/disable registers instead of a single mask
register.</p>
</div>
<dl class="function">
<dt id="c.irq_gc_mask_set_bit">
void <code class="sig-name descname">irq_gc_mask_set_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_mask_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask chip via setting bit in mask register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Chip has a single mask register. Values of this register are cached
and protected by gc-&gt;lock</p>
</div>
<dl class="function">
<dt id="c.irq_gc_mask_clr_bit">
void <code class="sig-name descname">irq_gc_mask_clr_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_mask_clr_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask chip via clearing bit in mask register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Chip has a single mask register. Values of this register are cached
and protected by gc-&gt;lock</p>
</div>
<dl class="function">
<dt id="c.irq_gc_unmask_enable_reg">
void <code class="sig-name descname">irq_gc_unmask_enable_reg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_unmask_enable_reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmask chip via enable register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Chip has separate enable/disable registers instead of a single mask
register.</p>
</div>
<dl class="function">
<dt id="c.irq_gc_ack_set_bit">
void <code class="sig-name descname">irq_gc_ack_set_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_ack_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Ack pending interrupt via setting bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_gc_set_wake">
int <code class="sig-name descname">irq_gc_set_wake</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em>, unsigned int<em> on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_gc_set_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/clr wake bit for an interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt><dd><p>Indicates whether the wake bit should be set or cleared</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For chips where the wake from suspend functionality is not
configured in a separate register and the wakeup active state is
just stored in a bitmask.</p>
</div>
<dl class="function">
<dt id="c.irq_alloc_generic_chip">
struct <a class="reference internal" href="#c.irq_chip_generic" title="irq_chip_generic">irq_chip_generic</a> * <code class="sig-name descname">irq_alloc_generic_chip</code><span class="sig-paren">(</span>const char<em> *name</em>, int<em> num_ct</em>, unsigned int<em> irq_base</em>, void __iomem<em> *reg_base</em>, irq_flow_handler_t<em> handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_alloc_generic_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a generic chip and initialize it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the irq chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_ct</span></code></dt><dd><p>Number of irq_chip_type instances associated with this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq_base</span></code></dt><dd><p>Interrupt base nr for this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*reg_base</span></code></dt><dd><p>Register base address (virtual)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flow_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Default flow handler associated with this chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an initialized irq_chip_generic structure. The chip defaults
to the primary (index 0) irq_chip_type and <strong>handler</strong></p>
</div>
<dl class="function">
<dt id="c.__irq_alloc_domain_generic_chips">
int <code class="sig-name descname">__irq_alloc_domain_generic_chips</code><span class="sig-paren">(</span>struct irq_domain<em> *d</em>, int<em> irqs_per_chip</em>, int<em> num_ct</em>, const char<em> *name</em>, irq_flow_handler_t<em> handler</em>, unsigned int<em> clr</em>, unsigned int<em> set</em>, enum <a class="reference internal" href="#c.irq_gc_flags" title="irq_gc_flags">irq_gc_flags</a><em> gcflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__irq_alloc_domain_generic_chips" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate generic chips for an irq domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>irq domain for which to allocate chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irqs_per_chip</span></code></dt><dd><p>Number of interrupts each chip handles (max 32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_ct</span></code></dt><dd><p>Number of irq_chip_type instances associated with this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the irq chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flow_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Default flow handler associated with these chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">clr</span></code></dt><dd><p>IRQ_* bits to clear in the mapping function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">set</span></code></dt><dd><p>IRQ_* bits to set in the mapping function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irq_gc_flags</span> <span class="pre">gcflags</span></code></dt><dd><p>Generic chip specific setup flags</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_get_domain_generic_chip">
struct <a class="reference internal" href="#c.irq_chip_generic" title="irq_chip_generic">irq_chip_generic</a> * <code class="sig-name descname">irq_get_domain_generic_chip</code><span class="sig-paren">(</span>struct irq_domain<em> *d</em>, unsigned int<em> hw_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_domain_generic_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pointer to the generic chip of a hw_irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>irq domain pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hw_irq</span></code></dt><dd><p>Hardware interrupt number</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_setup_generic_chip">
void <code class="sig-name descname">irq_setup_generic_chip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_chip_generic" title="irq_chip_generic">irq_chip_generic</a><em> *gc</em>, u32<em> msk</em>, enum <a class="reference internal" href="#c.irq_gc_flags" title="irq_gc_flags">irq_gc_flags</a><em> flags</em>, unsigned int<em> clr</em>, unsigned int<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_setup_generic_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup a range of interrupts with a generic chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_chip_generic</span> <span class="pre">*gc</span></code></dt><dd><p>Generic irq chip holding all data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">msk</span></code></dt><dd><p>Bitmask holding the irqs to initialize relative to gc-&gt;irq_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irq_gc_flags</span> <span class="pre">flags</span></code></dt><dd><p>Flags for initialization</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">clr</span></code></dt><dd><p>IRQ_* bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">set</span></code></dt><dd><p>IRQ_* bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up max. 32 interrupts starting from gc-&gt;irq_base. Note, this
initializes all interrupts to the primary irq_chip_type and its
associated handler.</p>
</div>
<dl class="function">
<dt id="c.irq_setup_alt_chip">
int <code class="sig-name descname">irq_setup_alt_chip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *d</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_setup_alt_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch to alternative chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*d</span></code></dt><dd><p>irq_data for this interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>Flow type to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only to be called from chip-&gt;irq_set_type() callbacks.</p>
</div>
<dl class="function">
<dt id="c.irq_remove_generic_chip">
void <code class="sig-name descname">irq_remove_generic_chip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_chip_generic" title="irq_chip_generic">irq_chip_generic</a><em> *gc</em>, u32<em> msk</em>, unsigned int<em> clr</em>, unsigned int<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_remove_generic_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_chip_generic</span> <span class="pre">*gc</span></code></dt><dd><p>Generic irq chip holding all data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">msk</span></code></dt><dd><p>Bitmask holding the irqs to initialize relative to gc-&gt;irq_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">clr</span></code></dt><dd><p>IRQ_* bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">set</span></code></dt><dd><p>IRQ_* bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove up to 32 interrupts starting from gc-&gt;irq_base.</p>
</div>
</section>
<section id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the structures
which are used in the generic IRQ layer.</p>
<dl class="type">
<dt id="c.irq_common_data">
struct <code class="sig-name descname">irq_common_data</code><a class="headerlink" href="#c.irq_common_data" title="Permalink to this definition">¶</a></dt>
<dd><p>per irq data shared by all irqchips</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_common_data {
    unsigned int            __private state_use_accessors;
#ifdef CONFIG_NUMA;
    unsigned int            node;
#endif;
    void *handler_data;
    struct msi_desc         *msi_desc;
#ifdef CONFIG_SMP;
    cpumask_var_t affinity;
#endif;
#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK;
    cpumask_var_t effective_affinity;
#endif;
#ifdef CONFIG_GENERIC_IRQ_IPI;
    unsigned int            ipi_offset;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state_use_accessors</span></code></dt><dd><p>status information for irq chip functions.
Use accessor functions to deal with it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>node index useful for balancing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler_data</span></code></dt><dd><p>per-IRQ data for the irq_chip methods</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi_desc</span></code></dt><dd><p>MSI descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affinity</span></code></dt><dd><p>IRQ affinity on SMP. If this is an IPI
related irq, then this is the mask of the
CPUs to which an IPI can be sent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">effective_affinity</span></code></dt><dd><p>The effective IRQ affinity on SMP as some irq
chips do not allow multi CPU destinations.
A subset of <strong>affinity</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipi_offset</span></code></dt><dd><p>Offset of first IPI target cpu in <strong>affinity</strong>. Optional.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_data">
struct <code class="sig-name descname">irq_data</code><a class="headerlink" href="#c.irq_data" title="Permalink to this definition">¶</a></dt>
<dd><p>per irq chip data passed down to chip functions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_data {
    u32 mask;
    unsigned int            irq;
    unsigned long           hwirq;
    struct irq_common_data  *common;
    struct irq_chip         *chip;
    struct irq_domain       *domain;
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
    struct irq_data         *parent_data;
#endif;
    void *chip_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>precomputed bitmask for accessing the chip registers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwirq</span></code></dt><dd><p>hardware interrupt number, local to the interrupt domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">common</span></code></dt><dd><p>point to data shared by all irqchips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>low level interrupt hardware access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>Interrupt translation domain; responsible for mapping
between hwirq number and linux irq number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_data</span></code></dt><dd><p>pointer to parent <a class="reference internal" href="#c.irq_data" title="irq_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span></code></a> to support hierarchy
irq_domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_data</span></code></dt><dd><p>platform-specific per-chip private data for the chip
methods, to allow shared chip implementations</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_chip">
struct <code class="sig-name descname">irq_chip</code><a class="headerlink" href="#c.irq_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware interrupt chip descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_chip {
    const char      *name;
    unsigned int    (*irq_startup)(struct irq_data *data);
    void (*irq_shutdown)(struct irq_data *data);
    void (*irq_enable)(struct irq_data *data);
    void (*irq_disable)(struct irq_data *data);
    void (*irq_ack)(struct irq_data *data);
    void (*irq_mask)(struct irq_data *data);
    void (*irq_mask_ack)(struct irq_data *data);
    void (*irq_unmask)(struct irq_data *data);
    void (*irq_eoi)(struct irq_data *data);
    int (*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
    int (*irq_retrigger)(struct irq_data *data);
    int (*irq_set_type)(struct irq_data *data, unsigned int flow_type);
    int (*irq_set_wake)(struct irq_data *data, unsigned int on);
    void (*irq_bus_lock)(struct irq_data *data);
    void (*irq_bus_sync_unlock)(struct irq_data *data);
#ifdef CONFIG_DEPRECATED_IRQ_CPU_ONOFFLINE;
    void (*irq_cpu_online)(struct irq_data *data);
    void (*irq_cpu_offline)(struct irq_data *data);
#endif;
    void (*irq_suspend)(struct irq_data *data);
    void (*irq_resume)(struct irq_data *data);
    void (*irq_pm_shutdown)(struct irq_data *data);
    void (*irq_calc_mask)(struct irq_data *data);
    void (*irq_print_chip)(struct irq_data *data, struct seq_file *p);
    int (*irq_request_resources)(struct irq_data *data);
    void (*irq_release_resources)(struct irq_data *data);
    void (*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
    void (*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);
    int (*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
    int (*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);
    int (*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);
    void (*ipi_send_single)(struct irq_data *data, unsigned int cpu);
    void (*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);
    int (*irq_nmi_setup)(struct irq_data *data);
    void (*irq_nmi_teardown)(struct irq_data *data);
    unsigned long   flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name for /proc/interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_startup</span></code></dt><dd><p>start up the interrupt (defaults to -&gt;enable if NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_shutdown</span></code></dt><dd><p>shut down the interrupt (defaults to -&gt;disable if NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_enable</span></code></dt><dd><p>enable the interrupt (defaults to chip-&gt;unmask if NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_disable</span></code></dt><dd><p>disable the interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_ack</span></code></dt><dd><p>start of a new interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_mask</span></code></dt><dd><p>mask an interrupt source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_mask_ack</span></code></dt><dd><p>ack and mask an interrupt source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_unmask</span></code></dt><dd><p>unmask an interrupt source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_eoi</span></code></dt><dd><p>end of interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_set_affinity</span></code></dt><dd><p>Set the CPU affinity on SMP machines. If the force
argument is true, it tells the driver to
unconditionally apply the affinity setting. Sanity
checks against the supplied affinity mask are not
required. This is used for CPU hotplug where the
target CPU is not yet set in the cpu_online_mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_retrigger</span></code></dt><dd><p>resend an IRQ to the CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_set_type</span></code></dt><dd><p>set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_set_wake</span></code></dt><dd><p>enable/disable power-management wake-on of an IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_bus_lock</span></code></dt><dd><p>function to lock access to slow bus (i2c) chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_bus_sync_unlock</span></code></dt><dd><p>function to sync and unlock slow bus (i2c) chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_cpu_online</span></code></dt><dd><p>configure an interrupt source for a secondary CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_cpu_offline</span></code></dt><dd><p>un-configure an interrupt source for a secondary CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_suspend</span></code></dt><dd><p>function called from core code on suspend once per
chip, when one or more interrupts are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_resume</span></code></dt><dd><p>function called from core code on resume once per chip,
when one ore more interrupts are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_pm_shutdown</span></code></dt><dd><p>function called from core code on shutdown once per chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_calc_mask</span></code></dt><dd><p>Optional function to set irq_data.mask for special cases</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_print_chip</span></code></dt><dd><p>optional to print special chip info in show_interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_request_resources</span></code></dt><dd><p>optional to request resources before calling
any other callback related to this irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_release_resources</span></code></dt><dd><p>optional to release resources acquired with
irq_request_resources</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_compose_msi_msg</span></code></dt><dd><p>optional to compose message content for MSI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_write_msi_msg</span></code></dt><dd><p>optional to write message content for MSI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_get_irqchip_state</span></code></dt><dd><p>return the internal state of an interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_set_irqchip_state</span></code></dt><dd><p>set the internal state of a interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_set_vcpu_affinity</span></code></dt><dd><p>optional to target a vCPU in a virtual machine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipi_send_single</span></code></dt><dd><p>send a single IPI to destination cpus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipi_send_mask</span></code></dt><dd><p>send an IPI to destination cpus in cpumask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_nmi_setup</span></code></dt><dd><p>function called from core code before enabling an NMI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_nmi_teardown</span></code></dt><dd><p>function called from core code after disabling an NMI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>chip specific flags</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_chip_regs">
struct <code class="sig-name descname">irq_chip_regs</code><a class="headerlink" href="#c.irq_chip_regs" title="Permalink to this definition">¶</a></dt>
<dd><p>register offsets for struct irq_gci</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_chip_regs {
    unsigned long           enable;
    unsigned long           disable;
    unsigned long           mask;
    unsigned long           ack;
    unsigned long           eoi;
    unsigned long           type;
    unsigned long           polarity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Enable register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Disable register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Mask register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack</span></code></dt><dd><p>Ack register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eoi</span></code></dt><dd><p>Eoi register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type configuration register offset to reg_base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polarity</span></code></dt><dd><p>Polarity configuration register offset to reg_base</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_chip_type">
struct <code class="sig-name descname">irq_chip_type</code><a class="headerlink" href="#c.irq_chip_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic interrupt chip instance for a flow type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_chip_type {
    struct irq_chip         chip;
    struct irq_chip_regs    regs;
    irq_flow_handler_t handler;
    u32 type;
    u32 mask_cache_priv;
    u32 *mask_cache;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>The real interrupt chip which provides the callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regs</span></code></dt><dd><p>Register offsets for this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>Flow handler associated with this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Chip can handle these flow types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask_cache_priv</span></code></dt><dd><p>Cached mask register private to the chip type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask_cache</span></code></dt><dd><p>Pointer to cached mask register</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A irq_generic_chip can have several instances of irq_chip_type when
it requires different functions and register offsets for different
flow types.</p>
<dl class="type">
<dt id="c.irq_chip_generic">
struct <code class="sig-name descname">irq_chip_generic</code><a class="headerlink" href="#c.irq_chip_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic irq chip data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_chip_generic {
    raw_spinlock_t lock;
    void __iomem            *reg_base;
    u32 (*reg_readl)(void __iomem *addr);
    void (*reg_writel)(u32 val, void __iomem *addr);
    void (*suspend)(struct irq_chip_generic *gc);
    void (*resume)(struct irq_chip_generic *gc);
    unsigned int            irq_base;
    unsigned int            irq_cnt;
    u32 mask_cache;
    u32 type_cache;
    u32 polarity_cache;
    u32 wake_enabled;
    u32 wake_active;
    unsigned int            num_ct;
    void *private;
    unsigned long           installed;
    unsigned long           unused;
    struct irq_domain       *domain;
    struct list_head        list;
    struct irq_chip_type    chip_types[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Lock to protect register and cache data access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_base</span></code></dt><dd><p>Register base address (virtual)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_readl</span></code></dt><dd><p>Alternate I/O accessor (defaults to readl if NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_writel</span></code></dt><dd><p>Alternate I/O accessor (defaults to writel if NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Function called from core code on suspend once per
chip; can be useful instead of irq_chip::suspend to
handle chip details even when no interrupts are in use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Function called from core code on resume once per chip;
can be useful instead of irq_chip::suspend to handle
chip details even when no interrupts are in use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_base</span></code></dt><dd><p>Interrupt base nr for this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_cnt</span></code></dt><dd><p>Number of interrupts handled by this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask_cache</span></code></dt><dd><p>Cached mask register shared between all chip types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type_cache</span></code></dt><dd><p>Cached type register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polarity_cache</span></code></dt><dd><p>Cached polarity register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wake_enabled</span></code></dt><dd><p>Interrupt can wakeup from suspend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wake_active</span></code></dt><dd><p>Interrupt is marked as an wakeup from suspend source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ct</span></code></dt><dd><p>Number of available irq_chip_type instances (usually 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>Private data for non generic chip callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">installed</span></code></dt><dd><p>bitfield to denote installed interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unused</span></code></dt><dd><p>bitfield to denote unused interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>irq domain pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List head for keeping track of instances</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_types</span></code></dt><dd><p>Array of interrupt irq_chip_types</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note, that irq_chip_generic can have multiple irq_chip_type
implementations which can be associated to a particular irq line of
an irq_chip_generic instance. That allows to share and protect
state in an irq_chip_generic instance when we need to implement
different flow mechanisms (level/edge) for it.</p>
<dl class="type">
<dt id="c.irq_gc_flags">
enum <code class="sig-name descname">irq_gc_flags</code><a class="headerlink" href="#c.irq_gc_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization flags for generic irq chips</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IRQ_GC_INIT_MASK_CACHE</span></code></dt><dd><p>Initialize the mask_cache by reading mask reg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IRQ_GC_INIT_NESTED_LOCK</span></code></dt><dd><p>Set the lock class of the irqs to nested for
irq chips which need to call irq_set_wake() on
the parent irq. Usually GPIO implementations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IRQ_GC_MASK_CACHE_PER_TYPE</span></code></dt><dd><p>Mask cache is chip type private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IRQ_GC_NO_MASK</span></code></dt><dd><p>Do not calculate irq_data-&gt;mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IRQ_GC_BE_IO</span></code></dt><dd><p>Use big-endian register accesses (default: LE)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irqaction">
struct <code class="sig-name descname">irqaction</code><a class="headerlink" href="#c.irqaction" title="Permalink to this definition">¶</a></dt>
<dd><p>per interrupt action descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irqaction {
    irq_handler_t handler;
    void *dev_id;
    void __percpu           *percpu_dev_id;
    struct irqaction        *next;
    irq_handler_t thread_fn;
    struct task_struct      *thread;
    struct irqaction        *secondary;
    unsigned int            irq;
    unsigned int            flags;
    unsigned long           thread_flags;
    unsigned long           thread_mask;
    const char              *name;
    struct proc_dir_entry   *dir;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>interrupt handler function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>cookie to identify the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_dev_id</span></code></dt><dd><p>cookie to identify the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>pointer to the next irqaction for shared interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_fn</span></code></dt><dd><p>interrupt handler function for threaded interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread</span></code></dt><dd><p>thread pointer for threaded interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secondary</span></code></dt><dd><p>pointer to secondary irqaction (force threading)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags (see IRQF_* above)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_flags</span></code></dt><dd><p>flags related to <strong>thread</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_mask</span></code></dt><dd><p>bitmask for keeping track of <strong>thread</strong> activity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir</span></code></dt><dd><p>pointer to the proc/irq/NN/name entry</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.request_irq">
int <code class="sig-name descname">request_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> flags</em>, const char<em> *name</em>, void<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a handler for an interrupt line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts
If NULL, the default primary handler is installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Handling flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the device generating this interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev</span></code></dt><dd><p>A cookie passed to the handler function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call allocates an interrupt and establishes a handler; see
the documentation for <a class="reference internal" href="#c.request_threaded_irq" title="request_threaded_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_threaded_irq()</span></code></a> for details.</p>
</div>
<dl class="type">
<dt id="c.irq_affinity_notify">
struct <code class="sig-name descname">irq_affinity_notify</code><a class="headerlink" href="#c.irq_affinity_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>context for notification of IRQ affinity changes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_affinity_notify {
    unsigned int irq;
    struct kref kref;
    struct work_struct work;
    void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
    void (*release)(struct kref *ref);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Interrupt to which notification applies</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Reference count, for internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Work item, for internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notify</span></code></dt><dd><p>Function to be called on change.  This will be
called in process context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Function to be called on release.  This will be
called in process context.  Once registered, the
structure must only be freed when this function is
called or later.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_affinity">
struct <code class="sig-name descname">irq_affinity</code><a class="headerlink" href="#c.irq_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Description for automatic irq affinity assignements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_affinity {
    unsigned int    pre_vectors;
    unsigned int    post_vectors;
    unsigned int    nr_sets;
    unsigned int    set_size[IRQ_AFFINITY_MAX_SETS];
    void (*calc_sets)(struct irq_affinity *, unsigned int nvecs);
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pre_vectors</span></code></dt><dd><p>Don’t apply affinity to <strong>pre_vectors</strong> at beginning of
the MSI(-X) vector space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_vectors</span></code></dt><dd><p>Don’t apply affinity to <strong>post_vectors</strong> at end of
the MSI(-X) vector space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_sets</span></code></dt><dd><p>The number of interrupt sets for which affinity
spreading is required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_size</span></code></dt><dd><p>Array holding the size of each interrupt set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">calc_sets</span></code></dt><dd><p>Callback for calculating the number and size
of interrupt sets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Private data for usage by <strong>calc_sets</strong>, usually a
pointer to driver/device specific data.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.irq_affinity_desc">
struct <code class="sig-name descname">irq_affinity_desc</code><a class="headerlink" href="#c.irq_affinity_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Interrupt affinity descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_affinity_desc {
    struct cpumask  mask;
    unsigned int    is_managed : 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>cpumask to hold the affinity assignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_managed</span></code></dt><dd><p>1 if the interrupt is managed internally</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_update_affinity_hint">
int <code class="sig-name descname">irq_update_affinity_hint</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, const struct cpumask<em> *m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_update_affinity_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the affinity hint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*m</span></code></dt><dd><p>cpumask pointer (NULL to clear the hint)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the affinity hint, but does not change the affinity of the interrupt.</p>
</div>
<dl class="function">
<dt id="c.irq_set_affinity_and_hint">
int <code class="sig-name descname">irq_set_affinity_and_hint</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, const struct cpumask<em> *m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_and_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the affinity hint and apply the provided cpumask to the interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*m</span></code></dt><dd><p>cpumask pointer (NULL to clear the hint)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the affinity hint and if <strong>m</strong> is not NULL it applies it as the
affinity of that interrupt.</p>
</div>
</section>
<section id="public-functions-provided">
<h2>Public Functions Provided<a class="headerlink" href="#public-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the kernel API
functions which are exported.</p>
<dl class="function">
<dt id="c.synchronize_hardirq">
bool <code class="sig-name descname">synchronize_hardirq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending hard IRQ handlers (on other CPUs)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to wait for</p>
<p>This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this
function while holding a resource the IRQ handler may need you
will deadlock. It does not take associated threaded handlers
into account.</p>
<p>Do not use this for shutdown scenarios where you must be sure
that all parts (hardirq and threaded handler) have completed.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div><p>This function may be called - with care - from IRQ context.</p>
<p>It does not check whether there is an interrupt in flight at the
hardware level, but not serviced yet, as this might deadlock when
called with interrupts disabled and the target CPU of the interrupt
is the current CPU.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.synchronize_irq">
void <code class="sig-name descname">synchronize_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending IRQ handlers (on other CPUs)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to wait for</p>
<p>This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>Can only be called from preemptible code as it might sleep when
an interrupt thread is associated to <strong>irq</strong>.</p>
<p>It optionally makes sure (when the irq chip supports that method)
that the interrupt is not pending in any CPU and waiting for
service.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_can_set_affinity">
int <code class="sig-name descname">irq_can_set_affinity</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_can_set_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the affinity of a given irq can be set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to check</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_can_set_affinity_usr">
bool <code class="sig-name descname">irq_can_set_affinity_usr</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_can_set_affinity_usr" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if affinity of a irq can be set from user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.irq_can_set_affinity" title="irq_can_set_affinity"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_can_set_affinity()</span></code></a> above, but additionally checks for the
AFFINITY_MANAGED flag.</p>
</div>
<dl class="function">
<dt id="c.irq_set_thread_affinity">
void <code class="sig-name descname">irq_set_thread_affinity</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_thread_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify irq threads to adjust affinity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>irq descriptor which has affinity changed</p>
<p>We just set IRQTF_AFFINITY and delegate the affinity setting
to the interrupt thread itself. We can not call
set_cpus_allowed_ptr() here as we hold desc-&gt;lock and this
code can be called from hard interrupt context.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_update_affinity_desc">
int <code class="sig-name descname">irq_update_affinity_desc</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct <a class="reference internal" href="#c.irq_affinity_desc" title="irq_affinity_desc">irq_affinity_desc</a><em> *affinity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_update_affinity_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Update affinity management for an interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The interrupt number to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity_desc</span> <span class="pre">*affinity</span></code></dt><dd><p>Pointer to the affinity descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface can be used to configure the affinity management of
interrupts which have been allocated already.</p>
<p>There are certain limitations on when it may be used - attempts to use it
for when the kernel is configured for generic IRQ reservation mode (in
config GENERIC_IRQ_RESERVATION_MODE) will fail, as it may conflict with
managed/non-managed interrupt accounting. In addition, attempts to use it on
an interrupt which is already started or which has already been configured
as managed will also fail, as these mean invalid init state or double init.</p>
</div>
<dl class="function">
<dt id="c.irq_set_affinity">
int <code class="sig-name descname">irq_set_affinity</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, const struct cpumask<em> *cpumask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the irq affinity of a given irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to set affinity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*cpumask</span></code></dt><dd><p>cpumask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fails if cpumask does not contain an online CPU</p>
</div>
<dl class="function">
<dt id="c.irq_force_affinity">
int <code class="sig-name descname">irq_force_affinity</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, const struct cpumask<em> *cpumask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_force_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the irq affinity of a given irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to set affinity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*cpumask</span></code></dt><dd><p>cpumask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as irq_set_affinity, but without checking the mask against
online cpus.</p>
<p>Solely for low level cpu hotplug code, where we need to make per
cpu interrupts affine before the cpu becomes online.</p>
</div>
<dl class="function">
<dt id="c.irq_set_affinity_notifier">
int <code class="sig-name descname">irq_set_affinity_notifier</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct <a class="reference internal" href="#c.irq_affinity_notify" title="irq_affinity_notify">irq_affinity_notify</a><em> *notify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>control notification of IRQ affinity changes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt for which to enable/disable notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity_notify</span> <span class="pre">*notify</span></code></dt><dd><p>Context for notification, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to disable
notification.  Function pointers must be initialised;
the other fields will be initialised by this function.</p>
<blockquote>
<div><p>Must be called in process context.  Notification may only be enabled
after the IRQ is allocated and must be disabled before the IRQ is
freed using <a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_vcpu_affinity">
int <code class="sig-name descname">irq_set_vcpu_affinity</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void<em> *vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_vcpu_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity for the interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to set affinity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vcpu_info</span></code></dt><dd><p>vCPU specific data or pointer to a percpu array of vCPU
specific data for percpu_devid interrupts</p>
<blockquote>
<div><p>This function uses the vCPU specific data to set the vCPU
affinity for an irq. The vCPU specific data is passed from
outside, such as KVM. One example code path is as below:
KVM -&gt; IOMMU -&gt; <a class="reference internal" href="#c.irq_set_vcpu_affinity" title="irq_set_vcpu_affinity"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_vcpu_affinity()</span></code></a>.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.disable_irq_nosync">
void <code class="sig-name descname">disable_irq_nosync</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq without waiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
<p>Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>, this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
<p>This function may be called from IRQ context.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.disable_irq">
void <code class="sig-name descname">disable_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq and wait for completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
<p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>Can only be called from preemptible code as it might sleep when
an interrupt thread is associated to <strong>irq</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.disable_hardirq">
bool <code class="sig-name descname">disable_hardirq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>disables an irq and waits for hardirq completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
<p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this function while
holding a resource the hard IRQ handler may need you will deadlock.</p>
<p>When used to optimistically disable an interrupt from atomic context
the return value must be checked.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div><p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.disable_nmi_nosync">
void <code class="sig-name descname">disable_nmi_nosync</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_nmi_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an nmi without waiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
<p>Disable the selected interrupt line. Disables and enables are
nested.
The interrupt to disable must have been requested through request_nmi.
Unlike disable_nmi(), this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.enable_irq">
void <code class="sig-name descname">enable_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to enable</p>
<p>Undoes the effect of one call to <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
<p>This function may be called from IRQ context only when
desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.enable_nmi">
void <code class="sig-name descname">enable_nmi</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an nmi</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to enable</p>
<p>The interrupt to enable must have been requested through request_nmi.
Undoes the effect of one call to disable_nmi(). If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_irq_wake">
int <code class="sig-name descname">irq_set_irq_wake</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, unsigned int<em> on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>control irq power management wakeup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt to control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt><dd><p>enable/disable power management wakeup</p>
<p>Enable/disable power management wakeup mode, which is
disabled by default.  Enables and disables must match,
just as they match for non-wakeup mode support.</p>
<p>Wakeup mode lets this IRQ wake the system from sleep
states like “suspend to RAM”.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>irq enable/disable state is completely orthogonal</dt><dd><p>to the enable/disable state of irq wake. An irq can be
disabled with <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> and still wake the system as
long as the irq has wake enabled. If this does not hold,
then the underlying irq chip and the related driver need
to be investigated.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_wake_thread">
void <code class="sig-name descname">irq_wake_thread</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_wake_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the irq thread for the action identified by dev_id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Device identity for which the thread should be woken</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.free_irq">
const void * <code class="sig-name descname">free_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Device identity to free</p>
<p>Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<p>Returns the devname argument passed to request_irq.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.request_threaded_irq">
int <code class="sig-name descname">request_threaded_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, irq_handler_t<em> thread_fn</em>, unsigned long<em> irqflags</em>, const char<em> *devname</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_threaded_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts.
If handler is NULL and thread_fn != NULL
the default primary handler is installed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt><dd><p>Function called from the irq handler thread
If NULL, no irq thread is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*devname</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>A cookie passed back to the handler function</p>
<p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.</p>
<p>If you want to set up a threaded irq handler for your device
then you need to supply <strong>handler</strong> and <strong>thread_fn</strong>. <strong>handler</strong> is
still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it
needs to disable the interrupt on the device and return
IRQ_WAKE_THREAD which will wake up the handler thread and run
<strong>thread_fn</strong>. This split handler design is necessary to support
shared interrupts.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.</p>
<p>Flags:</p>
<p>IRQF_SHARED             Interrupt is shared
IRQF_TRIGGER_*          Specify active edge(s) or level
IRQF_ONESHOT            Run thread_fn with interrupt line masked</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.request_any_context_irq">
int <code class="sig-name descname">request_any_context_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> flags</em>, const char<em> *name</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_any_context_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>A cookie passed back to the handler function</p>
<p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It selects either a
hardirq or threaded handling method depending on the
context.</p>
<p>On failure, it returns a negative value. On success,
it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.request_nmi">
int <code class="sig-name descname">request_nmi</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> irqflags</em>, const char<em> *name</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line for NMI delivery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>A cookie passed back to the handler function</p>
<p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It sets up the IRQ line
to be handled as an NMI.</p>
<p>An interrupt line delivering NMIs cannot be shared and IRQ handling
cannot be threaded.</p>
<p>Interrupt lines requested for NMI delivering must produce per cpu
interrupts and have auto enabling setting disabled.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If the interrupt line cannot be used to deliver NMIs, function
will fail and return a negative value.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_percpu_is_enabled">
bool <code class="sig-name descname">irq_percpu_is_enabled</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_percpu_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the per cpu irq is enabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Linux irq number to check for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called from a non migratable context. Returns the enable
state of a per cpu interrupt on the current cpu.</p>
</div>
<dl class="function">
<dt id="c.remove_percpu_irq">
void <code class="sig-name descname">remove_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct <a class="reference internal" href="#c.irqaction" title="irqaction">irqaction</a><em> *act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free a per-cpu interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*act</span></code></dt><dd><p>irqaction for the interrupt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to remove interrupts statically setup by the early boot process.</p>
</div>
<dl class="function">
<dt id="c.free_percpu_irq">
void <code class="sig-name descname">free_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void __percpu<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_percpu_irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*dev_id</span></code></dt><dd><p>Device identity to free</p>
<p>Remove a percpu interrupt handler. The handler is removed, but
the interrupt line is not disabled. This must be done on each
CPU before calling this function. The function does not return
until any executing interrupts for this IRQ have completed.</p>
<p>This function must not be called from interrupt context.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.setup_percpu_irq">
int <code class="sig-name descname">setup_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct <a class="reference internal" href="#c.irqaction" title="irqaction">irqaction</a><em> *act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a per-cpu interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to setup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*act</span></code></dt><dd><p>irqaction for the interrupt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to statically setup per-cpu interrupts in the early boot process.</p>
</div>
<dl class="function">
<dt id="c.__request_percpu_irq">
int <code class="sig-name descname">__request_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> flags</em>, const char<em> *devname</em>, void __percpu<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Interrupt type flags (IRQF_TIMER only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*devname</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*dev_id</span></code></dt><dd><p>A percpu cookie passed back to the handler function</p>
<p>This call allocates interrupt resources and enables the
interrupt on the local CPU. If the interrupt is supposed to be
enabled on other CPUs, it has to be done on each CPU using
enable_percpu_irq().</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU’s instance of
that variable.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.request_percpu_nmi">
int <code class="sig-name descname">request_percpu_nmi</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, const char<em> *name</em>, void __percpu<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_percpu_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line for NMI delivery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*dev_id</span></code></dt><dd><p>A percpu cookie passed back to the handler function</p>
<p>This call allocates interrupt resources for a per CPU NMI. Per CPU NMIs
have to be setup on each CPU by calling <a class="reference internal" href="#c.prepare_percpu_nmi" title="prepare_percpu_nmi"><code class="xref c c-func docutils literal notranslate"><span class="pre">prepare_percpu_nmi()</span></code></a> before
being enabled on the same CPU by using enable_percpu_nmi().</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU’s instance of
that variable.</p>
<p>Interrupt lines requested for NMI delivering should have auto enabling
setting disabled.</p>
<p>If the interrupt line cannot be used to deliver NMIs, function
will fail returning a negative value.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.prepare_percpu_nmi">
int <code class="sig-name descname">prepare_percpu_nmi</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.prepare_percpu_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>performs CPU local setup for NMI delivery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to prepare for NMI delivery</p>
<p>This call prepares an interrupt line to deliver NMI on the current CPU,
before that interrupt line gets enabled with enable_percpu_nmi().</p>
<p>As a CPU local operation, this should be called from non-preemptible
context.</p>
<p>If the interrupt line cannot be used to deliver NMIs, function
will fail returning a negative value.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.teardown_percpu_nmi">
void <code class="sig-name descname">teardown_percpu_nmi</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.teardown_percpu_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>undoes NMI setup of IRQ line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line from which CPU local NMI configuration should be
removed</p>
<blockquote>
<div><p>This call undoes the setup done by <a class="reference internal" href="#c.prepare_percpu_nmi" title="prepare_percpu_nmi"><code class="xref c c-func docutils literal notranslate"><span class="pre">prepare_percpu_nmi()</span></code></a>.</p>
<p>IRQ line should not be enabled for the current CPU.</p>
<p>As a CPU local operation, this should be called from non-preemptible
context.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_get_irqchip_state">
int <code class="sig-name descname">irq_get_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, enum irqchip_irq_state<em> which</em>, bool<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the irqchip state of a interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line that is forwarded to a VM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>One of IRQCHIP_STATE_* the caller wants to know about</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a boolean where the state is to be stored</p>
<p>This call snapshots the internal irqchip state of an
interrupt, returning into <strong>state</strong> the bit corresponding to
stage <strong>which</strong></p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_irqchip_state">
int <code class="sig-name descname">irq_set_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, enum irqchip_irq_state<em> which</em>, bool<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a forwarded interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line that is forwarded to a VM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>State to be restored (one of IRQCHIP_STATE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">val</span></code></dt><dd><p>Value corresponding to <strong>which</strong></p>
<p>This call sets the internal irqchip state of an interrupt,
depending on the value of <strong>which</strong>.</p>
<p>This function should be called with migration disabled if the
interrupt controller has per-cpu registers.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_has_action">
bool <code class="sig-name descname">irq_has_action</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_has_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether an interrupt is requested</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The linux irq number</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A snapshot of the current state</p>
</div>
<dl class="function">
<dt id="c.irq_check_status_bit">
bool <code class="sig-name descname">irq_check_status_bit</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, unsigned int<em> bitmask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_check_status_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether bits in the irq descriptor status are set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The linux irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bitmask</span></code></dt><dd><p>The bitmask to evaluate</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if one of the bits in <strong>bitmask</strong> is set</p>
</div>
<dl class="function">
<dt id="c.irq_set_chip">
int <code class="sig-name descname">irq_set_chip</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, const struct <a class="reference internal" href="#c.irq_chip" title="irq_chip">irq_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>set the irq chip for an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*chip</span></code></dt><dd><p>pointer to irq chip description structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_irq_type">
int <code class="sig-name descname">irq_set_irq_type</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_type" title="Permalink to this definition">¶</a></dt>
<dd><p>set the irq trigger type for an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>IRQ_TYPE_{LEVEL,EDGE}_* value - see include/linux/irq.h</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_handler_data">
int <code class="sig-name descname">irq_set_handler_data</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_handler_data" title="Permalink to this definition">¶</a></dt>
<dd><p>set irq handler data for an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
<p>Set the hardware irq controller data for an irq</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_chip_data">
int <code class="sig-name descname">irq_set_chip_data</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_chip_data" title="Permalink to this definition">¶</a></dt>
<dd><p>set irq chip data for an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to chip specific data</p>
<p>Set the hardware irq chip data for an irq</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_simple_irq">
void <code class="sig-name descname">handle_simple_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_simple_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple and software-decoded IRQs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Simple interrupts are either sent from a demultiplexing interrupt
handler or come from hardware, where no interrupt hardware control
is necessary.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The caller is expected to handle the ack, clear, mask and</dt><dd><p>unmask issues if necessary.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_untracked_irq">
void <code class="sig-name descname">handle_untracked_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_untracked_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple and software-decoded IRQs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Untracked interrupts are sent from a demultiplexing interrupt
handler when the demultiplexer does not know which device it its
multiplexed irq domain generated the interrupt. IRQ’s handled
through here are not subjected to stats tracking, randomness, or
spurious interrupt detection.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>Like handle_simple_irq, the caller is expected to handle</dt><dd><p>the ack, clear, mask and unmask issues if necessary.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_level_irq">
void <code class="sig-name descname">handle_level_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_level_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Level type irq handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Level type interrupts are active as long as the hardware line has
the active level. This may require to mask the interrupt and unmask
it after the associated handler has acknowledged the device, so the
interrupt line is back to inactive.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_fasteoi_irq">
void <code class="sig-name descname">handle_fasteoi_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_fasteoi_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>irq handler for transparent controllers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Only a single callback will be issued to the chip: an -&gt;eoi()
call when the interrupt has been serviced. This enables support
for modern forms of interrupt handlers, which handle the flow
details in hardware, transparently.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_fasteoi_nmi">
void <code class="sig-name descname">handle_fasteoi_nmi</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_fasteoi_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>irq handler for NMI interrupt lines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>A simple NMI-safe handler, considering the restrictions
from request_nmi.</p>
<p>Only a single callback will be issued to the chip: an -&gt;eoi()
call when the interrupt has been serviced. This enables support
for modern forms of interrupt handlers, which handle the flow
details in hardware, transparently.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_edge_irq">
void <code class="sig-name descname">handle_edge_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_edge_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>edge type IRQ handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Interrupt occurs on the falling and/or rising edge of a hardware
signal. The occurrence is latched into the irq controller hardware
and must be acked in order to be reenabled. After the ack another
interrupt can happen on the same source even before the first one
is handled by the associated event handler. If this happens it
might be necessary to disable (mask) the interrupt depending on the
controller hardware. This requires to reenable the interrupt inside
of the loop which handles the interrupts which have arrived while
the handler was running. If all pending interrupts are handled, the
loop is left.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_fasteoi_ack_irq">
void <code class="sig-name descname">handle_fasteoi_ack_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_fasteoi_ack_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>irq handler for edge hierarchy stacked on transparent controllers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Like <a class="reference internal" href="#c.handle_fasteoi_irq" title="handle_fasteoi_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_fasteoi_irq()</span></code></a>, but for use with hierarchy where
the irq_chip also needs to have its -&gt;irq_ack() function
called.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_fasteoi_mask_irq">
void <code class="sig-name descname">handle_fasteoi_mask_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_fasteoi_mask_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>irq handler for level hierarchy stacked on transparent controllers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Like <a class="reference internal" href="#c.handle_fasteoi_irq" title="handle_fasteoi_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_fasteoi_irq()</span></code></a>, but for use with hierarchy where
the irq_chip also needs to have its -&gt;irq_mask_ack() function
called.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_set_parent_state">
int <code class="sig-name descname">irq_chip_set_parent_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, enum irqchip_irq_state<em> which</em>, bool<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_set_parent_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a parent interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>State to be restored (one of IRQCHIP_STATE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">val</span></code></dt><dd><p>Value corresponding to <strong>which</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conditional success, if the underlying irqchip does not implement it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_get_parent_state">
int <code class="sig-name descname">irq_chip_get_parent_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, enum irqchip_irq_state<em> which</em>, bool<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_get_parent_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get the state of a parent interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>one of IRQCHIP_STATE_* the caller wants to know</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a boolean where the state is to be stored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conditional success, if the underlying irqchip does not implement it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_enable_parent">
void <code class="sig-name descname">irq_chip_enable_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_enable_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the parent interrupt (defaults to unmask if NULL)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_disable_parent">
void <code class="sig-name descname">irq_chip_disable_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_disable_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the parent interrupt (defaults to mask if NULL)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_ack_parent">
void <code class="sig-name descname">irq_chip_ack_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_ack_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledge the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_mask_parent">
void <code class="sig-name descname">irq_chip_mask_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_mask_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_mask_ack_parent">
void <code class="sig-name descname">irq_chip_mask_ack_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_mask_ack_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask and acknowledge the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_unmask_parent">
void <code class="sig-name descname">irq_chip_unmask_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_unmask_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmask the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_eoi_parent">
void <code class="sig-name descname">irq_chip_eoi_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_eoi_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke EOI on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_set_affinity_parent">
int <code class="sig-name descname">irq_chip_set_affinity_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, const struct cpumask<em> *dest</em>, bool<em> force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_set_affinity_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set affinity on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*dest</span></code></dt><dd><p>The affinity mask to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force</span></code></dt><dd><p>Flag to enforce setting (disable online checks)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conditional, as the underlying parent chip might not implement it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_set_type_parent">
int <code class="sig-name descname">irq_chip_set_type_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_set_type_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set IRQ type on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>IRQ_TYPE_{LEVEL,EDGE}_* value - see include/linux/irq.h</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conditional, as the underlying parent chip might not implement it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_retrigger_hierarchy">
int <code class="sig-name descname">irq_chip_retrigger_hierarchy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_retrigger_hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrigger an interrupt in hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate through the domain hierarchy of the interrupt and check
whether a hw retrigger function exists. If yes, invoke it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_set_vcpu_affinity_parent">
int <code class="sig-name descname">irq_chip_set_vcpu_affinity_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, void<em> *vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_set_vcpu_affinity_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vcpu_info</span></code></dt><dd><p>The vcpu affinity information</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_set_wake_parent">
int <code class="sig-name descname">irq_chip_set_wake_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, unsigned int<em> on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_set_wake_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/reset wake-up on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt><dd><p>Whether to set or reset the wake-up capability of this irq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conditional, as the underlying parent chip might not implement it.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_request_resources_parent">
int <code class="sig-name descname">irq_chip_request_resources_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_request_resources_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Request resources on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_chip_release_resources_parent">
void <code class="sig-name descname">irq_chip_release_resources_parent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_release_resources_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources on the parent interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
</div>
</section>
<section id="internal-functions-provided">
<h2>Internal Functions Provided<a class="headerlink" href="#internal-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the internal
functions.</p>
<dl class="function">
<dt id="c.generic_handle_irq">
int <code class="sig-name descname">generic_handle_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_handle_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the handler for a particular irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The irq number to handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or -EINVAL if conversion has failed</p>
<blockquote>
<div><p>This function must be called from an IRQ context with irq regs
initialized.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_handle_irq_safe">
int <code class="sig-name descname">generic_handle_irq_safe</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_handle_irq_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the handler for a particular irq from any context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The irq number to handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, a negative value on error.</p>
<p><strong>Description</strong></p>
<p>This function can be called from any context (IRQ or process context). It
will report an error if not invoked from IRQ context and the irq has been
marked to enforce IRQ-context only.</p>
</div>
<dl class="function">
<dt id="c.generic_handle_domain_irq">
int <code class="sig-name descname">generic_handle_domain_irq</code><span class="sig-paren">(</span>struct irq_domain<em> *domain</em>, unsigned int<em> hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_handle_domain_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the handler for a HW irq belonging to a domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>The domain where to perform the lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwirq</span></code></dt><dd><p>The HW irq number to convert to a logical one</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or -EINVAL if conversion has failed</p>
<blockquote>
<div><p>This function must be called from an IRQ context with irq regs
initialized.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.generic_handle_domain_nmi">
int <code class="sig-name descname">generic_handle_domain_nmi</code><span class="sig-paren">(</span>struct irq_domain<em> *domain</em>, unsigned int<em> hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_handle_domain_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the handler for a HW nmi belonging to a domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>The domain where to perform the lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwirq</span></code></dt><dd><p>The HW irq number to convert to a logical one</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or -EINVAL if conversion has failed</p>
<blockquote>
<div><p>This function must be called from an NMI context with irq regs
initialized.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.irq_free_descs">
void <code class="sig-name descname">irq_free_descs</code><span class="sig-paren">(</span>unsigned int<em> from</em>, unsigned int<em> cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_free_descs" title="Permalink to this definition">¶</a></dt>
<dd><p>free irq descriptors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>Start of descriptor range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cnt</span></code></dt><dd><p>Number of consecutive irqs to free</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__irq_alloc_descs">
int __ref <code class="sig-name descname">__irq_alloc_descs</code><span class="sig-paren">(</span>int<em> irq</em>, unsigned int<em> from</em>, unsigned int<em> cnt</em>, int<em> node</em>, struct module<em> *owner</em>, const struct <a class="reference internal" href="#c.irq_affinity_desc" title="irq_affinity_desc">irq_affinity_desc</a><em> *affinity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__irq_alloc_descs" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize a range of irq descriptors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Allocate for specific irq number if irq &gt;= 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>Start the search from this irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cnt</span></code></dt><dd><p>Number of consecutive irqs to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>Preferred node on which the irq descriptor should be allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>Owning module (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_affinity_desc</span> <span class="pre">*affinity</span></code></dt><dd><p>Optional pointer to an affinity mask array of size <strong>cnt</strong> which
hints where the irq descriptors should be allocated and which
default affinities to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the first irq number or error code</p>
</div>
<dl class="function">
<dt id="c.irq_get_next_irq">
unsigned int <code class="sig-name descname">irq_get_next_irq</code><span class="sig-paren">(</span>unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_next_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>get next allocated irq number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>where to start the search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns next irq number after offset or nr_irqs if none is found.</p>
</div>
<dl class="function">
<dt id="c.kstat_irqs_cpu">
unsigned int <code class="sig-name descname">kstat_irqs_cpu</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstat_irqs_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the statistics for an interrupt on a cpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The cpu number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the sum of interrupt counts on <strong>cpu</strong> since boot for
<strong>irq</strong>. The caller must ensure that the interrupt is not removed
concurrently.</p>
</div>
<dl class="function">
<dt id="c.kstat_irqs_usr">
unsigned int <code class="sig-name descname">kstat_irqs_usr</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstat_irqs_usr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the statistics for an interrupt from thread context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>The interrupt number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the sum of interrupt counts on all cpus since boot for <strong>irq</strong>.</p>
<p>It uses rcu to protect the access since a concurrent removal of an
interrupt descriptor is observing an rcu grace period before
delayed_free_desc()/irq_kobj_release().</p>
</div>
<dl class="function">
<dt id="c.handle_bad_irq">
void <code class="sig-name descname">handle_bad_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_bad_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>handle spurious and unhandled irqs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>description of the interrupt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles spurious and unhandled IRQ’s. It also prints a debugmessage.</p>
</div>
<dl class="function">
<dt id="c.generic_handle_arch_irq">
void noinstr <code class="sig-name descname">generic_handle_arch_irq</code><span class="sig-paren">(</span>struct pt_regs<em> *regs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_handle_arch_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>root irq handler for architectures which do no entry accounting themselves</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_regs</span> <span class="pre">*regs</span></code></dt><dd><p>Register file coming from the low-level handling code</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_msi_desc_off">
int <code class="sig-name descname">irq_set_msi_desc_off</code><span class="sig-paren">(</span>unsigned int<em> irq_base</em>, unsigned int<em> irq_offset</em>, struct msi_desc<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_msi_desc_off" title="Permalink to this definition">¶</a></dt>
<dd><p>set MSI descriptor data for an irq at offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq_base</span></code></dt><dd><p>Interrupt number base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq_offset</span></code></dt><dd><p>Interrupt number offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msi_desc</span> <span class="pre">*entry</span></code></dt><dd><p>Pointer to MSI descriptor data</p>
<p>Set the MSI descriptor entry for an irq at offset</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_set_msi_desc">
int <code class="sig-name descname">irq_set_msi_desc</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct msi_desc<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_msi_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>set MSI descriptor data for an irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msi_desc</span> <span class="pre">*entry</span></code></dt><dd><p>Pointer to MSI descriptor data</p>
<p>Set the MSI descriptor entry for an irq</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.irq_disable">
void <code class="sig-name descname">irq_disable</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark interrupt disabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>irq descriptor which should be disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the chip does not implement the irq_disable callback, we
use a lazy disable approach. That means we mark the interrupt
disabled, but leave the hardware unmasked. That’s an
optimization because we avoid the hardware access for the
common case where no interrupt happens after we marked it
disabled. If an interrupt happens, then the interrupt flow
handler masks the line at the hardware level and marks it
pending.</p>
<p>If the interrupt chip does not implement the irq_disable callback,
a driver can disable the lazy approach for a particular irq line by
calling ‘irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY)’. This can
be used for devices which cannot disable the interrupt at the
device level under certain circumstances and have to use
disable_irq[_nosync] instead.</p>
</div>
<dl class="function">
<dt id="c.handle_edge_eoi_irq">
void <code class="sig-name descname">handle_edge_eoi_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_edge_eoi_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>edge eoi type IRQ handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar as the above handle_edge_irq, but using eoi and w/o the
mask/unmask logic.</p>
</div>
<dl class="function">
<dt id="c.handle_percpu_irq">
void <code class="sig-name descname">handle_percpu_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Per CPU local irq handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
<p>Per CPU interrupts on SMP machines without locking requirements</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.handle_percpu_devid_irq">
void <code class="sig-name descname">handle_percpu_devid_irq</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_percpu_devid_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Per CPU local irq handler with per cpu dev ids</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Per CPU interrupts on SMP machines without locking requirements. Same as
<a class="reference internal" href="#c.handle_percpu_irq" title="handle_percpu_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_percpu_irq()</span></code></a> above but with the following extras:</p>
<p>action-&gt;percpu_dev_id is a pointer to percpu variables which
contain the real device id for the cpu on which this handler is
called</p>
</div>
<dl class="function">
<dt id="c.handle_percpu_devid_fasteoi_nmi">
void <code class="sig-name descname">handle_percpu_devid_fasteoi_nmi</code><span class="sig-paren">(</span>struct irq_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_percpu_devid_fasteoi_nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Per CPU local NMI handler with per cpu dev ids</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the interrupt description structure for this irq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to handle_fasteoi_nmi, but handling the dev_id cookie
as a percpu pointer.</p>
</div>
<dl class="function">
<dt id="c.irq_cpu_online">
void <code class="sig-name descname">irq_cpu_online</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_cpu_online" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke all irq_cpu_online functions.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Iterate through all irqs and invoke the chip.<a class="reference internal" href="#c.irq_cpu_online" title="irq_cpu_online"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_cpu_online()</span></code></a>
for each.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.irq_cpu_offline">
void <code class="sig-name descname">irq_cpu_offline</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_cpu_offline" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke all irq_cpu_offline functions.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Iterate through all irqs and invoke the chip.<a class="reference internal" href="#c.irq_cpu_offline" title="irq_cpu_offline"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_cpu_offline()</span></code></a>
for each.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.irq_chip_compose_msi_msg">
int <code class="sig-name descname">irq_chip_compose_msi_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, struct msi_msg<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_compose_msi_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose msi message for a irq chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msi_msg</span> <span class="pre">*msg</span></code></dt><dd><p>Pointer to the MSI message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For hierarchical domains we find the first chip in the hierarchy
which implements the irq_compose_msi_msg callback. For non
hierarchical we use the top level chip.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_pm_get">
int <code class="sig-name descname">irq_chip_pm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_pm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable power for an IRQ chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable the power to the IRQ chip referenced by the interrupt data
structure.</p>
</div>
<dl class="function">
<dt id="c.irq_chip_pm_put">
int <code class="sig-name descname">irq_chip_pm_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_chip_pm_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable power for an IRQ chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to interrupt specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable the power to the IRQ chip referenced by the interrupt data
structure, belongs. Note that power will only be disabled, once this
function has been called for all IRQs that have called <a class="reference internal" href="#c.irq_chip_pm_get" title="irq_chip_pm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_chip_pm_get()</span></code></a>.</p>
</div>
</section>
<section id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h2>
<p>The following people have contributed to this document:</p>
<ol class="arabic simple">
<li><p>Thomas Gleixner <a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a></p></li>
<li><p>Ingo Molnar <a class="reference external" href="mailto:mingo&#37;&#52;&#48;elte&#46;hu">mingo<span>&#64;</span>elte<span>&#46;</span>hu</a></p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Linux generic IRQ handling</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#known-bugs-and-assumptions">Known Bugs And Assumptions</a></li>
<li><a class="reference internal" href="#abstraction-layers">Abstraction layers</a><ul>
<li><a class="reference internal" href="#interrupt-control-flow">Interrupt control flow</a></li>
<li><a class="reference internal" href="#high-level-driver-api">High-level Driver API</a></li>
<li><a class="reference internal" href="#high-level-irq-flow-handlers">High-level IRQ flow handlers</a><ul>
<li><a class="reference internal" href="#default-flow-implementations">Default flow implementations</a><ul>
<li><a class="reference internal" href="#helper-functions">Helper functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#default-flow-handler-implementations">Default flow handler implementations</a><ul>
<li><a class="reference internal" href="#default-level-irq-flow-handler">Default Level IRQ flow handler</a></li>
<li><a class="reference internal" href="#default-fast-eoi-irq-flow-handler">Default Fast EOI IRQ flow handler</a></li>
<li><a class="reference internal" href="#default-edge-irq-flow-handler">Default Edge IRQ flow handler</a></li>
<li><a class="reference internal" href="#default-simple-irq-flow-handler">Default simple IRQ flow handler</a></li>
<li><a class="reference internal" href="#default-per-cpu-flow-handler">Default per CPU flow handler</a></li>
<li><a class="reference internal" href="#eoi-edge-irq-flow-handler">EOI Edge IRQ flow handler</a></li>
<li><a class="reference internal" href="#bad-irq-flow-handler">Bad IRQ flow handler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quirks-and-optimizations">Quirks and optimizations</a></li>
<li><a class="reference internal" href="#delayed-interrupt-disable">Delayed interrupt disable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chip-level-hardware-encapsulation">Chip-level hardware encapsulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#do-irq-entry-point">__do_IRQ entry point</a></li>
<li><a class="reference internal" href="#locking-on-smp">Locking on SMP</a></li>
<li><a class="reference internal" href="#generic-interrupt-chip">Generic interrupt chip</a></li>
<li><a class="reference internal" href="#structures">Structures</a></li>
<li><a class="reference internal" href="#public-functions-provided">Public Functions Provided</a></li>
<li><a class="reference internal" href="#internal-functions-provided">Internal Functions Provided</a></li>
<li><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/genericirq.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/genericirq.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>