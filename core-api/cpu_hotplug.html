
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>CPU hotplug in the Kernel &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory hotplug" href="memory-hotplug.html" />
    <link rel="prev" title="Cache and TLB Flushing Under Linux" href="cachetlb.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="cpu-hotplug-in-the-kernel">
<h1>CPU hotplug in the Kernel<a class="headerlink" href="#cpu-hotplug-in-the-kernel" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date</dt>
<dd class="field-odd"><p>September, 2021</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Sebastian Andrzej Siewior &lt;<a class="reference external" href="mailto:bigeasy&#37;&#52;&#48;linutronix&#46;de">bigeasy<span>&#64;</span>linutronix<span>&#46;</span>de</a>&gt;,
Rusty Russell &lt;<a class="reference external" href="mailto:rusty&#37;&#52;&#48;rustcorp&#46;com&#46;au">rusty<span>&#64;</span>rustcorp<span>&#46;</span>com<span>&#46;</span>au</a>&gt;,
Srivatsa Vaddagiri &lt;<a class="reference external" href="mailto:vatsa&#37;&#52;&#48;in&#46;ibm&#46;com">vatsa<span>&#64;</span>in<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;,
Ashok Raj &lt;<a class="reference external" href="mailto:ashok&#46;raj&#37;&#52;&#48;intel&#46;com">ashok<span>&#46;</span>raj<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;,
Joel Schopp &lt;<a class="reference external" href="mailto:jschopp&#37;&#52;&#48;austin&#46;ibm&#46;com">jschopp<span>&#64;</span>austin<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;,
Thomas Gleixner &lt;<a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a>&gt;</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Modern advances in system architectures have introduced advanced error
reporting and correction capabilities in processors. There are couple OEMS that
support NUMA hardware which are hot pluggable as well, where physical node
insertion and removal require support for CPU hotplug.</p>
<p>Such advances require CPUs available to a kernel to be removed either for
provisioning reasons, or for RAS purposes to keep an offending CPU off
system execution path. Hence the need for CPU hotplug support in the
Linux kernel.</p>
<p>A more novel use of CPU-hotplug support is its use today in suspend resume
support for SMP. Dual-core and HT support makes even a laptop run SMP kernels
which didn’t support these methods.</p>
</section>
<section id="command-line-switches">
<h2>Command Line Switches<a class="headerlink" href="#command-line-switches" title="Permalink to this headline">¶</a></h2>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">maxcpus=n</span></code></dt><dd><p>Restrict boot time CPUs to <em>n</em>. Say if you have four CPUs, using
<code class="docutils literal notranslate"><span class="pre">maxcpus=2</span></code> will only boot two. You can choose to bring the
other CPUs later online.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_cpus=n</span></code></dt><dd><p>Restrict the total amount of CPUs the kernel will support. If the number
supplied here is lower than the number of physically available CPUs, then
those CPUs can not be brought online later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">additional_cpus=n</span></code></dt><dd><p>Use this to limit hotpluggable CPUs. This option sets
<code class="docutils literal notranslate"><span class="pre">cpu_possible_mask</span> <span class="pre">=</span> <span class="pre">cpu_present_mask</span> <span class="pre">+</span> <span class="pre">additional_cpus</span></code></p>
<p>This option is limited to the IA64 architecture.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_cpus=n</span></code></dt><dd><p>This option sets <code class="docutils literal notranslate"><span class="pre">possible_cpus</span></code> bits in <code class="docutils literal notranslate"><span class="pre">cpu_possible_mask</span></code>.</p>
<p>This option is limited to the X86 and S390 architecture.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu0_hotplug</span></code></dt><dd><p>Allow to shutdown CPU0.</p>
<p>This option is limited to the X86 architecture.</p>
</dd>
</dl>
</section>
<section id="cpu-maps">
<h2>CPU maps<a class="headerlink" href="#cpu-maps" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cpu_possible_mask</span></code></dt><dd><p>Bitmap of possible CPUs that can ever be available in the
system. This is used to allocate some boot time memory for per_cpu variables
that aren’t designed to grow/shrink as CPUs are made available or removed.
Once set during boot time discovery phase, the map is static, i.e no bits
are added or removed anytime. Trimming it accurately for your system needs
upfront can save some boot time memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_online_mask</span></code></dt><dd><p>Bitmap of all CPUs currently online. Its set in <code class="docutils literal notranslate"><span class="pre">__cpu_up()</span></code>
after a CPU is available for kernel scheduling and ready to receive
interrupts from devices. Its cleared when a CPU is brought down using
<code class="docutils literal notranslate"><span class="pre">__cpu_disable()</span></code>, before which all OS services including interrupts are
migrated to another target CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_present_mask</span></code></dt><dd><p>Bitmap of CPUs currently present in the system. Not all
of them may be online. When physical hotplug is processed by the relevant
subsystem (e.g ACPI) can change and new bit either be added or removed
from the map depending on the event is hot-add/hot-remove. There are currently
no locking rules as of now. Typical usage is to init topology during boot,
at which time hotplug is disabled.</p>
</dd>
</dl>
<p>You really don’t need to manipulate any of the system CPU maps. They should
be read-only for most use. When setting up per-cpu resources almost always use
<code class="docutils literal notranslate"><span class="pre">cpu_possible_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">for_each_possible_cpu()</span></code> to iterate. To macro
<code class="docutils literal notranslate"><span class="pre">for_each_cpu()</span></code> can be used to iterate over a custom CPU mask.</p>
<p>Never use anything other than <code class="docutils literal notranslate"><span class="pre">cpumask_t</span></code> to represent bitmap of CPUs.</p>
</section>
<section id="using-cpu-hotplug">
<h2>Using CPU hotplug<a class="headerlink" href="#using-cpu-hotplug" title="Permalink to this headline">¶</a></h2>
<p>The kernel option <em>CONFIG_HOTPLUG_CPU</em> needs to be enabled. It is currently
available on multiple architectures including ARM, MIPS, PowerPC and X86. The
configuration is done via the sysfs interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -lh /sys/devices/system/cpu
total 0
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu0
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu1
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu2
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu3
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu4
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu5
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu6
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu7
drwxr-xr-x  2 root root    0 Dec 21 16:33 hotplug
-r--r--r--  1 root root 4.0K Dec 21 16:33 offline
-r--r--r--  1 root root 4.0K Dec 21 16:33 online
-r--r--r--  1 root root 4.0K Dec 21 16:33 possible
-r--r--r--  1 root root 4.0K Dec 21 16:33 present
</pre></div>
</div>
<p>The files <em>offline</em>, <em>online</em>, <em>possible</em>, <em>present</em> represent the CPU masks.
Each CPU folder contains an <em>online</em> file which controls the logical on (1) and
off (0) state. To logically shutdown CPU4:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 0 &gt; /sys/devices/system/cpu/cpu4/online
 smpboot: CPU 4 is now offline
</pre></div>
</div>
<p>Once the CPU is shutdown, it will be removed from <em>/proc/interrupts</em>,
<em>/proc/cpuinfo</em> and should also not be shown visible by the <em>top</em> command. To
bring CPU4 back online:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 1 &gt; /sys/devices/system/cpu/cpu4/online
smpboot: Booting Node 0 Processor 4 APIC 0x1
</pre></div>
</div>
<p>The CPU is usable again. This should work on all CPUs. CPU0 is often special
and excluded from CPU hotplug. On X86 the kernel option
<em>CONFIG_BOOTPARAM_HOTPLUG_CPU0</em> has to be enabled in order to be able to
shutdown CPU0. Alternatively the kernel command option <em>cpu0_hotplug</em> can be
used. Some known dependencies of CPU0:</p>
<ul class="simple">
<li><p>Resume from hibernate/suspend. Hibernate/suspend will fail if CPU0 is offline.</p></li>
<li><p>PIC interrupts. CPU0 can’t be removed if a PIC interrupt is detected.</p></li>
</ul>
<p>Please let Fenghua Yu &lt;<a class="reference external" href="mailto:fenghua&#46;yu&#37;&#52;&#48;intel&#46;com">fenghua<span>&#46;</span>yu<span>&#64;</span>intel<span>&#46;</span>com</a>&gt; know if you find any dependencies
on CPU0.</p>
</section>
<section id="the-cpu-hotplug-coordination">
<h2>The CPU hotplug coordination<a class="headerlink" href="#the-cpu-hotplug-coordination" title="Permalink to this headline">¶</a></h2>
<section id="the-offline-case">
<h3>The offline case<a class="headerlink" href="#the-offline-case" title="Permalink to this headline">¶</a></h3>
<p>Once a CPU has been logically shutdown the teardown callbacks of registered
hotplug states will be invoked, starting with <code class="docutils literal notranslate"><span class="pre">CPUHP_ONLINE</span></code> and terminating
at state <code class="docutils literal notranslate"><span class="pre">CPUHP_OFFLINE</span></code>. This includes:</p>
<ul class="simple">
<li><p>If tasks are frozen due to a suspend operation then <em>cpuhp_tasks_frozen</em>
will be set to true.</p></li>
<li><p>All processes are migrated away from this outgoing CPU to new CPUs.
The new CPU is chosen from each process’ current cpuset, which may be
a subset of all online CPUs.</p></li>
<li><p>All interrupts targeted to this CPU are migrated to a new CPU</p></li>
<li><p>timers are also migrated to a new CPU</p></li>
<li><p>Once all services are migrated, kernel calls an arch specific routine
<code class="docutils literal notranslate"><span class="pre">__cpu_disable()</span></code> to perform arch specific cleanup.</p></li>
</ul>
</section>
</section>
<section id="the-cpu-hotplug-api">
<h2>The CPU hotplug API<a class="headerlink" href="#the-cpu-hotplug-api" title="Permalink to this headline">¶</a></h2>
<section id="cpu-hotplug-state-machine">
<h3>CPU hotplug state machine<a class="headerlink" href="#cpu-hotplug-state-machine" title="Permalink to this headline">¶</a></h3>
<p>CPU hotplug uses a trivial state machine with a linear state space from
CPUHP_OFFLINE to CPUHP_ONLINE. Each state has a startup and a teardown
callback.</p>
<p>When a CPU is onlined, the startup callbacks are invoked sequentially until
the state CPUHP_ONLINE is reached. They can also be invoked when the
callbacks of a state are set up or an instance is added to a multi-instance
state.</p>
<p>When a CPU is offlined the teardown callbacks are invoked in the reverse
order sequentially until the state CPUHP_OFFLINE is reached. They can also
be invoked when the callbacks of a state are removed or an instance is
removed from a multi-instance state.</p>
<p>If a usage site requires only a callback in one direction of the hotplug
operations (CPU online or CPU offline) then the other not-required callback
can be set to NULL when the state is set up.</p>
<p>The state space is divided into three sections:</p>
<ul>
<li><p>The PREPARE section</p>
<p>The PREPARE section covers the state space from CPUHP_OFFLINE to
CPUHP_BRINGUP_CPU.</p>
<p>The startup callbacks in this section are invoked before the CPU is
started during a CPU online operation. The teardown callbacks are invoked
after the CPU has become dysfunctional during a CPU offline operation.</p>
<p>The callbacks are invoked on a control CPU as they can’t obviously run on
the hotplugged CPU which is either not yet started or has become
dysfunctional already.</p>
<p>The startup callbacks are used to setup resources which are required to
bring a CPU successfully online. The teardown callbacks are used to free
resources or to move pending work to an online CPU after the hotplugged
CPU became dysfunctional.</p>
<p>The startup callbacks are allowed to fail. If a callback fails, the CPU
online operation is aborted and the CPU is brought down to the previous
state (usually CPUHP_OFFLINE) again.</p>
<p>The teardown callbacks in this section are not allowed to fail.</p>
</li>
<li><p>The STARTING section</p>
<p>The STARTING section covers the state space between CPUHP_BRINGUP_CPU + 1
and CPUHP_AP_ONLINE.</p>
<p>The startup callbacks in this section are invoked on the hotplugged CPU
with interrupts disabled during a CPU online operation in the early CPU
setup code. The teardown callbacks are invoked with interrupts disabled
on the hotplugged CPU during a CPU offline operation shortly before the
CPU is completely shut down.</p>
<p>The callbacks in this section are not allowed to fail.</p>
<p>The callbacks are used for low level hardware initialization/shutdown and
for core subsystems.</p>
</li>
<li><p>The ONLINE section</p>
<p>The ONLINE section covers the state space between CPUHP_AP_ONLINE + 1 and
CPUHP_ONLINE.</p>
<p>The startup callbacks in this section are invoked on the hotplugged CPU
during a CPU online operation. The teardown callbacks are invoked on the
hotplugged CPU during a CPU offline operation.</p>
<p>The callbacks are invoked in the context of the per CPU hotplug thread,
which is pinned on the hotplugged CPU. The callbacks are invoked with
interrupts and preemption enabled.</p>
<p>The callbacks are allowed to fail. When a callback fails the hotplug
operation is aborted and the CPU is brought back to the previous state.</p>
</li>
</ul>
</section>
<section id="cpu-online-offline-operations">
<h3>CPU online/offline operations<a class="headerlink" href="#cpu-online-offline-operations" title="Permalink to this headline">¶</a></h3>
<p>A successful online operation looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_OFFLINE]
[CPUHP_OFFLINE + 1]-&gt;startup()       -&gt; success
[CPUHP_OFFLINE + 2]-&gt;startup()       -&gt; success
[CPUHP_OFFLINE + 3]                  -&gt; skipped because startup == NULL
...
[CPUHP_BRINGUP_CPU]-&gt;startup()       -&gt; success
=== End of PREPARE section
[CPUHP_BRINGUP_CPU + 1]-&gt;startup()   -&gt; success
...
[CPUHP_AP_ONLINE]-&gt;startup()         -&gt; success
=== End of STARTUP section
[CPUHP_AP_ONLINE + 1]-&gt;startup()     -&gt; success
...
[CPUHP_ONLINE - 1]-&gt;startup()        -&gt; success
[CPUHP_ONLINE]
</pre></div>
</div>
<p>A successful offline operation looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_ONLINE]
[CPUHP_ONLINE - 1]-&gt;teardown()       -&gt; success
...
[CPUHP_AP_ONLINE + 1]-&gt;teardown()    -&gt; success
=== Start of STARTUP section
[CPUHP_AP_ONLINE]-&gt;teardown()        -&gt; success
...
[CPUHP_BRINGUP_ONLINE - 1]-&gt;teardown()
...
=== Start of PREPARE section
[CPUHP_BRINGUP_CPU]-&gt;teardown()
[CPUHP_OFFLINE + 3]-&gt;teardown()
[CPUHP_OFFLINE + 2]                  -&gt; skipped because teardown == NULL
[CPUHP_OFFLINE + 1]-&gt;teardown()
[CPUHP_OFFLINE]
</pre></div>
</div>
<p>A failed online operation looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_OFFLINE]
[CPUHP_OFFLINE + 1]-&gt;startup()       -&gt; success
[CPUHP_OFFLINE + 2]-&gt;startup()       -&gt; success
[CPUHP_OFFLINE + 3]                  -&gt; skipped because startup == NULL
...
[CPUHP_BRINGUP_CPU]-&gt;startup()       -&gt; success
=== End of PREPARE section
[CPUHP_BRINGUP_CPU + 1]-&gt;startup()   -&gt; success
...
[CPUHP_AP_ONLINE]-&gt;startup()         -&gt; success
=== End of STARTUP section
[CPUHP_AP_ONLINE + 1]-&gt;startup()     -&gt; success
---
[CPUHP_AP_ONLINE + N]-&gt;startup()     -&gt; fail
[CPUHP_AP_ONLINE + (N - 1)]-&gt;teardown()
...
[CPUHP_AP_ONLINE + 1]-&gt;teardown()
=== Start of STARTUP section
[CPUHP_AP_ONLINE]-&gt;teardown()
...
[CPUHP_BRINGUP_ONLINE - 1]-&gt;teardown()
...
=== Start of PREPARE section
[CPUHP_BRINGUP_CPU]-&gt;teardown()
[CPUHP_OFFLINE + 3]-&gt;teardown()
[CPUHP_OFFLINE + 2]                  -&gt; skipped because teardown == NULL
[CPUHP_OFFLINE + 1]-&gt;teardown()
[CPUHP_OFFLINE]
</pre></div>
</div>
<p>A failed offline operation looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_ONLINE]
[CPUHP_ONLINE - 1]-&gt;teardown()       -&gt; success
...
[CPUHP_ONLINE - N]-&gt;teardown()       -&gt; fail
[CPUHP_ONLINE - (N - 1)]-&gt;startup()
...
[CPUHP_ONLINE - 1]-&gt;startup()
[CPUHP_ONLINE]
</pre></div>
</div>
<p>Recursive failures cannot be handled sensibly. Look at the following
example of a recursive fail due to a failed offline operation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_ONLINE]
[CPUHP_ONLINE - 1]-&gt;teardown()       -&gt; success
...
[CPUHP_ONLINE - N]-&gt;teardown()       -&gt; fail
[CPUHP_ONLINE - (N - 1)]-&gt;startup()  -&gt; success
[CPUHP_ONLINE - (N - 2)]-&gt;startup()  -&gt; fail
</pre></div>
</div>
<p>The CPU hotplug state machine stops right here and does not try to go back
down again because that would likely result in an endless loop:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_ONLINE - (N - 1)]-&gt;teardown() -&gt; success
[CPUHP_ONLINE - N]-&gt;teardown()       -&gt; fail
[CPUHP_ONLINE - (N - 1)]-&gt;startup()  -&gt; success
[CPUHP_ONLINE - (N - 2)]-&gt;startup()  -&gt; fail
[CPUHP_ONLINE - (N - 1)]-&gt;teardown() -&gt; success
[CPUHP_ONLINE - N]-&gt;teardown()       -&gt; fail
</pre></div>
</div>
<p>Lather, rinse and repeat. In this case the CPU left in state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[CPUHP_ONLINE - (N - 1)]
</pre></div>
</div>
<p>which at least lets the system make progress and gives the user a chance to
debug or even resolve the situation.</p>
</section>
<section id="allocating-a-state">
<h3>Allocating a state<a class="headerlink" href="#allocating-a-state" title="Permalink to this headline">¶</a></h3>
<p>There are two ways to allocate a CPU hotplug state:</p>
<ul>
<li><p>Static allocation</p>
<p>Static allocation has to be used when the subsystem or driver has
ordering requirements versus other CPU hotplug states. E.g. the PERF core
startup callback has to be invoked before the PERF driver startup
callbacks during a CPU online operation. During a CPU offline operation
the driver teardown callbacks have to be invoked before the core teardown
callback. The statically allocated states are described by constants in
the cpuhp_state enum which can be found in include/linux/cpuhotplug.h.</p>
<p>Insert the state into the enum at the proper place so the ordering
requirements are fulfilled. The state constant has to be used for state
setup and removal.</p>
<p>Static allocation is also required when the state callbacks are not set
up at runtime and are part of the initializer of the CPU hotplug state
array in kernel/cpu.c.</p>
</li>
<li><p>Dynamic allocation</p>
<p>When there are no ordering requirements for the state callbacks then
dynamic allocation is the preferred method. The state number is allocated
by the setup function and returned to the caller on success.</p>
<p>Only the PREPARE and ONLINE sections provide a dynamic allocation
range. The STARTING section does not as most of the callbacks in that
section have explicit ordering requirements.</p>
</li>
</ul>
</section>
<section id="setup-of-a-cpu-hotplug-state">
<h3>Setup of a CPU hotplug state<a class="headerlink" href="#setup-of-a-cpu-hotplug-state" title="Permalink to this headline">¶</a></h3>
<p>The core code provides the following functions to setup a state:</p>
<ul class="simple">
<li><p>cpuhp_setup_state(state, name, startup, teardown)</p></li>
<li><p>cpuhp_setup_state_nocalls(state, name, startup, teardown)</p></li>
<li><p>cpuhp_setup_state_cpuslocked(state, name, startup, teardown)</p></li>
<li><p>cpuhp_setup_state_nocalls_cpuslocked(state, name, startup, teardown)</p></li>
</ul>
<p>For cases where a driver or a subsystem has multiple instances and the same
CPU hotplug state callbacks need to be invoked for each instance, the CPU
hotplug core provides multi-instance support. The advantage over driver
specific instance lists is that the instance related functions are fully
serialized against CPU hotplug operations and provide the automatic
invocations of the state callbacks on add and removal. To set up such a
multi-instance state the following function is available:</p>
<ul class="simple">
<li><p>cpuhp_setup_state_multi(state, name, startup, teardown)</p></li>
</ul>
<p>The &#64;state argument is either a statically allocated state or one of the
constants for dynamically allocated states - CPUHP_PREPARE_DYN,
CPUHP_ONLINE_DYN - depending on the state section (PREPARE, ONLINE) for
which a dynamic state should be allocated.</p>
<p>The &#64;name argument is used for sysfs output and for instrumentation. The
naming convention is “subsys:mode” or “subsys/driver:mode”,
e.g. “perf:mode” or “perf/x86:mode”. The common mode names are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>prepare</p></td>
<td><p>For states in the PREPARE section</p></td>
</tr>
<tr class="row-even"><td><p>dead</p></td>
<td><p>For states in the PREPARE section which do not provide
a startup callback</p></td>
</tr>
<tr class="row-odd"><td><p>starting</p></td>
<td><p>For states in the STARTING section</p></td>
</tr>
<tr class="row-even"><td><p>dying</p></td>
<td><p>For states in the STARTING section which do not provide
a startup callback</p></td>
</tr>
<tr class="row-odd"><td><p>online</p></td>
<td><p>For states in the ONLINE section</p></td>
</tr>
<tr class="row-even"><td><p>offline</p></td>
<td><p>For states in the ONLINE section which do not provide
a startup callback</p></td>
</tr>
</tbody>
</table>
<p>As the &#64;name argument is only used for sysfs and instrumentation other mode
descriptors can be used as well if they describe the nature of the state
better than the common ones.</p>
<p>Examples for &#64;name arguments: “perf/online”, “perf/x86:prepare”,
“RCU/tree:dying”, “sched/waitempty”</p>
<p>The &#64;startup argument is a function pointer to the callback which should be
invoked during a CPU online operation. If the usage site does not require a
startup callback set the pointer to NULL.</p>
<p>The &#64;teardown argument is a function pointer to the callback which should
be invoked during a CPU offline operation. If the usage site does not
require a teardown callback set the pointer to NULL.</p>
<p>The functions differ in the way how the installed callbacks are treated:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="#c.cpuhp_setup_state_nocalls" title="cpuhp_setup_state_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_nocalls()</span></code></a>, <a class="reference internal" href="#c.cpuhp_setup_state_nocalls_cpuslocked" title="cpuhp_setup_state_nocalls_cpuslocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_nocalls_cpuslocked()</span></code></a>
and <a class="reference internal" href="#c.cpuhp_setup_state_multi" title="cpuhp_setup_state_multi"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_multi()</span></code></a> only install the callbacks</p></li>
<li><p><a class="reference internal" href="#c.cpuhp_setup_state" title="cpuhp_setup_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state()</span></code></a> and <a class="reference internal" href="#c.cpuhp_setup_state_cpuslocked" title="cpuhp_setup_state_cpuslocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_cpuslocked()</span></code></a> install the
callbacks and invoke the &#64;startup callback (if not NULL) for all online
CPUs which have currently a state greater than the newly installed
state. Depending on the state section the callback is either invoked on
the current CPU (PREPARE section) or on each online CPU (ONLINE
section) in the context of the CPU’s hotplug thread.</p>
<p>If a callback fails for CPU N then the teardown callback for CPU
0 .. N-1 is invoked to rollback the operation. The state setup fails,
the callbacks for the state are not installed and in case of dynamic
allocation the allocated state is freed.</p>
</li>
</ul>
</div></blockquote>
<p>The state setup and the callback invocations are serialized against CPU
hotplug operations. If the setup function has to be called from a CPU
hotplug read locked region, then the _cpuslocked() variants have to be
used. These functions cannot be used from within CPU hotplug callbacks.</p>
<dl>
<dt>The function return values:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>Statically allocated state was successfully set up</p></td>
</tr>
<tr class="row-even"><td><p>&gt;0</p></td>
<td><p>Dynamically allocated state was successfully set up.</p>
<p>The returned number is the state number which was allocated. If
the state callbacks have to be removed later, e.g. module
removal, then this number has to be saved by the caller and used
as &#64;state argument for the state remove function. For
multi-instance states the dynamically allocated state number is
also required as &#64;state argument for the instance add/remove
operations.</p>
</td>
</tr>
<tr class="row-odd"><td><p>&lt;0</p></td>
<td><p>Operation failed</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</section>
<section id="removal-of-a-cpu-hotplug-state">
<h3>Removal of a CPU hotplug state<a class="headerlink" href="#removal-of-a-cpu-hotplug-state" title="Permalink to this headline">¶</a></h3>
<p>To remove a previously set up state, the following functions are provided:</p>
<ul class="simple">
<li><p>cpuhp_remove_state(state)</p></li>
<li><p>cpuhp_remove_state_nocalls(state)</p></li>
<li><p>cpuhp_remove_state_nocalls_cpuslocked(state)</p></li>
<li><p>cpuhp_remove_multi_state(state)</p></li>
</ul>
<p>The &#64;state argument is either a statically allocated state or the state
number which was allocated in the dynamic range by cpuhp_setup_state*(). If
the state is in the dynamic range, then the state number is freed and
available for dynamic allocation again.</p>
<p>The functions differ in the way how the installed callbacks are treated:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="#c.cpuhp_remove_state_nocalls" title="cpuhp_remove_state_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_remove_state_nocalls()</span></code></a>, <a class="reference internal" href="#c.cpuhp_remove_state_nocalls_cpuslocked" title="cpuhp_remove_state_nocalls_cpuslocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_remove_state_nocalls_cpuslocked()</span></code></a>
and <a class="reference internal" href="#c.cpuhp_remove_multi_state" title="cpuhp_remove_multi_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_remove_multi_state()</span></code></a> only remove the callbacks.</p></li>
<li><p><a class="reference internal" href="#c.cpuhp_remove_state" title="cpuhp_remove_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_remove_state()</span></code></a> removes the callbacks and invokes the teardown
callback (if not NULL) for all online CPUs which have currently a state
greater than the removed state. Depending on the state section the
callback is either invoked on the current CPU (PREPARE section) or on
each online CPU (ONLINE section) in the context of the CPU’s hotplug
thread.</p>
<p>In order to complete the removal, the teardown callback should not fail.</p>
</li>
</ul>
</div></blockquote>
<p>The state removal and the callback invocations are serialized against CPU
hotplug operations. If the remove function has to be called from a CPU
hotplug read locked region, then the _cpuslocked() variants have to be
used. These functions cannot be used from within CPU hotplug callbacks.</p>
<p>If a multi-instance state is removed then the caller has to remove all
instances first.</p>
</section>
<section id="multi-instance-state-instance-management">
<h3>Multi-Instance state instance management<a class="headerlink" href="#multi-instance-state-instance-management" title="Permalink to this headline">¶</a></h3>
<p>Once the multi-instance state is set up, instances can be added to the
state:</p>
<blockquote>
<div><ul class="simple">
<li><p>cpuhp_state_add_instance(state, node)</p></li>
<li><p>cpuhp_state_add_instance_nocalls(state, node)</p></li>
</ul>
</div></blockquote>
<p>The &#64;state argument is either a statically allocated state or the state
number which was allocated in the dynamic range by <a class="reference internal" href="#c.cpuhp_setup_state_multi" title="cpuhp_setup_state_multi"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_multi()</span></code></a>.</p>
<p>The &#64;node argument is a pointer to an hlist_node which is embedded in the
instance’s data structure. The pointer is handed to the multi-instance
state callbacks and can be used by the callback to retrieve the instance
via container_of().</p>
<p>The functions differ in the way how the installed callbacks are treated:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="#c.cpuhp_state_add_instance_nocalls" title="cpuhp_state_add_instance_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_add_instance_nocalls()</span></code></a> and only adds the instance to the
multi-instance state’s node list.</p></li>
<li><p><a class="reference internal" href="#c.cpuhp_state_add_instance" title="cpuhp_state_add_instance"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_add_instance()</span></code></a> adds the instance and invokes the startup
callback (if not NULL) associated with &#64;state for all online CPUs which
have currently a state greater than &#64;state. The callback is only
invoked for the to be added instance. Depending on the state section
the callback is either invoked on the current CPU (PREPARE section) or
on each online CPU (ONLINE section) in the context of the CPU’s hotplug
thread.</p>
<p>If a callback fails for CPU N then the teardown callback for CPU
0 .. N-1 is invoked to rollback the operation, the function fails and
the instance is not added to the node list of the multi-instance state.</p>
</li>
</ul>
</div></blockquote>
<p>To remove an instance from the state’s node list these functions are
available:</p>
<blockquote>
<div><ul class="simple">
<li><p>cpuhp_state_remove_instance(state, node)</p></li>
<li><p>cpuhp_state_remove_instance_nocalls(state, node)</p></li>
</ul>
</div></blockquote>
<p>The arguments are the same as for the cpuhp_state_add_instance*()
variants above.</p>
<p>The functions differ in the way how the installed callbacks are treated:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="#c.cpuhp_state_remove_instance_nocalls" title="cpuhp_state_remove_instance_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_remove_instance_nocalls()</span></code></a> only removes the instance from the
state’s node list.</p></li>
<li><p><a class="reference internal" href="#c.cpuhp_state_remove_instance" title="cpuhp_state_remove_instance"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_remove_instance()</span></code></a> removes the instance and invokes the
teardown callback (if not NULL) associated with &#64;state for all online
CPUs which have currently a state greater than &#64;state.  The callback is
only invoked for the to be removed instance.  Depending on the state
section the callback is either invoked on the current CPU (PREPARE
section) or on each online CPU (ONLINE section) in the context of the
CPU’s hotplug thread.</p>
<p>In order to complete the removal, the teardown callback should not fail.</p>
</li>
</ul>
</div></blockquote>
<p>The node list add/remove operations and the callback invocations are
serialized against CPU hotplug operations. These functions cannot be used
from within CPU hotplug callbacks and CPU hotplug read locked regions.</p>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Setup and teardown a statically allocated state in the STARTING section for
notifications on online and offline operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = cpuhp_setup_state(CPUHP_SUBSYS_STARTING, &quot;subsys:starting&quot;, subsys_cpu_starting, subsys_cpu_dying);
if (ret &lt; 0)
     return ret;
....
cpuhp_remove_state(CPUHP_SUBSYS_STARTING);
</pre></div>
</div>
<p>Setup and teardown a dynamically allocated state in the ONLINE section
for notifications on offline operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state = cpuhp_setup_state(CPUHP_ONLINE_DYN, &quot;subsys:offline&quot;, NULL, subsys_cpu_offline);
if (state &lt; 0)
    return state;
....
cpuhp_remove_state(state);
</pre></div>
</div>
<p>Setup and teardown a dynamically allocated state in the ONLINE section
for notifications on online operations without invoking the callbacks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state = cpuhp_setup_state_nocalls(CPUHP_ONLINE_DYN, &quot;subsys:online&quot;, subsys_cpu_online, NULL);
if (state &lt; 0)
    return state;
....
cpuhp_remove_state_nocalls(state);
</pre></div>
</div>
<p>Setup, use and teardown a dynamically allocated multi-instance state in the
ONLINE section for notifications on online and offline operation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state = cpuhp_setup_state_multi(CPUHP_ONLINE_DYN, &quot;subsys:online&quot;, subsys_cpu_online, subsys_cpu_offline);
if (state &lt; 0)
    return state;
....
ret = cpuhp_state_add_instance(state, &amp;inst1-&gt;node);
if (ret)
     return ret;
....
ret = cpuhp_state_add_instance(state, &amp;inst2-&gt;node);
if (ret)
     return ret;
....
cpuhp_remove_instance(state, &amp;inst1-&gt;node);
....
cpuhp_remove_instance(state, &amp;inst2-&gt;node);
....
remove_multi_state(state);
</pre></div>
</div>
</section>
</section>
<section id="testing-of-hotplug-states">
<h2>Testing of hotplug states<a class="headerlink" href="#testing-of-hotplug-states" title="Permalink to this headline">¶</a></h2>
<p>One way to verify whether a custom state is working as expected or not is to
shutdown a CPU and then put it online again. It is also possible to put the CPU
to certain state (for instance <em>CPUHP_AP_ONLINE</em>) and then go back to
<em>CPUHP_ONLINE</em>. This would simulate an error one state after <em>CPUHP_AP_ONLINE</em>
which would lead to rollback to the online state.</p>
<p>All registered states are enumerated in <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/hotplug/states</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ tail /sys/devices/system/cpu/hotplug/states
138: mm/vmscan:online
139: mm/vmstat:online
140: lib/percpu_cnt:online
141: acpi/cpu-drv:online
142: base/cacheinfo:online
143: virtio/net:online
144: x86/mce:online
145: printk:online
168: sched:active
169: online
</pre></div>
</div>
<p>To rollback CPU4 to <code class="docutils literal notranslate"><span class="pre">lib/percpu_cnt:online</span></code> and back online just issue:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /sys/devices/system/cpu/cpu4/hotplug/state
169
$ echo 140 &gt; /sys/devices/system/cpu/cpu4/hotplug/target
$ cat /sys/devices/system/cpu/cpu4/hotplug/state
140
</pre></div>
</div>
<p>It is important to note that the teardown callback of state 140 have been
invoked. And now get back online:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 169 &gt; /sys/devices/system/cpu/cpu4/hotplug/target
$ cat /sys/devices/system/cpu/cpu4/hotplug/state
169
</pre></div>
</div>
<p>With trace events enabled, the individual steps are visible, too:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#  TASK-PID   CPU#    TIMESTAMP  FUNCTION
#     | |       |        |         |
    bash-394  [001]  22.976: cpuhp_enter: cpu: 0004 target: 140 step: 169 (cpuhp_kick_ap_work)
 cpuhp/4-31   [004]  22.977: cpuhp_enter: cpu: 0004 target: 140 step: 168 (sched_cpu_deactivate)
 cpuhp/4-31   [004]  22.990: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
 cpuhp/4-31   [004]  22.991: cpuhp_enter: cpu: 0004 target: 140 step: 144 (mce_cpu_pre_down)
 cpuhp/4-31   [004]  22.992: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
 cpuhp/4-31   [004]  22.993: cpuhp_multi_enter: cpu: 0004 target: 140 step: 143 (virtnet_cpu_down_prep)
 cpuhp/4-31   [004]  22.994: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
 cpuhp/4-31   [004]  22.995: cpuhp_enter: cpu: 0004 target: 140 step: 142 (cacheinfo_cpu_pre_down)
 cpuhp/4-31   [004]  22.996: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
    bash-394  [001]  22.997: cpuhp_exit:  cpu: 0004  state: 140 step: 169 ret: 0
    bash-394  [005]  95.540: cpuhp_enter: cpu: 0004 target: 169 step: 140 (cpuhp_kick_ap_work)
 cpuhp/4-31   [004]  95.541: cpuhp_enter: cpu: 0004 target: 169 step: 141 (acpi_soft_cpu_online)
 cpuhp/4-31   [004]  95.542: cpuhp_exit:  cpu: 0004  state: 141 step: 141 ret: 0
 cpuhp/4-31   [004]  95.543: cpuhp_enter: cpu: 0004 target: 169 step: 142 (cacheinfo_cpu_online)
 cpuhp/4-31   [004]  95.544: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
 cpuhp/4-31   [004]  95.545: cpuhp_multi_enter: cpu: 0004 target: 169 step: 143 (virtnet_cpu_online)
 cpuhp/4-31   [004]  95.546: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
 cpuhp/4-31   [004]  95.547: cpuhp_enter: cpu: 0004 target: 169 step: 144 (mce_cpu_online)
 cpuhp/4-31   [004]  95.548: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
 cpuhp/4-31   [004]  95.549: cpuhp_enter: cpu: 0004 target: 169 step: 145 (console_cpu_notify)
 cpuhp/4-31   [004]  95.550: cpuhp_exit:  cpu: 0004  state: 145 step: 145 ret: 0
 cpuhp/4-31   [004]  95.551: cpuhp_enter: cpu: 0004 target: 169 step: 168 (sched_cpu_activate)
 cpuhp/4-31   [004]  95.552: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
    bash-394  [005]  95.553: cpuhp_exit:  cpu: 0004  state: 169 step: 140 ret: 0
</pre></div>
</div>
<p>As it an be seen, CPU4 went down until timestamp 22.996 and then back up until
95.552. All invoked callbacks including their return codes are visible in the
trace.</p>
</section>
<section id="architecture-s-requirements">
<h2>Architecture’s requirements<a class="headerlink" href="#architecture-s-requirements" title="Permalink to this headline">¶</a></h2>
<p>The following functions and configurations are required:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CONFIG_HOTPLUG_CPU</span></code></dt><dd><p>This entry needs to be enabled in Kconfig</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__cpu_up()</span></code></dt><dd><p>Arch interface to bring up a CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__cpu_disable()</span></code></dt><dd><p>Arch interface to shutdown a CPU, no more interrupts can be handled by the
kernel after the routine returns. This includes the shutdown of the timer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__cpu_die()</span></code></dt><dd><p>This actually supposed to ensure death of the CPU. Actually look at some
example code in other arch that implement CPU hotplug. The processor is taken
down from the <code class="docutils literal notranslate"><span class="pre">idle()</span></code> loop for that specific architecture. <code class="docutils literal notranslate"><span class="pre">__cpu_die()</span></code>
typically waits for some per_cpu state to be set, to ensure the processor dead
routine is called to be sure positively.</p>
</dd>
</dl>
</section>
<section id="user-space-notification">
<h2>User Space Notification<a class="headerlink" href="#user-space-notification" title="Permalink to this headline">¶</a></h2>
<p>After CPU successfully onlined or offline udev events are sent. A udev rule like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SUBSYSTEM==&quot;cpu&quot;, DRIVERS==&quot;processor&quot;, DEVPATH==&quot;/devices/system/cpu/*&quot;, RUN+=&quot;the_hotplug_receiver.sh&quot;
</pre></div>
</div>
<p>will receive all events. A script like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/bin/sh

if [ &quot;${ACTION}&quot; = &quot;offline&quot; ]
then
    echo &quot;CPU ${DEVPATH##*/} offline&quot;

elif [ &quot;${ACTION}&quot; = &quot;online&quot; ]
then
    echo &quot;CPU ${DEVPATH##*/} online&quot;

fi
</pre></div>
</div>
<p>can process the event further.</p>
</section>
<section id="kernel-inline-documentations-reference">
<h2>Kernel Inline Documentations Reference<a class="headerlink" href="#kernel-inline-documentations-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.cpuhp_setup_state">
int <code class="sig-name descname">cpuhp_setup_state</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, const char<em> *name</em>, int (<em>*startup</em>)(unsigned int cpu), int (*teardown)(unsigned int cpu)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks with calling the <strong>startup</strong> callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the callback (will be used in debug output)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*startup)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>startup callback function or NULL if not required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*teardown)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>teardown callback function or NULL if not required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the callback functions and invokes the <strong>startup</strong> callback on
the online cpus which have already reached the <strong>state</strong>.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_setup_state_cpuslocked">
int <code class="sig-name descname">cpuhp_setup_state_cpuslocked</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, const char<em> *name</em>, int (<em>*startup</em>)(unsigned int cpu), int (*teardown)(unsigned int cpu)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_cpuslocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks with calling <strong>startup</strong> callback from a cpus_read_lock() held region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the callback (will be used in debug output)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*startup)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>startup callback function or NULL if not required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*teardown)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>teardown callback function or NULL if not required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.cpuhp_setup_state" title="cpuhp_setup_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state()</span></code></a> except that it must be invoked from within a
cpus_read_lock() held region.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_setup_state_nocalls">
int <code class="sig-name descname">cpuhp_setup_state_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, const char<em> *name</em>, int (<em>*startup</em>)(unsigned int cpu), int (*teardown)(unsigned int cpu)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks without calling the <strong>startup</strong> callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*startup)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>startup callback function or NULL if not required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*teardown)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>teardown callback function or NULL if not required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.cpuhp_setup_state" title="cpuhp_setup_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state()</span></code></a> except that the <strong>startup</strong> callback is not
invoked during installation. NOP if SMP=n or HOTPLUG_CPU=n.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_setup_state_nocalls_cpuslocked">
int <code class="sig-name descname">cpuhp_setup_state_nocalls_cpuslocked</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, const char<em> *name</em>, int (<em>*startup</em>)(unsigned int cpu), int (*teardown)(unsigned int cpu)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_nocalls_cpuslocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks without invoking the <strong>startup</strong> callback from a cpus_read_lock() held region callbacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*startup)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>startup callback function or NULL if not required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*teardown)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>teardown callback function or NULL if not required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.cpuhp_setup_state_nocalls" title="cpuhp_setup_state_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_nocalls()</span></code></a> except that it must be invoked from
within a cpus_read_lock() held region.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_setup_state_multi">
int <code class="sig-name descname">cpuhp_setup_state_multi</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, const char<em> *name</em>, int (<em>*startup</em>)(unsigned int cpu, struct hlist_node *node), int (*teardown)(unsigned int cpu, struct hlist_node *node)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Add callbacks for multi state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*startup)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu,</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node)</span></code></dt><dd><p>startup callback function or NULL if not required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*teardown)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu,</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node)</span></code></dt><dd><p>teardown callback function or NULL if not required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the internal multi_instance flag and prepares a state to work as a multi
instance callback. No callbacks are invoked at this point. The callbacks are
invoked once an instance for this state are registered via
<a class="reference internal" href="#c.cpuhp_state_add_instance" title="cpuhp_state_add_instance"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_add_instance()</span></code></a> or <a class="reference internal" href="#c.cpuhp_state_add_instance_nocalls" title="cpuhp_state_add_instance_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_add_instance_nocalls()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.cpuhp_state_add_instance">
int <code class="sig-name descname">cpuhp_state_add_instance</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, struct hlist_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_add_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance for a state and invoke startup callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the instance is installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node</span></code></dt><dd><p>The node for this individual state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the instance for the <strong>state</strong> and invokes the registered startup
callback on the online cpus which have already reached the <strong>state</strong>. The
<strong>state</strong> must have been earlier marked as multi-instance by
<a class="reference internal" href="#c.cpuhp_setup_state_multi" title="cpuhp_setup_state_multi"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_multi()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_state_add_instance_nocalls">
int <code class="sig-name descname">cpuhp_state_add_instance_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, struct hlist_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_add_instance_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance for a state without invoking the startup callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the instance is installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node</span></code></dt><dd><p>The node for this individual state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the instance for the <strong>state</strong>. The <strong>state</strong> must have been earlier
marked as multi-instance by cpuhp_setup_state_multi. NOP if SMP=n or
HOTPLUG_CPU=n.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_state_add_instance_nocalls_cpuslocked">
int <code class="sig-name descname">cpuhp_state_add_instance_nocalls_cpuslocked</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, struct hlist_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_add_instance_nocalls_cpuslocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance for a state without invoking the startup callback from a cpus_read_lock() held region.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the instance is installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node</span></code></dt><dd><p>The node for this individual state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.cpuhp_state_add_instance_nocalls" title="cpuhp_state_add_instance_nocalls"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_state_add_instance_nocalls()</span></code></a> except that it must be
invoked from within a cpus_read_lock() held region.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_remove_state">
void <code class="sig-name descname">cpuhp_remove_state</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug state callbacks and invoke the teardown</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the callback functions and invokes the teardown callback on
the online cpus which have already reached the <strong>state</strong>.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_remove_state_nocalls">
void <code class="sig-name descname">cpuhp_remove_state_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_state_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug state callbacks without invoking the teardown callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are removed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.cpuhp_remove_state_nocalls_cpuslocked">
void <code class="sig-name descname">cpuhp_remove_state_nocalls_cpuslocked</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_state_nocalls_cpuslocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug state callbacks without invoking teardown from a cpus_read_lock() held region.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as cpuhp_remove_state nocalls() except that it must be invoked
from within a cpus_read_lock() held region.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_remove_multi_state">
void <code class="sig-name descname">cpuhp_remove_multi_state</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_multi_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug multi state callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state for which the calls are removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the callback functions from a multi state. This is the reverse of
<a class="reference internal" href="#c.cpuhp_setup_state_multi" title="cpuhp_setup_state_multi"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpuhp_setup_state_multi()</span></code></a>. All instances should have been removed before
invoking this function.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_state_remove_instance">
int <code class="sig-name descname">cpuhp_state_remove_instance</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, struct hlist_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_remove_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug instance from state and invoke the teardown callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state from which the instance is removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node</span></code></dt><dd><p>The node for this individual state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the instance and invokes the teardown callback on the online cpus
which have already reached <strong>state</strong>.</p>
</div>
<dl class="function">
<dt id="c.cpuhp_state_remove_instance_nocalls">
int <code class="sig-name descname">cpuhp_state_remove_instance_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em> state</em>, struct hlist_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_remove_instance_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug instance from state without invoking the teardown callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt><dd><p>The state from which the instance is removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node</span></code></dt><dd><p>The node for this individual state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the instance without invoking the teardown callback.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CPU hotplug in the Kernel</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#command-line-switches">Command Line Switches</a></li>
<li><a class="reference internal" href="#cpu-maps">CPU maps</a></li>
<li><a class="reference internal" href="#using-cpu-hotplug">Using CPU hotplug</a></li>
<li><a class="reference internal" href="#the-cpu-hotplug-coordination">The CPU hotplug coordination</a><ul>
<li><a class="reference internal" href="#the-offline-case">The offline case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-cpu-hotplug-api">The CPU hotplug API</a><ul>
<li><a class="reference internal" href="#cpu-hotplug-state-machine">CPU hotplug state machine</a></li>
<li><a class="reference internal" href="#cpu-online-offline-operations">CPU online/offline operations</a></li>
<li><a class="reference internal" href="#allocating-a-state">Allocating a state</a></li>
<li><a class="reference internal" href="#setup-of-a-cpu-hotplug-state">Setup of a CPU hotplug state</a></li>
<li><a class="reference internal" href="#removal-of-a-cpu-hotplug-state">Removal of a CPU hotplug state</a></li>
<li><a class="reference internal" href="#multi-instance-state-instance-management">Multi-Instance state instance management</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-of-hotplug-states">Testing of hotplug states</a></li>
<li><a class="reference internal" href="#architecture-s-requirements">Architecture’s requirements</a></li>
<li><a class="reference internal" href="#user-space-notification">User Space Notification</a></li>
<li><a class="reference internal" href="#kernel-inline-documentations-reference">Kernel Inline Documentations Reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/cpu_hotplug.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/cpu_hotplug.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>