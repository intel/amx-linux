
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Adding reference counters (krefs) to kernel objects &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generic Associative Array Implementation" href="assoc_array.html" />
    <link rel="prev" title="Everything you never wanted to know about kobjects, ksets, and ktypes" href="kobject.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="adding-reference-counters-krefs-to-kernel-objects">
<h1>Adding reference counters (krefs) to kernel objects<a class="headerlink" href="#adding-reference-counters-krefs-to-kernel-objects" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Corey Minyard &lt;<a class="reference external" href="mailto:minyard&#37;&#52;&#48;acm&#46;org">minyard<span>&#64;</span>acm<span>&#46;</span>org</a>&gt;</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Thomas Hellstrom &lt;<a class="reference external" href="mailto:thellstrom&#37;&#52;&#48;vmware&#46;com">thellstrom<span>&#64;</span>vmware<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<p>A lot of this was lifted from Greg Kroah-Hartman’s 2004 OLS paper and
presentation on krefs, which can be found at:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-OLS2004.pdf">http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-OLS2004.pdf</a></p></li>
<li><p><a class="reference external" href="http://www.kroah.com/linux/talks/ols_2004_kref_talk/">http://www.kroah.com/linux/talks/ols_2004_kref_talk/</a></p></li>
</ul>
</div></blockquote>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>krefs allow you to add reference counters to your objects.  If you
have objects that are used in multiple places and passed around, and
you don’t have refcounts, your code is almost certainly broken.  If
you want refcounts, krefs are the way to go.</p>
<p>To use a kref, add one to your data structures like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_data
{
    .
    .
    struct kref refcount;
    .
    .
};
</pre></div>
</div>
<p>The kref can occur anywhere within the data structure.</p>
</section>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<p>You must initialize the kref after you allocate it.  To do this, call
kref_init as so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_data *data;

data = kmalloc(sizeof(*data), GFP_KERNEL);
if (!data)
       return -ENOMEM;
kref_init(&amp;data-&gt;refcount);
</pre></div>
</div>
<p>This sets the refcount in the kref to 1.</p>
</section>
<section id="kref-rules">
<h2>Kref rules<a class="headerlink" href="#kref-rules" title="Permalink to this headline">¶</a></h2>
<p>Once you have an initialized kref, you must follow the following
rules:</p>
<ol class="arabic">
<li><p>If you make a non-temporary copy of a pointer, especially if
it can be passed to another thread of execution, you must
increment the refcount with kref_get() before passing it off:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kref_get(&amp;data-&gt;refcount);
</pre></div>
</div>
<p>If you already have a valid pointer to a kref-ed structure (the
refcount cannot go to zero) you may do this without a lock.</p>
</li>
<li><p>When you are done with a pointer, you must call kref_put():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kref_put(&amp;data-&gt;refcount, data_release);
</pre></div>
</div>
<p>If this is the last reference to the pointer, the release
routine will be called.  If the code never tries to get
a valid pointer to a kref-ed structure without already
holding a valid pointer, it is safe to do this without
a lock.</p>
</li>
<li><p>If the code attempts to gain a reference to a kref-ed structure
without already holding a valid pointer, it must serialize access
where a kref_put() cannot occur during the kref_get(), and the
structure must remain valid during the kref_get().</p></li>
</ol>
<p>For example, if you allocate some data and then pass it to another
thread to process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void data_release(struct kref *ref)
{
    struct my_data *data = container_of(ref, struct my_data, refcount);
    kfree(data);
}

void more_data_handling(void *cb_data)
{
    struct my_data *data = cb_data;
    .
    . do stuff with data here
    .
    kref_put(&amp;data-&gt;refcount, data_release);
}

int my_data_handler(void)
{
    int rv = 0;
    struct my_data *data;
    struct task_struct *task;
    data = kmalloc(sizeof(*data), GFP_KERNEL);
    if (!data)
            return -ENOMEM;
    kref_init(&amp;data-&gt;refcount);

    kref_get(&amp;data-&gt;refcount);
    task = kthread_run(more_data_handling, data, &quot;more_data_handling&quot;);
    if (task == ERR_PTR(-ENOMEM)) {
            rv = -ENOMEM;
            kref_put(&amp;data-&gt;refcount, data_release);
            goto out;
    }

    .
    . do stuff with data here
    .
out:
    kref_put(&amp;data-&gt;refcount, data_release);
    return rv;
}
</pre></div>
</div>
<p>This way, it doesn’t matter what order the two threads handle the
data, the kref_put() handles knowing when the data is not referenced
any more and releasing it.  The kref_get() does not require a lock,
since we already have a valid pointer that we own a refcount for.  The
put needs no lock because nothing tries to get the data without
already holding a pointer.</p>
<p>In the above example, kref_put() will be called 2 times in both success
and error paths. This is necessary because the reference count got
incremented 2 times by kref_init() and kref_get().</p>
<p>Note that the “before” in rule 1 is very important.  You should never
do something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>task = kthread_run(more_data_handling, data, &quot;more_data_handling&quot;);
if (task == ERR_PTR(-ENOMEM)) {
        rv = -ENOMEM;
        goto out;
} else
        /* BAD BAD BAD - get is after the handoff */
        kref_get(&amp;data-&gt;refcount);
</pre></div>
</div>
<p>Don’t assume you know what you are doing and use the above construct.
First of all, you may not know what you are doing.  Second, you may
know what you are doing (there are some situations where locking is
involved where the above may be legal) but someone else who doesn’t
know what they are doing may change the code or copy the code.  It’s
bad style.  Don’t do it.</p>
<p>There are some situations where you can optimize the gets and puts.
For instance, if you are done with an object and enqueuing it for
something else or passing it off to something else, there is no reason
to do a get then a put:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Silly extra get and put */
kref_get(&amp;obj-&gt;ref);
enqueue(obj);
kref_put(&amp;obj-&gt;ref, obj_cleanup);
</pre></div>
</div>
<p>Just do the enqueue.  A comment about this is always welcome:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enqueue(obj);
/* We are done with obj, so we pass our refcount off
   to the queue.  DON&#39;T TOUCH obj AFTER HERE! */
</pre></div>
</div>
<p>The last rule (rule 3) is the nastiest one to handle.  Say, for
instance, you have a list of items that are each kref-ed, and you wish
to get the first one.  You can’t just pull the first item off the list
and kref_get() it.  That violates rule 3 because you are not already
holding a valid pointer.  You must add a mutex (or some other lock).
For instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static DEFINE_MUTEX(mutex);
static LIST_HEAD(q);
struct my_data
{
        struct kref      refcount;
        struct list_head link;
};

static struct my_data *get_entry()
{
        struct my_data *entry = NULL;
        mutex_lock(&amp;mutex);
        if (!list_empty(&amp;q)) {
                entry = container_of(q.next, struct my_data, link);
                kref_get(&amp;entry-&gt;refcount);
        }
        mutex_unlock(&amp;mutex);
        return entry;
}

static void release_entry(struct kref *ref)
{
        struct my_data *entry = container_of(ref, struct my_data, refcount);

        list_del(&amp;entry-&gt;link);
        kfree(entry);
}

static void put_entry(struct my_data *entry)
{
        mutex_lock(&amp;mutex);
        kref_put(&amp;entry-&gt;refcount, release_entry);
        mutex_unlock(&amp;mutex);
}
</pre></div>
</div>
<p>The kref_put() return value is useful if you do not want to hold the
lock during the whole release operation.  Say you didn’t want to call
<a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> with the lock held in the example above (since it is kind of
pointless to do so).  You could use kref_put() as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void release_entry(struct kref *ref)
{
        /* All work is done after the return from kref_put(). */
}

static void put_entry(struct my_data *entry)
{
        mutex_lock(&amp;mutex);
        if (kref_put(&amp;entry-&gt;refcount, release_entry)) {
                list_del(&amp;entry-&gt;link);
                mutex_unlock(&amp;mutex);
                kfree(entry);
        } else
                mutex_unlock(&amp;mutex);
}
</pre></div>
</div>
<p>This is really more useful if you have to call other routines as part
of the free operations that could take a long time or might claim the
same lock.  Note that doing everything in the release routine is still
preferred as it is a little neater.</p>
<p>The above example could also be optimized using kref_get_unless_zero() in
the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct my_data *get_entry()
{
        struct my_data *entry = NULL;
        mutex_lock(&amp;mutex);
        if (!list_empty(&amp;q)) {
                entry = container_of(q.next, struct my_data, link);
                if (!kref_get_unless_zero(&amp;entry-&gt;refcount))
                        entry = NULL;
        }
        mutex_unlock(&amp;mutex);
        return entry;
}

static void release_entry(struct kref *ref)
{
        struct my_data *entry = container_of(ref, struct my_data, refcount);

        mutex_lock(&amp;mutex);
        list_del(&amp;entry-&gt;link);
        mutex_unlock(&amp;mutex);
        kfree(entry);
}

static void put_entry(struct my_data *entry)
{
        kref_put(&amp;entry-&gt;refcount, release_entry);
}
</pre></div>
</div>
<p>Which is useful to remove the mutex lock around kref_put() in put_entry(), but
it’s important that kref_get_unless_zero is enclosed in the same critical
section that finds the entry in the lookup table,
otherwise kref_get_unless_zero may reference already freed memory.
Note that it is illegal to use kref_get_unless_zero without checking its
return value. If you are sure (by already having a valid pointer) that
kref_get_unless_zero() will return true, then use kref_get() instead.</p>
</section>
<section id="krefs-and-rcu">
<h2>Krefs and RCU<a class="headerlink" href="#krefs-and-rcu" title="Permalink to this headline">¶</a></h2>
<p>The function kref_get_unless_zero also makes it possible to use rcu
locking for lookups in the above example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_data
{
        struct rcu_head rhead;
        .
        struct kref refcount;
        .
        .
};

static struct my_data *get_entry_rcu()
{
        struct my_data *entry = NULL;
        rcu_read_lock();
        if (!list_empty(&amp;q)) {
                entry = container_of(q.next, struct my_data, link);
                if (!kref_get_unless_zero(&amp;entry-&gt;refcount))
                        entry = NULL;
        }
        rcu_read_unlock();
        return entry;
}

static void release_entry_rcu(struct kref *ref)
{
        struct my_data *entry = container_of(ref, struct my_data, refcount);

        mutex_lock(&amp;mutex);
        list_del_rcu(&amp;entry-&gt;link);
        mutex_unlock(&amp;mutex);
        kfree_rcu(entry, rhead);
}

static void put_entry(struct my_data *entry)
{
        kref_put(&amp;entry-&gt;refcount, release_entry_rcu);
}
</pre></div>
</div>
<p>But note that the struct kref member needs to remain in valid memory for a
rcu grace period after release_entry_rcu was called. That can be accomplished
by using kfree_rcu(entry, rhead) as done above, or by calling <a class="reference internal" href="kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
before using kfree, but note that <a class="reference internal" href="kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> may sleep for a
substantial amount of time.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Adding reference counters (krefs) to kernel objects</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#kref-rules">Kref rules</a></li>
<li><a class="reference internal" href="#krefs-and-rcu">Krefs and RCU</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/kref.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/kref.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>