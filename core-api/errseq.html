
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The errseq_t datatype &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Atomic types" href="wrappers/atomic_t.html" />
    <link rel="prev" title="ktime accessors" href="timekeeping.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-errseq-t-datatype">
<h1>The errseq_t datatype<a class="headerlink" href="#the-errseq-t-datatype" title="Permalink to this headline">¶</a></h1>
<p>An errseq_t is a way of recording errors in one place, and allowing any
number of “subscribers” to tell whether it has changed since a previous
point where it was sampled.</p>
<p>The initial use case for this is tracking errors for file
synchronization syscalls (fsync, fdatasync, msync and sync_file_range),
but it may be usable in other situations.</p>
<p>It’s implemented as an unsigned 32-bit value.  The low order bits are
designated to hold an error code (between 1 and MAX_ERRNO).  The upper bits
are used as a counter.  This is done with atomics instead of locking so that
these functions can be called from any context.</p>
<p>Note that there is a risk of collisions if new errors are being recorded
frequently, since we have so few bits to use as a counter.</p>
<p>To mitigate this, the bit between the error value and counter is used as
a flag to tell whether the value has been sampled since a new value was
recorded.  That allows us to avoid bumping the counter if no one has
sampled it since the last time an error was recorded.</p>
<p>Thus we end up with a value that looks something like this:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 58%" />
<col style="width: 6%" />
<col style="width: 36%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>31..13</p></td>
<td><p>12</p></td>
<td><p>11..0</p></td>
</tr>
<tr class="row-even"><td><p>counter</p></td>
<td><p>SF</p></td>
<td><p>errno</p></td>
</tr>
</tbody>
</table>
<p>The general idea is for “watchers” to sample an errseq_t value and keep
it as a running cursor.  That value can later be used to tell whether
any new errors have occurred since that sampling was done, and atomically
record the state at the time that it was checked.  This allows us to
record errors in one place, and then have a number of “watchers” that
can tell whether the value has changed since they last checked it.</p>
<p>A new errseq_t should always be zeroed out.  An errseq_t value of all zeroes
is the special (but common) case where there has never been an error. An all
zero value thus serves as the “epoch” if one wishes to know whether there
has ever been an error set since it was first initialized.</p>
<section id="api-usage">
<h2>API usage<a class="headerlink" href="#api-usage" title="Permalink to this headline">¶</a></h2>
<p>Let me tell you a story about a worker drone.  Now, he’s a good worker
overall, but the company is a little…management heavy.  He has to
report to 77 supervisors today, and tomorrow the “big boss” is coming in
from out of town and he’s sure to test the poor fellow too.</p>
<p>They’re all handing him work to do – so much he can’t keep track of who
handed him what, but that’s not really a big problem.  The supervisors
just want to know when he’s finished all of the work they’ve handed him so
far and whether he made any mistakes since they last asked.</p>
<p>He might have made the mistake on work they didn’t actually hand him,
but he can’t keep track of things at that level of detail, all he can
remember is the most recent mistake that he made.</p>
<p>Here’s our worker_drone representation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct worker_drone {
        errseq_t        wd_err; /* for recording errors */
};
</pre></div>
</div>
<p>Every day, the worker_drone starts out with a blank slate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct worker_drone wd;

wd.wd_err = (errseq_t)0;
</pre></div>
</div>
<p>The supervisors come in and get an initial read for the day.  They
don’t care about anything that happened before their watch begins:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct supervisor {
        errseq_t        s_wd_err; /* private &quot;cursor&quot; for wd_err */
        spinlock_t      s_wd_err_lock; /* protects s_wd_err */
}

struct supervisor       su;

su.s_wd_err = errseq_sample(&amp;wd.wd_err);
spin_lock_init(&amp;su.s_wd_err_lock);
</pre></div>
</div>
<p>Now they start handing him tasks to do.  Every few minutes they ask him to
finish up all of the work they’ve handed him so far.  Then they ask him
whether he made any mistakes on any of it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>spin_lock(&amp;su.su_wd_err_lock);
err = errseq_check_and_advance(&amp;wd.wd_err, &amp;su.s_wd_err);
spin_unlock(&amp;su.su_wd_err_lock);
</pre></div>
</div>
<p>Up to this point, that just keeps returning 0.</p>
<p>Now, the owners of this company are quite miserly and have given him
substandard equipment with which to do his job. Occasionally it
glitches and he makes a mistake.  He sighs a heavy sigh, and marks it
down:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>errseq_set(&amp;wd.wd_err, -EIO);
</pre></div>
</div>
<p>…and then gets back to work.  The supervisors eventually poll again
and they each get the error when they next check.  Subsequent calls will
return 0, until another error is recorded, at which point it’s reported
to each of them once.</p>
<p>Note that the supervisors can’t tell how many mistakes he made, only
whether one was made since they last checked, and the latest value
recorded.</p>
<p>Occasionally the big boss comes in for a spot check and asks the worker
to do a one-off job for him. He’s not really watching the worker
full-time like the supervisors, but he does need to know whether a
mistake occurred while his job was processing.</p>
<p>He can just sample the current errseq_t in the worker, and then use that
to tell whether an error has occurred later:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>errseq_t since = errseq_sample(&amp;wd.wd_err);
/* submit some work and wait for it to complete */
err = errseq_check(&amp;wd.wd_err, since);
</pre></div>
</div>
<p>Since he’s just going to discard “since” after that point, he doesn’t
need to advance it here. He also doesn’t need any locking since it’s
not usable by anyone else.</p>
</section>
<section id="serializing-errseq-t-cursor-updates">
<h2>Serializing errseq_t cursor updates<a class="headerlink" href="#serializing-errseq-t-cursor-updates" title="Permalink to this headline">¶</a></h2>
<p>Note that the errseq_t API does not protect the errseq_t cursor during a
check_and_advance_operation. Only the canonical error code is handled
atomically.  In a situation where more than one task might be using the
same errseq_t cursor at the same time, it’s important to serialize
updates to that cursor.</p>
<p>If that’s not done, then it’s possible for the cursor to go backward
in which case the same error could be reported more than once.</p>
<p>Because of this, it’s often advantageous to first do an errseq_check to
see if anything has changed, and only later do an
errseq_check_and_advance after taking the lock. e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (errseq_check(&amp;wd.wd_err, READ_ONCE(su.s_wd_err)) {
        /* su.s_wd_err is protected by s_wd_err_lock */
        spin_lock(&amp;su.s_wd_err_lock);
        err = errseq_check_and_advance(&amp;wd.wd_err, &amp;su.s_wd_err);
        spin_unlock(&amp;su.s_wd_err_lock);
}
</pre></div>
</div>
<p>That avoids the spinlock in the common case where nothing has changed
since the last time it was checked.</p>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.errseq_set">
errseq_t <code class="sig-name descname">errseq_set</code><span class="sig-paren">(</span>errseq_t<em> *eseq</em>, int<em> err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.errseq_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set a errseq_t for later reporting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">*eseq</span></code></dt><dd><p>errseq_t field that should be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt><dd><p>error to set (must be between -1 and -MAX_ERRNO)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the error in <strong>eseq</strong>, and increments the sequence counter
if the last sequence was sampled at some point in the past.</p>
<p>Any error set will always overwrite an existing error.</p>
<p><strong>Return</strong></p>
<p>The previous value, primarily for debugging purposes. The
return value should not be used as a previously sampled value in later
calls as it will not have the SEEN flag set.</p>
</div>
<dl class="function">
<dt id="c.errseq_sample">
errseq_t <code class="sig-name descname">errseq_sample</code><span class="sig-paren">(</span>errseq_t<em> *eseq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.errseq_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Grab current errseq_t value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">*eseq</span></code></dt><dd><p>Pointer to errseq_t to be sampled.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows callers to initialise their errseq_t variable.
If the error has been “seen”, new callers will not see an old error.
If there is an unseen error in <strong>eseq</strong>, the caller of this function will
see it the next time it checks for an error.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The current errseq value.</p>
</div>
<dl class="function">
<dt id="c.errseq_check">
int <code class="sig-name descname">errseq_check</code><span class="sig-paren">(</span>errseq_t<em> *eseq</em>, errseq_t<em> since</em><span class="sig-paren">)</span><a class="headerlink" href="#c.errseq_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Has an error occurred since a particular sample point?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">*eseq</span></code></dt><dd><p>Pointer to errseq_t value to be checked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">since</span></code></dt><dd><p>Previously-sampled errseq_t from which to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the value that eseq points to, and see if it has changed <strong>since</strong>
the given value was sampled. The <strong>since</strong> value is not advanced, so there
is no need to mark the value as seen.</p>
<p><strong>Return</strong></p>
<p>The latest error set in the errseq_t or 0 if it hasn’t changed.</p>
</div>
<dl class="function">
<dt id="c.errseq_check_and_advance">
int <code class="sig-name descname">errseq_check_and_advance</code><span class="sig-paren">(</span>errseq_t<em> *eseq</em>, errseq_t<em> *since</em><span class="sig-paren">)</span><a class="headerlink" href="#c.errseq_check_and_advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Check an errseq_t and advance to current value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">*eseq</span></code></dt><dd><p>Pointer to value being checked and reported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">*since</span></code></dt><dd><p>Pointer to previously-sampled errseq_t to check against and advance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the eseq value, and see whether it matches the value that <strong>since</strong>
points to. If it does, then just return 0.</p>
<p>If it doesn’t, then the value has changed. Set the “seen” flag, and try to
swap it into place as the new eseq value. Then, set that value as the new
“since” value, and return whatever the error portion is set to.</p>
<p>Note that no locking is provided here for concurrent updates to the “since”
value. The caller must provide that if necessary. Because of this, callers
may want to do a lockless errseq_check before taking the lock and calling
this.</p>
<p><strong>Return</strong></p>
<p>Negative errno if one has been stored, or 0 if no new error has
occurred.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The errseq_t datatype</a><ul>
<li><a class="reference internal" href="#api-usage">API usage</a></li>
<li><a class="reference internal" href="#serializing-errseq-t-cursor-updates">Serializing errseq_t cursor updates</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/errseq.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/errseq.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>