
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>XArray &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Maple Tree" href="maple_tree.html" />
    <link rel="prev" title="Generic Associative Array Implementation" href="assoc_array.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="xarray">
<h1>XArray<a class="headerlink" href="#xarray" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Matthew Wilcox</p>
</dd>
</dl>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The XArray is an abstract data type which behaves like a very large array
of pointers.  It meets many of the same needs as a hash or a conventional
resizable array.  Unlike a hash, it allows you to sensibly go to the
next or previous entry in a cache-efficient manner.  In contrast to a
resizable array, there is no need to copy data or change MMU mappings in
order to grow the array.  It is more memory-efficient, parallelisable
and cache friendly than a doubly-linked list.  It takes advantage of
RCU to perform lookups without locking.</p>
<p>The XArray implementation is efficient when the indices used are densely
clustered; hashing the object and using the hash as the index will not
perform well.  The XArray is optimised for small indices, but still has
good performance with large indices.  If your index can be larger than
<code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code> then the XArray is not the data type for you.  The most
important user of the XArray is the page cache.</p>
<p>Normal pointers may be stored in the XArray directly.  They must be 4-byte
aligned, which is true for any pointer returned from <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and
alloc_page().  It isn’t true for arbitrary user-space pointers,
nor for function pointers.  You can store pointers to statically allocated
objects, as long as those objects have an alignment of at least 4.</p>
<p>You can also store integers between 0 and <code class="docutils literal notranslate"><span class="pre">LONG_MAX</span></code> in the XArray.
You must first convert it into an entry using <a class="reference internal" href="#c.xa_mk_value" title="xa_mk_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_mk_value()</span></code></a>.
When you retrieve an entry from the XArray, you can check whether it is
a value entry by calling <a class="reference internal" href="#c.xa_is_value" title="xa_is_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_is_value()</span></code></a>, and convert it back to
an integer by calling <a class="reference internal" href="#c.xa_to_value" title="xa_to_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_to_value()</span></code></a>.</p>
<p>Some users want to tag the pointers they store in the XArray.  You can
call <a class="reference internal" href="#c.xa_tag_pointer" title="xa_tag_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_tag_pointer()</span></code></a> to create an entry with a tag, <a class="reference internal" href="#c.xa_untag_pointer" title="xa_untag_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_untag_pointer()</span></code></a>
to turn a tagged entry back into an untagged pointer and <a class="reference internal" href="#c.xa_pointer_tag" title="xa_pointer_tag"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_pointer_tag()</span></code></a>
to retrieve the tag of an entry.  Tagged pointers use the same bits that
are used to distinguish value entries from normal pointers, so you must
decide whether they want to store value entries or tagged pointers in
any particular XArray.</p>
<p>The XArray does not support storing IS_ERR() pointers as some
conflict with value entries or internal entries.</p>
<p>An unusual feature of the XArray is the ability to create entries which
occupy a range of indices.  Once stored to, looking up any index in
the range will return the same entry as looking up any other index in
the range.  Storing to any index will store to all of them.  Multi-index
entries can be explicitly split into smaller entries, or storing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
into any entry will cause the XArray to forget about the range.</p>
</section>
<section id="normal-api">
<h2>Normal API<a class="headerlink" href="#normal-api" title="Permalink to this headline">¶</a></h2>
<p>Start by initialising an XArray, either with <a class="reference internal" href="#c.DEFINE_XARRAY" title="DEFINE_XARRAY"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_XARRAY()</span></code></a>
for statically allocated XArrays or <a class="reference internal" href="#c.xa_init" title="xa_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init()</span></code></a> for dynamically
allocated ones.  A freshly-initialised XArray contains a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
pointer at every index.</p>
<p>You can then set entries using <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a> and get entries
using <a class="reference internal" href="#c.xa_load" title="xa_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_load()</span></code></a>.  xa_store will overwrite any entry with the
new entry and return the previous entry stored at that index.  You can
use <a class="reference internal" href="#c.xa_erase" title="xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase()</span></code></a> instead of calling <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a> with a
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> entry.  There is no difference between an entry that has never
been stored to, one that has been erased and one that has most recently
had <code class="docutils literal notranslate"><span class="pre">NULL</span></code> stored to it.</p>
<p>You can conditionally replace an entry at an index by using
<a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a>.  Like cmpxchg(), it will only succeed if
the entry at that index has the ‘old’ value.  It also returns the entry
which was at that index; if it returns the same entry which was passed as
‘old’, then <a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a> succeeded.</p>
<p>If you want to only store a new entry to an index if the current entry
at that index is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, you can use <a class="reference internal" href="#c.xa_insert" title="xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert()</span></code></a> which
returns <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> if the entry is not empty.</p>
<p>You can copy entries out of the XArray into a plain array by calling
<a class="reference internal" href="#c.xa_extract" title="xa_extract"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_extract()</span></code></a>.  Or you can iterate over the present entries in the XArray
by calling <a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a>, <a class="reference internal" href="#c.xa_for_each_start" title="xa_for_each_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_start()</span></code></a> or <a class="reference internal" href="#c.xa_for_each_range" title="xa_for_each_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_range()</span></code></a>.
You may prefer to use <a class="reference internal" href="#c.xa_find" title="xa_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find()</span></code></a> or <a class="reference internal" href="#c.xa_find_after" title="xa_find_after"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find_after()</span></code></a> to move to the next
present entry in the XArray.</p>
<p>Calling <a class="reference internal" href="#c.xa_store_range" title="xa_store_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_range()</span></code></a> stores the same entry in a range
of indices.  If you do this, some of the other operations will behave
in a slightly odd way.  For example, marking the entry at one index
may result in the entry being marked at some, but not all of the other
indices.  Storing into one index may result in the entry retrieved by
some, but not all of the other indices changing.</p>
<p>Sometimes you need to ensure that a subsequent call to <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a>
will not need to allocate memory.  The <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a> function
will store a reserved entry at the indicated index.  Users of the
normal API will see this entry as containing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  If you do
not need to use the reserved entry, you can call <a class="reference internal" href="#c.xa_release" title="xa_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_release()</span></code></a>
to remove the unused entry.  If another user has stored to the entry
in the meantime, <a class="reference internal" href="#c.xa_release" title="xa_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_release()</span></code></a> will do nothing; if instead you
want the entry to become <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, you should use <a class="reference internal" href="#c.xa_erase" title="xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase()</span></code></a>.
Using <a class="reference internal" href="#c.xa_insert" title="xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert()</span></code></a> on a reserved entry will fail.</p>
<p>If all entries in the array are <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the <a class="reference internal" href="#c.xa_empty" title="xa_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_empty()</span></code></a> function
will return <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Finally, you can remove all entries from an XArray by calling
<a class="reference internal" href="#c.xa_destroy" title="xa_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_destroy()</span></code></a>.  If the XArray entries are pointers, you may wish
to free the entries first.  You can do this by iterating over all present
entries in the XArray using the <a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a> iterator.</p>
<section id="search-marks">
<h3>Search Marks<a class="headerlink" href="#search-marks" title="Permalink to this headline">¶</a></h3>
<p>Each entry in the array has three bits associated with it called marks.
Each mark may be set or cleared independently of the others.  You can
iterate over marked entries by using the <a class="reference internal" href="#c.xa_for_each_marked" title="xa_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_marked()</span></code></a> iterator.</p>
<p>You can enquire whether a mark is set on an entry by using
<a class="reference internal" href="#c.xa_get_mark" title="xa_get_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_get_mark()</span></code></a>.  If the entry is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, you can set a mark on it
by using <a class="reference internal" href="#c.xa_set_mark" title="xa_set_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_set_mark()</span></code></a> and remove the mark from an entry by calling
<a class="reference internal" href="#c.xa_clear_mark" title="xa_clear_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_clear_mark()</span></code></a>.  You can ask whether any entry in the XArray has a
particular mark set by calling <a class="reference internal" href="#c.xa_marked" title="xa_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_marked()</span></code></a>.  Erasing an entry from the
XArray causes all marks associated with that entry to be cleared.</p>
<p>Setting or clearing a mark on any index of a multi-index entry will
affect all indices covered by that entry.  Querying the mark on any
index will return the same result.</p>
<p>There is no way to iterate over entries which are not marked; the data
structure does not allow this to be implemented efficiently.  There are
not currently iterators to search for logical combinations of bits (eg
iterate over all entries which have both <code class="docutils literal notranslate"><span class="pre">XA_MARK_1</span></code> and <code class="docutils literal notranslate"><span class="pre">XA_MARK_2</span></code>
set, or iterate over all entries which have <code class="docutils literal notranslate"><span class="pre">XA_MARK_0</span></code> or <code class="docutils literal notranslate"><span class="pre">XA_MARK_2</span></code>
set).  It would be possible to add these if a user arises.</p>
</section>
<section id="allocating-xarrays">
<h3>Allocating XArrays<a class="headerlink" href="#allocating-xarrays" title="Permalink to this headline">¶</a></h3>
<p>If you use <a class="reference internal" href="#c.DEFINE_XARRAY_ALLOC" title="DEFINE_XARRAY_ALLOC"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_XARRAY_ALLOC()</span></code></a> to define the XArray, or
initialise it by passing <code class="docutils literal notranslate"><span class="pre">XA_FLAGS_ALLOC</span></code> to <a class="reference internal" href="#c.xa_init_flags" title="xa_init_flags"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init_flags()</span></code></a>,
the XArray changes to track whether entries are in use or not.</p>
<p>You can call <a class="reference internal" href="#c.xa_alloc" title="xa_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc()</span></code></a> to store the entry at an unused index
in the XArray.  If you need to modify the array from interrupt context,
you can use <a class="reference internal" href="#c.xa_alloc_bh" title="xa_alloc_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc_bh()</span></code></a> or <a class="reference internal" href="#c.xa_alloc_irq" title="xa_alloc_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc_irq()</span></code></a> to disable
interrupts while allocating the ID.</p>
<p>Using <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a>, <a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a> or <a class="reference internal" href="#c.xa_insert" title="xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert()</span></code></a> will
also mark the entry as being allocated.  Unlike a normal XArray, storing
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> will mark the entry as being in use, like <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>.
To free an entry, use <a class="reference internal" href="#c.xa_erase" title="xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase()</span></code></a> (or <a class="reference internal" href="#c.xa_release" title="xa_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_release()</span></code></a> if
you only want to free the entry if it’s <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
<p>By default, the lowest free entry is allocated starting from 0.  If you
want to allocate entries starting at 1, it is more efficient to use
<a class="reference internal" href="#c.DEFINE_XARRAY_ALLOC1" title="DEFINE_XARRAY_ALLOC1"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_XARRAY_ALLOC1()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">XA_FLAGS_ALLOC1</span></code>.  If you want to
allocate IDs up to a maximum, then wrap back around to the lowest free
ID, you can use <a class="reference internal" href="#c.xa_alloc_cyclic" title="xa_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc_cyclic()</span></code></a>.</p>
<p>You cannot use <code class="docutils literal notranslate"><span class="pre">XA_MARK_0</span></code> with an allocating XArray as this mark
is used to track whether an entry is free or not.  The other marks are
available for your use.</p>
</section>
<section id="memory-allocation">
<h3>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a>, <a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a>, <a class="reference internal" href="#c.xa_alloc" title="xa_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc()</span></code></a>,
<a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a> and <a class="reference internal" href="#c.xa_insert" title="xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert()</span></code></a> functions take a gfp_t
parameter in case the XArray needs to allocate memory to store this entry.
If the entry is being deleted, no memory allocation needs to be performed,
and the GFP flags specified will be ignored.</p>
<p>It is possible for no memory to be allocatable, particularly if you pass
a restrictive set of GFP flags.  In that case, the functions return a
special value which can be turned into an errno using <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a>.
If you don’t need to know exactly which error occurred, using
<a class="reference internal" href="#c.xa_is_err" title="xa_is_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_is_err()</span></code></a> is slightly more efficient.</p>
</section>
<section id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h3>
<p>When using the Normal API, you do not have to worry about locking.
The XArray uses RCU and an internal spinlock to synchronise access:</p>
<dl class="simple">
<dt>No lock needed:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.xa_empty" title="xa_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_empty()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_marked" title="xa_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_marked()</span></code></a></p></li>
</ul>
</dd>
<dt>Takes RCU read lock:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.xa_load" title="xa_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_load()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_for_each_start" title="xa_for_each_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_start()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_for_each_range" title="xa_for_each_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_range()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_find" title="xa_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_find_after" title="xa_find_after"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find_after()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_extract" title="xa_extract"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_extract()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_get_mark" title="xa_get_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_get_mark()</span></code></a></p></li>
</ul>
</dd>
<dt>Takes xa_lock internally:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_store_bh" title="xa_store_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_store_irq" title="xa_store_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_insert" title="xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_insert_bh" title="xa_insert_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_insert_irq" title="xa_insert_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_insert_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_erase" title="xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_erase_bh" title="xa_erase_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_erase_irq" title="xa_erase_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_cmpxchg_bh" title="xa_cmpxchg_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_cmpxchg_irq" title="xa_cmpxchg_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_store_range" title="xa_store_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_range()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_alloc" title="xa_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_alloc_bh" title="xa_alloc_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_alloc_irq" title="xa_alloc_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_alloc_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_reserve_bh" title="xa_reserve_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve_bh()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_reserve_irq" title="xa_reserve_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve_irq()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_destroy" title="xa_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_destroy()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_set_mark" title="xa_set_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_set_mark()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.xa_clear_mark" title="xa_clear_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_clear_mark()</span></code></a></p></li>
</ul>
</dd>
<dt>Assumes xa_lock held on entry:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.__xa_store" title="__xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_store()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_insert" title="__xa_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_insert()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_erase" title="__xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_erase()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_cmpxchg" title="__xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_cmpxchg()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_alloc" title="__xa_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_alloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_set_mark" title="__xa_set_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_set_mark()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.__xa_clear_mark" title="__xa_clear_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_clear_mark()</span></code></a></p></li>
</ul>
</dd>
</dl>
<p>If you want to take advantage of the lock to protect the data structures
that you are storing in the XArray, you can call xa_lock()
before calling <a class="reference internal" href="#c.xa_load" title="xa_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_load()</span></code></a>, then take a reference count on the
object you have found before calling xa_unlock().  This will
prevent stores from removing the object from the array between looking
up the object and incrementing the refcount.  You can also use RCU to
avoid dereferencing freed memory, but an explanation of that is beyond
the scope of this document.</p>
<p>The XArray does not disable interrupts or softirqs while modifying
the array.  It is safe to read the XArray from interrupt or softirq
context as the RCU lock provides enough protection.</p>
<p>If, for example, you want to store entries in the XArray in process
context and then erase them in softirq context, you can do that this way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void foo_init(struct foo *foo)
{
    xa_init_flags(&amp;foo-&gt;array, XA_FLAGS_LOCK_BH);
}

int foo_store(struct foo *foo, unsigned long index, void *entry)
{
    int err;

    xa_lock_bh(&amp;foo-&gt;array);
    err = xa_err(__xa_store(&amp;foo-&gt;array, index, entry, GFP_KERNEL));
    if (!err)
        foo-&gt;count++;
    xa_unlock_bh(&amp;foo-&gt;array);
    return err;
}

/* foo_erase() is only called from softirq context */
void foo_erase(struct foo *foo, unsigned long index)
{
    xa_lock(&amp;foo-&gt;array);
    __xa_erase(&amp;foo-&gt;array, index);
    foo-&gt;count--;
    xa_unlock(&amp;foo-&gt;array);
}
</pre></div>
</div>
<p>If you are going to modify the XArray from interrupt or softirq context,
you need to initialise the array using <a class="reference internal" href="#c.xa_init_flags" title="xa_init_flags"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init_flags()</span></code></a>, passing
<code class="docutils literal notranslate"><span class="pre">XA_FLAGS_LOCK_IRQ</span></code> or <code class="docutils literal notranslate"><span class="pre">XA_FLAGS_LOCK_BH</span></code>.</p>
<p>The above example also shows a common pattern of wanting to extend the
coverage of the xa_lock on the store side to protect some statistics
associated with the array.</p>
<p>Sharing the XArray with interrupt context is also possible, either
using xa_lock_irqsave() in both the interrupt handler and process
context, or xa_lock_irq() in process context and xa_lock()
in the interrupt handler.  Some of the more common patterns have helper
functions such as <a class="reference internal" href="#c.xa_store_bh" title="xa_store_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_bh()</span></code></a>, <a class="reference internal" href="#c.xa_store_irq" title="xa_store_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store_irq()</span></code></a>,
<a class="reference internal" href="#c.xa_erase_bh" title="xa_erase_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase_bh()</span></code></a>, <a class="reference internal" href="#c.xa_erase_irq" title="xa_erase_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase_irq()</span></code></a>, <a class="reference internal" href="#c.xa_cmpxchg_bh" title="xa_cmpxchg_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg_bh()</span></code></a>
and <a class="reference internal" href="#c.xa_cmpxchg_irq" title="xa_cmpxchg_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg_irq()</span></code></a>.</p>
<p>Sometimes you need to protect access to the XArray with a mutex because
that lock sits above another mutex in the locking hierarchy.  That does
not entitle you to use functions like <a class="reference internal" href="#c.__xa_erase" title="__xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_erase()</span></code></a> without taking
the xa_lock; the xa_lock is used for lockdep validation and will be used
for other purposes in the future.</p>
<p>The <a class="reference internal" href="#c.__xa_set_mark" title="__xa_set_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_set_mark()</span></code></a> and <a class="reference internal" href="#c.__xa_clear_mark" title="__xa_clear_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">__xa_clear_mark()</span></code></a> functions are also
available for situations where you look up an entry and want to atomically
set or clear a mark.  It may be more efficient to use the advanced API
in this case, as it will save you from walking the tree twice.</p>
</section>
</section>
<section id="advanced-api">
<h2>Advanced API<a class="headerlink" href="#advanced-api" title="Permalink to this headline">¶</a></h2>
<p>The advanced API offers more flexibility and better performance at the
cost of an interface which can be harder to use and has fewer safeguards.
No locking is done for you by the advanced API, and you are required
to use the xa_lock while modifying the array.  You can choose whether
to use the xa_lock or the RCU lock while doing read-only operations on
the array.  You can mix advanced and normal operations on the same array;
indeed the normal API is implemented in terms of the advanced API.  The
advanced API is only available to modules with a GPL-compatible license.</p>
<p>The advanced API is based around the xa_state.  This is an opaque data
structure which you declare on the stack using the <a class="reference internal" href="#c.XA_STATE" title="XA_STATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">XA_STATE()</span></code></a> macro.
This macro initialises the xa_state ready to start walking around the
XArray.  It is used as a cursor to maintain the position in the XArray
and let you compose various operations together without having to restart
from the top every time.  The contents of the xa_state are protected by
the <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> or the xas_lock().  If you need to drop whichever of
those locks is protecting your state and tree, you must call <a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a>
so that future calls do not rely on the parts of the state which were
left unprotected.</p>
<p>The xa_state is also used to store errors.  You can call
<a class="reference internal" href="#c.xas_error" title="xas_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_error()</span></code></a> to retrieve the error.  All operations check whether
the xa_state is in an error state before proceeding, so there’s no need
for you to check for an error after each call; you can make multiple
calls in succession and only check at a convenient point.  The only
errors currently generated by the XArray code itself are <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code> and
<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>, but it supports arbitrary errors in case you want to call
<a class="reference internal" href="#c.xas_set_err" title="xas_set_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set_err()</span></code></a> yourself.</p>
<p>If the xa_state is holding an <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code> error, calling <a class="reference internal" href="#c.xas_nomem" title="xas_nomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_nomem()</span></code></a>
will attempt to allocate more memory using the specified gfp flags and
cache it in the xa_state for the next attempt.  The idea is that you take
the xa_lock, attempt the operation and drop the lock.  The operation
attempts to allocate memory while holding the lock, but it is more
likely to fail.  Once you have dropped the lock, <a class="reference internal" href="#c.xas_nomem" title="xas_nomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_nomem()</span></code></a>
can try harder to allocate more memory.  It will return <code class="docutils literal notranslate"><span class="pre">true</span></code> if it
is worth retrying the operation (i.e. that there was a memory error <em>and</em>
more memory was allocated).  If it has previously allocated memory, and
that memory wasn’t used, and there is no error (or some error that isn’t
<code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>), then it will free the memory previously allocated.</p>
<section id="internal-entries">
<h3>Internal Entries<a class="headerlink" href="#internal-entries" title="Permalink to this headline">¶</a></h3>
<p>The XArray reserves some entries for its own purposes.  These are never
exposed through the normal API, but when using the advanced API, it’s
possible to see them.  Usually the best way to handle them is to pass them
to <a class="reference internal" href="#c.xas_retry" title="xas_retry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_retry()</span></code></a>, and retry the operation if it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Test</p></td>
<td><p>Usage</p></td>
</tr>
<tr class="row-even"><td><p>Node</p></td>
<td><p>xa_is_node()</p></td>
<td><p>An XArray node.  May be visible when using a multi-index xa_state.</p></td>
</tr>
<tr class="row-odd"><td><p>Sibling</p></td>
<td><p><a class="reference internal" href="#c.xa_is_sibling" title="xa_is_sibling"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_is_sibling()</span></code></a></p></td>
<td><p>A non-canonical entry for a multi-index entry.  The value indicates
which slot in this node has the canonical entry.</p></td>
</tr>
<tr class="row-even"><td><p>Retry</p></td>
<td><p><a class="reference internal" href="#c.xa_is_retry" title="xa_is_retry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_is_retry()</span></code></a></p></td>
<td><p>This entry is currently being modified by a thread which has the
xa_lock.  The node containing this entry may be freed at the end
of this RCU period.  You should restart the lookup from the head
of the array.</p></td>
</tr>
<tr class="row-odd"><td><p>Zero</p></td>
<td><p><a class="reference internal" href="#c.xa_is_zero" title="xa_is_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_is_zero()</span></code></a></p></td>
<td><p>Zero entries appear as <code class="docutils literal notranslate"><span class="pre">NULL</span></code> through the Normal API, but occupy
an entry in the XArray which can be used to reserve the index for
future use.  This is used by allocating XArrays for allocated entries
which are <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>Other internal entries may be added in the future.  As far as possible, they
will be handled by <a class="reference internal" href="#c.xas_retry" title="xas_retry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_retry()</span></code></a>.</p>
</section>
<section id="additional-functionality">
<h3>Additional functionality<a class="headerlink" href="#additional-functionality" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#c.xas_create_range" title="xas_create_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_create_range()</span></code></a> function allocates all the necessary memory
to store every entry in a range.  It will set ENOMEM in the xa_state if
it cannot allocate memory.</p>
<p>You can use <a class="reference internal" href="#c.xas_init_marks" title="xas_init_marks"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_init_marks()</span></code></a> to reset the marks on an entry
to their default state.  This is usually all marks clear, unless the
XArray is marked with <code class="docutils literal notranslate"><span class="pre">XA_FLAGS_TRACK_FREE</span></code>, in which case mark 0 is set
and all other marks are clear.  Replacing one entry with another using
<a class="reference internal" href="#c.xas_store" title="xas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_store()</span></code></a> will not reset the marks on that entry; if you want
the marks reset, you should do that explicitly.</p>
<p>The <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a> will walk the xa_state as close to the entry
as it can.  If you know the xa_state has already been walked to the
entry and need to check that the entry hasn’t changed, you can use
<a class="reference internal" href="#c.xas_reload" title="xas_reload"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_reload()</span></code></a> to save a function call.</p>
<p>If you need to move to a different index in the XArray, call
<a class="reference internal" href="#c.xas_set" title="xas_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set()</span></code></a>.  This resets the cursor to the top of the tree, which
will generally make the next operation walk the cursor to the desired
spot in the tree.  If you want to move to the next or previous index,
call <a class="reference internal" href="#c.xas_next" title="xas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next()</span></code></a> or <a class="reference internal" href="#c.xas_prev" title="xas_prev"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_prev()</span></code></a>.  Setting the index does
not walk the cursor around the array so does not require a lock to be
held, while moving to the next or previous index does.</p>
<p>You can search for the next present entry using <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>.  This
is the equivalent of both <a class="reference internal" href="#c.xa_find" title="xa_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find()</span></code></a> and <a class="reference internal" href="#c.xa_find_after" title="xa_find_after"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_find_after()</span></code></a>;
if the cursor has been walked to an entry, then it will find the next
entry after the one currently referenced.  If not, it will return the
entry at the index of the xa_state.  Using <a class="reference internal" href="#c.xas_next_entry" title="xas_next_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next_entry()</span></code></a> to
move to the next present entry instead of <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a> will save
a function call in the majority of cases at the expense of emitting more
inline code.</p>
<p>The <a class="reference internal" href="#c.xas_find_marked" title="xas_find_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find_marked()</span></code></a> function is similar.  If the xa_state has
not been walked, it will return the entry at the index of the xa_state,
if it is marked.  Otherwise, it will return the first marked entry after
the entry referenced by the xa_state.  The <a class="reference internal" href="#c.xas_next_marked" title="xas_next_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next_marked()</span></code></a>
function is the equivalent of <a class="reference internal" href="#c.xas_next_entry" title="xas_next_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next_entry()</span></code></a>.</p>
<p>When iterating over a range of the XArray using <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>
or <a class="reference internal" href="#c.xas_for_each_marked" title="xas_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each_marked()</span></code></a>, it may be necessary to temporarily stop
the iteration.  The <a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a> function exists for this purpose.
After you have done the necessary work and wish to resume, the xa_state
is in an appropriate state to continue the iteration after the entry
you last processed.  If you have interrupts disabled while iterating,
then it is good manners to pause the iteration and reenable interrupts
every <code class="docutils literal notranslate"><span class="pre">XA_CHECK_SCHED</span></code> entries.</p>
<p>The <a class="reference internal" href="#c.xas_get_mark" title="xas_get_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_get_mark()</span></code></a>, <a class="reference internal" href="#c.xas_set_mark" title="xas_set_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set_mark()</span></code></a> and <a class="reference internal" href="#c.xas_clear_mark" title="xas_clear_mark"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_clear_mark()</span></code></a> functions require
the xa_state cursor to have been moved to the appropriate location in the
XArray; they will do nothing if you have called <a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a> or <a class="reference internal" href="#c.xas_set" title="xas_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set()</span></code></a>
immediately before.</p>
<p>You can call <a class="reference internal" href="#c.xas_set_update" title="xas_set_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set_update()</span></code></a> to have a callback function
called each time the XArray updates a node.  This is used by the page
cache workingset code to maintain its list of nodes which contain only
shadow entries.</p>
</section>
<section id="multi-index-entries">
<h3>Multi-Index Entries<a class="headerlink" href="#multi-index-entries" title="Permalink to this headline">¶</a></h3>
<p>The XArray has the ability to tie multiple indices together so that
operations on one index affect all indices.  For example, storing into
any index will change the value of the entry retrieved from any index.
Setting or clearing a mark on any index will set or clear the mark
on every index that is tied together.  The current implementation
only allows tying ranges which are aligned powers of two together;
eg indices 64-127 may be tied together, but 2-6 may not be.  This may
save substantial quantities of memory; for example tying 512 entries
together will save over 4kB.</p>
<p>You can create a multi-index entry by using <a class="reference internal" href="#c.XA_STATE_ORDER" title="XA_STATE_ORDER"><code class="xref c c-func docutils literal notranslate"><span class="pre">XA_STATE_ORDER()</span></code></a>
or <a class="reference internal" href="#c.xas_set_order" title="xas_set_order"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set_order()</span></code></a> followed by a call to <a class="reference internal" href="#c.xas_store" title="xas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_store()</span></code></a>.
Calling <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a> with a multi-index xa_state will walk the
xa_state to the right location in the tree, but the return value is not
meaningful, potentially being an internal entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> even when there
is an entry stored within the range.  Calling <a class="reference internal" href="#c.xas_find_conflict" title="xas_find_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find_conflict()</span></code></a>
will return the first entry within the range or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there are no
entries in the range.  The <a class="reference internal" href="#c.xas_for_each_conflict" title="xas_for_each_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each_conflict()</span></code></a> iterator will
iterate over every entry which overlaps the specified range.</p>
<p>If <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a> encounters a multi-index entry, the xa_index
in the xa_state will not be changed.  When iterating over an XArray
or calling <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>, if the initial index is in the middle
of a multi-index entry, it will not be altered.  Subsequent calls
or iterations will move the index to the first index in the range.
Each entry will only be returned once, no matter how many indices it
occupies.</p>
<p>Using <a class="reference internal" href="#c.xas_next" title="xas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next()</span></code></a> or <a class="reference internal" href="#c.xas_prev" title="xas_prev"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_prev()</span></code></a> with a multi-index xa_state is not
supported.  Using either of these functions on a multi-index entry will
reveal sibling entries; these should be skipped over by the caller.</p>
<p>Storing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> into any index of a multi-index entry will set the
entry at every index to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and dissolve the tie.  A multi-index
entry can be split into entries occupying smaller ranges by calling
<a class="reference internal" href="#c.xas_split_alloc" title="xas_split_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_split_alloc()</span></code></a> without the xa_lock held, followed by taking the lock
and calling <a class="reference internal" href="#c.xas_split" title="xas_split"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_split()</span></code></a>.</p>
</section>
</section>
<section id="functions-and-structures">
<h2>Functions and structures<a class="headerlink" href="#functions-and-structures" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.xa_mk_value">
void * <code class="sig-name descname">xa_mk_value</code><span class="sig-paren">(</span>unsigned long<em> v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_mk_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an XArray entry from an integer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">v</span></code></dt><dd><p>Value to store in XArray.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>An entry suitable for storing in the XArray.</p>
</div>
<dl class="function">
<dt id="c.xa_to_value">
unsigned long <code class="sig-name descname">xa_to_value</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_to_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get value stored in an XArray entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>XArray entry.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The value stored in the XArray entry.</p>
</div>
<dl class="function">
<dt id="c.xa_is_value">
bool <code class="sig-name descname">xa_is_value</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an entry is a value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>XArray entry.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>True if the entry is a value, false if it is a pointer.</p>
</div>
<dl class="function">
<dt id="c.xa_tag_pointer">
void * <code class="sig-name descname">xa_tag_pointer</code><span class="sig-paren">(</span>void<em> *p</em>, unsigned long<em> tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_tag_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an XArray entry for a tagged pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>Plain pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">tag</span></code></dt><dd><p>Tag value (0, 1 or 3).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the user of the XArray prefers, they can tag their pointers instead
of storing value entries.  Three tags are available (0, 1 and 3).
These are distinct from the xa_mark_t as they are not replicated up
through the array and cannot be searched for.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>An XArray entry.</p>
</div>
<dl class="function">
<dt id="c.xa_untag_pointer">
void * <code class="sig-name descname">xa_untag_pointer</code><span class="sig-paren">(</span>void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_untag_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn an XArray entry into a plain pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>XArray entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you have stored a tagged pointer in the XArray, call this function
to get the untagged version of the pointer.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>A pointer.</p>
</div>
<dl class="function">
<dt id="c.xa_pointer_tag">
unsigned int <code class="sig-name descname">xa_pointer_tag</code><span class="sig-paren">(</span>void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_pointer_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the tag stored in an XArray entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>XArray entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you have stored a tagged pointer in the XArray, call this function
to get the tag of that pointer.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>A tag.</p>
</div>
<dl class="function">
<dt id="c.xa_is_zero">
bool <code class="sig-name descname">xa_is_zero</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the entry a zero entry?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Entry retrieved from the XArray</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The normal API will return NULL as the contents of a slot containing
a zero entry.  You can only see zero entries by using the advanced API.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entry is a zero entry.</p>
</div>
<dl class="function">
<dt id="c.xa_is_err">
bool <code class="sig-name descname">xa_is_err</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether an XArray operation returned an error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Result from calling an XArray function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an XArray operation cannot complete an operation, it will return
a special value indicating an error.  This function tells you
whether an error occurred; <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> tells you which error occurred.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entry indicates an error.</p>
</div>
<dl class="function">
<dt id="c.xa_err">
int <code class="sig-name descname">xa_err</code><span class="sig-paren">(</span>void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn an XArray result into an errno.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Result from calling an XArray function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an XArray operation cannot complete an operation, it will return
a special pointer value which encodes an errno.  This function extracts
the errno from the pointer value, or returns 0 if the pointer does not
represent an errno.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>A negative errno or 0.</p>
</div>
<dl class="type">
<dt id="c.xa_limit">
struct <code class="sig-name descname">xa_limit</code><a class="headerlink" href="#c.xa_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a range of IDs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xa_limit {
    u32 max;
    u32 min;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt><dd><p>The maximum ID to allocate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min</span></code></dt><dd><p>The lowest ID to allocate (inclusive).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used either directly or via the XA_LIMIT() macro
to communicate the range of IDs that are valid for allocation.
Three common ranges are predefined for you:
* xa_limit_32b       - [0 - UINT_MAX]
* xa_limit_31b       - [0 - INT_MAX]
* xa_limit_16b       - [0 - USHRT_MAX]</p>
<dl class="type">
<dt id="c.xarray">
struct <code class="sig-name descname">xarray</code><a class="headerlink" href="#c.xarray" title="Permalink to this definition">¶</a></dt>
<dd><p>The anchor of the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xarray {
    spinlock_t xa_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xa_lock</span></code></dt><dd><p>Lock that protects the contents of the XArray.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>To use the xarray, define it statically or embed it in your data structure.
It is a very small data structure, so it does not usually make sense to
allocate it separately and keep a pointer to it in your data structure.</p>
<p>You may use the xa_lock to protect your own data structures as well.</p>
<dl class="function">
<dt id="c.DEFINE_XARRAY_FLAGS">
<code class="sig-name descname">DEFINE_XARRAY_FLAGS</code><span class="sig-paren">(</span><em>name</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_XARRAY_FLAGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an XArray with custom flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>A string that names your XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>XA_FLAG values.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is intended for file scope definitions of XArrays.  It declares
and initialises an empty XArray with the chosen name and flags.  It is
equivalent to calling <a class="reference internal" href="#c.xa_init_flags" title="xa_init_flags"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init_flags()</span></code></a> on the array, but it does the
initialisation at compiletime instead of runtime.</p>
</div>
<dl class="function">
<dt id="c.DEFINE_XARRAY">
<code class="sig-name descname">DEFINE_XARRAY</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_XARRAY" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>A string that names your XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is intended for file scope definitions of XArrays.  It declares
and initialises an empty XArray with the chosen name.  It is equivalent
to calling <a class="reference internal" href="#c.xa_init" title="xa_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init()</span></code></a> on the array, but it does the initialisation at
compiletime instead of runtime.</p>
</div>
<dl class="function">
<dt id="c.DEFINE_XARRAY_ALLOC">
<code class="sig-name descname">DEFINE_XARRAY_ALLOC</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_XARRAY_ALLOC" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an XArray which allocates IDs starting at 0.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>A string that names your XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is intended for file scope definitions of allocating XArrays.
See also <a class="reference internal" href="#c.DEFINE_XARRAY" title="DEFINE_XARRAY"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_XARRAY()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.DEFINE_XARRAY_ALLOC1">
<code class="sig-name descname">DEFINE_XARRAY_ALLOC1</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_XARRAY_ALLOC1" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an XArray which allocates IDs starting at 1.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>A string that names your XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is intended for file scope definitions of allocating XArrays.
See also <a class="reference internal" href="#c.DEFINE_XARRAY" title="DEFINE_XARRAY"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_XARRAY()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.xa_init_flags">
void <code class="sig-name descname">xa_init_flags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, gfp_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_init_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an empty XArray with flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>XA_FLAG values.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you need to initialise an XArray with special flags (eg you need
to take the lock from interrupt context), use this function instead
of <a class="reference internal" href="#c.xa_init" title="xa_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_init()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="function">
<dt id="c.xa_init">
void <code class="sig-name descname">xa_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an empty XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An empty XArray is full of NULL entries.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="function">
<dt id="c.xa_empty">
bool <code class="sig-name descname">xa_empty</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an array has any present entries.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the array contains only NULL pointers.</p>
</div>
<dl class="function">
<dt id="c.xa_marked">
bool <code class="sig-name descname">xa_marked</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_marked" title="Permalink to this definition">¶</a></dt>
<dd><p>Inquire whether any entry in this array has a mark set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>Array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark value</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if any entry has this mark set.</p>
</div>
<dl class="function">
<dt id="c.xa_for_each_range">
<code class="sig-name descname">xa_for_each_range</code><span class="sig-paren">(</span><em>xa</em>, <em>index</em>, <em>entry</em>, <em>start</em>, <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_for_each_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a portion of an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Index of <strong>entry</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>First index to retrieve from array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>Last index to retrieve from array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During the iteration, <strong>entry</strong> will have the value of the entry stored
in <strong>xa</strong> at <strong>index</strong>.  You may modify <strong>index</strong> during the iteration if you
want to skip or reprocess indices.  It is safe to modify the array
during the iteration.  At the end of the iteration, <strong>entry</strong> will be set
to NULL and <strong>index</strong> will have a value less than or equal to max.</p>
<p><a class="reference internal" href="#c.xa_for_each_range" title="xa_for_each_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_range()</span></code></a> is O(n.log(n)) while <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> is O(n).  You have
to handle your own locking with <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>, and if you have to unlock
after each iteration, it will also end up being O(n.log(n)).
<a class="reference internal" href="#c.xa_for_each_range" title="xa_for_each_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_range()</span></code></a> will spin if it hits a retry entry; if you intend to
see retry entries, you should use the <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> iterator instead.
The <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> iterator will expand into more inline code than
<a class="reference internal" href="#c.xa_for_each_range" title="xa_for_each_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_range()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
</div>
<dl class="function">
<dt id="c.xa_for_each_start">
<code class="sig-name descname">xa_for_each_start</code><span class="sig-paren">(</span><em>xa</em>, <em>index</em>, <em>entry</em>, <em>start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_for_each_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a portion of an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Index of <strong>entry</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>First index to retrieve from array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During the iteration, <strong>entry</strong> will have the value of the entry stored
in <strong>xa</strong> at <strong>index</strong>.  You may modify <strong>index</strong> during the iteration if you
want to skip or reprocess indices.  It is safe to modify the array
during the iteration.  At the end of the iteration, <strong>entry</strong> will be set
to NULL and <strong>index</strong> will have a value less than or equal to max.</p>
<p><a class="reference internal" href="#c.xa_for_each_start" title="xa_for_each_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_start()</span></code></a> is O(n.log(n)) while <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> is O(n).  You have
to handle your own locking with <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>, and if you have to unlock
after each iteration, it will also end up being O(n.log(n)).
<a class="reference internal" href="#c.xa_for_each_start" title="xa_for_each_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_start()</span></code></a> will spin if it hits a retry entry; if you intend to
see retry entries, you should use the <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> iterator instead.
The <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> iterator will expand into more inline code than
<a class="reference internal" href="#c.xa_for_each_start" title="xa_for_each_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_start()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
</div>
<dl class="function">
<dt id="c.xa_for_each">
<code class="sig-name descname">xa_for_each</code><span class="sig-paren">(</span><em>xa</em>, <em>index</em>, <em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over present entries in an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Index of <strong>entry</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During the iteration, <strong>entry</strong> will have the value of the entry stored
in <strong>xa</strong> at <strong>index</strong>.  You may modify <strong>index</strong> during the iteration if you want
to skip or reprocess indices.  It is safe to modify the array during the
iteration.  At the end of the iteration, <strong>entry</strong> will be set to NULL and
<strong>index</strong> will have a value less than or equal to max.</p>
<p><a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a> is O(n.log(n)) while <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> is O(n).  You have
to handle your own locking with <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>, and if you have to unlock
after each iteration, it will also end up being O(n.log(n)).  <a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a>
will spin if it hits a retry entry; if you intend to see retry entries,
you should use the <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a> iterator instead.  The <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>
iterator will expand into more inline code than <a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
</div>
<dl class="function">
<dt id="c.xa_for_each_marked">
<code class="sig-name descname">xa_for_each_marked</code><span class="sig-paren">(</span><em>xa</em>, <em>index</em>, <em>entry</em>, <em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_for_each_marked" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over marked entries in an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Index of <strong>entry</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filter</span></code></dt><dd><p>Selection criterion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During the iteration, <strong>entry</strong> will have the value of the entry stored
in <strong>xa</strong> at <strong>index</strong>.  The iteration will skip all entries in the array
which do not match <strong>filter</strong>.  You may modify <strong>index</strong> during the iteration
if you want to skip or reprocess indices.  It is safe to modify the array
during the iteration.  At the end of the iteration, <strong>entry</strong> will be set to
NULL and <strong>index</strong> will have a value less than or equal to max.</p>
<p><a class="reference internal" href="#c.xa_for_each_marked" title="xa_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_marked()</span></code></a> is O(n.log(n)) while <a class="reference internal" href="#c.xas_for_each_marked" title="xas_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each_marked()</span></code></a> is O(n).
You have to handle your own locking with <a class="reference internal" href="#c.xas_for_each" title="xas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each()</span></code></a>, and if you have
to unlock after each iteration, it will also end up being O(n.log(n)).
<a class="reference internal" href="#c.xa_for_each_marked" title="xa_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_marked()</span></code></a> will spin if it hits a retry entry; if you intend to
see retry entries, you should use the <a class="reference internal" href="#c.xas_for_each_marked" title="xas_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each_marked()</span></code></a> iterator
instead.  The <a class="reference internal" href="#c.xas_for_each_marked" title="xas_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_for_each_marked()</span></code></a> iterator will expand into more inline
code than <a class="reference internal" href="#c.xa_for_each_marked" title="xa_for_each_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each_marked()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
</div>
<dl class="function">
<dt id="c.xa_store_bh">
void * <code class="sig-name descname">xa_store_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_store_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is like calling <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a> except it disables softirqs
while holding the array lock.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_store_irq">
void * <code class="sig-name descname">xa_store_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_store_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is like calling <a class="reference internal" href="#c.xa_store" title="xa_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_store()</span></code></a> except it disables interrupts
while holding the array lock.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_erase_bh">
void * <code class="sig-name descname">xa_erase_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_erase_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase this entry from the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loading from <strong>index</strong> will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
If the index is part of a multi-index entry, all indices will be erased
and none of the entries will be part of a multi-index entry.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.</p>
<p><strong>Return</strong></p>
<p>The entry which used to be at this index.</p>
</div>
<dl class="function">
<dt id="c.xa_erase_irq">
void * <code class="sig-name descname">xa_erase_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_erase_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase this entry from the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loading from <strong>index</strong> will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
If the index is part of a multi-index entry, all indices will be erased
and none of the entries will be part of a multi-index entry.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.</p>
<p><strong>Return</strong></p>
<p>The entry which used to be at this index.</p>
</div>
<dl class="function">
<dt id="c.xa_cmpxchg">
void * <code class="sig-name descname">xa_cmpxchg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *old</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_cmpxchg" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally replace an entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*old</span></code></dt><dd><p>Old value to test against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New value to place in array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the entry at <strong>index</strong> is the same as <strong>old</strong>, replace it with <strong>entry</strong>.
If the return value is equal to <strong>old</strong>, then the exchange was successful.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.  May sleep
if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old value at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_cmpxchg_bh">
void * <code class="sig-name descname">xa_cmpxchg_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *old</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_cmpxchg_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally replace an entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*old</span></code></dt><dd><p>Old value to test against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New value to place in array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is like calling <a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a> except it disables softirqs
while holding the array lock.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old value at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_cmpxchg_irq">
void * <code class="sig-name descname">xa_cmpxchg_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *old</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_cmpxchg_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally replace an entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*old</span></code></dt><dd><p>Old value to test against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New value to place in array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is like calling <a class="reference internal" href="#c.xa_cmpxchg" title="xa_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_cmpxchg()</span></code></a> except it disables interrupts
while holding the array lock.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old value at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_insert">
int <code class="sig-name descname">xa_insert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray unless another entry is already present.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inserting a NULL entry will store a reserved entry (like <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>)
if no entry is present.  Inserting will fail if a reserved entry is
present, even though loading from this index will return NULL.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.  May sleep if
the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the store succeeded.  -EBUSY if another entry was present.
-ENOMEM if memory could not be allocated.</p>
</div>
<dl class="function">
<dt id="c.xa_insert_bh">
int <code class="sig-name descname">xa_insert_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_insert_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray unless another entry is already present.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inserting a NULL entry will store a reserved entry (like <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>)
if no entry is present.  Inserting will fail if a reserved entry is
present, even though loading from this index will return NULL.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the store succeeded.  -EBUSY if another entry was present.
-ENOMEM if memory could not be allocated.</p>
</div>
<dl class="function">
<dt id="c.xa_insert_irq">
int <code class="sig-name descname">xa_insert_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_insert_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray unless another entry is already present.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inserting a NULL entry will store a reserved entry (like <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>)
if no entry is present.  Inserting will fail if a reserved entry is
present, even though loading from this index will return NULL.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the store succeeded.  -EBUSY if another entry was present.
-ENOMEM if memory could not be allocated.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc">
int <code class="sig-name descname">xa_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.  May sleep if
the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated or
-EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc_bh">
int <code class="sig-name descname">xa_alloc_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated or
-EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc_irq">
int <code class="sig-name descname">xa_alloc_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated or
-EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc_cyclic">
int <code class="sig-name descname">xa_alloc_cyclic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, u32<em> *next</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of allocated ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.
The search for an empty entry will start at <strong>next</strong> and will wrap
around if necessary.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.  May sleep if
the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping.  1 if the
allocation succeeded after wrapping, -ENOMEM if memory could not be
allocated or -EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc_cyclic_bh">
int <code class="sig-name descname">xa_alloc_cyclic_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, u32<em> *next</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc_cyclic_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of allocated ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.
The search for an empty entry will start at <strong>next</strong> and will wrap
around if necessary.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping.  1 if the
allocation succeeded after wrapping, -ENOMEM if memory could not be
allocated or -EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_alloc_cyclic_irq">
int <code class="sig-name descname">xa_alloc_cyclic_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, u32<em> *next</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_alloc_cyclic_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of allocated ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.
The search for an empty entry will start at <strong>next</strong> and will wrap
around if necessary.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.  May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping.  1 if the
allocation succeeded after wrapping, -ENOMEM if memory could not be
allocated or -EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.xa_reserve">
int <code class="sig-name descname">xa_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve this index in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures there is somewhere to store an entry at <strong>index</strong> in the array.
If there is already something stored at <strong>index</strong>, this function does
nothing.  If there was nothing there, the entry is marked as reserved.
Loading from a reserved entry returns a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer.</p>
<p>If you do not use the entry that you have reserved, call <a class="reference internal" href="#c.xa_release" title="xa_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_release()</span></code></a>
or <a class="reference internal" href="#c.xa_erase" title="xa_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_erase()</span></code></a> to free any unnecessary memory.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.
May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the reservation succeeded or -ENOMEM if it failed.</p>
</div>
<dl class="function">
<dt id="c.xa_reserve_bh">
int <code class="sig-name descname">xa_reserve_bh</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_reserve_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve this index in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A softirq-disabling version of <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock while
disabling softirqs.</p>
<p><strong>Return</strong></p>
<p>0 if the reservation succeeded or -ENOMEM if it failed.</p>
</div>
<dl class="function">
<dt id="c.xa_reserve_irq">
int <code class="sig-name descname">xa_reserve_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_reserve_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve this index in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An interrupt-disabling version of <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock while
disabling interrupts.</p>
<p><strong>Return</strong></p>
<p>0 if the reservation succeeded or -ENOMEM if it failed.</p>
</div>
<dl class="function">
<dt id="c.xa_release">
void <code class="sig-name descname">xa_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a reserved entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After calling <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>, you can call this function to release the
reservation.  If the entry at <strong>index</strong> has been stored to, this function
will do nothing.</p>
</div>
<dl class="function">
<dt id="c.xa_is_sibling">
bool <code class="sig-name descname">xa_is_sibling</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_sibling" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the entry a sibling entry?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Entry retrieved from the XArray</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entry is a sibling entry.</p>
</div>
<dl class="function">
<dt id="c.xa_is_retry">
bool <code class="sig-name descname">xa_is_retry</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the entry a retry entry?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Entry retrieved from the XArray</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entry is a retry entry.</p>
</div>
<dl class="function">
<dt id="c.xa_is_advanced">
bool <code class="sig-name descname">xa_is_advanced</code><span class="sig-paren">(</span>const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_is_advanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the entry only permitted for the advanced API?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Entry to be stored in the XArray.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entry cannot be stored by the normal API.</p>
</div>
<dl class="type">
<dt id="c.xa_update_node_t">
<code class="sig-name descname">xa_update_node_t</code><a class="headerlink" href="#c.xa_update_node_t" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: A callback function from the XArray.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">xa_update_node_t</span> <span class="pre">(struct</span> <span class="pre">xa_node</span> <span class="pre">*node)</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_node</span> <span class="pre">*node</span></code></dt><dd><p>The node which is being processed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called every time the XArray updates the count of
present and value entries in a node.  It allows advanced users to
maintain the private_list in the node.</p>
<p><strong>Context</strong></p>
<p>The xa_lock is held and interrupts may be disabled.
Implementations should not drop the xa_lock, nor re-enable
interrupts.</p>
</div>
<dl class="function">
<dt id="c.XA_STATE">
<code class="sig-name descname">XA_STATE</code><span class="sig-paren">(</span><em>name</em>, <em>array</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.XA_STATE" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare an XArray operation state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of this operation state (usually xas).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>Array to operate on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Initial index of interest.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Declare and initialise an xa_state on the stack.</p>
</div>
<dl class="function">
<dt id="c.XA_STATE_ORDER">
<code class="sig-name descname">XA_STATE_ORDER</code><span class="sig-paren">(</span><em>name</em>, <em>array</em>, <em>index</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.XA_STATE_ORDER" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare an XArray operation state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of this operation state (usually xas).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>Array to operate on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Initial index of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">order</span></code></dt><dd><p>Order of entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Declare and initialise an xa_state on the stack.  This variant of
<a class="reference internal" href="#c.XA_STATE" title="XA_STATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">XA_STATE()</span></code></a> allows you to specify the ‘order’ of the element you
want to operate on.`</p>
</div>
<dl class="function">
<dt id="c.xas_error">
int <code class="sig-name descname">xas_error</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an errno stored in the xa_state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if no error has been noted.  A negative errno if one has.</p>
</div>
<dl class="function">
<dt id="c.xas_set_err">
void <code class="sig-name descname">xas_set_err</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, long<em> err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_set_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Note an error in the xa_state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">err</span></code></dt><dd><p>Negative error number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only call this function with a negative <strong>err</strong>; zero or positive errors
will probably not behave the way you think they should.  If you want
to clear the error from an xa_state, use <a class="reference internal" href="#c.xas_reset" title="xas_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_reset()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.xas_invalid">
bool <code class="sig-name descname">xas_invalid</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the xas in a retry or error state?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the xas cannot be used for operations.</p>
</div>
<dl class="function">
<dt id="c.xas_valid">
bool <code class="sig-name descname">xas_valid</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the xas a valid cursor into the array?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the xas can be used for operations.</p>
</div>
<dl class="function">
<dt id="c.xas_is_node">
bool <code class="sig-name descname">xas_is_node</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_is_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the xas point to a node?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the xas currently references a node.</p>
</div>
<dl class="function">
<dt id="c.xas_reset">
void <code class="sig-name descname">xas_reset</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset an XArray operation state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the error or walk state of the <strong>xas</strong> so future walks of the
array will start from the root.  Use this if you have dropped the
xarray lock and want to reuse the xa_state.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="function">
<dt id="c.xas_retry">
bool <code class="sig-name descname">xas_retry</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, const void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retry the operation if appropriate.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>Entry from xarray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The advanced functions may sometimes return an internal entry, such as
a retry entry or a zero entry.  This function sets up the <strong>xas</strong> to restart
the walk from the head of the array if needed.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>true if the operation needs to be retried.</p>
</div>
<dl class="function">
<dt id="c.xas_reload">
void * <code class="sig-name descname">xas_reload</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Refetch an entry from the xarray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to check that a previously loaded entry still has
the same value.  This is useful for the lockless pagecache lookup where
we walk the array with only the RCU lock to protect us, lock the page,
then check that the page hasn’t moved since we looked it up.</p>
<p>The caller guarantees that <strong>xas</strong> is still valid.  If it may be in an
error or restart state, call <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>The entry at this location in the xarray.</p>
</div>
<dl class="function">
<dt id="c.xas_set">
void <code class="sig-name descname">xas_set</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up XArray operation state for a different index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>New index into the XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the operation state to refer to a different index.  This will
have the effect of starting a walk from the top; see <a class="reference internal" href="#c.xas_next" title="xas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next()</span></code></a>
to move to an adjacent index.</p>
</div>
<dl class="function">
<dt id="c.xas_advance">
void <code class="sig-name descname">xas_advance</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip over sibling entries.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of last sibling entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the operation state to refer to the last sibling entry.
This is useful for loops that normally want to see sibling
entries but sometimes want to skip them.  Use <a class="reference internal" href="#c.xas_set" title="xas_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_set()</span></code></a> if you
want to move to an index which is not part of this entry.</p>
</div>
<dl class="function">
<dt id="c.xas_set_order">
void <code class="sig-name descname">xas_set_order</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> index</em>, unsigned int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up XArray operation state for a multislot entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Target of the operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Entry occupies 2^**order** indices.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xas_set_update">
void <code class="sig-name descname">xas_set_update</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, <a class="reference internal" href="#c.xa_update_node_t" title="xa_update_node_t">xa_update_node_t</a><em> update</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_set_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up XArray operation state for a callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_update_node_t</span> <span class="pre">update</span></code></dt><dd><p>Function to call when updating a node.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The XArray can notify a caller after it has updated an xa_node.
This is advanced functionality and is only needed by the page cache.</p>
</div>
<dl class="function">
<dt id="c.xas_next_entry">
void * <code class="sig-name descname">xas_next_entry</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_next_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance iterator to next present entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Highest index to return.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.xas_next_entry" title="xas_next_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next_entry()</span></code></a> is an inline function to optimise xarray traversal for
speed.  It is equivalent to calling <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>, and will call <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>
for all the hard cases.</p>
<p><strong>Return</strong></p>
<p>The next present entry after the one currently referred to by <strong>xas</strong>.</p>
</div>
<dl class="function">
<dt id="c.xas_next_marked">
void * <code class="sig-name descname">xas_next_marked</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> max</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_next_marked" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance iterator to next marked entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Highest index to return.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark to search for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.xas_next_marked" title="xas_next_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_next_marked()</span></code></a> is an inline function to optimise xarray traversal for
speed.  It is equivalent to calling <a class="reference internal" href="#c.xas_find_marked" title="xas_find_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find_marked()</span></code></a>, and will call
<a class="reference internal" href="#c.xas_find_marked" title="xas_find_marked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find_marked()</span></code></a> for all the hard cases.</p>
<p><strong>Return</strong></p>
<p>The next marked entry after the one currently referred to by <strong>xas</strong>.</p>
</div>
<dl class="function">
<dt id="c.xas_for_each">
<code class="sig-name descname">xas_for_each</code><span class="sig-paren">(</span><em>xas</em>, <em>entry</em>, <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a range of an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt><dd><p>Maximum index to retrieve from array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The loop body will be executed for each entry present in the xarray
between the current xas position and <strong>max</strong>.  <strong>entry</strong> will be set to
the entry retrieved from the xarray.  It is safe to delete entries
from the array in the loop body.  You should hold either the RCU lock
or the xa_lock while iterating.  If you need to drop the lock, call
<a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a> first.</p>
</div>
<dl class="function">
<dt id="c.xas_for_each_marked">
<code class="sig-name descname">xas_for_each_marked</code><span class="sig-paren">(</span><em>xas</em>, <em>entry</em>, <em>max</em>, <em>mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_for_each_marked" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a range of an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt><dd><p>Maximum index to retrieve from array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mark</span></code></dt><dd><p>Mark to search for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The loop body will be executed for each marked entry in the xarray
between the current xas position and <strong>max</strong>.  <strong>entry</strong> will be set to
the entry retrieved from the xarray.  It is safe to delete entries
from the array in the loop body.  You should hold either the RCU lock
or the xa_lock while iterating.  If you need to drop the lock, call
<a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a> first.</p>
</div>
<dl class="function">
<dt id="c.xas_for_each_conflict">
<code class="sig-name descname">xas_for_each_conflict</code><span class="sig-paren">(</span><em>xas</em>, <em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_for_each_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a range of an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>Entry retrieved from the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The loop body will be executed for each entry in the XArray that
lies within the range specified by <strong>xas</strong>.  If the loop terminates
normally, <strong>entry</strong> will be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The user may break out of the loop,
which will leave <strong>entry</strong> set to the conflicting entry.  The caller
may also call xa_set_err() to exit the loop while setting an error
to record the reason.</p>
</div>
<dl class="function">
<dt id="c.xas_prev">
void * <code class="sig-name descname">xas_prev</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Move iterator to previous index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>xas</strong> was in an error state, it will remain in an error state
and this function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  If the <strong>xas</strong> has never been walked,
it will have the effect of calling <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a>.  Otherwise one will be
subtracted from the index and the state will be walked to the correct
location in the array for the next operation.</p>
<p>If the iterator was referencing index 0, this function wraps
around to <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code>.</p>
<p><strong>Return</strong></p>
<p>The entry at the new index.  This may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or an internal
entry.</p>
</div>
<dl class="function">
<dt id="c.xas_next">
void * <code class="sig-name descname">xas_next</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Move state to next index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>xas</strong> was in an error state, it will remain in an error state
and this function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  If the <strong>xas</strong> has never been walked,
it will have the effect of calling <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a>.  Otherwise one will be
added to the index and the state will be walked to the correct
location in the array for the next operation.</p>
<p>If the iterator was referencing index <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code>, this function wraps
around to 0.</p>
<p><strong>Return</strong></p>
<p>The entry at the new index.  This may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or an internal
entry.</p>
</div>
<dl class="function">
<dt id="c.xas_load">
void * <code class="sig-name descname">xas_load</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an entry from the XArray (advanced).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually walks the <strong>xas</strong> to the appropriate state to load the entry
stored at xa_index.  However, it will do nothing and return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if
<strong>xas</strong> is in an error state.  <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a> will never expand the tree.</p>
<p>If the xa_state is set up to operate on a multi-index entry, <a class="reference internal" href="#c.xas_load" title="xas_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_load()</span></code></a>
may return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or an internal entry, even if there are entries
present within the range specified by <strong>xas</strong>.</p>
<p><strong>Context</strong></p>
<p>Any context.  The caller should hold the xa_lock or the RCU lock.</p>
<p><strong>Return</strong></p>
<p>Usually an entry in the XArray, but see description for exceptions.</p>
</div>
<dl class="function">
<dt id="c.xas_nomem">
bool <code class="sig-name descname">xas_nomem</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_nomem" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory if needed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we need to add new nodes to the XArray, we try to allocate memory
with GFP_NOWAIT while holding the lock, which will usually succeed.
If it fails, <strong>xas</strong> is flagged as needing memory to continue.  The caller
should drop the lock and call <a class="reference internal" href="#c.xas_nomem" title="xas_nomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_nomem()</span></code></a>.  If <a class="reference internal" href="#c.xas_nomem" title="xas_nomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_nomem()</span></code></a> succeeds,
the caller should retry the operation.</p>
<p>Forward progress is guaranteed as one node is allocated here and
stored in the xa_state where it will be found by xas_alloc().  More
nodes will likely be found in the slab allocator, but we do not tie
them up here.</p>
<p><strong>Return</strong></p>
<p>true if memory was needed, and was successfully allocated.</p>
</div>
<dl class="function">
<dt id="c.xas_free_nodes">
void <code class="sig-name descname">xas_free_nodes</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, struct xa_node<em> *top</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_free_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Free this node and all nodes that it references</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>Array operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_node</span> <span class="pre">*top</span></code></dt><dd><p>Node to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This node has been removed from the tree.  We must now free it and all
of its subnodes.  There may be RCU walkers with references into the tree,
so we must replace all entries with retry markers.</p>
</div>
<dl class="function">
<dt id="c.xas_create_range">
void <code class="sig-name descname">xas_create_range</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_create_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that stores to this range will succeed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates all of the slots in the range covered by <strong>xas</strong>.  Sets <strong>xas</strong> to
create single-index entries and positions it at the beginning of the
range.  This is for the benefit of users which have not yet been
converted to use multi-index entries.</p>
</div>
<dl class="function">
<dt id="c.xas_store">
void * <code class="sig-name descname">xas_store</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, void<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>xas</strong> is operating on a multi-index entry, the entry returned by this
function is essentially meaningless (it may be an internal entry or it
may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, even if there are non-NULL entries at some of the indices
covered by the range).  This is not a problem for any current users,
and can be changed if needed.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index.</p>
</div>
<dl class="function">
<dt id="c.xas_get_mark">
bool <code class="sig-name descname">xas_get_mark</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_get_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state of this mark.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mark is set, false if the mark is clear or <strong>xas</strong>
is in an error state.</p>
</div>
<dl class="function">
<dt id="c.xas_set_mark">
void <code class="sig-name descname">xas_set_mark</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_set_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mark on this entry and its parents.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the specified mark on this entry, and walks up the tree setting it
on all the ancestor entries.  Does nothing if <strong>xas</strong> has not been walked to
an entry, or is in an error state.</p>
</div>
<dl class="function">
<dt id="c.xas_clear_mark">
void <code class="sig-name descname">xas_clear_mark</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_clear_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the mark on this entry and its parents.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clears the specified mark on this entry, and walks back to the head
attempting to clear it on all the ancestor entries.  Does nothing if
<strong>xas</strong> has not been walked to an entry, or is in an error state.</p>
</div>
<dl class="function">
<dt id="c.xas_init_marks">
void <code class="sig-name descname">xas_init_marks</code><span class="sig-paren">(</span>const struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_init_marks" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise all marks for the entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>Array operations state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise all marks for the entry specified by <strong>xas</strong>.  If we’re tracking
free entries with a mark, we need to set it on all entries.  All other
marks are cleared.</p>
<p>This implementation is not as efficient as it could be; we may walk
up the tree multiple times.</p>
</div>
<dl class="function">
<dt id="c.xas_split_alloc">
void <code class="sig-name descname">xas_split_alloc</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, void<em> *entry</em>, unsigned int<em> order</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_split_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory for splitting an entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry which will be stored in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Current entry order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called before calling <a class="reference internal" href="#c.xas_split" title="xas_split"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_split()</span></code></a>.
If necessary, it will allocate new nodes (and fill them with <strong>entry</strong>)
to prepare for the upcoming split of an entry of <strong>order</strong> size into
entries of the order stored in the <strong>xas</strong>.</p>
<p><strong>Context</strong></p>
<p>May sleep if <strong>gfp</strong> flags permit.</p>
</div>
<dl class="function">
<dt id="c.xas_split">
void <code class="sig-name descname">xas_split</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, void<em> *entry</em>, unsigned int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a multi-index entry into smaller entries.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry to store in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Current entry order.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the new entries is set in <strong>xas</strong>.  The value in <strong>entry</strong> is
copied to all the replacement entries.</p>
<p><strong>Context</strong></p>
<p>Any context.  The caller should hold the xa_lock.</p>
</div>
<dl class="function">
<dt id="c.xas_pause">
void <code class="sig-name descname">xas_pause</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause a walk to drop a lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some users need to pause a walk and drop the lock they’re holding in
order to yield to a higher priority thread or carry out an operation
on an entry.  Those users should call this function before they drop
the lock.  It resets the <strong>xas</strong> to be suitable for the next iteration
of the loop after the user has reacquired the lock.  If most entries
found during a walk require you to call <a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a>, the <a class="reference internal" href="#c.xa_for_each" title="xa_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_for_each()</span></code></a>
iterator may be more appropriate.</p>
<p>Note that <a class="reference internal" href="#c.xas_pause" title="xas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_pause()</span></code></a> only works for forward iteration.  If a user needs
to pause a reverse iteration, we will need a xas_pause_rev().</p>
</div>
<dl class="function">
<dt id="c.xas_find">
void * <code class="sig-name descname">xas_find</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next present entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Highest index to return.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>xas</strong> has not yet been walked to an entry, return the entry
which has an index &gt;= xas.xa_index.  If it has been walked, the entry
currently being pointed at has been processed, and so we move to the
next entry.</p>
<p>If no entry is found and the array is smaller than <strong>max</strong>, the iterator
is set to the smallest index not yet in the array.  This allows <strong>xas</strong>
to be immediately passed to <a class="reference internal" href="#c.xas_store" title="xas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_store()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The entry, if found, otherwise <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.xas_find_marked">
void * <code class="sig-name descname">xas_find_marked</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em>, unsigned long<em> max</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_find_marked" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next marked entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Highest index to return.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number to search for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>xas</strong> has not yet been walked to an entry, return the marked entry
which has an index &gt;= xas.xa_index.  If it has been walked, the entry
currently being pointed at has been processed, and so we return the
first marked entry with an index &gt; xas.xa_index.</p>
<p>If no marked entry is found and the array is smaller than <strong>max</strong>, <strong>xas</strong> is
set to the bounds state and xas-&gt;xa_index is set to the smallest index
not yet in the array.  This allows <strong>xas</strong> to be immediately passed to
<a class="reference internal" href="#c.xas_store" title="xas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_store()</span></code></a>.</p>
<p>If no entry is found before <strong>max</strong> is reached, <strong>xas</strong> is set to the restart
state.</p>
<p><strong>Return</strong></p>
<p>The entry, if found, otherwise <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.xas_find_conflict">
void * <code class="sig-name descname">xas_find_conflict</code><span class="sig-paren">(</span>struct xa_state<em> *xas</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xas_find_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next present entry in a range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_state</span> <span class="pre">*xas</span></code></dt><dd><p>XArray operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>xas</strong> describes both a range and a position within that range.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held.</p>
<p><strong>Return</strong></p>
<p>The next entry in the range covered by <strong>xas</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.xa_load">
void * <code class="sig-name descname">xa_load</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an entry from an XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>index into array.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
<p><strong>Return</strong></p>
<p>The entry at <strong>index</strong> in <strong>xa</strong>.</p>
</div>
<dl class="function">
<dt id="c.__xa_erase">
void * <code class="sig-name descname">__xa_erase</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase this entry from the XArray while locked.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loading from <strong>index</strong> will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
If the index is part of a multi-index entry, all indices will be erased
and none of the entries will be part of a multi-index entry.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.</p>
<p><strong>Return</strong></p>
<p>The entry which used to be at this index.</p>
</div>
<dl class="function">
<dt id="c.xa_erase">
void * <code class="sig-name descname">xa_erase</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase this entry from the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loading from <strong>index</strong> will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
If the index is part of a multi-index entry, all indices will be erased
and none of the entries will be part of a multi-index entry.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.</p>
<p><strong>Return</strong></p>
<p>The entry which used to be at this index.</p>
</div>
<dl class="function">
<dt id="c.__xa_store">
void * <code class="sig-name descname">__xa_store</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You must already be holding the xa_lock when calling this function.
It will drop the lock if needed to allocate memory, and then reacquire
it afterwards.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.  May
release and reacquire xa_lock if <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.xa_store">
void * <code class="sig-name descname">xa_store</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loads from this index will return <strong>entry</strong>.
Storing into an existing multi-index entry updates the entry of every index.
The marks associated with <strong>index</strong> are unaffected unless <strong>entry</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock.
May sleep if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index on success, xa_err(-EINVAL) if <strong>entry</strong>
cannot be stored in an XArray, or xa_err(-ENOMEM) if memory allocation
failed.</p>
</div>
<dl class="function">
<dt id="c.__xa_cmpxchg">
void * <code class="sig-name descname">__xa_cmpxchg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *old</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_cmpxchg" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*old</span></code></dt><dd><p>Old value to test against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You must already be holding the xa_lock when calling this function.
It will drop the lock if needed to allocate memory, and then reacquire
it afterwards.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.  May
release and reacquire xa_lock if <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>The old entry at this index or <a class="reference internal" href="#c.xa_err" title="xa_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_err()</span></code></a> if an error happened.</p>
</div>
<dl class="function">
<dt id="c.__xa_insert">
int <code class="sig-name descname">__xa_insert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry in the XArray if no entry is present.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index into array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inserting a NULL entry will store a reserved entry (like <a class="reference internal" href="#c.xa_reserve" title="xa_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_reserve()</span></code></a>)
if no entry is present.  Inserting will fail if a reserved entry is
present, even though loading from this index will return NULL.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.  May
release and reacquire xa_lock if <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the store succeeded.  -EBUSY if another entry was present.
-ENOMEM if memory could not be allocated.</p>
</div>
<dl class="function">
<dt id="c.xa_store_range">
void * <code class="sig-name descname">xa_store_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> first</em>, unsigned long<em> last</em>, void<em> *entry</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_store_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Store this entry at a range of indices in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">first</span></code></dt><dd><p>First index to affect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">last</span></code></dt><dd><p>Last index to affect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function returns, loads from any index between <strong>first</strong> and <strong>last</strong>,
inclusive will return <strong>entry</strong>.
Storing into an existing multi-index entry updates the entry of every index.
The marks associated with <strong>index</strong> are unaffected unless <strong>entry</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock.  May sleep
if the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> on success, xa_err(-EINVAL) if <strong>entry</strong> cannot be stored in
an XArray, or xa_err(-ENOMEM) if memory allocation failed.</p>
</div>
<dl class="function">
<dt id="c.xa_get_order">
int <code class="sig-name descname">xa_get_order</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the order of an entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of the entry.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A number between 0 and 63 indicating the order of the entry.</p>
</div>
<dl class="function">
<dt id="c.__xa_alloc">
int <code class="sig-name descname">__xa_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range for allocated ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.  May
release and reacquire xa_lock if <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated or
-EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.__xa_alloc_cyclic">
int <code class="sig-name descname">__xa_alloc_cyclic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, u32<em> *id</em>, void<em> *entry</em>, struct <a class="reference internal" href="#c.xa_limit" title="xa_limit">xa_limit</a><em> limit</em>, u32<em> *next</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_alloc_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Find somewhere to store this entry in the XArray.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>New entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_limit</span> <span class="pre">limit</span></code></dt><dd><p>Range of allocated ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>xa</strong> between <strong>limit.min</strong> and <strong>limit.max</strong>,
stores the index into the <strong>id</strong> pointer, then stores the entry at
that index.  A concurrent lookup will not see an uninitialised <strong>id</strong>.
The search for an empty entry will start at <strong>next</strong> and will wrap
around if necessary.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.  May
release and reacquire xa_lock if <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping.  1 if the
allocation succeeded after wrapping, -ENOMEM if memory could not be
allocated or -EBUSY if there are no free entries in <strong>limit</strong>.</p>
</div>
<dl class="function">
<dt id="c.__xa_set_mark">
void <code class="sig-name descname">__xa_set_mark</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_set_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this mark on this entry while locked.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempting to set a mark on a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> entry does not succeed.</p>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.</p>
</div>
<dl class="function">
<dt id="c.__xa_clear_mark">
void <code class="sig-name descname">__xa_clear_mark</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xa_clear_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear this mark on this entry while locked.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.  Expects xa_lock to be held on entry.</p>
</div>
<dl class="function">
<dt id="c.xa_get_mark">
bool <code class="sig-name descname">xa_get_mark</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_get_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Inquire whether this mark is set on this entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function uses the RCU read lock, so the result may be out of date
by the time it returns.  If you need the result to be stable, use a lock.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
<p><strong>Return</strong></p>
<p>True if the entry at <strong>index</strong> has this mark set, false if it doesn’t.</p>
</div>
<dl class="function">
<dt id="c.xa_set_mark">
void <code class="sig-name descname">xa_set_mark</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_set_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this mark on this entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempting to set a mark on a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> entry does not succeed.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock.</p>
</div>
<dl class="function">
<dt id="c.xa_clear_mark">
void <code class="sig-name descname">xa_clear_mark</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> index</em>, xa_mark_t<em> mark</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_clear_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear this mark on this entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>Index of entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">mark</span></code></dt><dd><p>Mark number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clearing a mark always succeeds.</p>
<p><strong>Context</strong></p>
<p>Process context.  Takes and releases the xa_lock.</p>
</div>
<dl class="function">
<dt id="c.xa_find">
void * <code class="sig-name descname">xa_find</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> *indexp</em>, unsigned long<em> max</em>, xa_mark_t<em> filter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the XArray for an entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*indexp</span></code></dt><dd><p>Pointer to an index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Maximum index to search to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">filter</span></code></dt><dd><p>Selection criterion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the entry in <strong>xa</strong> which matches the <strong>filter</strong>, and has the lowest
index that is at least <strong>indexp</strong> and no more than <strong>max</strong>.
If an entry is found, <strong>indexp</strong> is updated to be the index of the entry.
This function is protected by the RCU read lock, so it may not find
entries which are being simultaneously added.  It will not return an
<code class="docutils literal notranslate"><span class="pre">XA_RETRY_ENTRY</span></code>; if you need to see retry entries, use <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
<p><strong>Return</strong></p>
<p>The entry, if found, otherwise <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.xa_find_after">
void * <code class="sig-name descname">xa_find_after</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, unsigned long<em> *indexp</em>, unsigned long<em> max</em>, xa_mark_t<em> filter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_find_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the XArray for a present entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*indexp</span></code></dt><dd><p>Pointer to an index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Maximum index to search to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">filter</span></code></dt><dd><p>Selection criterion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the entry in <strong>xa</strong> which matches the <strong>filter</strong> and has the lowest
index that is above <strong>indexp</strong> and no more than <strong>max</strong>.
If an entry is found, <strong>indexp</strong> is updated to be the index of the entry.
This function is protected by the RCU read lock, so it may miss entries
which are being simultaneously added.  It will not return an
<code class="docutils literal notranslate"><span class="pre">XA_RETRY_ENTRY</span></code>; if you need to see retry entries, use <a class="reference internal" href="#c.xas_find" title="xas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">xas_find()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
<p><strong>Return</strong></p>
<p>The pointer, if found, otherwise <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.xa_extract">
unsigned int <code class="sig-name descname">xa_extract</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em>, void<em> **dst</em>, unsigned long<em> start</em>, unsigned long<em> max</em>, unsigned int<em> n</em>, xa_mark_t<em> filter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy selected entries from the XArray into a normal array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>The source XArray to copy from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**dst</span></code></dt><dd><p>The buffer to copy entries into.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>The first index in the XArray eligible to be selected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The last index in the XArray eligible to be selected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>The maximum number of entries to copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">filter</span></code></dt><dd><p>Selection criterion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies up to <strong>n</strong> entries that match <strong>filter</strong> from the XArray.  The
copied entries will have indices between <strong>start</strong> and <strong>max</strong>, inclusive.</p>
<p>The <strong>filter</strong> may be an XArray mark value, in which case entries which are
marked with that mark will be copied.  It may also be <code class="docutils literal notranslate"><span class="pre">XA_PRESENT</span></code>, in
which case all entries which are not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be copied.</p>
<p>The entries returned may not represent a snapshot of the XArray at a
moment in time.  For example, if another thread stores to index 5, then
index 10, calling <a class="reference internal" href="#c.xa_extract" title="xa_extract"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_extract()</span></code></a> may return the old contents of index 5
and the new contents of index 10.  Indices not modified while this
function is running will not be skipped.</p>
<p>If you need stronger guarantees, holding the xa_lock across calls to this
function will prevent concurrent modification.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the RCU lock.</p>
<p><strong>Return</strong></p>
<p>The number of entries copied.</p>
</div>
<dl class="function">
<dt id="c.xa_delete_node">
void <code class="sig-name descname">xa_delete_node</code><span class="sig-paren">(</span>struct xa_node<em> *node</em>, <a class="reference internal" href="#c.xa_update_node_t" title="xa_update_node_t">xa_update_node_t</a><em> update</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_delete_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Private interface for workingset code.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xa_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to be removed from the tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_update_node_t</span> <span class="pre">update</span></code></dt><dd><p>Function to call to update ancestor nodes.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>xa_lock must be held on entry and will not be released.</p>
</div>
<dl class="function">
<dt id="c.xa_destroy">
void <code class="sig-name descname">xa_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.xarray" title="xarray">xarray</a><em> *xa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xa_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free all internal data structures.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span> <span class="pre">*xa</span></code></dt><dd><p>XArray.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After calling this function, the XArray is empty and has freed all memory
allocated for its internal data structures.  You are responsible for
freeing the objects referenced by the XArray.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the xa_lock, interrupt-safe.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">XArray</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#normal-api">Normal API</a><ul>
<li><a class="reference internal" href="#search-marks">Search Marks</a></li>
<li><a class="reference internal" href="#allocating-xarrays">Allocating XArrays</a></li>
<li><a class="reference internal" href="#memory-allocation">Memory allocation</a></li>
<li><a class="reference internal" href="#locking">Locking</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-api">Advanced API</a><ul>
<li><a class="reference internal" href="#internal-entries">Internal Entries</a></li>
<li><a class="reference internal" href="#additional-functionality">Additional functionality</a></li>
<li><a class="reference internal" href="#multi-index-entries">Multi-Index Entries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-and-structures">Functions and structures</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/xarray.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/xarray.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>