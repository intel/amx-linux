<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unevictable LRU Infrastructure &mdash; The Linux Kernel 5.19.0-selftest+ documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Virtually Mapped Kernel Stack Support" href="vmalloced-kernel-stacks.html" />
    <link rel="prev" title="Transparent Hugepage Support" href="transhuge.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          </a>
              <div class="version">
                5.19.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Memory Management Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management-guide">Memory Management Guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#legacy-documentation">Legacy Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="active_mm.html">Active MM</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html">Architecture Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="balance.html">Memory Balancing</a></li>
<li class="toctree-l3"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="free_page_reporting.html">Free Page Reporting</a></li>
<li class="toctree-l3"><a class="reference internal" href="frontswap.html">Frontswap</a></li>
<li class="toctree-l3"><a class="reference internal" href="hmm.html">Heterogeneous Memory Management (HMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hwpoison.html">hwpoison</a></li>
<li class="toctree-l3"><a class="reference internal" href="hugetlbfs_reserv.html">Hugetlbfs Reservation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-model.html">Physical Memory Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmu_notifier.html">When do you need to notify inside page table lock ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="numa.html">What is NUMA?</a></li>
<li class="toctree-l3"><a class="reference internal" href="overcommit-accounting.html">Overcommit Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_migration.html">Page migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_frags.html">Page fragments</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_owner.html">page owner: Tracking about who allocated each page</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_check.html">Page Table Check</a></li>
<li class="toctree-l3"><a class="reference internal" href="remap_file_pages.html">remap_file_pages() system call</a></li>
<li class="toctree-l3"><a class="reference internal" href="slub.html">Short users guide for SLUB</a></li>
<li class="toctree-l3"><a class="reference internal" href="split_page_table_lock.html">Split page table lock</a></li>
<li class="toctree-l3"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Unevictable LRU Infrastructure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-unevictable-lru">The Unevictable LRU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlocked-pages">MLOCKED Pages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="vmalloced-kernel-stacks.html">Virtually Mapped Kernel Stack Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="vmemmap_dedup.html">A vmemmap diet for HugeTLB and Device DAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="z3fold.html">z3fold</a></li>
<li class="toctree-l3"><a class="reference internal" href="zsmalloc.html">zsmalloc</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Linux Memory Management Documentation</a> &raquo;</li>
      <li>Unevictable LRU Infrastructure</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/vm/unevictable-lru.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="unevictable-lru-infrastructure">
<span id="unevictable-lru"></span><h1>Unevictable LRU Infrastructure<a class="headerlink" href="#unevictable-lru-infrastructure" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-unevictable-lru" id="id2">The Unevictable LRU</a></p>
<ul>
<li><p><a class="reference internal" href="#the-unevictable-lru-page-list" id="id3">The Unevictable LRU Page List</a></p></li>
<li><p><a class="reference internal" href="#memory-control-group-interaction" id="id4">Memory Control Group Interaction</a></p></li>
<li><p><a class="reference internal" href="#marking-address-spaces-unevictable" id="id5">Marking Address Spaces Unevictable</a></p></li>
<li><p><a class="reference internal" href="#detecting-unevictable-pages" id="id6">Detecting Unevictable Pages</a></p></li>
<li><p><a class="reference internal" href="#vmscan-s-handling-of-unevictable-pages" id="id7">Vmscan’s Handling of Unevictable Pages</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mlocked-pages" id="id8">MLOCKED Pages</a></p>
<ul>
<li><p><a class="reference internal" href="#history" id="id9">History</a></p></li>
<li><p><a class="reference internal" href="#basic-management" id="id10">Basic Management</a></p></li>
<li><p><a class="reference internal" href="#mlock-mlock2-mlockall-system-call-handling" id="id11">mlock()/mlock2()/mlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#filtering-special-vmas" id="id12">Filtering Special VMAs</a></p></li>
<li><p><a class="reference internal" href="#munlock-munlockall-system-call-handling" id="id13">munlock()/munlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#migrating-mlocked-pages" id="id14">Migrating MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#compacting-mlocked-pages" id="id15">Compacting MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#mlocking-transparent-huge-pages" id="id16">MLOCKING Transparent Huge Pages</a></p></li>
<li><p><a class="reference internal" href="#mmap-map-locked-system-call-handling" id="id17">mmap(MAP_LOCKED) System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#munmap-exit-exec-system-call-handling" id="id18">munmap()/exit()/exec() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#truncating-mlocked-pages" id="id19">Truncating MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#page-reclaim-in-shrink-list" id="id20">Page Reclaim in shrink_*_list()</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the Linux memory manager’s “Unevictable LRU”
infrastructure and the use of this to manage several types of “unevictable”
pages.</p>
<p>The document attempts to provide the overall rationale behind this mechanism
and the rationale for some of the design decisions that drove the
implementation.  The latter design rationale is discussed in the context of an
implementation description.  Admittedly, one can obtain the implementation
details - the “what does it do?” - by reading the code.  One hopes that the
descriptions below add value by provide the answer to “why does it do that?”.</p>
</section>
<section id="the-unevictable-lru">
<h2><a class="toc-backref" href="#id2">The Unevictable LRU</a><a class="headerlink" href="#the-unevictable-lru" title="Permalink to this headline">¶</a></h2>
<p>The Unevictable LRU facility adds an additional LRU list to track unevictable
pages and to hide these pages from vmscan.  This mechanism is based on a patch
by Larry Woodman of Red Hat to address several scalability problems with page
reclaim in Linux.  The problems have been observed at customer sites on large
memory x86_64 systems.</p>
<p>To illustrate this with an example, a non-NUMA x86_64 platform with 128GB of
main memory will have over 32 million 4k pages in a single node.  When a large
fraction of these pages are not evictable for any reason [see below], vmscan
will spend a lot of time scanning the LRU lists looking for the small fraction
of pages that are evictable.  This can result in a situation where all CPUs are
spending 100% of their time in vmscan for hours or days on end, with the system
completely unresponsive.</p>
<p>The unevictable list addresses the following classes of unevictable pages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Those owned by ramfs.</p></li>
<li><p>Those mapped into SHM_LOCK’d shared memory regions.</p></li>
<li><p>Those mapped into VM_LOCKED [mlock()ed] VMAs.</p></li>
</ul>
</div></blockquote>
<p>The infrastructure may also be able to handle other conditions that make pages
unevictable, either by definition or by circumstance, in the future.</p>
<section id="the-unevictable-lru-page-list">
<h3><a class="toc-backref" href="#id3">The Unevictable LRU Page List</a><a class="headerlink" href="#the-unevictable-lru-page-list" title="Permalink to this headline">¶</a></h3>
<p>The Unevictable LRU page list is a lie.  It was never an LRU-ordered list, but a
companion to the LRU-ordered anonymous and file, active and inactive page lists;
and now it is not even a page list.  But following familiar convention, here in
this document and in the source, we often imagine it as a fifth LRU page list.</p>
<p>The Unevictable LRU infrastructure consists of an additional, per-node, LRU list
called the “unevictable” list and an associated page flag, PG_unevictable, to
indicate that the page is being managed on the unevictable list.</p>
<p>The PG_unevictable flag is analogous to, and mutually exclusive with, the
PG_active flag in that it indicates on which LRU list a page resides when
PG_lru is set.</p>
<p>The Unevictable LRU infrastructure maintains unevictable pages as if they were
on an additional LRU list for a few reasons:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>We get to “treat unevictable pages just like we treat other pages in the
system - which means we get to use the same code to manipulate them, the
same code to isolate them (for migrate, etc.), the same code to keep track
of the statistics, etc…” [Rik van Riel]</p></li>
<li><p>We want to be able to migrate unevictable pages between nodes for memory
defragmentation, workload management and memory hotplug.  The Linux kernel
can only migrate pages that it can successfully isolate from the LRU
lists (or “Movable” pages: outside of consideration here).  If we were to
maintain pages elsewhere than on an LRU-like list, where they can be
detected by isolate_lru_page(), we would prevent their migration.</p></li>
</ol>
</div></blockquote>
<p>The unevictable list does not differentiate between file-backed and anonymous,
swap-backed pages.  This differentiation is only important while the pages are,
in fact, evictable.</p>
<p>The unevictable list benefits from the “arrayification” of the per-node LRU
lists and statistics originally proposed and posted by Christoph Lameter.</p>
</section>
<section id="memory-control-group-interaction">
<h3><a class="toc-backref" href="#id4">Memory Control Group Interaction</a><a class="headerlink" href="#memory-control-group-interaction" title="Permalink to this headline">¶</a></h3>
<p>The unevictable LRU facility interacts with the memory control group [aka
memory controller; see <a class="reference internal" href="../admin-guide/cgroup-v1/memory.html"><span class="doc">Memory Resource Controller</span></a>] by
extending the lru_list enum.</p>
<p>The memory controller data structure automatically gets a per-node unevictable
list as a result of the “arrayification” of the per-node LRU lists (one per
lru_list enum element).  The memory controller tracks the movement of pages to
and from the unevictable list.</p>
<p>When a memory control group comes under memory pressure, the controller will
not attempt to reclaim pages on the unevictable list.  This has a couple of
effects:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Because the pages are “hidden” from reclaim on the unevictable list, the
reclaim process can be more efficient, dealing only with pages that have a
chance of being reclaimed.</p></li>
<li><p>On the other hand, if too many of the pages charged to the control group
are unevictable, the evictable portion of the working set of the tasks in
the control group may not fit into the available memory.  This can cause
the control group to thrash or to OOM-kill tasks.</p></li>
</ol>
</div></blockquote>
</section>
<section id="marking-address-spaces-unevictable">
<span id="mark-addr-space-unevict"></span><h3><a class="toc-backref" href="#id5">Marking Address Spaces Unevictable</a><a class="headerlink" href="#marking-address-spaces-unevictable" title="Permalink to this headline">¶</a></h3>
<p>For facilities such as ramfs none of the pages attached to the address space
may be evicted.  To prevent eviction of any such pages, the AS_UNEVICTABLE
address space flag is provided, and this can be manipulated by a filesystem
using a number of wrapper functions:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_set_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being completely unevictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_clear_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being evictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mapping_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Query the address space, and return true if it is completely
unevictable.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>These are currently used in three places in the kernel:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>By ramfs to mark the address spaces of its inodes when they are created,
and this mark remains for the life of the inode.</p></li>
<li><p>By SYSV SHM to mark SHM_LOCK’d address spaces until SHM_UNLOCK is called.
Note that SHM_LOCK is not required to page in the locked pages if they’re
swapped out; the application must touch the pages manually if it wants to
ensure they’re in memory.</p></li>
<li><p>By the i915 driver to mark pinned address space until it’s unpinned. The
amount of unevictable memory marked by i915 driver is roughly the bounded
object size in debugfs/dri/0/i915_gem_objects.</p></li>
</ol>
</div></blockquote>
</section>
<section id="detecting-unevictable-pages">
<h3><a class="toc-backref" href="#id6">Detecting Unevictable Pages</a><a class="headerlink" href="#detecting-unevictable-pages" title="Permalink to this headline">¶</a></h3>
<p>The function page_evictable() in mm/internal.h determines whether a page is
evictable or not using the query function outlined above [see section
<a class="reference internal" href="#mark-addr-space-unevict"><span class="std std-ref">Marking address spaces unevictable</span></a>]
to check the AS_UNEVICTABLE flag.</p>
<p>For address spaces that are so marked after being populated (as SHM regions
might be), the lock action (e.g. SHM_LOCK) can be lazy, and need not populate
the page tables for the region as does, for example, mlock(), nor need it make
any special effort to push any pages in the SHM_LOCK’d area to the unevictable
list.  Instead, vmscan will do this if and when it encounters the pages during
a reclamation scan.</p>
<p>On an unlock action (such as SHM_UNLOCK), the unlocker (e.g. shmctl()) must scan
the pages in the region and “rescue” them from the unevictable list if no other
condition is keeping them unevictable.  If an unevictable region is destroyed,
the pages are also “rescued” from the unevictable list in the process of
freeing them.</p>
<p>page_evictable() also checks for mlocked pages by testing an additional page
flag, PG_mlocked (as wrapped by PageMlocked()), which is set when a page is
faulted into a VM_LOCKED VMA, or found in a VMA being VM_LOCKED.</p>
</section>
<section id="vmscan-s-handling-of-unevictable-pages">
<h3><a class="toc-backref" href="#id7">Vmscan’s Handling of Unevictable Pages</a><a class="headerlink" href="#vmscan-s-handling-of-unevictable-pages" title="Permalink to this headline">¶</a></h3>
<p>If unevictable pages are culled in the fault path, or moved to the unevictable
list at mlock() or mmap() time, vmscan will not encounter the pages until they
have become evictable again (via munlock() for example) and have been “rescued”
from the unevictable list.  However, there may be situations where we decide,
for the sake of expediency, to leave an unevictable page on one of the regular
active/inactive LRU lists for vmscan to deal with.  vmscan checks for such
pages in all of the shrink_{active|inactive|page}_list() functions and will
“cull” such pages that it encounters: that is, it diverts those pages to the
unevictable list for the memory cgroup and node being scanned.</p>
<p>There may be situations where a page is mapped into a VM_LOCKED VMA, but the
page is not marked as PG_mlocked.  Such pages will make it all the way to
shrink_active_list() or shrink_page_list() where they will be detected when
vmscan walks the reverse map in page_referenced() or try_to_unmap().  The page
is culled to the unevictable list when it is released by the shrinker.</p>
<p>To “cull” an unevictable page, vmscan simply puts the page back on the LRU list
using putback_lru_page() - the inverse operation to isolate_lru_page() - after
dropping the page lock.  Because the condition which makes the page unevictable
may change once the page is unlocked, __pagevec_lru_add_fn() will recheck the
unevictable state of a page before placing it on the unevictable list.</p>
</section>
</section>
<section id="mlocked-pages">
<h2><a class="toc-backref" href="#id8">MLOCKED Pages</a><a class="headerlink" href="#mlocked-pages" title="Permalink to this headline">¶</a></h2>
<p>The unevictable page list is also useful for mlock(), in addition to ramfs and
SYSV SHM.  Note that mlock() is only available in CONFIG_MMU=y situations; in
NOMMU situations, all mappings are effectively mlocked.</p>
<section id="history">
<h3><a class="toc-backref" href="#id9">History</a><a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h3>
<p>The “Unevictable mlocked Pages” infrastructure is based on work originally
posted by Nick Piggin in an RFC patch entitled “mm: mlocked pages off LRU”.
Nick posted his patch as an alternative to a patch posted by Christoph Lameter
to achieve the same objective: hiding mlocked pages from vmscan.</p>
<p>In Nick’s patch, he used one of the struct page LRU list link fields as a count
of VM_LOCKED VMAs that map the page (Rik van Riel had the same idea three years
earlier).  But this use of the link field for a count prevented the management
of the pages on an LRU list, and thus mlocked pages were not migratable as
isolate_lru_page() could not detect them, and the LRU list link field was not
available to the migration subsystem.</p>
<p>Nick resolved this by putting mlocked pages back on the LRU list before
attempting to isolate them, thus abandoning the count of VM_LOCKED VMAs.  When
Nick’s patch was integrated with the Unevictable LRU work, the count was
replaced by walking the reverse map when munlocking, to determine whether any
other VM_LOCKED VMAs still mapped the page.</p>
<p>However, walking the reverse map for each page when munlocking was ugly and
inefficient, and could lead to catastrophic contention on a file’s rmap lock,
when many processes which had it mlocked were trying to exit.  In 5.18, the
idea of keeping mlock_count in Unevictable LRU list link field was revived and
put to work, without preventing the migration of mlocked pages.  This is why
the “Unevictable LRU list” cannot be a linked list of pages now; but there was
no use for that linked list anyway - though its size is maintained for meminfo.</p>
</section>
<section id="basic-management">
<h3><a class="toc-backref" href="#id10">Basic Management</a><a class="headerlink" href="#basic-management" title="Permalink to this headline">¶</a></h3>
<p>mlocked pages - pages mapped into a VM_LOCKED VMA - are a class of unevictable
pages.  When such a page has been “noticed” by the memory management subsystem,
the page is marked with the PG_mlocked flag.  This can be manipulated using the
PageMlocked() functions.</p>
<p>A PG_mlocked page will be placed on the unevictable list when it is added to
the LRU.  Such pages can be “noticed” by memory management in several places:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>in the mlock()/mlock2()/mlockall() system call handlers;</p></li>
<li><p>in the mmap() system call handler when mmapping a region with the
MAP_LOCKED flag;</p></li>
<li><p>mmapping a region in a task that has called mlockall() with the MCL_FUTURE
flag;</p></li>
<li><p>in the fault path and when a VM_LOCKED stack segment is expanded; or</p></li>
<li><p>as mentioned above, in vmscan:shrink_page_list() when attempting to
reclaim a page in a VM_LOCKED VMA by page_referenced() or try_to_unmap().</p></li>
</ol>
</div></blockquote>
<p>mlocked pages become unlocked and rescued from the unevictable list when:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>mapped in a range unlocked via the munlock()/munlockall() system calls;</p></li>
<li><p>munmap()’d out of the last VM_LOCKED VMA that maps the page, including
unmapping at task exit;</p></li>
<li><p>when the page is truncated from the last VM_LOCKED VMA of an mmapped file;
or</p></li>
<li><p>before a page is COW’d in a VM_LOCKED VMA.</p></li>
</ol>
</div></blockquote>
</section>
<section id="mlock-mlock2-mlockall-system-call-handling">
<h3><a class="toc-backref" href="#id11">mlock()/mlock2()/mlockall() System Call Handling</a><a class="headerlink" href="#mlock-mlock2-mlockall-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>mlock(), mlock2() and mlockall() system call handlers proceed to mlock_fixup()
for each VMA in the range specified by the call.  In the case of mlockall(),
this is the entire active address space of the task.  Note that mlock_fixup()
is used for both mlocking and munlocking a range of memory.  A call to mlock()
an already VM_LOCKED VMA, or to munlock() a VMA that is not VM_LOCKED, is
treated as a no-op and mlock_fixup() simply returns.</p>
<p>If the VMA passes some filtering as described in “Filtering Special VMAs”
below, mlock_fixup() will attempt to merge the VMA with its neighbors or split
off a subset of the VMA if the range does not cover the entire VMA.  Any pages
already present in the VMA are then marked as mlocked by mlock_page() via
mlock_pte_range() via walk_page_range() via mlock_vma_pages_range().</p>
<p>Before returning from the system call, do_mlock() or mlockall() will call
__mm_populate() to fault in the remaining pages via get_user_pages() and to
mark those pages as mlocked as they are faulted.</p>
<p>Note that the VMA being mlocked might be mapped with PROT_NONE.  In this case,
get_user_pages() will be unable to fault in the pages.  That’s okay.  If pages
do end up getting faulted into this VM_LOCKED VMA, they will be handled in the
fault path - which is also how mlock2()’s MLOCK_ONFAULT areas are handled.</p>
<p>For each PTE (or PMD) being faulted into a VMA, the page add rmap function
calls mlock_vma_page(), which calls mlock_page() when the VMA is VM_LOCKED
(unless it is a PTE mapping of a part of a transparent huge page).  Or when
it is a newly allocated anonymous page, lru_cache_add_inactive_or_unevictable()
calls mlock_new_page() instead: similar to mlock_page(), but can make better
judgments, since this page is held exclusively and known not to be on LRU yet.</p>
<p>mlock_page() sets PageMlocked immediately, then places the page on the CPU’s
mlock pagevec, to batch up the rest of the work to be done under lru_lock by
__mlock_page().  __mlock_page() sets PageUnevictable, initializes mlock_count
and moves the page to unevictable state (“the unevictable LRU”, but with
mlock_count in place of LRU threading).  Or if the page was already PageLRU
and PageUnevictable and PageMlocked, it simply increments the mlock_count.</p>
<p>But in practice that may not work ideally: the page may not yet be on an LRU, or
it may have been temporarily isolated from LRU.  In such cases the mlock_count
field cannot be touched, but will be set to 0 later when __pagevec_lru_add_fn()
returns the page to “LRU”.  Races prohibit mlock_count from being set to 1 then:
rather than risk stranding a page indefinitely as unevictable, always err with
mlock_count on the low side, so that when munlocked the page will be rescued to
an evictable LRU, then perhaps be mlocked again later if vmscan finds it in a
VM_LOCKED VMA.</p>
</section>
<section id="filtering-special-vmas">
<h3><a class="toc-backref" href="#id12">Filtering Special VMAs</a><a class="headerlink" href="#filtering-special-vmas" title="Permalink to this headline">¶</a></h3>
<p>mlock_fixup() filters several classes of “special” VMAs:</p>
<ol class="arabic simple">
<li><p>VMAs with VM_IO or VM_PFNMAP set are skipped entirely.  The pages behind
these mappings are inherently pinned, so we don’t need to mark them as
mlocked.  In any case, most of the pages have no struct page in which to so
mark the page.  Because of this, get_user_pages() will fail for these VMAs,
so there is no sense in attempting to visit them.</p></li>
<li><p>VMAs mapping hugetlbfs page are already effectively pinned into memory.  We
neither need nor want to mlock() these pages.  But __mm_populate() includes
hugetlbfs ranges, allocating the huge pages and populating the PTEs.</p></li>
<li><p>VMAs with VM_DONTEXPAND are generally userspace mappings of kernel pages,
such as the VDSO page, relay channel pages, etc.  These pages are inherently
unevictable and are not managed on the LRU lists.  __mm_populate() includes
these ranges, populating the PTEs if not already populated.</p></li>
<li><p>VMAs with VM_MIXEDMAP set are not marked VM_LOCKED, but __mm_populate()
includes these ranges, populating the PTEs if not already populated.</p></li>
</ol>
<p>Note that for all of these special VMAs, mlock_fixup() does not set the
VM_LOCKED flag.  Therefore, we won’t have to deal with them later during
munlock(), munmap() or task exit.  Neither does mlock_fixup() account these
VMAs against the task’s “locked_vm”.</p>
</section>
<section id="munlock-munlockall-system-call-handling">
<h3><a class="toc-backref" href="#id13">munlock()/munlockall() System Call Handling</a><a class="headerlink" href="#munlock-munlockall-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>The munlock() and munlockall() system calls are handled by the same
mlock_fixup() function as mlock(), mlock2() and mlockall() system calls are.
If called to munlock an already munlocked VMA, mlock_fixup() simply returns.
Because of the VMA filtering discussed above, VM_LOCKED will not be set in
any “special” VMAs.  So, those VMAs will be ignored for munlock.</p>
<p>If the VMA is VM_LOCKED, mlock_fixup() again attempts to merge or split off the
specified range.  All pages in the VMA are then munlocked by munlock_page() via
mlock_pte_range() via walk_page_range() via mlock_vma_pages_range() - the same
function used when mlocking a VMA range, with new flags for the VMA indicating
that it is munlock() being performed.</p>
<p>munlock_page() uses the mlock pagevec to batch up work to be done under
lru_lock by  __munlock_page().  __munlock_page() decrements the page’s
mlock_count, and when that reaches 0 it clears PageMlocked and clears
PageUnevictable, moving the page from unevictable state to inactive LRU.</p>
<p>But in practice that may not work ideally: the page may not yet have reached
“the unevictable LRU”, or it may have been temporarily isolated from it.  In
those cases its mlock_count field is unusable and must be assumed to be 0: so
that the page will be rescued to an evictable LRU, then perhaps be mlocked
again later if vmscan finds it in a VM_LOCKED VMA.</p>
</section>
<section id="migrating-mlocked-pages">
<h3><a class="toc-backref" href="#id14">Migrating MLOCKED Pages</a><a class="headerlink" href="#migrating-mlocked-pages" title="Permalink to this headline">¶</a></h3>
<p>A page that is being migrated has been isolated from the LRU lists and is held
locked across unmapping of the page, updating the page’s address space entry
and copying the contents and state, until the page table entry has been
replaced with an entry that refers to the new page.  Linux supports migration
of mlocked pages and other unevictable pages.  PG_mlocked is cleared from the
the old page when it is unmapped from the last VM_LOCKED VMA, and set when the
new page is mapped in place of migration entry in a VM_LOCKED VMA.  If the page
was unevictable because mlocked, PG_unevictable follows PG_mlocked; but if the
page was unevictable for other reasons, PG_unevictable is copied explicitly.</p>
<p>Note that page migration can race with mlocking or munlocking of the same page.
There is mostly no problem since page migration requires unmapping all PTEs of
the old page (including munlock where VM_LOCKED), then mapping in the new page
(including mlock where VM_LOCKED).  The page table locks provide sufficient
synchronization.</p>
<p>However, since mlock_vma_pages_range() starts by setting VM_LOCKED on a VMA,
before mlocking any pages already present, if one of those pages were migrated
before mlock_pte_range() reached it, it would get counted twice in mlock_count.
To prevent that, mlock_vma_pages_range() temporarily marks the VMA as VM_IO,
so that mlock_vma_page() will skip it.</p>
<p>To complete page migration, we place the old and new pages back onto the LRU
afterwards.  The “unneeded” page - old page on success, new page on failure -
is freed when the reference count held by the migration process is released.</p>
</section>
<section id="compacting-mlocked-pages">
<h3><a class="toc-backref" href="#id15">Compacting MLOCKED Pages</a><a class="headerlink" href="#compacting-mlocked-pages" title="Permalink to this headline">¶</a></h3>
<p>The memory map can be scanned for compactable regions and the default behavior
is to let unevictable pages be moved.  /proc/sys/vm/compact_unevictable_allowed
controls this behavior (see <a class="reference internal" href="../admin-guide/sysctl/vm.html"><span class="doc">Documentation for /proc/sys/vm/</span></a>).  The work
of compaction is mostly handled by the page migration code and the same work
flow as described in Migrating MLOCKED Pages will apply.</p>
</section>
<section id="mlocking-transparent-huge-pages">
<h3><a class="toc-backref" href="#id16">MLOCKING Transparent Huge Pages</a><a class="headerlink" href="#mlocking-transparent-huge-pages" title="Permalink to this headline">¶</a></h3>
<p>A transparent huge page is represented by a single entry on an LRU list.
Therefore, we can only make unevictable an entire compound page, not
individual subpages.</p>
<p>If a user tries to mlock() part of a huge page, and no user mlock()s the
whole of the huge page, we want the rest of the page to be reclaimable.</p>
<p>We cannot just split the page on partial mlock() as split_huge_page() can
fail and a new intermittent failure mode for the syscall is undesirable.</p>
<p>We handle this by keeping PTE-mlocked huge pages on evictable LRU lists:
the PMD on the border of a VM_LOCKED VMA will be split into a PTE table.</p>
<p>This way the huge page is accessible for vmscan.  Under memory pressure the
page will be split, subpages which belong to VM_LOCKED VMAs will be moved
to the unevictable LRU and the rest can be reclaimed.</p>
<p>/proc/meminfo’s Unevictable and Mlocked amounts do not include those parts
of a transparent huge page which are mapped only by PTEs in VM_LOCKED VMAs.</p>
</section>
<section id="mmap-map-locked-system-call-handling">
<h3><a class="toc-backref" href="#id17">mmap(MAP_LOCKED) System Call Handling</a><a class="headerlink" href="#mmap-map-locked-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>In addition to the mlock(), mlock2() and mlockall() system calls, an application
can request that a region of memory be mlocked by supplying the MAP_LOCKED flag
to the mmap() call.  There is one important and subtle difference here, though.
mmap() + mlock() will fail if the range cannot be faulted in (e.g. because
mm_populate fails) and returns with ENOMEM while mmap(MAP_LOCKED) will not fail.
The mmaped area will still have properties of the locked area - pages will not
get swapped out - but major page faults to fault memory in might still happen.</p>
<p>Furthermore, any mmap() call or brk() call that expands the heap by a task
that has previously called mlockall() with the MCL_FUTURE flag will result
in the newly mapped memory being mlocked.  Before the unevictable/mlock
changes, the kernel simply called make_pages_present() to allocate pages
and populate the page table.</p>
<p>To mlock a range of memory under the unevictable/mlock infrastructure,
the mmap() handler and task address space expansion functions call
populate_vma_page_range() specifying the vma and the address range to mlock.</p>
</section>
<section id="munmap-exit-exec-system-call-handling">
<h3><a class="toc-backref" href="#id18">munmap()/exit()/exec() System Call Handling</a><a class="headerlink" href="#munmap-exit-exec-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>When unmapping an mlocked region of memory, whether by an explicit call to
munmap() or via an internal unmap from exit() or exec() processing, we must
munlock the pages if we’re removing the last VM_LOCKED VMA that maps the pages.
Before the unevictable/mlock changes, mlocking did not mark the pages in any
way, so unmapping them required no processing.</p>
<p>For each PTE (or PMD) being unmapped from a VMA, page_remove_rmap() calls
munlock_vma_page(), which calls munlock_page() when the VMA is VM_LOCKED
(unless it was a PTE mapping of a part of a transparent huge page).</p>
<p>munlock_page() uses the mlock pagevec to batch up work to be done under
lru_lock by  __munlock_page().  __munlock_page() decrements the page’s
mlock_count, and when that reaches 0 it clears PageMlocked and clears
PageUnevictable, moving the page from unevictable state to inactive LRU.</p>
<p>But in practice that may not work ideally: the page may not yet have reached
“the unevictable LRU”, or it may have been temporarily isolated from it.  In
those cases its mlock_count field is unusable and must be assumed to be 0: so
that the page will be rescued to an evictable LRU, then perhaps be mlocked
again later if vmscan finds it in a VM_LOCKED VMA.</p>
</section>
<section id="truncating-mlocked-pages">
<h3><a class="toc-backref" href="#id19">Truncating MLOCKED Pages</a><a class="headerlink" href="#truncating-mlocked-pages" title="Permalink to this headline">¶</a></h3>
<p>File truncation or hole punching forcibly unmaps the deleted pages from
userspace; truncation even unmaps and deletes any private anonymous pages
which had been Copied-On-Write from the file pages now being truncated.</p>
<p>Mlocked pages can be munlocked and deleted in this way: like with munmap(),
for each PTE (or PMD) being unmapped from a VMA, page_remove_rmap() calls
munlock_vma_page(), which calls munlock_page() when the VMA is VM_LOCKED
(unless it was a PTE mapping of a part of a transparent huge page).</p>
<p>However, if there is a racing munlock(), since mlock_vma_pages_range() starts
munlocking by clearing VM_LOCKED from a VMA, before munlocking all the pages
present, if one of those pages were unmapped by truncation or hole punch before
mlock_pte_range() reached it, it would not be recognized as mlocked by this VMA,
and would not be counted out of mlock_count.  In this rare case, a page may
still appear as PageMlocked after it has been fully unmapped: and it is left to
release_pages() (or __page_cache_release()) to clear it and update statistics
before freeing (this event is counted in /proc/vmstat unevictable_pgs_cleared,
which is usually 0).</p>
</section>
<section id="page-reclaim-in-shrink-list">
<h3><a class="toc-backref" href="#id20">Page Reclaim in shrink_*_list()</a><a class="headerlink" href="#page-reclaim-in-shrink-list" title="Permalink to this headline">¶</a></h3>
<p>vmscan’s shrink_active_list() culls any obviously unevictable pages -
i.e. !page_evictable(page) pages - diverting those to the unevictable list.
However, shrink_active_list() only sees unevictable pages that made it onto the
active/inactive LRU lists.  Note that these pages do not have PageUnevictable
set - otherwise they would be on the unevictable list and shrink_active_list()
would never see them.</p>
<p>Some examples of these unevictable pages on the LRU lists are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>ramfs pages that have been placed on the LRU lists when first allocated.</p></li>
<li><p>SHM_LOCK’d shared memory pages.  shmctl(SHM_LOCK) does not attempt to
allocate or fault in the pages in the shared memory region.  This happens
when an application accesses the page the first time after SHM_LOCK’ing
the segment.</p></li>
<li><p>pages still mapped into VM_LOCKED VMAs, which should be marked mlocked,
but events left mlock_count too low, so they were munlocked too early.</p></li>
</ol>
</div></blockquote>
<p>vmscan’s shrink_inactive_list() and shrink_page_list() also divert obviously
unevictable pages found on the inactive lists to the appropriate memory cgroup
and node unevictable list.</p>
<p>rmap’s page_referenced_one(), called via vmscan’s shrink_active_list() or
shrink_page_list(), and rmap’s try_to_unmap_one() called via shrink_page_list(),
check for (3) pages still mapped into VM_LOCKED VMAs, and call mlock_vma_page()
to correct them.  Such pages are culled to the unevictable list when released
by the shrinker.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="transhuge.html" class="btn btn-neutral float-left" title="Transparent Hugepage Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vmalloced-kernel-stacks.html" class="btn btn-neutral float-right" title="Virtually Mapped Kernel Stack Support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>